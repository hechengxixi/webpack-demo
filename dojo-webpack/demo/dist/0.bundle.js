(function(){
(this||window)["webpackJsonp"].registerAbsMids({
	"dijit/BackgroundIframe":"./node_modules/dijit/BackgroundIframe.js",
	"dijit/Destroyable":"./node_modules/dijit/Destroyable.js",
	"dijit/Tooltip":"./node_modules/dijit/Tooltip.js",
	"dijit/Viewport":"./node_modules/dijit/Viewport.js",
	"dijit/_AttachMixin":"./node_modules/dijit/_AttachMixin.js",
	"dijit/_BidiMixin":"./node_modules/dijit/_BidiMixin.js",
	"dijit/_CssStateMixin":"./node_modules/dijit/_CssStateMixin.js",
	"dijit/_FocusMixin":"./node_modules/dijit/_FocusMixin.js",
	"dijit/_OnDijitClickMixin":"./node_modules/dijit/_OnDijitClickMixin.js",
	"dijit/_TemplatedMixin":"./node_modules/dijit/_TemplatedMixin.js",
	"dijit/_Widget":"./node_modules/dijit/_Widget.js",
	"dijit/_WidgetBase":"./node_modules/dijit/_WidgetBase.js",
	"dijit/_base/manager":"./node_modules/dijit/_base/manager.js",
	"dijit/a11y":"./node_modules/dijit/a11y.js",
	"dijit/a11yclick":"./node_modules/dijit/a11yclick.js",
	"dijit/focus":"./node_modules/dijit/focus.js",
	"dijit/form/Form":"./node_modules/dijit/form/Form.js",
	"dijit/form/TextBox":"./node_modules/dijit/form/TextBox.js",
	"dijit/form/ValidationTextBox":"./node_modules/dijit/form/ValidationTextBox.js",
	"dijit/form/_FormMixin":"./node_modules/dijit/form/_FormMixin.js",
	"dijit/form/_FormValueMixin":"./node_modules/dijit/form/_FormValueMixin.js",
	"dijit/form/_FormValueWidget":"./node_modules/dijit/form/_FormValueWidget.js",
	"dijit/form/_FormWidget":"./node_modules/dijit/form/_FormWidget.js",
	"dijit/form/_FormWidgetMixin":"./node_modules/dijit/form/_FormWidgetMixin.js",
	"dijit/form/_TextBoxMixin":"./node_modules/dijit/form/_TextBoxMixin.js",
	"dijit/form/nls/es/validate":"./node_modules/dijit/form/nls/es/validate.js",
	"dijit/form/nls/fr/validate":"./node_modules/dijit/form/nls/fr/validate.js",
	"dijit/form/nls/validate":"./node_modules/dijit/form/nls/validate.js",
	"dijit/hccss":"./node_modules/dijit/hccss.js",
	"dijit/layout/_ContentPaneResizeMixin":"./node_modules/dijit/layout/_ContentPaneResizeMixin.js",
	"dijit/layout/utils":"./node_modules/dijit/layout/utils.js",
	"dijit/main":"./node_modules/dijit/main.js",
	"dijit/place":"./node_modules/dijit/place.js",
	"dijit/registry":"./node_modules/dijit/registry.js",
	// "E:\\dojo-webpack\\node_modules\\dojo-webpack-plugin\\lib\\NoModule.js" = "./node_modules/dojo-webpack-plugin/lib/NoModule.js"
	"dojo/i18n!dijit/form/nls/validate":"./node_modules/dojo-webpack-plugin/loaders/dojo/i18n/index.js!./node_modules/dijit/form/nls/validate.js",
	// "E:/dojo-webpack/node_modules/dojo-webpack-plugin/loaders/dojo/runner.js" = "./node_modules/dojo-webpack-plugin/loaders/dojo/runner.js"
	"dojo/text!dijit/form/templates/TextBox.html":"./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dijit/form/templates/TextBox.html",
	"dojo/text!dijit/form/templates/ValidationTextBox.html":"./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dijit/form/templates/ValidationTextBox.html",
	"dojo/text!dijit/templates/Tooltip.html":"./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dijit/templates/Tooltip.html",
	"dojo/Deferred":"./node_modules/dojo/Deferred.js",
	"dojo/Evented":"./node_modules/dojo/Evented.js",
	"dojo/Stateful":"./node_modules/dojo/Stateful.js",
	"dojo/_base/Color":"./node_modules/dojo/_base/Color.js",
	"dojo/_base/Deferred":"./node_modules/dojo/_base/Deferred.js",
	"dojo/_base/array":"./node_modules/dojo/_base/array.js",
	"dojo/_base/config":"./node_modules/dojo/_base/config.js",
	"dojo/_base/connect":"./node_modules/dojo/_base/connect.js",
	"dojo/_base/declare":"./node_modules/dojo/_base/declare.js",
	"dojo/_base/event":"./node_modules/dojo/_base/event.js",
	"dojo/_base/fx":"./node_modules/dojo/_base/fx.js",
	"dojo/_base/json":"./node_modules/dojo/_base/json.js",
	"dojo/_base/kernel":"./node_modules/dojo/_base/kernel.js",
	"dojo/_base/lang":"./node_modules/dojo/_base/lang.js",
	"dojo/_base/sniff":"./node_modules/dojo/_base/sniff.js",
	"dojo/_base/window":"./node_modules/dojo/_base/window.js",
	"dojo/_base/xhr":"./node_modules/dojo/_base/xhr.js",
	"dojo/aspect":"./node_modules/dojo/aspect.js",
	"dojo/cache":"./node_modules/dojo/cache.js",
	"dojo/dom-attr":"./node_modules/dojo/dom-attr.js",
	"dojo/dom-class":"./node_modules/dojo/dom-class.js",
	"dojo/dom-construct":"./node_modules/dojo/dom-construct.js",
	"dojo/dom-form":"./node_modules/dojo/dom-form.js",
	"dojo/dom-geometry":"./node_modules/dojo/dom-geometry.js",
	"dojo/dom-prop":"./node_modules/dojo/dom-prop.js",
	"dojo/dom-style":"./node_modules/dojo/dom-style.js",
	"dojo/dom":"./node_modules/dojo/dom.js",
	"dojo/domReady":"./node_modules/dojo/domReady.js",
	"dojo/errors/CancelError":"./node_modules/dojo/errors/CancelError.js",
	"dojo/errors/RequestError":"./node_modules/dojo/errors/RequestError.js",
	"dojo/errors/RequestTimeoutError":"./node_modules/dojo/errors/RequestTimeoutError.js",
	"dojo/errors/create":"./node_modules/dojo/errors/create.js",
	"dojo/global":"./node_modules/dojo/global.js",
	"dojo/has":"./node_modules/dojo/has.js",
	"dojo/hccss":"./node_modules/dojo/hccss.js",
	"dojo/i18n":"./node_modules/dojo/i18n.js",
	"dojo/io-query":"./node_modules/dojo/io-query.js",
	"dojo/json":"./node_modules/dojo/json.js",
	"dojo/keys":"./node_modules/dojo/keys.js",
	"dojo/mouse":"./node_modules/dojo/mouse.js",
	"dojo/on":"./node_modules/dojo/on.js",
	"dojo/promise/Promise":"./node_modules/dojo/promise/Promise.js",
	"dojo/promise/instrumentation":"./node_modules/dojo/promise/instrumentation.js",
	"dojo/promise/tracer":"./node_modules/dojo/promise/tracer.js",
	"dojo/query":"./node_modules/dojo/query.js",
	"dojo/ready":"./node_modules/dojo/ready.js",
	"dojo/request":"./node_modules/dojo/request.js",
	"dojo/request/handlers":"./node_modules/dojo/request/handlers.js",
	"dojo/request/util":"./node_modules/dojo/request/util.js",
	"dojo/request/watch":"./node_modules/dojo/request/watch.js",
	"dojo/request/default!":"./node_modules/dojo/request/xhr.js",
	"dojo/request/xhr":"./node_modules/dojo/request/xhr.js",
	"dojo/selector/_loader":"./node_modules/dojo/selector/_loader.js",
	"dojo/selector/lite":"./node_modules/dojo/selector/lite.js",
	"dojo/selector/_loader!default":"./node_modules/dojo/selector/lite.js",
	"dojo/sniff":"./node_modules/dojo/sniff.js",
	"dojo/string":"./node_modules/dojo/string.js",
	"dojo/text":"./node_modules/dojo/text.js",
	"dojo/topic":"./node_modules/dojo/topic.js",
	"dojo/touch":"./node_modules/dojo/touch.js",
	"dojo/uacss":"./node_modules/dojo/uacss.js",
	"dojo/when":"./node_modules/dojo/when.js",
	"dojo/window":"./node_modules/dojo/window.js"
})
})(),(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./node_modules/dijit/BackgroundIframe.js":
/*!************************************************!*\
  !*** ./node_modules/dijit/BackgroundIframe.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__.dj.c(module.i),			// require.toUrl
	__webpack_require__(/*! ./main */ "./node_modules/dijit/main.js"),	// to export dijit.BackgroundIframe
	__webpack_require__(/*! dojo/_base/config */ "./node_modules/dojo/_base/config.js"),
	__webpack_require__(/*! dojo/dom-construct */ "./node_modules/dojo/dom-construct.js"), // domConstruct.create
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"), // domStyle.set
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.extend lang.hitch
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js") // has("ie"), has("trident"), has("quirks")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(require, dijit, config, domConstruct, domStyle, lang, on, has){

	// module:
	//		dijit/BackgroundIFrame

	// Flag for whether to create background iframe behind popups like Menus and Dialog.
	// A background iframe is useful to prevent problems with popups appearing behind applets/pdf files,
	// and is also useful on older versions of IE (IE6 and IE7) to prevent the "bleed through select" problem.
	// By default, it's enabled for IE6-11, excluding Windows Phone 8.
	// TODO: For 2.0, make this false by default.  Also, possibly move definition to has.js so that this module can be
	// conditionally required via  dojo/has!bgIfame?dijit/BackgroundIframe
	has.add("config-bgIframe",
    	(has("ie") || has("trident")) && !/IEMobile\/10\.0/.test(navigator.userAgent)); // No iframe on WP8, to match 1.9 behavior

	var _frames = new function(){
		// summary:
		//		cache of iframes

		var queue = [];

		this.pop = function(){
			var iframe;
			if(queue.length){
				iframe = queue.pop();
				iframe.style.display="";
			}else{
				// transparency needed for DialogUnderlay and for tooltips on IE (to see screen near connector)
				if(has("ie") < 9){
					var burl = config["dojoBlankHtmlUrl"] || require.toUrl("dojo/resources/blank.html") || "javascript:\"\"";
					var html="<iframe src='" + burl + "' role='presentation'"
						+ " style='position: absolute; left: 0px; top: 0px;"
						+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
					iframe = document.createElement(html);
				}else{
					iframe = domConstruct.create("iframe");
					iframe.src = 'javascript:""';
					iframe.className = "dijitBackgroundIframe";
					iframe.setAttribute("role", "presentation");
					domStyle.set(iframe, "opacity", 0.1);
				}
				iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didn't work.
			}
			return iframe;
		};

		this.push = function(iframe){
			iframe.style.display="none";
			queue.push(iframe);
		}
	}();


	dijit.BackgroundIframe = function(/*DomNode*/ node){
		// summary:
		//		For IE/FF z-index shenanigans. id attribute is required.
		//
		// description:
		//		new dijit.BackgroundIframe(node).
		//
		//		Makes a background iframe as a child of node, that fills
		//		area (and position) of node

		if(!node.id){ throw new Error("no id"); }
		if(has("config-bgIframe")){
			var iframe = (this.iframe = _frames.pop());
			node.appendChild(iframe);
			if(has("ie")<7 || has("quirks")){
				this.resize(node);
				this._conn = on(node, 'resize', lang.hitch(this, "resize", node));
			}else{
				domStyle.set(iframe, {
					width: '100%',
					height: '100%'
				});
			}
		}
	};

	lang.extend(dijit.BackgroundIframe, {
		resize: function(node){
			// summary:
			//		Resize the iframe so it's the same size as node.
			//		Needed on IE6 and IE/quirks because height:100% doesn't work right.
			if(this.iframe){
				domStyle.set(this.iframe, {
					width: node.offsetWidth + 'px',
					height: node.offsetHeight + 'px'
				});
			}
		},
		destroy: function(){
			// summary:
			//		destroy the iframe
			if(this._conn){
				this._conn.remove();
				this._conn = null;
			}
			if(this.iframe){
				this.iframe.parentNode.removeChild(this.iframe);
				_frames.push(this.iframe);
				delete this.iframe;
			}
		}
	});

	return dijit.BackgroundIframe;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/Destroyable.js":
/*!*******************************************!*\
  !*** ./node_modules/dijit/Destroyable.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.forEach array.map
	__webpack_require__(/*! dojo/aspect */ "./node_modules/dojo/aspect.js"),
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(array, aspect, declare){

	// module:
	//		dijit/Destroyable

	return declare("dijit.Destroyable", null, {
		// summary:
		//		Mixin to track handles and release them when instance is destroyed.
		// description:
		//		Call this.own(...) on list of handles (returned from dojo/aspect, dojo/on,
		//		dojo/Stateful::watch, or any class (including widgets) with a destroyRecursive() or destroy() method.
		//		Then call destroy() later to destroy this instance and release the resources.

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this class, releasing any resources registered via own().
			this._destroyed = true;
		},

		own: function(){
			// summary:
			//		Track specified handles and remove/destroy them when this instance is destroyed, unless they were
			//		already removed/destroyed manually.
			// tags:
			//		protected
			// returns:
			//		The array of specified handles, so you can do for example:
			//	|		var handle = this.own(on(...))[0];

			var cleanupMethods = [
				"destroyRecursive",
				"destroy",
				"remove"
			];

			array.forEach(arguments, function(handle){
				// When this.destroy() is called, destroy handle.  Since I'm using aspect.before(),
				// the handle will be destroyed before a subclass's destroy() method starts running, before it calls
				// this.inherited() or even if it doesn't call this.inherited() at all.  If that's an issue, make an
				// onDestroy() method and connect to that instead.
				var destroyMethodName;
				var odh = aspect.before(this, "destroy", function (preserveDom){
					handle[destroyMethodName](preserveDom);
				});

				// Callback for when handle is manually destroyed.
				var hdhs = [];
				function onManualDestroy(){
					odh.remove();
					array.forEach(hdhs, function(hdh){
						hdh.remove();
					});
				}

				// Setup listeners for manual destroy of handle.
				// Also computes destroyMethodName, used in listener above.
				if(handle.then){
					// Special path for Promises.  Detect when Promise is resolved, rejected, or
					// canceled (nb: cancelling a Promise causes it to be rejected).
					destroyMethodName = "cancel";
					handle.then(onManualDestroy, onManualDestroy);
				}else{
					// Path for other handles.  Just use AOP to detect when handle is manually destroyed.
					array.forEach(cleanupMethods, function(cleanupMethod){
						if(typeof handle[cleanupMethod] === "function"){
							if(!destroyMethodName){
								// Use first matching method name in above listener (prefer destroyRecursive() to destroy())
								destroyMethodName = cleanupMethod;
							}
							hdhs.push(aspect.after(handle, cleanupMethod, onManualDestroy, true));
						}
					});
				}
			}, this);

			return arguments;		// handle
		}
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/Tooltip.js":
/*!***************************************!*\
  !*** ./node_modules/dijit/Tooltip.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.forEach array.indexOf array.map
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/_base/fx */ "./node_modules/dojo/_base/fx.js"), // fx.fadeIn fx.fadeOut
	__webpack_require__(/*! dojo/dom */ "./node_modules/dojo/dom.js"), // dom.byId
	__webpack_require__(/*! dojo/dom-class */ "./node_modules/dojo/dom-class.js"), // domClass.add
	__webpack_require__(/*! dojo/dom-geometry */ "./node_modules/dojo/dom-geometry.js"), // domGeometry.position
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"), // domStyle.set, domStyle.get
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.hitch lang.isArrayLike
	__webpack_require__(/*! dojo/mouse */ "./node_modules/dojo/mouse.js"),
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js"), // has("ie"), has("trident")
	__webpack_require__(/*! ./_base/manager */ "./node_modules/dijit/_base/manager.js"),	// manager.defaultDuration
	__webpack_require__(/*! ./place */ "./node_modules/dijit/place.js"),
	__webpack_require__(/*! ./_Widget */ "./node_modules/dijit/_Widget.js"),
	__webpack_require__(/*! ./_TemplatedMixin */ "./node_modules/dijit/_TemplatedMixin.js"),
	__webpack_require__(/*! ./BackgroundIframe */ "./node_modules/dijit/BackgroundIframe.js"),
	__webpack_require__(/*! dojo/text!./templates/Tooltip.html */ "./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dijit/templates/Tooltip.html"),
	__webpack_require__(/*! ./main */ "./node_modules/dijit/main.js")		// sets dijit.showTooltip etc. for back-compat
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(array, declare, fx, dom, domClass, domGeometry, domStyle, lang, mouse, on, has,
			manager, place, _Widget, _TemplatedMixin, BackgroundIframe, template, dijit){

	// module:
	//		dijit/Tooltip


	// TODO: Tooltip should really share more positioning code with TooltipDialog, like:
	//		- the orient() method
	//		- the connector positioning code in show()
	//		- the dijitTooltip[Dialog] class
	//
	// The problem is that Tooltip's implementation supplies it's own <iframe> and interacts directly
	// with dijit/place, rather than going through dijit/popup like TooltipDialog and other popups (ex: Menu).

	var MasterTooltip = declare("dijit._MasterTooltip", [_Widget, _TemplatedMixin], {
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: manager.defaultDuration,

		templateString: template,

		postCreate: function(){
			this.ownerDocumentBody.appendChild(this.domNode);

			this.bgIframe = new BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = fx.fadeIn({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onShow") });
			this.fadeOut = fx.fadeOut({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onHide") });
		},

		show: function(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if rtl == true)
			// innerHTML: String
			//		Contents of the tooltip
			// aroundNode: DomNode|dijit/place.__Rectangle
			//		Specifies that tooltip should be next to this node / area
			// position: String[]?
			//		List of positions to try to position tooltip (ex: ["right", "above"])
			// rtl: Boolean?
			//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
			//		means "rtl"; specifies GUI direction, not text direction.
			// textDir: String?
			//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
			// onMouseEnter: Function?
			//		Callback function for mouse enter on tooltip
			// onMouseLeave: Function?
			//		Callback function for mouse leave on tooltip

			if(this.aroundNode && this.aroundNode === aroundNode && this.containerNode.innerHTML == innerHTML){
				return;
			}

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			if(textDir){
				this.set("textDir", textDir);
			}

			this.containerNode.align = rtl? "right" : "left"; //fix the text alignment

			var pos = place.around(this.domNode, aroundNode,
				position && position.length ? position : Tooltip.defaultPosition, !rtl, lang.hitch(this, "orient"));

			// Position the tooltip connector for middle alignment.
			// This could not have been done in orient() since the tooltip wasn't positioned at that time.
			var aroundNodeCoords = pos.aroundNodePos;
			if(pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M'){
				this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
				this.connectorNode.style.left = "";
			}else if(pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M'){
				this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
			}else{
				// Not *-centered, but just above/below/after/before
				this.connectorNode.style.left = "";
				this.connectorNode.style.top = "";
			}

			// show it
			domStyle.set(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;

			this.onMouseEnter = onMouseEnter || noop;
			this.onMouseLeave = onMouseLeave || noop;
		},

		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.   It will also reduce the tooltip's
			//		width to whatever width is available
			// tags:
			//		protected

			this.connectorNode.style.top = ""; //reset to default

			var heightAvailable = spaceAvailable.h,
				widthAvailable = spaceAvailable.w;

			node.className = "dijitTooltip " +
				{
					"MR-ML": "dijitTooltipRight",
					"ML-MR": "dijitTooltipLeft",
					"TM-BM": "dijitTooltipAbove",
					"BM-TM": "dijitTooltipBelow",
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];

			// reset width; it may have been set by orient() on a previous tooltip show()
			this.domNode.style.width = "auto";

			// Reduce tooltip's width to the amount of width available, so that it doesn't overflow screen.
			// Note that sometimes widthAvailable is negative, but we guard against setting style.width to a
			// negative number since that causes an exception on IE.
			var size = domGeometry.position(this.domNode);
			if(has("ie") || has("trident")){
				// workaround strange IE bug where setting width to offsetWidth causes words to wrap
				size.w += 2;
			}

			var width = Math.min((Math.max(widthAvailable,1)), size.w);

			domGeometry.setMarginBox(this.domNode, {w: width});

			// Reposition the tooltip connector.
			if(tooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B'){
				var bb = domGeometry.position(node);
				var tooltipConnectorHeight = this.connectorNode.offsetHeight;
				if(bb.h > heightAvailable){
					// The tooltip starts at the top of the page and will extend past the aroundNode
					var aroundNodePlacement = heightAvailable - ((aroundNodeCoords.h + tooltipConnectorHeight) >> 1);
					this.connectorNode.style.top = aroundNodePlacement + "px";
					this.connectorNode.style.bottom = "";
				}else{
					// Align center of connector with center of aroundNode, except don't let bottom
					// of connector extend below bottom of tooltip content, or top of connector
					// extend past top of tooltip content
					this.connectorNode.style.bottom = Math.min(
						Math.max(aroundNodeCoords.h/2 - tooltipConnectorHeight/2, 0),
						bb.h - tooltipConnectorHeight) + "px";
					this.connectorNode.style.top = "";
				}
			}else{
				// reset the tooltip back to the defaults
				this.connectorNode.style.top = "";
				this.connectorNode.style.bottom = "";
			}

			return Math.max(0, size.w - widthAvailable);
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(has("ie")){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip

			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}

			this.onMouseEnter = this.onMouseLeave = noop;
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			this.containerNode.innerHTML="";
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		}
	});

	if(has("dojo-bidi")){
		MasterTooltip.extend({
			_setAutoTextDir: function(/*Object*/node){
				// summary:
				//		Resolve "auto" text direction for children nodes
				// tags:
				//		private

				this.applyTextDir(node);
				array.forEach(node.children, function(child){ this._setAutoTextDir(child); }, this);
			},

			_setTextDirAttr: function(/*String*/ textDir){
				// summary:
				//		Setter for textDir.
				// description:
				//		Users shouldn't call this function; they should be calling
				//		set('textDir', value)
				// tags:
				//		private

				this._set("textDir", textDir);

				if (textDir == "auto"){
					this._setAutoTextDir(this.containerNode);
				}else{
					this.containerNode.dir = this.textDir;
				}
			}
		});
	}

	dijit.showTooltip = function(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave){
		// summary:
		//		Static method to display tooltip w/specified contents in specified position.
		//		See description of dijit/Tooltip.defaultPosition for details on position parameter.
		//		If position is not specified then dijit/Tooltip.defaultPosition is used.
		// innerHTML: String
		//		Contents of the tooltip
		// aroundNode: place.__Rectangle
		//		Specifies that tooltip should be next to this node / area
		// position: String[]?
		//		List of positions to try to position tooltip (ex: ["right", "above"])
		// rtl: Boolean?
		//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
		//		means "rtl"; specifies GUI direction, not text direction.
		// textDir: String?
		//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
		// onMouseEnter: Function?
		//		Callback function for mouse over on tooltip
		// onMouseLeave: Function?
		//		Callback function for mouse leave on tooltip

		// After/before don't work, but for back-compat convert them to the working after-centered, before-centered.
		// Possibly remove this in 2.0.   Alternately, get before/after to work.
		if(position){
			position = array.map(position, function(val){
				return {after: "after-centered", before: "before-centered"}[val] || val;
			});
		}

		if(!Tooltip._masterTT){ dijit._masterTT = Tooltip._masterTT = new MasterTooltip(); }
		return Tooltip._masterTT.show(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave);
	};

	dijit.hideTooltip = function(aroundNode){
		// summary:
		//		Static method to hide the tooltip displayed via showTooltip()
		return Tooltip._masterTT && Tooltip._masterTT.hide(aroundNode);
	};

	// Possible states for a tooltip, see Tooltip.state property for definitions
	var DORMANT = "DORMANT",
		SHOW_TIMER = "SHOW TIMER",
		SHOWING = "SHOWING",
		HIDE_TIMER = "HIDE TIMER";

	function noop(){}

	var Tooltip = declare("dijit.Tooltip", _Widget, {
		// summary:
		//		Pops up a tooltip (a help message) when you hover over a node.
		//		Also provides static show() and hide() methods that can be used without instantiating a dijit/Tooltip.

		// label: String
		//		HTML to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// hideDelay: Integer
		//		Number of milliseconds to wait after unhovering the object, before
		//		the tooltip is hidden.  Note that blurring an object hides the tooltip immediately.
		hideDelay: 400,

		// connectId: String|String[]|DomNode|DomNode[]
		//		Id of domNode(s) to attach the tooltip to.
		//		When user hovers over specified dom node(s), the tooltip will appear.
		connectId: [],

		// position: String[]
		//		See description of `dijit/Tooltip.defaultPosition` for details on position parameter.
		position: [],

		// selector: String?
		//		CSS expression to apply this Tooltip to descendants of connectIds, rather than to
		//		the nodes specified by connectIds themselves.    Useful for applying a Tooltip to
		//		a range of rows in a table, tree, etc.   Use in conjunction with getContent() parameter.
		//		Ex: connectId: myTable, selector: "tr", getContent: function(node){ return ...; }
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		selector: "",

		// TODO: in 2.0 remove support for multiple connectIds.   selector gives the same effect.
		// So, change connectId to a "", remove addTarget()/removeTarget(), etc.

		_setConnectIdAttr: function(/*String|String[]|DomNode|DomNode[]*/ newId){
			// summary:
			//		Connect to specified node(s)

			// Remove connections to old nodes (if there are any)
			array.forEach(this._connections || [], function(nested){
				array.forEach(nested, function(handle){ handle.remove(); });
			}, this);

			// Make array of id's to connect to, excluding entries for nodes that don't exist yet, see startup()
			this._connectIds = array.filter(lang.isArrayLike(newId) ? newId : (newId ? [newId] : []),
					function(id){ return dom.byId(id, this.ownerDocument); }, this);

			// Make connections
			this._connections = array.map(this._connectIds, function(id){
				var node = dom.byId(id, this.ownerDocument),
					selector = this.selector,
					delegatedEvent = selector ?
						function(eventType){ return on.selector(selector, eventType); } :
						function(eventType){ return eventType; },
					self = this;
				return [
					on(node, delegatedEvent(mouse.enter), function(){
						self._onHover(this);
					}),
					on(node, delegatedEvent("focusin"), function(){
						self._onHover(this);
					}),
					on(node, delegatedEvent(mouse.leave), lang.hitch(self, "_onUnHover")),
					on(node, delegatedEvent("focusout"), lang.hitch(self, "set", "state", DORMANT))
				];
			}, this);

			this._set("connectId", newId);
		},

		addTarget: function(/*DomNode|String*/ node){
			// summary:
			//		Attach tooltip to specified node if it's not already connected

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node;
			if(array.indexOf(this._connectIds, id) == -1){
				this.set("connectId", this._connectIds.concat(id));
			}
		},

		removeTarget: function(/*DomNode|String*/ node){
			// summary:
			//		Detach tooltip from specified node

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node,	// map from DOMNode back to plain id string
				idx = array.indexOf(this._connectIds, id);
			if(idx >= 0){
				// remove id (modifies original this._connectIds but that's OK in this case)
				this._connectIds.splice(idx, 1);
				this.set("connectId", this._connectIds);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode,"dijitTooltipData");
		},

		startup: function(){
			this.inherited(arguments);

			// If this tooltip was created in a template, or for some other reason the specified connectId[s]
			// didn't exist during the widget's initialization, then connect now.
			var ids = this.connectId;
			array.forEach(lang.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
		},

		getContent: function(/*DomNode*/ node){
			// summary:
			//		User overridable function that return the text to display in the tooltip.
			// tags:
			//		extension
			return this.label || this.domNode.innerHTML;
		},

		// state: [private readonly] String
		//		One of:
		//
		//		- DORMANT: tooltip not SHOWING
		//		- SHOW TIMER: tooltip not SHOWING but timer set to show it
		//		- SHOWING: tooltip displayed
		//		- HIDE TIMER: tooltip displayed, but timer set to hide it
		state: DORMANT,
		_setStateAttr: function(val){
			if(this.state == val ||
				(val == SHOW_TIMER && this.state == SHOWING) ||
				(val == HIDE_TIMER && this.state == DORMANT)){
				return;
			}

			if(this._hideTimer){
				this._hideTimer.remove();
				delete this._hideTimer;
			}
			if(this._showTimer){
				this._showTimer.remove();
				delete this._showTimer;
			}

			switch(val){
				case DORMANT:
					if(this._connectNode){
						Tooltip.hide(this._connectNode);
						delete this._connectNode;
						this.onHide();
					}
					break;
				case SHOW_TIMER:	 // set timer to show tooltip
					// should only get here from a DORMANT state, i.e. tooltip can't be already SHOWING
					if(this.state != SHOWING){
						this._showTimer = this.defer(function(){ this.set("state", SHOWING); }, this.showDelay);
					}
					break;
				case SHOWING:		// show tooltip and clear timers
					var content = this.getContent(this._connectNode);
					if(!content){
						this.set("state", DORMANT);
						return;
					}

					// Show tooltip and setup callbacks for mouseenter/mouseleave of tooltip itself
					Tooltip.show(content, this._connectNode, this.position, !this.isLeftToRight(), this.textDir,
						lang.hitch(this, "set", "state", SHOWING), lang.hitch(this, "set", "state", HIDE_TIMER));

					this.onShow(this._connectNode, this.position);
					break;
				case HIDE_TIMER:	// set timer set to hide tooltip
					this._hideTimer = this.defer(function(){ this.set("state", DORMANT); }, this.hideDelay);
					break;
			}

			this._set("state", val);
		},

		_onHover: function(/*DomNode*/ target){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private

			if(this._connectNode && target != this._connectNode){
				// Tooltip is displaying for another node
				this.set("state", DORMANT);
			}
			this._connectNode = target;		// _connectNode means "tooltip currently displayed for this node"

			this.set("state", SHOW_TIMER);	// no-op if show-timer already set, or if already showing
		},

		_onUnHover: function(/*DomNode*/ target){
			// summary:
			//		Handles mouseleave event on the target node, hiding the tooltip.
			// tags:
			//		private

			this.set("state", HIDE_TIMER);		// no-op if already dormant, or if hide-timer already set
		},

		// open() and close() aren't used anymore, except from the _BidiSupport/misc/Tooltip test.
		// Should probably remove for 2.0, but leaving for now.
		open: function(/*DomNode*/ target){
			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			this.set("state", DORMANT);
			this._connectNode = target;		// _connectNode means "tooltip currently displayed for this node"
			this.set("state", SHOWING);
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			this.set("state", DORMANT);
		},

		onShow: function(/*===== target, position =====*/){
			// summary:
			//		Called when the tooltip is shown
			// tags:
			//		callback
		},

		onHide: function(){
			// summary:
			//		Called when the tooltip is hidden
			// tags:
			//		callback
		},

		destroy: function(){
			this.set("state", DORMANT);

			// Remove connections manually since they aren't registered to be removed by _WidgetBase
			array.forEach(this._connections || [], function(nested){
				array.forEach(nested, function(handle){ handle.remove(); });
			}, this);

			this.inherited(arguments);
		}
	});

	Tooltip._MasterTooltip = MasterTooltip;		// for monkey patching
	Tooltip.show = dijit.showTooltip;		// export function through module return value
	Tooltip.hide = dijit.hideTooltip;		// export function through module return value

	Tooltip.defaultPosition = ["after-centered", "before-centered"];

	/*=====
	lang.mixin(Tooltip, {
		 // defaultPosition: String[]
		 //		This variable controls the position of tooltips, if the position is not specified to
		 //		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the values
		 //		possible for `dijit/place.around()`.   The recommended values are:
		 //
		 //		- before-centered: centers tooltip to the left of the anchor node/widget, or to the right
		 //		  in the case of RTL scripts like Hebrew and Arabic
		 //		- after-centered: centers tooltip to the right of the anchor node/widget, or to the left
		 //		  in the case of RTL scripts like Hebrew and Arabic
		 //		- above-centered: tooltip is centered above anchor node
		 //		- below-centered: tooltip is centered above anchor node
		 //
		 //		The list is positions is tried, in order, until a position is found where the tooltip fits
		 //		within the viewport.
		 //
		 //		Be careful setting this parameter.  A value of "above-centered" may work fine until the user scrolls
		 //		the screen so that there's no room above the target node.   Nodes with drop downs, like
		 //		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
		 //		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
		 //		is only room below (or above) the target node, but not both.
	 });
	=====*/
	return Tooltip;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/Viewport.js":
/*!****************************************!*\
  !*** ./node_modules/dijit/Viewport.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/Evented */ "./node_modules/dojo/Evented.js"),
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/domReady */ "./node_modules/dojo/domReady.js"),
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js"),	// has("ie"), has("ios")
	__webpack_require__(/*! dojo/window */ "./node_modules/dojo/window.js") // getBox()
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Evented, on, domReady, has, winUtils){

	// module:
	//		dijit/Viewport

	/*=====
	return {
		// summary:
		//		Utility singleton to watch for viewport resizes, avoiding duplicate notifications
		//		which can lead to infinite loops.
		// description:
		//		Usage: Viewport.on("resize", myCallback).
		//
		//		myCallback() is called without arguments in case it's _WidgetBase.resize(),
		//		which would interpret the argument as the size to make the widget.
	};
	=====*/

	var Viewport = new Evented();

	var focusedNode;

	domReady(function(){
		var oldBox = winUtils.getBox();
		Viewport._rlh = on(window, "resize", function(){
			var newBox = winUtils.getBox();
			if(oldBox.h == newBox.h && oldBox.w == newBox.w){ return; }
			oldBox = newBox;
			Viewport.emit("resize");
		});

		// Also catch zoom changes on IE8, since they don't naturally generate resize events
		if(has("ie") == 8){
			var deviceXDPI = screen.deviceXDPI;
			setInterval(function(){
				if(screen.deviceXDPI != deviceXDPI){
					deviceXDPI = screen.deviceXDPI;
					Viewport.emit("resize");
				}
			}, 500);
		}

		// On iOS, keep track of the focused node so we can guess when the keyboard is/isn't being displayed.
		if(has("ios")){
			on(document, "focusin", function(evt){
				focusedNode = evt.target;
			});
			on(document, "focusout", function(evt){
				focusedNode = null;
			});
		}
	});

	Viewport.getEffectiveBox = function(/*Document*/ doc){
		// summary:
		//		Get the size of the viewport, or on mobile devices, the part of the viewport not obscured by the
		//		virtual keyboard.

		var box = winUtils.getBox(doc);

		// Account for iOS virtual keyboard, if it's being shown.  Unfortunately no direct way to check or measure.
		var tag = focusedNode && focusedNode.tagName && focusedNode.tagName.toLowerCase();
		if(has("ios") && focusedNode && !focusedNode.readOnly && (tag == "textarea" || (tag == "input" &&
			/^(color|email|number|password|search|tel|text|url)$/.test(focusedNode.type)))){

			// Box represents the size of the viewport.  Some of the viewport is likely covered by the keyboard.
			// Estimate height of visible viewport assuming viewport goes to bottom of screen, but is covered by keyboard.
			box.h *= (orientation == 0 || orientation == 180 ? 0.66 : 0.40);

			// Above measurement will be inaccurate if viewport was scrolled up so far that it ends before the bottom
			// of the screen.   In this case, keyboard isn't covering as much of the viewport as we thought.
			// We know the visible size is at least the distance from the top of the viewport to the focused node.
			var rect = focusedNode.getBoundingClientRect();
			box.h = Math.max(box.h, rect.top + rect.height);
		}

		return box;
	};

	return Viewport;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/_AttachMixin.js":
/*!********************************************!*\
  !*** ./node_modules/dijit/_AttachMixin.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__.dj.c(module.i),
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.forEach
	__webpack_require__(/*! dojo/_base/connect */ "./node_modules/dojo/_base/connect.js"),	// remove for 2.0
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.getObject
	__webpack_require__(/*! dojo/mouse */ "./node_modules/dojo/mouse.js"),
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/touch */ "./node_modules/dojo/touch.js"),
	__webpack_require__(/*! ./_WidgetBase */ "./node_modules/dijit/_WidgetBase.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(require, array, connect, declare, lang, mouse, on, touch, _WidgetBase){

	// module:
	//		dijit/_AttachMixin

	// Map from string name like "mouseenter" to synthetic event like mouse.enter
	var synthEvents = lang.delegate(touch, {
		"mouseenter": mouse.enter,
		"mouseleave": mouse.leave,
		"keypress": connect._keypress	// remove for 2.0
	});

	// To be lightweight, _AttachMixin doesn't require() dijit/a11yclick.
	// If the subclass has a template using "ondijitclick", it must load dijit/a11yclick itself.
	// In that case, the a11yclick variable below will get set to point to that synthetic event.
	var a11yclick;

	var _AttachMixin = declare("dijit._AttachMixin", null, {
		// summary:
		//		Mixin for widgets to attach to dom nodes and setup events via
		//		convenient data-dojo-attach-point and data-dojo-attach-event DOM attributes.
		//
		//		Superclass of _TemplatedMixin, and can also be used standalone when templates are pre-rendered on the
		//		server.
		//
		//		Does not [yet] handle widgets like ContentPane with this.containerNode set.   It should skip
		//		scanning for data-dojo-attach-point and data-dojo-attach-event inside this.containerNode, but it
		//		doesn't.

/*=====
		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with data-dojo-attach-point=... in the
		//		template, ex: ["containerNode", "labelNode"]
		_attachPoints: [],

		// _attachEvents: [private] Handle[]
		//		List of connections associated with data-dojo-attach-event=... in the
		//		template
		_attachEvents: [],

		// attachScope: [public] Object
		//		Object to which attach points and events will be scoped.  Defaults
		//		to 'this'.
		attachScope: undefined,

		// searchContainerNode: [protected] Boolean
		//		Search descendants of this.containerNode for data-dojo-attach-point and data-dojo-attach-event.
		//		Should generally be left false (the default value) both for performance and to avoid failures when
		//		this.containerNode holds other _AttachMixin instances with their own attach points and events.
 		searchContainerNode: false,
 =====*/

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.

			this._attachPoints = [];
			this._attachEvents = [];
		},


		buildRendering: function(){
			// summary:
			//		Attach to DOM nodes marked with special attributes.
			// tags:
			//		protected

			this.inherited(arguments);

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(this.domNode);

			this._beforeFillContent();		// hook for _WidgetsInTemplateMixin
		},

		_beforeFillContent: function(){
		},

		_attachTemplateNodes: function(rootNode){
			// summary:
			//		Iterate through the dom nodes and attach functions and nodes accordingly.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//
			//		- dojoAttachPoint/data-dojo-attach-point
			//		- dojoAttachEvent/data-dojo-attach-event
			// rootNode: DomNode
			//		The node to search for properties. All descendants will be searched.
			// tags:
			//		private

			// DFS to process all nodes except those inside of this.containerNode
			var node = rootNode;
			while(true){
				if(node.nodeType == 1 && (this._processTemplateNode(node, function(n,p){ return n.getAttribute(p); },
						this._attach) || this.searchContainerNode) && node.firstChild){
					node = node.firstChild;
				}else{
					if(node == rootNode){ return; }
					while(!node.nextSibling){
						node = node.parentNode;
						if(node == rootNode){ return; }
					}
					node = node.nextSibling;
				}
			}
		},

		_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
			// summary:
			//		Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.
			//		Returns true if caller should process baseNode's children too.

			var ret = true;

			// Process data-dojo-attach-point
			var _attachScope = this.attachScope || this,
				attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
			if(attachPoint){
				var point, points = attachPoint.split(/\s*,\s*/);
				while((point = points.shift())){
					if(lang.isArray(_attachScope[point])){
						_attachScope[point].push(baseNode);
					}else{
						_attachScope[point] = baseNode;
					}
					ret = (point != "containerNode");
					this._attachPoints.push(point);
				}
			}

			// Process data-dojo-attach-event
			var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");
			if(attachEvent){
				// NOTE: we want to support attributes that have the form
				// "domEvent: nativeEvent, ..."
				var event, events = attachEvent.split(/\s*,\s*/);
				var trim = lang.trim;
				while((event = events.shift())){
					if(event){
						var thisFunc = null;
						if(event.indexOf(":") != -1){
							// oh, if only JS had tuple assignment
							var funcNameArr = event.split(":");
							event = trim(funcNameArr[0]);
							thisFunc = trim(funcNameArr[1]);
						}else{
							event = trim(event);
						}
						if(!thisFunc){
							thisFunc = event;
						}

						this._attachEvents.push(attachFunc(baseNode, event, lang.hitch(_attachScope, thisFunc)));
					}
				}
			}

			return ret;
		},

		_attach: function(node, type, func){
			// summary:
			//		Roughly corresponding to dojo/on, this is the default function for processing a
			//		data-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.
			// node: DOMNode
			//		The node to setup a listener on.
			// type: String
			//		Event name like "click".
			// getAttrFunc: Function
			//		Function to get the specified property for a given DomNode/Widget.
			// attachFunc: Function?
			//		Attaches an event handler from the specified node/widget to specified function.

			// Map special type names like "mouseenter" to synthetic events.
			// Subclasses are responsible to require() dijit/a11yclick if they want to use it.
			type = type.replace(/^on/, "").toLowerCase();
			if(type == "dijitclick"){
				type = a11yclick || (a11yclick = require("./a11yclick"));
			}else{
				type = synthEvents[type] || type;
			}

			return on(node, type, func);
		},

		_detachTemplateNodes: function() {
			// summary:
			//		Detach and clean up the attachments made in _attachtempalteNodes.

			// Delete all attach points to prevent IE6 memory leaks.
			var _attachScope = this.attachScope || this;
			array.forEach(this._attachPoints, function(point){
				delete _attachScope[point];
			});
			this._attachPoints = [];

			// And same for event handlers
			array.forEach(this._attachEvents, function(handle){ handle.remove(); });
			this._attachEvents = [];
		},

		destroyRendering: function(){
			this._detachTemplateNodes();
			this.inherited(arguments);
		}
	});

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.).
	// Remove for 2.0.   Also, hide from API doc parser.
	lang.extend(_WidgetBase, /*===== {} || =====*/ {
		dojoAttachEvent: "",
		dojoAttachPoint: ""
	});
	
	return _AttachMixin;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/_BidiMixin.js":
/*!******************************************!*\
  !*** ./node_modules/dijit/_BidiMixin.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){

	// module:
	//		dijit/_BidiMixin

	// UCC - constants that will be used by bidi support.
	var bidi_const = {
		LRM : '\u200E',
		LRE : '\u202A',
		PDF : '\u202C',
		RLM : '\u200f',
		RLE : '\u202B'
	};

	return {
		// summary:
		//		When has("dojo-bidi") is true, _WidgetBase will mixin this class.   It enables support for the textdir
		//		property to control text direction independently from the GUI direction.
		// description:
		//		There's a special need for displaying BIDI text in rtl direction
		//		in ltr GUI, sometimes needed auto support.
		//		In creation of widget, if it's want to activate this class,
		//		the widget should define the "textDir".

		getTextDir: function(/*String*/ text){
			// summary:
			//		Gets the right direction of text.
			// description:
			//		If textDir is ltr or rtl returns the value.
			//		If it's auto, calls to another function that responsible
			//		for checking the value, and defining the direction.
			// tags:
			//		protected.
			return this.textDir == "auto" ? this._checkContextual(text) : this.textDir;
		},

		_checkContextual: function(text){
			// summary:
			//		Finds the first strong (directional) character, return ltr if isLatin
			//		or rtl if isBidiChar.
			// tags:
			//		private.

			// look for strong (directional) characters
			var fdc = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(text);
			// if found return the direction that defined by the character, else return widgets dir as defult.
			return fdc ? ( fdc[0] <= 'z' ? "ltr" : "rtl" ) : this.dir ? this.dir : this.isLeftToRight() ? "ltr" : "rtl";
		},

		applyTextDir: function(/*DOMNode*/ element, /*String?*/ text){
			// summary:
			//		Set element.dir according to this.textDir, assuming this.textDir has a value.
			// element:
			//		The text element to be set. Should have dir property.
			// text:
			//		If specified, and this.textDir is "auto", for calculating the right transformation
			//		Otherwise text read from element.
			// description:
			//		If textDir is ltr or rtl returns the value.
			//		If it's auto, calls to another function that responsible
			//		for checking the value, and defining the direction.
			// tags:
			//		protected.

			if(this.textDir){
				var textDir = this.textDir;
				if(textDir == "auto"){
					// convert "auto" to either "ltr" or "rtl"
					if(typeof text === "undefined"){
						// text not specified, get text from element
						var tagName = element.tagName.toLowerCase();
						text = (tagName == "input" || tagName == "textarea") ? element.value :
							element.innerText || element.textContent || "";
					}
					textDir = this._checkContextual(text);
				}

				if(element.dir != textDir){
					// set element's dir to match textDir, but not when textDir is null and not when it already matches
					element.dir = textDir;
				}
			}
		},

		enforceTextDirWithUcc: function(option, text){
			// summary:
			//		Wraps by UCC (Unicode control characters) option's text according to this.textDir
			// option:
			//		The element (`<option>`) we wrapping the text for.
			// text:
			//		The text to be wrapped.
			// description:
			//		There's a dir problem with some HTML elements. For some elements (e.g. `<option>`, `<select>`)
			//		defining the dir in different direction then the GUI orientation, won't display correctly.
			//		FF 3.6 will change the alignment of the text in option - this doesn't follow the bidi standards (static text
			//		should be aligned following GUI direction). IE8 and Opera11.10 completely ignore dir setting for `<option>`.
			//		Therefore the only solution is to use UCC (Unicode  control characters) to display the text in correct orientation.
			//		This function saves the original text value for later restoration if needed, for example if the textDir will change etc.
			if(this.textDir){
				if(option){
					option.originalText = text;
				}
				var dir = this.textDir == "auto" ? this._checkContextual(text) : this.textDir;
				return (dir == "ltr" ? bidi_const.LRE : bidi_const.RLE ) + text + bidi_const.PDF;
			}
			return text;
		},

		restoreOriginalText: function(origObj){
			// summary:
			//		Restores the text of origObj, if needed, after enforceTextDirWithUcc, e.g. set("textDir", textDir).
			// origObj:
			//		The element (`<option>`) to restore.
			// description:
			//		Sets the text of origObj to origObj.originalText, which is the original text, without the UCCs.
			//		The function than removes the originalText from origObj!
			if(origObj.originalText){
				origObj.text = origObj.originalText;
				delete origObj.originalText;
			}
			return origObj;
		},

		_setTextDirAttr: function(/*String*/ textDir){
			// summary:
			//		Setter for textDir.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('textDir', value)
			if(!this._created || this.textDir != textDir){
				this._set("textDir", textDir);
				var node = null;
				if(this.displayNode){
					node = this.displayNode;
					this.displayNode.align = this.dir == "rtl" ? "right" : "left";
				}else{
					node = this.textDirNode || this.focusNode || this.textbox;
				}
				if(node){
					this.applyTextDir(node);
				}
			}
		}
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/_CssStateMixin.js":
/*!**********************************************!*\
  !*** ./node_modules/dijit/_CssStateMixin.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.forEach array.map
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom */ "./node_modules/dojo/dom.js"), // dom.isDescendant()
	__webpack_require__(/*! dojo/dom-class */ "./node_modules/dojo/dom-class.js"), // domClass.toggle
	__webpack_require__(/*! dojo/has */ "./node_modules/dojo/has.js"),
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.hitch
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/domReady */ "./node_modules/dojo/domReady.js"),
	__webpack_require__(/*! dojo/touch */ "./node_modules/dojo/touch.js"),
	__webpack_require__(/*! dojo/_base/window */ "./node_modules/dojo/_base/window.js"), // win.body
	__webpack_require__(/*! ./a11yclick */ "./node_modules/dijit/a11yclick.js"),
	__webpack_require__(/*! ./registry */ "./node_modules/dijit/registry.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(array, declare, dom, domClass, has, lang, on, domReady, touch, win, a11yclick, registry){

	// module:
	//		dijit/_CssStateMixin

	var CssStateMixin = declare("dijit._CssStateMixin", [], {
		// summary:
		//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
		//		state changes, and also higher-level state changes such becoming disabled or selected.
		//
		// description:
		//		By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
		//		maintain CSS classes on the widget root node (this.domNode) depending on hover,
		//		active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
		//		dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
		//
		//		It also sets CSS like dijitButtonDisabled based on widget semantic state.
		//
		//		By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
		//		within the widget).

		/*=====
		 // cssStateNodes: [protected] Object
		 //		Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
		 //		need CSS classes applied on mouse hover/press and focus.
		 //
		 //		Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
		 //		(like "dijitUpArrowButton"). Example:
		 //	|		{
		 //	|			"upArrowButton": "dijitUpArrowButton",
		 //	|			"downArrowButton": "dijitDownArrowButton"
		 //	|		}
		 //		The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
		 //		is hovered, etc.
		 cssStateNodes: {},
		 =====*/

		// hovering: [readonly] Boolean
		//		True if cursor is over this widget
		hovering: false,

		// active: [readonly] Boolean
		//		True if mouse was pressed while over this widget, and hasn't been released yet
		active: false,

		_applyAttributes: function(){
			// This code would typically be in postCreate(), but putting in _applyAttributes() for
			// performance: so the class changes happen before DOM is inserted into the document.
			// Change back to postCreate() in 2.0.  See #11635.

			this.inherited(arguments);

			// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
			array.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active", "_opened"], function(attr){
				this.watch(attr, lang.hitch(this, "_setStateClass"));
			}, this);

			// Track hover and active mouse events on widget root node, plus possibly on subnodes
			for(var ap in this.cssStateNodes || {}){
				this._trackMouseState(this[ap], this.cssStateNodes[ap]);
			}
			this._trackMouseState(this.domNode, this.baseClass);

			// Set state initially; there's probably no hover/active/focus state but widget might be
			// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
			this._setStateClass();
		},

		_cssMouseEvent: function(/*Event*/ event){
			// summary:
			//		Handler for CSS event on this.domNode. Sets hovering and active properties depending on mouse state,
			//		which triggers _setStateClass() to set appropriate CSS classes for this.domNode.

			if(!this.disabled){
				switch(event.type){
					case "mouseover":
					case "MSPointerOver":
					case "pointerover":
						this._set("hovering", true);
						this._set("active", this._mouseDown);
						break;
					case "mouseout":
					case "MSPointerOut":
					case "pointerout":
						this._set("hovering", false);
						this._set("active", false);
						break;
					case "mousedown":
					case "touchstart":
					case "MSPointerDown":
					case "pointerdown":
					case "keydown":
						this._set("active", true);
						break;
					case "mouseup":
					case "dojotouchend":
					case "MSPointerUp":
					case "pointerup":
					case "keyup":
						this._set("active", false);
						break;
				}
			}
		},

		_setStateClass: function(){
			// summary:
			//		Update the visual state of the widget by setting the css classes on this.domNode
			//		(or this.stateNode if defined) by combining this.baseClass with
			//		various suffixes that represent the current widget state(s).
			//
			// description:
			//		In the case where a widget has multiple
			//		states, it sets the class based on all possible
			//		combinations.  For example, an invalid form widget that is being hovered
			//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
			//
			//		The widget may have one or more of the following states, determined
			//		by this.state, this.checked, this.valid, and this.selected:
			//
			//		- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
			//		- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
			//		- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
			//		- Selected - ex: currently selected tab will have this.selected==true
			//
			//		In addition, it may have one or more of the following states,
			//		based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
			//
			//		- Disabled	- if the widget is disabled
			//		- Active		- if the mouse (or space/enter key?) is being pressed down
			//		- Focused		- if the widget has focus
			//		- Hover		- if the mouse is over the widget

			// Compute new set of classes
			var newStateClasses = this.baseClass.split(" ");

			function multiply(modifier){
				newStateClasses = newStateClasses.concat(array.map(newStateClasses, function(c){
					return c + modifier;
				}), "dijit" + modifier);
			}

			if(!this.isLeftToRight()){
				// For RTL mode we need to set an addition class like dijitTextBoxRtl.
				multiply("Rtl");
			}

			var checkedState = this.checked == "mixed" ? "Mixed" : (this.checked ? "Checked" : "");
			if(this.checked){
				multiply(checkedState);
			}
			if(this.state){
				multiply(this.state);
			}
			if(this.selected){
				multiply("Selected");
			}
			if(this._opened){
				multiply("Opened");
			}

			if(this.disabled){
				multiply("Disabled");
			}else if(this.readOnly){
				multiply("ReadOnly");
			}else{
				if(this.active){
					multiply("Active");
				}else if(this.hovering){
					multiply("Hover");
				}
			}

			if(this.focused){
				multiply("Focused");
			}

			// Remove old state classes and add new ones.
			// For performance concerns we only write into domNode.className once.
			var tn = this.stateNode || this.domNode,
				classHash = {};	// set of all classes (state and otherwise) for node

			array.forEach(tn.className.split(" "), function(c){
				classHash[c] = true;
			});

			if("_stateClasses" in this){
				array.forEach(this._stateClasses, function(c){
					delete classHash[c];
				});
			}

			array.forEach(newStateClasses, function(c){
				classHash[c] = true;
			});

			var newClasses = [];
			for(var c in classHash){
				newClasses.push(c);
			}
			tn.className = newClasses.join(" ");

			this._stateClasses = newStateClasses;
		},

		_subnodeCssMouseEvent: function(node, clazz, evt){
			// summary:
			//		Handler for hover/active mouse event on widget's subnode
			if(this.disabled || this.readOnly){
				return;
			}

			function hover(isHovering){
				domClass.toggle(node, clazz + "Hover", isHovering);
			}

			function active(isActive){
				domClass.toggle(node, clazz + "Active", isActive);
			}

			function focused(isFocused){
				domClass.toggle(node, clazz + "Focused", isFocused);
			}

			switch(evt.type){
				case "mouseover":
				case "MSPointerOver":
				case "pointerover":
					hover(true);
					break;
				case "mouseout":
				case "MSPointerOut":
				case "pointerout":
					hover(false);
					active(false);
					break;
				case "mousedown":
				case "touchstart":
				case "MSPointerDown":
				case "pointerdown":
				case "keydown":
					active(true);
					break;
				case "mouseup":
				case "MSPointerUp":
				case "pointerup":
				case "dojotouchend":
				case "keyup":
					active(false);
					break;
				case "focus":
				case "focusin":
					focused(true);
					break;
				case "blur":
				case "focusout":
					focused(false);
					break;
			}
		},

		_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
			// summary:
			//		Track mouse/focus events on specified node and set CSS class on that node to indicate
			//		current state.   Usually not called directly, but via cssStateNodes attribute.
			// description:
			//		Given class=foo, will set the following CSS class on the node
			//
			//		- fooActive: if the user is currently pressing down the mouse button while over the node
			//		- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
			//		- fooFocus: if the node is focused
			//
			//		Note that it won't set any classes if the widget is disabled.
			// node: DomNode
			//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
			//		is handled specially and automatically just by mixing in this class.
			// clazz: String
			//		CSS class name (ex: dijitSliderUpArrow)

			// Flag for listener code below to call this._cssMouseEvent() or this._subnodeCssMouseEvent()
			// when node is hovered/active
			node._cssState = clazz;
		}
	});

	domReady(function(){
		// Document level listener to catch hover etc. events on widget root nodes and subnodes.
		// Note that when the mouse is moved quickly, a single onmouseenter event could signal that multiple widgets
		// have been hovered or unhovered (try test_Accordion.html)

		function pointerHandler(evt, target, relatedTarget){
			// Handler for mouseover, mouseout, a11yclick.press and a11click.release events

			// Poor man's event propagation.  Don't propagate event to ancestors of evt.relatedTarget,
			// to avoid processing mouseout events moving from a widget's domNode to a descendant node;
			// such events shouldn't be interpreted as a mouseleave on the widget.
			if(relatedTarget && dom.isDescendant(relatedTarget, target)){
				return;
			}

			for(var node = target; node && node != relatedTarget; node = node.parentNode){
				// Process any nodes with _cssState property.   They are generally widget root nodes,
				// but could also be sub-nodes within a widget
				if(node._cssState){
					var widget = registry.getEnclosingWidget(node);
					if(widget){
						if(node == widget.domNode){
							// event on the widget's root node
							widget._cssMouseEvent(evt);
						}else{
							// event on widget's sub-node
							widget._subnodeCssMouseEvent(node, node._cssState, evt);
						}
					}
				}
			}
		}

		var body = win.body(), activeNode;

		// Handle pointer related events (i.e. mouse or touch)
		on(body, touch.over, function(evt){
			// Using touch.over rather than mouseover mainly to ignore phantom mouse events on iOS.
			pointerHandler(evt, evt.target, evt.relatedTarget);
		});
		on(body, touch.out, function(evt){
			// Using touch.out rather than mouseout mainly to ignore phantom mouse events on iOS.
			pointerHandler(evt, evt.target, evt.relatedTarget);
		});
		on(body, a11yclick.press, function(evt){
			// Save the a11yclick.press target to reference when the a11yclick.release comes.
			activeNode = evt.target;
			pointerHandler(evt, activeNode)
		});
		on(body, a11yclick.release, function(evt){
			// The release event could come on a separate node than the press event, if for example user slid finger.
			// Reference activeNode to reset the state of the node that got state set in the a11yclick.press handler.
			pointerHandler(evt, activeNode);
			activeNode = null;
		});

		// Track focus events on widget sub-nodes that have been registered via _trackMouseState().
		// However, don't track focus events on the widget root nodes, because focus is tracked via the
		// focus manager (and it's not really tracking focus, but rather tracking that focus is on one of the widget's
		// nodes or a subwidget's node or a popup node, etc.)
		// Remove for 2.0 (if focus CSS needed, just use :focus pseudo-selector).
		on(body, "focusin, focusout", function(evt){
			var node = evt.target;
			if(node._cssState && !node.getAttribute("widgetId")){
				var widget = registry.getEnclosingWidget(node);
				if(widget){
					widget._subnodeCssMouseEvent(node, node._cssState, evt);
				}
			}
		});
	});

	return CssStateMixin;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/_FocusMixin.js":
/*!*******************************************!*\
  !*** ./node_modules/dijit/_FocusMixin.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./focus */ "./node_modules/dijit/focus.js"),
	__webpack_require__(/*! ./_WidgetBase */ "./node_modules/dijit/_WidgetBase.js"),
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js") // lang.extend
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(focus, _WidgetBase, declare, lang){

	// module:
	//		dijit/_FocusMixin

	// We don't know where _FocusMixin will occur in the inheritance chain, but we need the _onFocus()/_onBlur() below
	// to be last in the inheritance chain, so mixin to _WidgetBase.
	lang.extend(_WidgetBase, {
		// focused: [readonly] Boolean
		//		This widget or a widget it contains has focus, or is "active" because
		//		it was recently clicked.
		focused: false,

		onFocus: function(){
			// summary:
			//		Called when the widget becomes "active" because
			//		it or a widget inside of it either has focus, or has recently
			//		been clicked.
			// tags:
			//		callback
		},

		onBlur: function(){
			// summary:
			//		Called when the widget stops being "active" because
			//		focus moved to something outside of it, or the user
			//		clicked somewhere outside of it, or the widget was
			//		hidden.
			// tags:
			//		callback
		},

		_onFocus: function(){
			// summary:
			//		This is where widgets do processing for when they are active,
			//		such as changing CSS classes.  See onFocus() for more details.
			// tags:
			//		protected
			this.onFocus();
		},

		_onBlur: function(){
			// summary:
			//		This is where widgets do processing for when they stop being active,
			//		such as changing CSS classes.  See onBlur() for more details.
			// tags:
			//		protected
			this.onBlur();
		}
	});

	return declare("dijit._FocusMixin", null, {
		// summary:
		//		Mixin to widget to provide _onFocus() and _onBlur() methods that
		//		fire when a widget or its descendants get/lose focus

		// flag that I want _onFocus()/_onBlur() notifications from focus manager
		_focusManager: focus
	});

}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/_OnDijitClickMixin.js":
/*!**************************************************!*\
  !*** ./node_modules/dijit/_OnDijitClickMixin.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.forEach
	__webpack_require__(/*! dojo/keys */ "./node_modules/dojo/keys.js"), // keys.ENTER keys.SPACE
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/has */ "./node_modules/dojo/has.js"), // has("dom-addeventlistener")
	__webpack_require__(/*! ./a11yclick */ "./node_modules/dijit/a11yclick.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(on, array, keys, declare, has, a11yclick){

	// module:
	//		dijit/_OnDijitClickMixin

	var ret = declare("dijit._OnDijitClickMixin", null, {
		// summary:
		//		Deprecated.   New code should access the dijit/a11yclick event directly, ex:
		//		|	this.own(on(node, a11yclick, function(){ ... }));
		//
		//		Mixing in this class will make _WidgetBase.connect(node, "ondijitclick", ...) work.
		//		It also used to be necessary to make templates with ondijitclick work, but now you can just require
		//		dijit/a11yclick.

		connect: function(obj, event, method){
			// override _WidgetBase.connect() to make this.connect(node, "ondijitclick", ...) work
			return this.inherited(arguments, [obj, event == "ondijitclick" ? a11yclick : event, method]);
		}
	});

	ret.a11yclick = a11yclick;	// back compat

	return ret;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/_TemplatedMixin.js":
/*!***********************************************!*\
  !*** ./node_modules/dijit/_TemplatedMixin.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/cache */ "./node_modules/dojo/cache.js"),	// dojo.cache
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom-construct */ "./node_modules/dojo/dom-construct.js"), // domConstruct.destroy, domConstruct.toDom
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.getObject
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js"), // has("ie")
	__webpack_require__(/*! dojo/string */ "./node_modules/dojo/string.js"), // string.substitute string.trim
	__webpack_require__(/*! ./_AttachMixin */ "./node_modules/dijit/_AttachMixin.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(cache, declare, domConstruct, lang, on, has, string, _AttachMixin){

	// module:
	//		dijit/_TemplatedMixin

	var _TemplatedMixin = declare("dijit._TemplatedMixin", _AttachMixin, {
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template.
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
		templatePath: null,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template nodes poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

/*=====
		// _rendered: Boolean
		//		Not normally use, but this flag can be set by the app if the server has already rendered the template,
		//		i.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to
		//		just function like _AttachMixin.
		_rendered: false,
=====*/

		// Set _AttachMixin.searchContainerNode to true for back-compat for widgets that have data-dojo-attach-point's
		// and events inside this.containerNode.   Remove for 2.0.
		searchContainerNode: true,

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value : this._escapeValue("" + value);
			}, this);
		},

		_escapeValue: function(/*String*/ val){
			// summary:
			//		Escape a value to be inserted into the template, either into an attribute value
			//		(ex: foo="${bar}") or as inner text of an element (ex: <span>${foo}</span>)

			// Safer substitution, see heading "Attribute values" in
			// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
			// and also https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content
			return val.replace(/["'<>&]/g, function(val){
				return {
					"&": "&amp;",
					"<": "&lt;",
					">": "&gt;",
					"\"": "&quot;",
					"'": "&#x27;"
				}[val];
			});
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			if(!this._rendered){
				if(!this.templateString){
					this.templateString = cache(this.templatePath, {sanitize: true});
				}

				// Lookup cached version of template, and download to cache if it
				// isn't there already.  Returns either a DomNode or a string, depending on
				// whether or not the template contains ${foo} replacement parameters.
				var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache, this.ownerDocument);

				var node;
				if(lang.isString(cached)){
					node = domConstruct.toDom(this._stringRepl(cached), this.ownerDocument);
					if(node.nodeType != 1){
						// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
						throw new Error("Invalid template: " + cached);
					}
				}else{
					// if it's a node, all we have to do is clone it
					node = cached.cloneNode(true);
				}

				this.domNode = node;
			}

			// Call down to _WidgetBase.buildRendering() to get base classes assigned
			// TODO: change the baseClass assignment to _setBaseClassAttr
			this.inherited(arguments);

			if(!this._rendered){
				this._fillContent(this.srcNodeRef);
			}

			this._rendered = true;
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		}

	});

	// key is templateString; object is either string or DOM tree
	_TemplatedMixin._templateCache = {};

	_TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString, doc){
		// summary:
		//		Static method to get a template based on the templatePath or
		//		templateString key
		// templateString: String
		//		The template
		// alwaysUseString: Boolean
		//		Don't cache the DOM tree for this template, even if it doesn't have any variables
		// doc: Document?
		//		The target document.   Defaults to document global if unspecified.
		// returns: Mixed
		//		Either string (if there are ${} variables that need to be replaced) or just
		//		a DOM tree (if the node can be cloned directly)

		// is it already cached?
		var tmplts = _TemplatedMixin._templateCache;
		var key = templateString;
		var cached = tmplts[key];
		if(cached){
			try{
				// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the
				// current document, then use the current cached value
				if(!cached.ownerDocument || cached.ownerDocument == (doc || document)){
					// string or node of the same document
					return cached;
				}
			}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
			domConstruct.destroy(cached);
		}

		templateString = string.trim(templateString);

		if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
			// there are variables in the template so all we can do is cache the string
			return (tmplts[key] = templateString); //String
		}else{
			// there are no variables in the template so we can cache the DOM tree
			var node = domConstruct.toDom(templateString, doc);
			if(node.nodeType != 1){
				throw new Error("Invalid template: " + templateString);
			}
			return (tmplts[key] = node); //Node
		}
	};

	if(has("ie")){
		on(window, "unload", function(){
			var cache = _TemplatedMixin._templateCache;
			for(var key in cache){
				var value = cache[key];
				if(typeof value == "object"){ // value is either a string or a DOM node template
					domConstruct.destroy(value);
				}
				delete cache[key];
			}
		});
	}

	return _TemplatedMixin;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/_Widget.js":
/*!***************************************!*\
  !*** ./node_modules/dijit/_Widget.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/aspect */ "./node_modules/dojo/aspect.js"),	// aspect.around
	__webpack_require__(/*! dojo/_base/config */ "./node_modules/dojo/_base/config.js"),	// config.isDebug
	__webpack_require__(/*! dojo/_base/connect */ "./node_modules/dojo/_base/connect.js"),	// connect.connect
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/has */ "./node_modules/dojo/has.js"),
	__webpack_require__(/*! dojo/_base/kernel */ "./node_modules/dojo/_base/kernel.js"), // kernel.deprecated
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.hitch
	__webpack_require__(/*! dojo/query */ "./node_modules/dojo/query.js"),
	__webpack_require__(/*! dojo/ready */ "./node_modules/dojo/ready.js"),
	__webpack_require__(/*! ./registry */ "./node_modules/dijit/registry.js"),	// registry.byNode
	__webpack_require__(/*! ./_WidgetBase */ "./node_modules/dijit/_WidgetBase.js"),
	__webpack_require__(/*! ./_OnDijitClickMixin */ "./node_modules/dijit/_OnDijitClickMixin.js"),
	__webpack_require__(/*! ./_FocusMixin */ "./node_modules/dijit/_FocusMixin.js"),
	__webpack_require__(/*! dojo/uacss */ "./node_modules/dojo/uacss.js"),		// browser sniffing (included for back-compat; subclasses may be using)
	__webpack_require__(/*! ./hccss */ "./node_modules/dijit/hccss.js")		// high contrast mode sniffing (included to set CSS classes on <body>, module ret value unused)
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(aspect, config, connect, declare, has, kernel, lang, query, ready,
			registry, _WidgetBase, _OnDijitClickMixin, _FocusMixin){


// module:
//		dijit/_Widget


function connectToDomNode(){
	// summary:
	//		If user connects to a widget method === this function, then they will
	//		instead actually be connecting the equivalent event on this.domNode
}

// Trap dojo.connect() calls to connectToDomNode methods, and redirect to _Widget.on()
function aroundAdvice(originalConnect){
	return function(obj, event, scope, method){
		if(obj && typeof event == "string" && obj[event] == connectToDomNode){
			return obj.on(event.substring(2).toLowerCase(), lang.hitch(scope, method));
		}
		return originalConnect.apply(connect, arguments);
	};
}
aspect.around(connect, "connect", aroundAdvice);
if(kernel.connect){
	aspect.around(kernel, "connect", aroundAdvice);
}

var _Widget = declare("dijit._Widget", [_WidgetBase, _OnDijitClickMixin, _FocusMixin], {
	// summary:
	//		Old base class for widgets.   New widgets should extend `dijit/_WidgetBase` instead
	// description:
	//		Old Base class for Dijit widgets.
	//
	//		Extends _WidgetBase, adding support for:
	//
	//		- declaratively/programatically specifying widget initialization parameters like
	//			onMouseMove="foo" that call foo when this.domNode gets a mousemove event
	//		- ondijitclick:
	//			Support new data-dojo-attach-event="ondijitclick: ..." that is triggered by a mouse click or a SPACE/ENTER keypress
	//		- focus related functions:
	//			In particular, the onFocus()/onBlur() callbacks.   Driven internally by
	//			dijit/_base/focus.js.
	//		- deprecated methods
	//		- onShow(), onHide(), onClose()
	//
	//		Also, by loading code in dijit/_base, turns on:
	//
	//		- browser sniffing (putting browser class like `dj_ie` on `<html>` node)
	//		- high contrast mode sniffing (add `dijit_a11y` class to `<body>` if machine is in high contrast mode)


	////////////////// DEFERRED CONNECTS ///////////////////

	onClick: connectToDomNode,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: connectToDomNode,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: connectToDomNode,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: connectToDomNode,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: connectToDomNode,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: connectToDomNode,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: connectToDomNode,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: connectToDomNode,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: connectToDomNode,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: connectToDomNode,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: connectToDomNode,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: connectToDomNode,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	constructor: function(params /*===== ,srcNodeRef =====*/){
		// summary:
		//		Create the widget.
		// params: Object|null
		//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
		//		and functions, typically callbacks like onClick.
		//		The hash can contain any of the widget's properties, excluding read-only properties.
		// srcNodeRef: DOMNode|String?
		//		If a srcNodeRef (DOM node) is specified:
		//
		//		- use srcNodeRef.innerHTML as my contents
		//		- if this is a behavioral widget then apply behavior to that srcNodeRef
		//		- otherwise, replace srcNodeRef with my generated DOM tree

		// extract parameters like onMouseMove that should connect directly to this.domNode
		this._toConnect = {};
		for(var name in params){
			if(this[name] === connectToDomNode){
				this._toConnect[name.replace(/^on/, "").toLowerCase()] = params[name];
				delete params[name];
			}
		}
	},

	postCreate: function(){
		this.inherited(arguments);

		// perform connection from this.domNode to user specified handlers (ex: onMouseMove)
		for(var name in this._toConnect){
			this.on(name, this._toConnect[name]);
		}
		delete this._toConnect;
	},

	on: function(/*String|Function*/ type, /*Function*/ func){
		if(this[this._onMap(type)] === connectToDomNode){
			// Use connect.connect() rather than on() to get handling for "onmouseenter" on non-IE,
			// normalization of onkeypress/onkeydown to behave like firefox, etc.
			// Also, need to specify context as "this" rather than the default context of the DOMNode
			// Remove in 2.0.
			return connect.connect(this.domNode, type.toLowerCase(), this, func);
		}
		return this.inherited(arguments);
	},

	_setFocusedAttr: function(val){
		// Remove this method in 2.0 (or sooner), just here to set _focused == focused, for back compat
		// (but since it's a private variable we aren't required to keep supporting it).
		this._focused = val;
		this._set("focused", val);
	},

	////////////////// DEPRECATED METHODS ///////////////////

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use set() instead.
		// tags:
		//		deprecated
		kernel.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
		this.set(attr, value);
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		This method is deprecated, use get() or set() directly.
		// name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		// value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// tags:
		//		deprecated

		var args = arguments.length;
		if(args >= 2 || typeof name === "object"){ // setter
			return this.set.apply(this, arguments);
		}else{ // getter
			return this.get(name);
		}
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		kernel.deprecated(this.declaredClass+"::getDescendants() is deprecated. Use getChildren() instead.", "", "2.0");
		return this.containerNode ? query('[widgetId]', this.containerNode).map(registry.byNode) : []; // dijit/_WidgetBase[]
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
		//		`dijit/layout/AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
		//		Called when another widget becomes the selected pane in a
		//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
		//		`dijit/layout/AccordionContainer`, etc.
		//
		//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onClose: function(){
		// summary:
		//		Called when this widget is being displayed as a popup (ex: a Calendar popped
		//		up from a DateTextBox), and it is hidden.
		//		This is called from the dijit.popup code, and should not be called directly.
		//
		//		Also used as a parameter for children of `dijit/layout/StackContainer` or subclasses.
		//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
		// tags:
		//		extension

		return true;		// Boolean
	}
});

// For back-compat, remove in 2.0.
if(has("dijit-legacy-requires")){
	ready(0, function(){
		var requires = ["dijit/_base"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}
return _Widget;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/_WidgetBase.js":
/*!*******************************************!*\
  !*** ./node_modules/dijit/_WidgetBase.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__.dj.c(module.i), // require.toUrl
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.forEach array.map
	__webpack_require__(/*! dojo/aspect */ "./node_modules/dojo/aspect.js"),
	__webpack_require__(/*! dojo/_base/config */ "./node_modules/dojo/_base/config.js"), // config.blankGif
	__webpack_require__(/*! dojo/_base/connect */ "./node_modules/dojo/_base/connect.js"), // connect.connect
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom */ "./node_modules/dojo/dom.js"), // dom.byId
	__webpack_require__(/*! dojo/dom-attr */ "./node_modules/dojo/dom-attr.js"), // domAttr.set domAttr.remove
	__webpack_require__(/*! dojo/dom-class */ "./node_modules/dojo/dom-class.js"), // domClass.add domClass.replace
	__webpack_require__(/*! dojo/dom-construct */ "./node_modules/dojo/dom-construct.js"), // domConstruct.destroy domConstruct.place
	__webpack_require__(/*! dojo/dom-geometry */ "./node_modules/dojo/dom-geometry.js"), // isBodyLtr
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"), // domStyle.set, domStyle.get
	__webpack_require__(/*! dojo/has */ "./node_modules/dojo/has.js"),
	__webpack_require__(/*! dojo/_base/kernel */ "./node_modules/dojo/_base/kernel.js"),
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // mixin(), isArray(), etc.
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/ready */ "./node_modules/dojo/ready.js"),
	__webpack_require__(/*! dojo/Stateful */ "./node_modules/dojo/Stateful.js"), // Stateful
	__webpack_require__(/*! dojo/topic */ "./node_modules/dojo/topic.js"),
	__webpack_require__(/*! dojo/_base/window */ "./node_modules/dojo/_base/window.js"), // win.body()
	__webpack_require__(/*! ./Destroyable */ "./node_modules/dijit/Destroyable.js"),
	__webpack_require__.dj.h("dojo-bidi?./node_modules/dijit/_BidiMixin.js"),
	__webpack_require__(/*! ./registry */ "./node_modules/dijit/registry.js")    // registry.getUniqueId(), registry.findWidgets()
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(require, array, aspect, config, connect, declare,
			dom, domAttr, domClass, domConstruct, domGeometry, domStyle, has, kernel,
			lang, on, ready, Stateful, topic, win, Destroyable, _BidiMixin, registry){

	// module:
	//		dijit/_WidgetBase

	// Flag to make dijit load modules the app didn't explicitly request, for backwards compatibility
	has.add("dijit-legacy-requires", !kernel.isAsync);

	// Flag to enable support for textdir attribute
	has.add("dojo-bidi", false);


	// For back-compat, remove in 2.0.
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/_base/manager"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	// Nested hash listing attributes for each tag, all strings in lowercase.
	// ex: {"div": {"style": true, "tabindex" true}, "form": { ...
	var tagAttrs = {};

	function getAttrs(obj){
		var ret = {};
		for(var attr in obj){
			ret[attr.toLowerCase()] = true;
		}
		return ret;
	}

	function nonEmptyAttrToDom(attr){
		// summary:
		//		Returns a setter function that copies the attribute to this.domNode,
		//		or removes the attribute from this.domNode, depending on whether the
		//		value is defined or not.
		return function(val){
			domAttr[val ? "set" : "remove"](this.domNode, attr, val);
			this._set(attr, val);
		};
	}

	function isEqual(a, b){
		//	summary:
		//		Function that determines whether two values are identical,
		//		taking into account that NaN is not normally equal to itself
		//		in JS.

		return a === b || (/* a is NaN */ a !== a && /* b is NaN */ b !== b);
	}

	var _WidgetBase = declare("dijit._WidgetBase", [Stateful, Destroyable], {
		// summary:
		//		Future base class for all Dijit widgets.
		// description:
		//		Future base class for all Dijit widgets.
		//		_Widget extends this class adding support for various features needed by desktop.
		//
		//		Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),
		//		postCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().
		//
		//		Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).
		//		For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
		//
		//		_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:
		//
		//		- DOM node attribute
		// |		_setFocusAttr: {node: "focusNode", type: "attribute"}
		// |		_setFocusAttr: "focusNode"	(shorthand)
		// |		_setFocusAttr: ""		(shorthand, maps to this.domNode)
		//		Maps this.focus to this.focusNode.focus, or (last example) this.domNode.focus
		//
		//		- DOM node innerHTML
		//	|		_setTitleAttr: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		_setTitleAttr: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		_setMyClassAttr: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		- Toggle DOM node CSS class
		// |		_setMyClassAttr: { node: "domNode", type: "toggleClass" }
		//		Toggles myClass on this.domNode by this.myClass
		//
		//		If the value of _setXXXAttr is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		If the custom setter is null, no action is performed other than saving the new value
		//		in the widget (in this).
		//
		//		If no custom setter is defined for an attribute, then it will be copied
		//		to this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.
		//		That's only done though for attributes that match DOMNode attributes (title,
		//		alt, aria-labelledby, etc.)

		// id: [const] String
		//		A unique, opaque ID string that can be assigned by users or by the
		//		system. If the developer passes an ID which is known not to be
		//		unique, the specified ID is ignored and the system-generated ID is
		//		used instead.
		id: "",
		_setIdAttr: "domNode", // to copy to this.domNode even for auto-generated id's

		// lang: [const] String
		//		Rarely used.  Overrides the default Dojo locale used to render this widget,
		//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
		//		Value must be among the list of locales specified during by the Dojo bootstrap,
		//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
		lang: "",
		// set on domNode even when there's a focus node.	but don't set lang="", since that's invalid.
		_setLangAttr: nonEmptyAttrToDom("lang"),

		// dir: [const] String
		//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
		//		attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
		//		default direction.
		dir: "",
		// set on domNode even when there's a focus node.	but don't set dir="", since that's invalid.
		_setDirAttr: nonEmptyAttrToDom("dir"), // to set on domNode even when there's a focus node

		// class: String
		//		HTML class attribute
		"class": "",
		_setClassAttr: { node: "domNode", type: "class" },

		// Override automatic assigning type --> focusNode, it causes exception on IE6-8.
		// Instead, type must be specified as ${type} in the template, as part of the original DOM.
		_setTypeAttr: null,

		// style: String||Object
		//		HTML style attributes as cssText string or name/value hash
		style: "",

		// title: String
		//		HTML title attribute.
		//
		//		For form widgets this specifies a tooltip to display when hovering over
		//		the widget (just like the native HTML title attribute).
		//
		//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
		//		etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
		//		interpreted as HTML.
		title: "",

		// tooltip: String
		//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
		//		this specifies the tooltip to appear when the mouse is hovered over that text.
		tooltip: "",

		// baseClass: [protected] String
		//		Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
		//		widget state.
		baseClass: "",

		// srcNodeRef: [readonly] DomNode
		//		pointer to original DOM node
		srcNodeRef: null,

		// domNode: [readonly] DomNode
		//		This is our visible representation of the widget! Other DOM
		//		Nodes may by assigned to other properties, usually through the
		//		template system's data-dojo-attach-point syntax, but the domNode
		//		property is the canonical "top level" node in widget UI.
		domNode: null,

		// containerNode: [readonly] DomNode
		//		Designates where children of the source DOM node will be placed.
		//		"Children" in this case refers to both DOM nodes and widgets.
		//		For example, for myWidget:
		//
		//		|	<div data-dojo-type=myWidget>
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//		|	</div>
		//
		//		containerNode would point to:
		//
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//
		//		In templated widgets, "containerNode" is set via a
		//		data-dojo-attach-point assignment.
		//
		//		containerNode must be defined for any widget that accepts innerHTML
		//		(like ContentPane or BorderContainer or even Button), and conversely
		//		is null for widgets that don't, like TextBox.
		containerNode: null,

		// ownerDocument: [const] Document?
		//		The document this widget belongs to.  If not specified to constructor, will default to
		//		srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
		ownerDocument: null,
		_setOwnerDocumentAttr: function(val){
			// this setter is merely to avoid automatically trying to set this.domNode.ownerDocument
			this._set("ownerDocument", val);
		},

		/*=====
		// _started: [readonly] Boolean
		//		startup() has completed.
		_started: false,
		=====*/

		// attributeMap: [protected] Object
		//		Deprecated.	Instead of attributeMap, widget should have a _setXXXAttr attribute
		//		for each XXX attribute to be mapped to the DOM.
		//
		//		attributeMap sets up a "binding" between attributes (aka properties)
		//		of the widget and the widget's DOM.
		//		Changes to widget attributes listed in attributeMap will be
		//		reflected into the DOM.
		//
		//		For example, calling set('title', 'hello')
		//		on a TitlePane will automatically cause the TitlePane's DOM to update
		//		with the new title.
		//
		//		attributeMap is a hash where the key is an attribute of the widget,
		//		and the value reflects a binding to a:
		//
		//		- DOM node attribute
		// |		focus: {node: "focusNode", type: "attribute"}
		//		Maps this.focus to this.focusNode.focus
		//
		//		- DOM node innerHTML
		//	|		title: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		title: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		myClass: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		If the value is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		There are also some shorthands for backwards compatibility:
		//
		//		- string --> { node: string, type: "attribute" }, for example:
		//
		//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
		//
		//		- "" --> { node: "domNode", type: "attribute" }
		attributeMap: {},

		// _blankGif: [protected] String
		//		Path to a blank 1x1 image.
		//		Used by `<img>` nodes in templates that really get their image via CSS background-image.
		_blankGif: config.blankGif || require.toUrl("dojo/resources/blank.gif"),

		// textDir: String
		//		Bi-directional support,	the main variable which is responsible for the direction of the text.
		//		The text direction can be different than the GUI direction by using this parameter in creation
		//		of a widget.
		//
		//		This property is only effective when `has("dojo-bidi")` is defined to be true.
		//
		//		Allowed values:
		//
		//		1. "" - default value; text is same direction as widget
		//		2. "ltr"
		//		3. "rtl"
		//		4. "auto" - contextual the direction of a text defined by first strong letter.
		textDir: "",

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		/*=====
		constructor: function(params, srcNodeRef){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
		},
		=====*/

		_introspect: function(){
			// summary:
			//		Collect metadata about this widget (only once per class, not once per instance):
			//
			//			- list of attributes with custom setters, storing in this.constructor._setterAttrs
			//			- generate this.constructor._onMap, mapping names like "mousedown" to functions like onMouseDown

			var ctor = this.constructor;
			if(!ctor._setterAttrs){
				var proto = ctor.prototype,
					attrs = ctor._setterAttrs = [], // attributes with custom setters
					onMap = (ctor._onMap = {});

				// Items in this.attributeMap are like custom setters.  For back-compat, remove for 2.0.
				for(var name in proto.attributeMap){
					attrs.push(name);
				}

				// Loop over widget properties, collecting properties with custom setters and filling in ctor._onMap.
				for(name in proto){
					if(/^on/.test(name)){
						onMap[name.substring(2).toLowerCase()] = name;
					}

					if(/^_set[A-Z](.*)Attr$/.test(name)){
						name = name.charAt(4).toLowerCase() + name.substr(5, name.length - 9);
						if(!proto.attributeMap || !(name in proto.attributeMap)){
							attrs.push(name);
						}
					}
				}

				// Note: this isn't picking up info on properties like aria-label and role, that don't have custom setters
				// but that set() maps to attributes on this.domNode or this.focusNode
			}
		},

		postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
			// summary:
			//		Kicks off widget instantiation.  See create() for details.
			// tags:
			//		private

			// Note that we skip calling this.inherited(), i.e. dojo/Stateful::postscript(), because 1.x widgets don't
			// expect their custom setters to get called until after buildRendering().  Consider changing for 2.0.

			this.create(params, srcNodeRef);
		},

		create: function(params, srcNodeRef){
			// summary:
			//		Kick off the life-cycle of a widget
			// description:
			//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
			//		etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
			//		for a discussion of the widget creation lifecycle.
			//
			//		Of course, adventurous developers could override create entirely, but this should
			//		only be done as a last resort.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
			// tags:
			//		private

			// First time widget is instantiated, scan prototype to figure out info about custom setters etc.
			this._introspect();

			// store pointer to original DOM tree
			this.srcNodeRef = dom.byId(srcNodeRef);

			// No longer used, remove for 2.0.
			this._connects = [];
			this._supportingWidgets = [];

			// this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)
			if(this.srcNodeRef && this.srcNodeRef.id  && (typeof this.srcNodeRef.id == "string")){
				this.id = this.srcNodeRef.id;
			}

			// mix in our passed parameters
			if(params){
				this.params = params;
				lang.mixin(this, params);
			}
			this.postMixInProperties();

			// Generate an id for the widget if one wasn't specified, or it was specified as id: undefined.
			// Do this before buildRendering() because it might expect the id to be there.
			if(!this.id){
				this.id = registry.getUniqueId(this.declaredClass.replace(/\./g, "_"));
				if(this.params){
					// if params contains {id: undefined}, prevent _applyAttributes() from processing it
					delete this.params.id;
				}
			}

			// The document and <body> node this widget is associated with
			this.ownerDocument = this.ownerDocument || (this.srcNodeRef ? this.srcNodeRef.ownerDocument : document);
			this.ownerDocumentBody = win.body(this.ownerDocument);

			registry.add(this);

			this.buildRendering();

			var deleteSrcNodeRef;

			if(this.domNode){
				// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
				// Also calls custom setters for all attributes with custom setters.
				this._applyAttributes();

				// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
				// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
				// widget being attached to the DOM since it isn't when a widget is created programmatically like
				// new MyWidget({}).	See #11635.
				var source = this.srcNodeRef;
				if(source && source.parentNode && this.domNode !== source){
					source.parentNode.replaceChild(this.domNode, source);
					deleteSrcNodeRef = true;
				}

				// Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
				// assuming that dojo._scopeName even exists in 2.0
				this.domNode.setAttribute("widgetId", this.id);
			}
			this.postCreate();

			// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
			// I think for back-compatibility it isn't deleting srcNodeRef until after postCreate() has run.
			if(deleteSrcNodeRef){
				delete this.srcNodeRef;
			}

			this._created = true;
		},

		_applyAttributes: function(){
			// summary:
			//		Step during widget creation to copy  widget attributes to the
			//		DOM according to attributeMap and _setXXXAttr objects, and also to call
			//		custom _setXXXAttr() methods.
			//
			//		Skips over blank/false attribute values, unless they were explicitly specified
			//		as parameters to the widget, since those are the default anyway,
			//		and setting tabIndex="" is different than not setting tabIndex at all.
			//
			//		For backwards-compatibility reasons attributeMap overrides _setXXXAttr when
			//		_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.
			// tags:
			//		private

			// Call this.set() for each property that was either specified as parameter to constructor,
			// or is in the list found above.	For correlated properties like value and displayedValue, the one
			// specified as a parameter should take precedence.
			// Particularly important for new DateTextBox({displayedValue: ...}) since DateTextBox's default value is
			// NaN and thus is not ignored like a default value of "".

			// Step 1: Save the current values of the widget properties that were specified as parameters to the constructor.
			// Generally this.foo == this.params.foo, except if postMixInProperties() changed the value of this.foo.
			var params = {};
			for(var key in this.params || {}){
				params[key] = this._get(key);
			}

			// Step 2: Call set() for each property with a non-falsy value that wasn't passed as a parameter to the constructor
			array.forEach(this.constructor._setterAttrs, function(key){
				if(!(key in params)){
					var val = this._get(key);
					if(val){
						this.set(key, val);
					}
				}
			}, this);

			// Step 3: Call set() for each property that was specified as parameter to constructor.
			// Use params hash created above to ignore side effects from step #2 above.
			for(key in params){
				this.set(key, params[key]);
			}
		},

		postMixInProperties: function(){
			// summary:
			//		Called after the parameters to the widget have been read-in,
			//		but before the widget template is instantiated. Especially
			//		useful to set properties that are referenced in the widget
			//		template.
			// tags:
			//		protected
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget, setting this.domNode.
			//		Most widgets will mixin `dijit._TemplatedMixin`, which implements this method.
			// tags:
			//		protected

			if(!this.domNode){
				// Create root node if it wasn't created by _TemplatedMixin
				this.domNode = this.srcNodeRef || this.ownerDocument.createElement("div");
			}

			// baseClass is a single class name or occasionally a space-separated list of names.
			// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.
			// TODO: make baseClass custom setter
			if(this.baseClass){
				var classes = this.baseClass.split(" ");
				if(!this.isLeftToRight()){
					classes = classes.concat(array.map(classes, function(name){
						return name + "Rtl";
					}));
				}
				domClass.add(this.domNode, classes);
			}
		},

		postCreate: function(){
			// summary:
			//		Processing after the DOM fragment is created
			// description:
			//		Called after the DOM fragment has been created, but not necessarily
			//		added to the document.  Do not include any operations which rely on
			//		node dimensions or placement.
			// tags:
			//		protected
		},

		startup: function(){
			// summary:
			//		Processing after the DOM fragment is added to the document
			// description:
			//		Called after a widget and its children have been created and added to the page,
			//		and all related widgets have finished their create() cycle, up through postCreate().
			//
			//		Note that startup() may be called while the widget is still hidden, for example if the widget is
			//		inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
			//		For widgets that need to do layout, it's best to put that layout code inside resize(), and then
			//		extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
			if(this._started){
				return;
			}
			this._started = true;
			array.forEach(this.getChildren(), function(obj){
				if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			});
		},

		//////////// DESTROY FUNCTIONS ////////////////////////////////

		destroyRecursive: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroy this widget and its descendants
			// description:
			//		This is the generic "destructor" function that all widget users
			//		should call to cleanly discard with a widget. Once a widget is
			//		destroyed, it is removed from the manager object.
			// preserveDom:
			//		If true, this method will leave the original DOM structure
			//		alone of descendant Widgets. Note: This will NOT work with
			//		dijit._TemplatedMixin widgets.

			this._beingDestroyed = true;
			this.destroyDescendants(preserveDom);
			this.destroy(preserveDom);
		},

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this widget, but not its descendants.  Descendants means widgets inside of
			//		this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
			//
			//		This method will also destroy internal widgets such as those created from a template,
			//		assuming those widgets exist inside of this.domNode but outside of this.containerNode.
			//
			//		For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
			//		depend on the current ability to destroy a widget without destroying its descendants.   Generally
			//		they should use destroyRecursive() for widgets with children.
			// preserveDom: Boolean
			//		If true, this method will leave the original DOM structure alone.
			//		Note: This will not yet work with _TemplatedMixin widgets

			this._beingDestroyed = true;
			this.uninitialize();

			function destroy(w){
				if(w.destroyRecursive){
					w.destroyRecursive(preserveDom);
				}else if(w.destroy){
					w.destroy(preserveDom);
				}
			}

			// Back-compat, remove for 2.0
			array.forEach(this._connects, lang.hitch(this, "disconnect"));
			array.forEach(this._supportingWidgets, destroy);

			// Destroy supporting widgets, but not child widgets under this.containerNode (for 2.0, destroy child widgets
			// here too).   if() statement is to guard against exception if destroy() called multiple times (see #15815).
			if(this.domNode){
				array.forEach(registry.findWidgets(this.domNode, this.containerNode), destroy);
			}

			this.destroyRendering(preserveDom);
			registry.remove(this.id);
			this._destroyed = true;
		},

		destroyRendering: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroys the DOM nodes associated with this widget.
			// preserveDom:
			//		If true, this method will leave the original DOM structure alone
			//		during tear-down. Note: this will not work with _Templated
			//		widgets yet.
			// tags:
			//		protected

			if(this.bgIframe){
				this.bgIframe.destroy(preserveDom);
				delete this.bgIframe;
			}

			if(this.domNode){
				if(preserveDom){
					domAttr.remove(this.domNode, "widgetId");
				}else{
					domConstruct.destroy(this.domNode);
				}
				delete this.domNode;
			}

			if(this.srcNodeRef){
				if(!preserveDom){
					domConstruct.destroy(this.srcNodeRef);
				}
				delete this.srcNodeRef;
			}
		},

		destroyDescendants: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Recursively destroy the children of this widget and their
			//		descendants.
			// preserveDom:
			//		If true, the preserveDom attribute is passed to all descendant
			//		widget's .destroy() method. Not for use with _Templated
			//		widgets.

			// get all direct descendants and destroy them recursively
			array.forEach(this.getChildren(), function(widget){
				if(widget.destroyRecursive){
					widget.destroyRecursive(preserveDom);
				}
			});
		},

		uninitialize: function(){
			// summary:
			//		Deprecated. Override destroy() instead to implement custom widget tear-down
			//		behavior.
			// tags:
			//		protected
			return false;
		},

		////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////

		_setStyleAttr: function(/*String||Object*/ value){
			// summary:
			//		Sets the style attribute of the widget according to value,
			//		which is either a hash like {height: "5px", width: "3px"}
			//		or a plain string
			// description:
			//		Determines which node to set the style on based on style setting
			//		in attributeMap.
			// tags:
			//		protected

			var mapNode = this.domNode;

			// Note: technically we should revert any style setting made in a previous call
			// to his method, but that's difficult to keep track of.

			if(lang.isObject(value)){
				domStyle.set(mapNode, value);
			}else{
				if(mapNode.style.cssText){
					mapNode.style.cssText += "; " + value;
				}else{
					mapNode.style.cssText = value;
				}
			}

			this._set("style", value);
		},

		_attrToDom: function(/*String*/ attr, /*String*/ value, /*Object?*/ commands){
			// summary:
			//		Reflect a widget attribute (title, tabIndex, duration etc.) to
			//		the widget DOM, as specified by commands parameter.
			//		If commands isn't specified then it's looked up from attributeMap.
			//		Note some attributes like "type"
			//		cannot be processed this way as they are not mutable.
			// attr:
			//		Name of member variable (ex: "focusNode" maps to this.focusNode) pointing
			//		to DOMNode inside the widget, or alternately pointing to a subwidget
			// tags:
			//		private

			commands = arguments.length >= 3 ? commands : this.attributeMap[attr];

			array.forEach(lang.isArray(commands) ? commands : [commands], function(command){

				// Get target node and what we are doing to that node
				var mapNode = this[command.node || command || "domNode"];	// DOM node
				var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

				switch(type){
					case "attribute":
						if(lang.isFunction(value)){ // functions execute in the context of the widget
							value = lang.hitch(this, value);
						}

						// Get the name of the DOM node attribute; usually it's the same
						// as the name of the attribute in the widget (attr), but can be overridden.
						// Also maps handler names to lowercase, like onSubmit --> onsubmit
						var attrName = command.attribute ? command.attribute :
							(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

						if(mapNode.tagName){
							// Normal case, mapping to a DOMNode.  Note that modern browsers will have a mapNode.set()
							// method, but for consistency we still call domAttr
							domAttr.set(mapNode, attrName, value);
						}else{
							// mapping to a sub-widget
							mapNode.set(attrName, value);
						}
						break;
					case "innerText":
						// Deprecated, use "textContent" instead.
						mapNode.innerHTML = "";
						mapNode.appendChild(this.ownerDocument.createTextNode(value));
						break;
					case "textContent":
						mapNode.textContent = value;
						break;
					case "innerHTML":
						mapNode.innerHTML = value;
						break;
					case "class":
						domClass.replace(mapNode, value, this[attr]);
						break;
					case "toggleClass":
						domClass.toggle(mapNode, command.className || attr, value);
						break;
				}
			}, this);
		},

		get: function(name){
			// summary:
			//		Get a property from a widget.
			// name:
			//		The property to get.
			// description:
			//		Get a named property from a widget. The property may
			//		potentially be retrieved via a getter method. If no getter is defined, this
			//		just retrieves the object's property.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_getFooAttr()`, calling:
			//		`myWidget.get("foo")` would be equivalent to calling
			//		`widget._getFooAttr()` and `myWidget.get("bar")`
			//		would be equivalent to the expression
			//		`widget.bar2`
			var names = this._getAttrNames(name);
			return this[names.g] ? this[names.g]() : this._get(name);
		},

		set: function(name, value){
			// summary:
			//		Set a property on a widget
			// name:
			//		The property to set.
			// value:
			//		The value to set in the property.
			// description:
			//		Sets named properties on a widget which may potentially be handled by a
			//		setter in the widget.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_setFooAttr()`, calling
			//		`myWidget.set("foo", "Howdy!")` would be equivalent to calling
			//		`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
			//		would be equivalent to the statement `widget.bar = 3;`
			//
			//		set() may also be called with a hash of name/value pairs, ex:
			//
			//	|	myWidget.set({
			//	|		foo: "Howdy",
			//	|		bar: 3
			//	|	});
			//
			//	This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`

			if(typeof name === "object"){
				for(var x in name){
					this.set(x, name[x]);
				}
				return this;
			}
			var names = this._getAttrNames(name),
				setter = this[names.s];
			if(lang.isFunction(setter)){
				// use the explicit setter
				var result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
			}else{
				// Mapping from widget attribute to DOMNode/subwidget attribute/value/etc.
				// Map according to:
				//		1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)
				//		2. _setFooAttr: {...} type attribute in the widget (if one exists)
				//		3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.
				// Checks if an attribute is a "standard attribute" by whether the DOMNode JS object has a similar
				// attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).
				// Note also that Tree.focusNode() is a function not a DOMNode, so test for that.
				var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode",
					tag = this[defaultNode] && this[defaultNode].tagName,
					attrsForTag = tag && (tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode]))),
					map = name in this.attributeMap ? this.attributeMap[name] :
						names.s in this ? this[names.s] :
							((attrsForTag && names.l in attrsForTag && typeof value != "function") ||
								/^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
				if(map != null){
					this._attrToDom(name, value, map);
				}
				this._set(name, value);
			}
			return result || this;
		},

		_attrPairNames: {}, // shared between all widgets
		_getAttrNames: function(name){
			// summary:
			//		Helper function for get() and set().
			//		Caches attribute name values so we don't do the string ops every time.
			// tags:
			//		private

			var apn = this._attrPairNames;
			if(apn[name]){
				return apn[name];
			}
			var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){
				return c.charAt(c.length - 1).toUpperCase();
			});
			return (apn[name] = {
				n: name + "Node",
				s: "_set" + uc + "Attr", // converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
				g: "_get" + uc + "Attr",
				l: uc.toLowerCase()        // lowercase name w/out dashes, ex: acceptcharset
			});
		},

		_set: function(/*String*/ name, /*anything*/ value){
			// summary:
			//		Helper function to set new value for specified property, and call handlers
			//		registered with watch() if the value has changed.
			var oldValue = this[name];
			this[name] = value;
			if(this._created && !isEqual(oldValue, value)){
				if(this._watchCallbacks){
					this._watchCallbacks(name, oldValue, value);
				}
				this.emit("attrmodified-" + name, {
					detail: {
						prevValue: oldValue,
						newValue: value
					}
				});
			}
		},

		_get: function(/*String*/ name){
			// summary:
			//		Helper function to get value for specified property stored by this._set(),
			//		i.e. for properties with custom setters.  Used mainly by custom getters.
			//
			//		For example, CheckBox._getValueAttr() calls this._get("value").

			// future: return name in this.props ? this.props[name] : this[name];
			return this[name];
		},

		emit: function(/*String*/ type, /*Object?*/ eventObj, /*Array?*/ callbackArgs){
			// summary:
			//		Used by widgets to signal that a synthetic event occurred, ex:
			//	|	myWidget.emit("attrmodified-selectedChildWidget", {}).
			//
			//		Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
			//		Also calls onType() method, if present, and returns value from that method.
			//		By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
			//		Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
			// tags:
			//		protected

			// Specify fallback values for bubbles, cancelable in case they are not set in eventObj.
			// Also set pointer to widget, although since we can't add a pointer to the widget for native events
			// (see #14729), maybe we shouldn't do it here?
			eventObj = eventObj || {};
			if(eventObj.bubbles === undefined){
				eventObj.bubbles = true;
			}
			if(eventObj.cancelable === undefined){
				eventObj.cancelable = true;
			}
			if(!eventObj.detail){
				eventObj.detail = {};
			}
			eventObj.detail.widget = this;

			var ret, callback = this["on" + type];
			if(callback){
				ret = callback.apply(this, callbackArgs ? callbackArgs : [eventObj]);
			}

			// Emit event, but avoid spurious emit()'s as parent sets properties on child during startup/destroy
			if(this._started && !this._beingDestroyed){
				on.emit(this.domNode, type.toLowerCase(), eventObj);
			}

			return ret;
		},

		on: function(/*String|Function*/ type, /*Function*/ func){
			// summary:
			//		Call specified function when event occurs, ex: myWidget.on("click", function(){ ... }).
			// type:
			//		Name of event (ex: "click") or extension event like touch.press.
			// description:
			//		Call specified function when event `type` occurs, ex: `myWidget.on("click", function(){ ... })`.
			//		Note that the function is not run in any particular scope, so if (for example) you want it to run in the
			//		widget's scope you must do `myWidget.on("click", lang.hitch(myWidget, func))`.

			// For backwards compatibility, if there's an onType() method in the widget then connect to that.
			// Remove in 2.0.
			var widgetMethod = this._onMap(type);
			if(widgetMethod){
				return aspect.after(this, widgetMethod, func, true);
			}

			// Otherwise, just listen for the event on this.domNode.
			return this.own(on(this.domNode, type, func))[0];
		},

		_onMap: function(/*String|Function*/ type){
			// summary:
			//		Maps on() type parameter (ex: "mousemove") to method name (ex: "onMouseMove").
			//		If type is a synthetic event like touch.press then returns undefined.
			var ctor = this.constructor, map = ctor._onMap;
			if(!map){
				map = (ctor._onMap = {});
				for(var attr in ctor.prototype){
					if(/^on/.test(attr)){
						map[attr.replace(/^on/, "").toLowerCase()] = attr;
					}
				}
			}
			return map[typeof type == "string" && type.toLowerCase()];	// String
		},

		toString: function(){
			// summary:
			//		Returns a string that represents the widget.
			// description:
			//		When a widget is cast to a string, this method will be used to generate the
			//		output. Currently, it does not implement any sort of reversible
			//		serialization.
			return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
		},

		getChildren: function(){
			// summary:
			//		Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
			//		is this widget.   Note that it does not return all descendants, but rather just direct children.
			//		Analogous to [Node.childNodes](https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes),
			//		except containing widgets rather than DOMNodes.
			//
			//		The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
			//		outside of this.containerNode.
			//
			//		Note that the array returned is a simple array.  Application code should not assume
			//		existence of methods like forEach().

			return this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit/_WidgetBase[]
		},

		getParent: function(){
			// summary:
			//		Returns the parent widget of this widget.

			return registry.getEnclosingWidget(this.domNode.parentNode);
		},

		connect: function(/*Object|null*/ obj, /*String|Function*/ event, /*String|Function*/ method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
			//
			//		Connects specified obj/event to specified method of this object
			//		and registers for disconnect() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.connect, except with the
			//		implicit use of this widget as the target object.
			//		Events connected with `this.connect` are disconnected upon
			//		destruction.
			// returns:
			//		A handle that can be passed to `disconnect` in order to disconnect before
			//		the widget is destroyed.
			// example:
			//	|	var btn = new Button();
			//	|	// when foo.bar() is called, call the listener we're going to
			//	|	// provide in the scope of btn
			//	|	btn.connect(foo, "bar", function(){
			//	|		console.debug(this.toString());
			//	|	});
			// tags:
			//		protected

			return this.own(connect.connect(obj, event, this, method))[0];	// handle
		},

		disconnect: function(handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Disconnects handle created by `connect`.
			// tags:
			//		protected

			handle.remove();
		},

		subscribe: function(t, method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
			//
			//		Subscribes to the specified topic and calls the specified method
			//		of this object and registers for unsubscribe() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.subscribe, except with the
			//		implicit use of this widget as the target object.
			// t: String
			//		The topic
			// method: Function
			//		The callback
			// example:
			//	|	var btn = new Button();
			//	|	// when /my/topic is published, this button changes its label to
			//	|	// be the parameter of the topic.
			//	|	btn.subscribe("/my/topic", function(v){
			//	|		this.set("label", v);
			//	|	});
			// tags:
			//		protected
			return this.own(topic.subscribe(t, lang.hitch(this, method)))[0];	// handle
		},

		unsubscribe: function(/*Object*/ handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Unsubscribes handle created by this.subscribe.
			//		Also removes handle from this widget's list of subscriptions
			// tags:
			//		protected

			handle.remove();
		},

		isLeftToRight: function(){
			// summary:
			//		Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
			// tags:
			//		protected
			return this.dir ? (this.dir.toLowerCase() == "ltr") : domGeometry.isBodyLtr(this.ownerDocument); //Boolean
		},

		isFocusable: function(){
			// summary:
			//		Return true if this widget can currently be focused
			//		and false if not
			return this.focus && (domStyle.get(this.domNode, "display") != "none");
		},

		placeAt: function(/*String|DomNode|DocumentFragment|dijit/_WidgetBase*/ reference, /*String|Int?*/ position){
			// summary:
			//		Place this widget somewhere in the DOM based
			//		on standard domConstruct.place() conventions.
			// description:
			//		A convenience function provided in all _Widgets, providing a simple
			//		shorthand mechanism to put an existing (or newly created) Widget
			//		somewhere in the dom, and allow chaining.
			// reference:
			//		Widget, DOMNode, DocumentFragment, or id of widget or DOMNode
			// position:
			//		If reference is a widget (or id of widget), and that widget has an ".addChild" method,
			//		it will be called passing this widget instance into that method, supplying the optional
			//		position index passed.  In this case position (if specified) should be an integer.
			//
			//		If reference is a DOMNode (or id matching a DOMNode but not a widget),
			//		the position argument can be a numeric index or a string
			//		"first", "last", "before", or "after", same as dojo/dom-construct::place().
			// returns: dijit/_WidgetBase
			//		Provides a useful return of the newly created dijit._Widget instance so you
			//		can "chain" this function by instantiating, placing, then saving the return value
			//		to a variable.
			// example:
			//	|	// create a Button with no srcNodeRef, and place it in the body:
			//	|	var button = new Button({ label:"click" }).placeAt(win.body());
			//	|	// now, 'button' is still the widget reference to the newly created button
			//	|	button.on("click", function(e){ console.log('click'); }));
			// example:
			//	|	// create a button out of a node with id="src" and append it to id="wrapper":
			//	|	var button = new Button({},"src").placeAt("wrapper");
			// example:
			//	|	// place a new button as the first element of some div
			//	|	var button = new Button({ label:"click" }).placeAt("wrapper","first");
			// example:
			//	|	// create a contentpane and add it to a TabContainer
			//	|	var tc = dijit.byId("myTabs");
			//	|	new ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

			var refWidget = !reference.tagName && registry.byId(reference);
			if(refWidget && refWidget.addChild && (!position || typeof position === "number")){
				// Adding this to refWidget and can use refWidget.addChild() to handle everything.
				refWidget.addChild(this, position);
			}else{
				// "reference" is a plain DOMNode, or we can't use refWidget.addChild().   Use domConstruct.place() and
				// target refWidget.containerNode for nested placement (position==number, "first", "last", "only"), and
				// refWidget.domNode otherwise ("after"/"before"/"replace").  (But not supported officially, see #14946.)
				var ref = refWidget && ("domNode" in refWidget) ?
					(refWidget.containerNode && !/after|before|replace/.test(position || "") ?
						refWidget.containerNode : refWidget.domNode) : dom.byId(reference, this.ownerDocument);
				domConstruct.place(this.domNode, ref, position);

				// Start this iff it has a parent widget that's already started.
				// TODO: for 2.0 maybe it should also start the widget when this.getParent() returns null??
				if(!this._started && (this.getParent() || {})._started){
					this.startup();
				}
			}
			return this;
		},

		defer: function(fcn, delay){
			// summary:
			//		Wrapper to setTimeout to avoid deferred functions executing
			//		after the originating widget has been destroyed.
			//		Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
			// fcn: Function
			//		Function reference.
			// delay: Number?
			//		Delay, defaults to 0.
			// tags:
			//		protected

			var timer = setTimeout(lang.hitch(this,
				function(){
					if(!timer){
						return;
					}
					timer = null;
					if(!this._destroyed){
						lang.hitch(this, fcn)();
					}
				}),
				delay || 0
			);
			return {
				remove: function(){
					if(timer){
						clearTimeout(timer);
						timer = null;
					}
					return null; // so this works well: handle = handle.remove();
				}
			};
		}
	});

	if(has("dojo-bidi")){
		_WidgetBase.extend(_BidiMixin);
	}

	return _WidgetBase;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/_base/manager.js":
/*!*********************************************!*\
  !*** ./node_modules/dijit/_base/manager.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"),
	__webpack_require__(/*! dojo/_base/config */ "./node_modules/dojo/_base/config.js"), // defaultDuration
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! ../registry */ "./node_modules/dijit/registry.js"),
	__webpack_require__(/*! ../main */ "./node_modules/dijit/main.js")	// for setting exports to dijit namespace
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(array, config, lang, registry, dijit){

	// module:
	//		dijit/_base/manager

	var exports = {
		// summary:
		//		Deprecated.  Shim to methods on registry, plus a few other declarations.
		//		New code should access dijit/registry directly when possible.
	};

	array.forEach(["byId", "getUniqueId", "findWidgets", "_destroyAll", "byNode", "getEnclosingWidget"], function(name){
		exports[name] = registry[name];
	});

	 lang.mixin(exports, {
		 // defaultDuration: Integer
		 //		The default fx.animation speed (in ms) to use for all Dijit
		 //		transitional fx.animations, unless otherwise specified
		 //		on a per-instance basis. Defaults to 200, overrided by
		 //		`djConfig.defaultDuration`
		 defaultDuration: config["defaultDuration"] || 200
	 });

	lang.mixin(dijit, exports);

	/*===== return exports; =====*/
	return dijit;	// for back compat :-(
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/a11y.js":
/*!************************************!*\
  !*** ./node_modules/dijit/a11y.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.forEach array.map
	__webpack_require__(/*! dojo/dom */ "./node_modules/dojo/dom.js"),			// dom.byId
	__webpack_require__(/*! dojo/dom-attr */ "./node_modules/dojo/dom-attr.js"), // domAttr.attr domAttr.has
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"), // domStyle.style
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.mixin()
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js"), // has("ie") has("extend-dojo")
	__webpack_require__(/*! ./main */ "./node_modules/dijit/main.js")	// for exporting methods to dijit namespace
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(array, dom, domAttr, domStyle, lang, has, dijit){

	// module:
	//		dijit/a11y

	var undefined;

	var a11y = {
		// summary:
		//		Accessibility utility functions (keyboard, tab stops, etc.)

		_isElementShown: function(/*Element*/ elem){
			var s = domStyle.get(elem);
			return (s.visibility != "hidden")
				&& (s.visibility != "collapsed")
				&& (s.display != "none")
				&& (domAttr.get(elem, "type") != "hidden");
		},

		hasDefaultTabStop: function(/*Element*/ elem){
			// summary:
			//		Tests if element is tab-navigable even without an explicit tabIndex setting

			// No explicit tabIndex setting, need to investigate node type
			switch(elem.nodeName.toLowerCase()){
				case "a":
					// An <a> w/out a tabindex is only navigable if it has an href
					return domAttr.has(elem, "href");
				case "area":
				case "button":
				case "input":
				case "object":
				case "select":
				case "textarea":
					// These are navigable by default
					return true;
				case "iframe":
					// If it's an editor <iframe> then it's tab navigable.
					var body;
					try{
						// non-IE
						var contentDocument = elem.contentDocument;
						if("designMode" in contentDocument && contentDocument.designMode == "on"){
							return true;
						}
						body = contentDocument.body;
					}catch(e1){
						// contentWindow.document isn't accessible within IE7/8
						// if the iframe.src points to a foreign url and this
						// page contains an element, that could get focus
						try{
							body = elem.contentWindow.document.body;
						}catch(e2){
							return false;
						}
					}
					return body && (body.contentEditable == 'true' ||
						(body.firstChild && body.firstChild.contentEditable == 'true'));
				default:
					return elem.contentEditable == 'true';
			}
		},

		effectiveTabIndex: function(/*Element*/ elem){
			// summary:
			//		Returns effective tabIndex of an element, either a number, or undefined if element isn't focusable.

			if(domAttr.get(elem, "disabled")){
				return undefined;
			}else if(domAttr.has(elem, "tabIndex")){
				// Explicit tab index setting
				return +domAttr.get(elem, "tabIndex");// + to convert string --> number
			}else{
				// No explicit tabIndex setting, so depends on node type
				return a11y.hasDefaultTabStop(elem) ? 0 : undefined;
			}
		},

		isTabNavigable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is tab-navigable

			return a11y.effectiveTabIndex(elem) >= 0;
		},

		isFocusable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is focusable by tabbing to it, or clicking it with the mouse.

			return a11y.effectiveTabIndex(elem) >= -1;
		},

		_getTabNavigable: function(/*DOMNode*/ root){
			// summary:
			//		Finds descendants of the specified root node.
			// description:
			//		Finds the following descendants of the specified root node:
			//
			//		- the first tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the last tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the first element in document order with the lowest
			//		  positive tabIndex value
			//		- the last element in document order with the highest
			//		  positive tabIndex value
			var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};

			function radioName(node){
				// If this element is part of a radio button group, return the name for that group.
				return node && node.tagName.toLowerCase() == "input" &&
					node.type && node.type.toLowerCase() == "radio" &&
					node.name && node.name.toLowerCase();
			}

			var shown = a11y._isElementShown, effectiveTabIndex = a11y.effectiveTabIndex;
			var walkTree = function(/*DOMNode*/ parent){
				for(var child = parent.firstChild; child; child = child.nextSibling){
					// Skip text elements, hidden elements, and also non-HTML elements (those in custom namespaces) in IE,
					// since show() invokes getAttribute("type"), which crash on VML nodes in IE.
					if(child.nodeType != 1 || (has("ie") <= 9 && child.scopeName !== "HTML") || !shown(child)){
						continue;
					}

					var tabindex = effectiveTabIndex(child);
					if(tabindex >= 0){
						if(tabindex == 0){
							if(!first){
								first = child;
							}
							last = child;
						}else if(tabindex > 0){
							if(!lowest || tabindex < lowestTabindex){
								lowestTabindex = tabindex;
								lowest = child;
							}
							if(!highest || tabindex >= highestTabindex){
								highestTabindex = tabindex;
								highest = child;
							}
						}
						var rn = radioName(child);
						if(domAttr.get(child, "checked") && rn){
							radioSelected[rn] = child;
						}
					}
					if(child.nodeName.toUpperCase() != 'SELECT'){
						walkTree(child);
					}
				}
			};
			if(shown(root)){
				walkTree(root);
			}
			function rs(node){
				// substitute checked radio button for unchecked one, if there is a checked one with the same name.
				return radioSelected[radioName(node)] || node;
			}

			return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
		},

		getFirstInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is first in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.lowest ? elems.lowest : elems.first; // DomNode
		},

		getLastInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is last in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.last ? elems.last : elems.highest; // DomNode
		}
	};

	has("extend-dojo") && lang.mixin(dijit, a11y);

	return a11y;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/a11yclick.js":
/*!*****************************************!*\
  !*** ./node_modules/dijit/a11yclick.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/keys */ "./node_modules/dojo/keys.js"), // keys.ENTER keys.SPACE
	__webpack_require__(/*! dojo/mouse */ "./node_modules/dojo/mouse.js"),
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/touch */ "./node_modules/dojo/touch.js") // touch support for click is now there
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(keys, mouse, on, touch){

	// module:
	//		dijit/a11yclick

	/*=====
	return {
		// summary:
		//		Custom press, release, and click synthetic events
		//		which trigger on a left mouse click, touch, or space/enter keyup.

		click: function(node, listener){
			// summary:
			//		Logical click operation for mouse, touch, or keyboard (space/enter key)
		},
		press: function(node, listener){
			// summary:
			//		Mousedown (left button), touchstart, or keydown (space or enter) corresponding to logical click operation.
		},
		release: function(node, listener){
			// summary:
			//		Mouseup (left button), touchend, or keyup (space or enter) corresponding to logical click operation.
		},
		move: function(node, listener){
			// summary:
			//		Mouse cursor or a finger is dragged over the given node.
		}
	};
	=====*/

	function clickKey(/*Event*/ e){
		// Test if this keyboard event should be tracked as the start (if keydown) or end (if keyup) of a click event.
		// Only track for nodes marked to be tracked, and not for buttons or inputs,
		// since buttons handle keyboard click natively, and text inputs should not
		// prevent typing spaces or newlines.
		if((e.keyCode === keys.ENTER || e.keyCode === keys.SPACE) && !/input|button|textarea/i.test(e.target.nodeName)){

			// Test if a node or its ancestor has been marked with the dojoClick property to indicate special processing
			for(var node = e.target; node; node = node.parentNode){
				if(node.dojoClick){ return true; }
			}
		}
	}

	var lastKeyDownNode;

	on(document, "keydown", function(e){
		//console.log("a11yclick: onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
		if(clickKey(e)){
			// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
			lastKeyDownNode = e.target;

			// Prevent viewport scrolling on space key in IE<9.
			// (Reproducible on test_Button.html on any of the first dijit/form/Button examples)
			e.preventDefault();
		}else{
			lastKeyDownNode = null;
		}
	});

	on(document, "keyup", function(e){
		//console.log("a11yclick: onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
		if(clickKey(e) && e.target == lastKeyDownNode){	// === breaks greasemonkey
			//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
			lastKeyDownNode = null;

			on.emit(e.target, "click", {
				cancelable: true,
				bubbles: true,
				ctrlKey: e.ctrlKey,
				shiftKey: e.shiftKey,
				metaKey: e.metaKey,
				altKey: e.altKey,
				_origType: e.type
			});
		}
	});

	// I want to return a hash of the synthetic events, but for backwards compatibility the main return value
	// needs to be the click event.   Change for 2.0.

	var click = function(node, listener){
		// Set flag on node so that keydown/keyup above emits click event.
		// Also enables fast click processing from dojo/touch.
		node.dojoClick = true;

		return on(node, "click", listener);
	};
	click.click = click;	// forward compatibility with 2.0

	click.press =  function(node, listener){
		var touchListener = on(node, touch.press, function(evt){
			if(evt.type == "mousedown" && !mouse.isLeft(evt)){
				// Ignore right click
				return;
			}
			listener(evt);
		}), keyListener = on(node, "keydown", function(evt){
			if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
				listener(evt);
			}
		});
		return {
			remove: function(){
				touchListener.remove();
				keyListener.remove();
			}
		};
	};

	click.release =  function(node, listener){
		var touchListener = on(node, touch.release, function(evt){
			if(evt.type == "mouseup" && !mouse.isLeft(evt)){
				// Ignore right click
				return;
			}
			listener(evt);
		}), keyListener = on(node, "keyup", function(evt){
			if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
				listener(evt);
			}
		});
		return {
			remove: function(){
				touchListener.remove();
				keyListener.remove();
			}
		};
	};

	click.move = touch.move;	// just for convenience

	return click;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/focus.js":
/*!*************************************!*\
  !*** ./node_modules/dijit/focus.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/aspect */ "./node_modules/dojo/aspect.js"),
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom */ "./node_modules/dojo/dom.js"), // domAttr.get dom.isDescendant
	__webpack_require__(/*! dojo/dom-attr */ "./node_modules/dojo/dom-attr.js"), // domAttr.get dom.isDescendant
	__webpack_require__(/*! dojo/dom-class */ "./node_modules/dojo/dom-class.js"),
	__webpack_require__(/*! dojo/dom-construct */ "./node_modules/dojo/dom-construct.js"), // connect to domConstruct.empty, domConstruct.destroy
	__webpack_require__(/*! dojo/Evented */ "./node_modules/dojo/Evented.js"),
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.hitch
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/domReady */ "./node_modules/dojo/domReady.js"),
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js"), // has("ie")
	__webpack_require__(/*! dojo/Stateful */ "./node_modules/dojo/Stateful.js"),
	__webpack_require__(/*! dojo/_base/window */ "./node_modules/dojo/_base/window.js"), // win.body
	__webpack_require__(/*! dojo/window */ "./node_modules/dojo/window.js"), // winUtils.get
	__webpack_require__(/*! ./a11y */ "./node_modules/dijit/a11y.js"),	// a11y.isTabNavigable
	__webpack_require__(/*! ./registry */ "./node_modules/dijit/registry.js"),	// registry.byId
	__webpack_require__(/*! ./main */ "./node_modules/dijit/main.js")		// to set dijit.focus
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(aspect, declare, dom, domAttr, domClass, domConstruct, Evented, lang, on, domReady, has, Stateful, win, winUtils,
			a11y, registry, dijit){

	// module:
	//		dijit/focus

	// Time of the last focusin event
	var lastFocusin;

	// Time of the last touch/mousedown or focusin event
	var lastTouchOrFocusin;

	var FocusManager = declare([Stateful, Evented], {
		// summary:
		//		Tracks the currently focused node, and which widgets are currently "active".
		//		Access via require(["dijit/focus"], function(focus){ ... }).
		//
		//		A widget is considered active if it or a descendant widget has focus,
		//		or if a non-focusable node of this widget or a descendant was recently clicked.
		//
		//		Call focus.watch("curNode", callback) to track the current focused DOMNode,
		//		or focus.watch("activeStack", callback) to track the currently focused stack of widgets.
		//
		//		Call focus.on("widget-blur", func) or focus.on("widget-focus", ...) to monitor when
		//		when widgets become active/inactive
		//
		//		Finally, focus(node) will focus a node, suppressing errors if the node doesn't exist.

		// curNode: DomNode
		//		Currently focused item on screen
		curNode: null,

		// activeStack: dijit/_WidgetBase[]
		//		List of currently active widgets (focused widget and it's ancestors)
		activeStack: [],

		constructor: function(){
			// Don't leave curNode/prevNode pointing to bogus elements
			var check = lang.hitch(this, function(node){
				if(dom.isDescendant(this.curNode, node)){
					this.set("curNode", null);
				}
				if(dom.isDescendant(this.prevNode, node)){
					this.set("prevNode", null);
				}
			});
			aspect.before(domConstruct, "empty", check);
			aspect.before(domConstruct, "destroy", check);
		},

		registerIframe: function(/*DomNode*/ iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the `<iframe>` itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle with remove() method to deregister.
			return this.registerWin(iframe.contentWindow, iframe);
		},

		registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow:
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode:
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle with remove() method to deregister.

			// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

			// Listen for blur and focus events on targetWindow's document.
			var _this = this,
				body = targetWindow.document && targetWindow.document.body;

			if(body){
				// Listen for touches or mousedowns... could also use dojo/touch.press here.
				var event = has("pointer-events") ? "pointerdown" : has("MSPointer") ? "MSPointerDown" :
					has("touch-events") ? "mousedown, touchstart" : "mousedown";
				var mdh = on(targetWindow.document, event, function(evt){
					// workaround weird IE bug where the click is on an orphaned node
					// (first time clicking a Select/DropDownButton inside a TooltipDialog).
					// actually, strangely this is happening on latest chrome too.
					if(evt && evt.target && evt.target.parentNode == null){
						return;
					}

					_this._onTouchNode(effectiveNode || evt.target, "mouse");
				});

				var fih = on(body, 'focusin', function(evt){
					// When you refocus the browser window, IE gives an event with an empty srcElement
					if(!evt.target.tagName) { return; }

					// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
					// ignore those events
					var tag = evt.target.tagName.toLowerCase();
					if(tag == "#document" || tag == "body"){ return; }

					if(a11y.isFocusable(evt.target)){
						_this._onFocusNode(effectiveNode || evt.target);
					}else{
						// Previous code called _onTouchNode() for any activate event on a non-focusable node.   Can
						// probably just ignore such an event as it will be handled by onmousedown handler above, but
						// leaving the code for now.
						_this._onTouchNode(effectiveNode || evt.target);
					}
				});

				var foh = on(body, 'focusout', function(evt){
					_this._onBlurNode(effectiveNode || evt.target);
				});

				return {
					remove: function(){
						mdh.remove();
						fih.remove();
						foh.remove();
						mdh = fih = foh = null;
						body = null;	// prevent memory leak (apparent circular reference via closure)
					}
				};
			}
		},

		_onBlurNode: function(/*DomNode*/ node){
			// summary:
			//		Called when focus leaves a node.
			//		Usually ignored, _unless_ it *isn't* followed by touching another node,
			//		which indicates that we tabbed off the last field on the page,
			//		in which case every widget is marked inactive

			var now = (new Date()).getTime();

			// IE9+ and chrome have a problem where focusout events come after the corresponding focusin event.
			// For chrome problem see https://bugs.dojotoolkit.org/ticket/17668.
			// IE problem happens when moving focus from the Editor's <iframe> to a normal DOMNode.
			if(now < lastFocusin + 100){
				return;
			}

			// If the blur event isn't followed by a focus event, it means the user clicked on something unfocusable,
			// so clear focus.
			if(this._clearFocusTimer){
				clearTimeout(this._clearFocusTimer);
			}
			this._clearFocusTimer = setTimeout(lang.hitch(this, function(){
				this.set("prevNode", this.curNode);
				this.set("curNode", null);
			}), 0);

			// Unset timer to zero-out widget stack; we'll reset it below if appropriate.
			if(this._clearActiveWidgetsTimer){
				clearTimeout(this._clearActiveWidgetsTimer);
			}

			if(now < lastTouchOrFocusin + 100){
				// This blur event is coming late (after the call to _onTouchNode() rather than before.
				// So let _onTouchNode() handle setting the widget stack.
				// See https://bugs.dojotoolkit.org/ticket/17668
				return;
			}

			// If the blur event isn't followed (or preceded) by a focus or touch event then mark all widgets as inactive.
			this._clearActiveWidgetsTimer = setTimeout(lang.hitch(this, function(){
				delete this._clearActiveWidgetsTimer;
				this._setStack([]);
			}), 0);
		},

		_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
			// summary:
			//		Callback when node is focused or touched.
			//		Note that _onFocusNode() calls _onTouchNode().
			// node:
			//		The node that was touched.
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			// Keep track of time of last focusin or touch event.
			lastTouchOrFocusin = (new Date()).getTime();

			if(this._clearActiveWidgetsTimer){
				// forget the recent blur event
				clearTimeout(this._clearActiveWidgetsTimer);
				delete this._clearActiveWidgetsTimer;
			}

			// if the click occurred on the scrollbar of a dropdown, treat it as a click on the dropdown,
			// even though the scrollbar is technically on the popup wrapper (see #10631)
			if(domClass.contains(node, "dijitPopup")){
				node = node.firstChild;
			}

			// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
			var newStack=[];
			try{
				while(node){
					var popupParent = domAttr.get(node, "dijitPopupParent");
					if(popupParent){
						node=registry.byId(popupParent).domNode;
					}else if(node.tagName && node.tagName.toLowerCase() == "body"){
						// is this the root of the document or just the root of an iframe?
						if(node === win.body()){
							// node is the root of the main document
							break;
						}
						// otherwise, find the iframe this node refers to (can't access it via parentNode,
						// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
						node=winUtils.get(node.ownerDocument).frameElement;
					}else{
						// if this node is the root node of a widget, then add widget id to stack,
						// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
						// to support MenuItem)
						var id = node.getAttribute && node.getAttribute("widgetId"),
							widget = id && registry.byId(id);
						if(widget && !(by == "mouse" && widget.get("disabled"))){
							newStack.unshift(id);
						}
						node=node.parentNode;
					}
				}
			}catch(e){ /* squelch */ }

			this._setStack(newStack, by);
		},

		_onFocusNode: function(/*DomNode*/ node){
			// summary:
			//		Callback when node is focused

			if(!node){
				return;
			}

			if(node.nodeType == 9){
				// Ignore focus events on the document itself.  This is here so that
				// (for example) clicking the up/down arrows of a spinner
				// (which don't get focus) won't cause that widget to blur. (FF issue)
				return;
			}

			// Keep track of time of last focusin event.
			lastFocusin = (new Date()).getTime();

			// There was probably a blur event right before this event, but since we have a new focus,
			// forget about the blur
			if(this._clearFocusTimer){
				clearTimeout(this._clearFocusTimer);
				delete this._clearFocusTimer;
			}

			this._onTouchNode(node);

			if(node == this.curNode){ return; }
			this.set("prevNode", this.curNode);
			this.set("curNode", node);
		},

		_setStack: function(/*String[]*/ newStack, /*String*/ by){
			// summary:
			//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
			// newStack:
			//		array of widget id's, starting from the top (outermost) widget
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			var oldStack = this.activeStack, lastOldIdx = oldStack.length - 1, lastNewIdx = newStack.length - 1;

			if(newStack[lastNewIdx] == oldStack[lastOldIdx]){
				// no changes, return now to avoid spurious notifications about changes to activeStack
				return;
			}

			this.set("activeStack", newStack);

			var widget, i;

			// for all elements that have gone out of focus, set focused=false
			for(i = lastOldIdx; i >= 0 && oldStack[i] != newStack[i]; i--){
				widget = registry.byId(oldStack[i]);
				if(widget){
					widget._hasBeenBlurred = true;		// TODO: used by form widgets, should be moved there
					widget.set("focused", false);
					if(widget._focusManager == this){
						widget._onBlur(by);
					}
					this.emit("widget-blur", widget, by);
				}
			}

			// for all element that have come into focus, set focused=true
			for(i++; i <= lastNewIdx; i++){
				widget = registry.byId(newStack[i]);
				if(widget){
					widget.set("focused", true);
					if(widget._focusManager == this){
						widget._onFocus(by);
					}
					this.emit("widget-focus", widget, by);
				}
			}
		},

		focus: function(node){
			// summary:
			//		Focus the specified node, suppressing errors if they occur
			if(node){
				try{ node.focus(); }catch(e){/*quiet*/}
			}
		}
	});

	var singleton = new FocusManager();

	// register top window and all the iframes it contains
	domReady(function(){
		var handle = singleton.registerWin(winUtils.get(document));
		if(has("ie")){
			on(window, "unload", function(){
				if(handle){	// because this gets called twice when doh.robot is running
					handle.remove();
					handle = null;
				}
			});
		}
	});

	// Setup dijit.focus as a pointer to the singleton but also (for backwards compatibility)
	// as a function to set focus.   Remove for 2.0.
	dijit.focus = function(node){
		singleton.focus(node);	// indirection here allows dijit/_base/focus.js to override behavior
	};
	for(var attr in singleton){
		if(!/^_/.test(attr)){
			dijit.focus[attr] = typeof singleton[attr] == "function" ? lang.hitch(singleton, attr) : singleton[attr];
		}
	}
	singleton.watch(function(attr, oldVal, newVal){
		dijit.focus[attr] = newVal;
	});

	return singleton;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/form/Form.js":
/*!*****************************************!*\
  !*** ./node_modules/dijit/form/Form.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom-attr */ "./node_modules/dojo/dom-attr.js"), // domAttr.set
	__webpack_require__(/*! dojo/_base/kernel */ "./node_modules/dojo/_base/kernel.js"), // kernel.deprecated
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js"), // has("ie")
	__webpack_require__(/*! ../_Widget */ "./node_modules/dijit/_Widget.js"),
	__webpack_require__(/*! ../_TemplatedMixin */ "./node_modules/dijit/_TemplatedMixin.js"),
	__webpack_require__(/*! ./_FormMixin */ "./node_modules/dijit/form/_FormMixin.js"),
	__webpack_require__(/*! ../layout/_ContentPaneResizeMixin */ "./node_modules/dijit/layout/_ContentPaneResizeMixin.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(declare, domAttr, kernel, has, _Widget, _TemplatedMixin, _FormMixin, _ContentPaneResizeMixin){

	// module:
	//		dijit/form/Form


	return declare("dijit.form.Form", [_Widget, _TemplatedMixin, _FormMixin, _ContentPaneResizeMixin], {
		// summary:
		//		Widget corresponding to HTML form tag, for validation and serialization
		//
		// example:
		//	|	<form data-dojo-type="dijit/form/Form" id="myForm">
		//	|		Name: <input type="text" name="name" />
		//	|	</form>
		//	|	// Example assumes you have required dijit/registry
		//	|	myObj = {name: "John Doe"};
		//	|	registry.byId('myForm').set('value', myObj);
		//	|
		//	|	myObj=registry.byId('myForm').get('value');

		// HTML <FORM> attributes

		// name: String?
		//		Name of form for scripting.
		name: "",

		// action: String?
		//		Server-side form handler.
		action: "",

		// method: String?
		//		HTTP method used to submit the form, either "GET" or "POST".
		method: "",

		// encType: String?
		//		Encoding type for the form, ex: application/x-www-form-urlencoded.
		encType: "",

		// accept-charset: String?
		//		List of supported charsets.
		"accept-charset": "",

		// accept: String?
		//		List of MIME types for file upload.
		accept: "",

		// target: String?
		//		Target frame for the document to be opened in.
		target: "",

		templateString: "<form data-dojo-attach-point='containerNode' data-dojo-attach-event='onreset:_onReset,onsubmit:_onSubmit' ${!nameAttrSetting}></form>",

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified)
			// Unfortunately we can't use _setNameAttr to set the name due to IE limitations, see #8660
			this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
			this.inherited(arguments);
		},

		execute: function(/*Object*/ /*===== formContents =====*/){
			// summary:
			//		Deprecated: use submit()
			// tags:
			//		deprecated
		},

		onExecute: function(){
			// summary:
			//		Deprecated: use onSubmit()
			// tags:
			//		deprecated
		},

		_setEncTypeAttr: function(/*String*/ value){
			domAttr.set(this.domNode, "encType", value);
			if(has("ie")){
				this.domNode.encoding = value;
			}
			this._set("encType", value);
		},

		reset: function(/*Event?*/ e){
			// summary:
			//		restores all widget values back to their init values,
			//		calls onReset() which can cancel the reset by returning false

			// create fake event so we can know if preventDefault() is called
			var faux = {
				returnValue: true, // the IE way
				preventDefault: function(){ // not IE
					this.returnValue = false;
				},
				stopPropagation: function(){
				},
				currentTarget: e ? e.target : this.domNode,
				target: e ? e.target : this.domNode
			};
			// if return value is not exactly false, and haven't called preventDefault(), then reset
			if(!(this.onReset(faux) === false) && faux.returnValue){
				this.inherited(arguments, []);
			}
		},

		onReset: function(/*Event?*/ /*===== e =====*/){
			// summary:
			//		Callback when user resets the form. This method is intended
			//		to be over-ridden. When the `reset` method is called
			//		programmatically, the return value from `onReset` is used
			//		to compute whether or not resetting should proceed
			// tags:
			//		callback
			return true; // Boolean
		},

		_onReset: function(e){
			this.reset(e);
			e.stopPropagation();
			e.preventDefault();
			return false;
		},

		_onSubmit: function(e){
			var fp = this.constructor.prototype;
			// TODO: remove this if statement beginning with 2.0
			if(this.execute != fp.execute || this.onExecute != fp.onExecute){
				kernel.deprecated("dijit.form.Form:execute()/onExecute() are deprecated. Use onSubmit() instead.", "", "2.0");
				this.onExecute();
				this.execute(this.getValues());
			}
			if(this.onSubmit(e) === false){ // only exactly false stops submit
				e.stopPropagation();
				e.preventDefault();
			}
		},

		onSubmit: function(/*Event?*/ /*===== e =====*/){
			// summary:
			//		Callback when user submits the form.
			// description:
			//		This method is intended to be over-ridden, but by default it checks and
			//		returns the validity of form elements. When the `submit`
			//		method is called programmatically, the return value from
			//		`onSubmit` is used to compute whether or not submission
			//		should proceed
			// tags:
			//		extension

			return this.isValid(); // Boolean
		},

		submit: function(){
			// summary:
			//		programmatically submit form if and only if the `onSubmit` returns true
			if(!(this.onSubmit() === false)){
				this.containerNode.submit();
			}
		}
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/form/TextBox.js":
/*!********************************************!*\
  !*** ./node_modules/dijit/form/TextBox.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom-construct */ "./node_modules/dojo/dom-construct.js"), // domConstruct.create
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"), // domStyle.getComputedStyle
	__webpack_require__(/*! dojo/_base/kernel */ "./node_modules/dojo/_base/kernel.js"), // kernel.deprecated
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.hitch
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js"), // has("ie") has("mozilla")
	__webpack_require__(/*! ./_FormValueWidget */ "./node_modules/dijit/form/_FormValueWidget.js"),
	__webpack_require__(/*! ./_TextBoxMixin */ "./node_modules/dijit/form/_TextBoxMixin.js"),
	__webpack_require__(/*! dojo/text!./templates/TextBox.html */ "./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dijit/form/templates/TextBox.html"),
	__webpack_require__(/*! ../main */ "./node_modules/dijit/main.js")	// to export dijit._setSelectionRange, remove in 2.0
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(declare, domConstruct, domStyle, kernel, lang, on, has,
			_FormValueWidget, _TextBoxMixin, template, dijit){

	// module:
	//		dijit/form/TextBox

	var TextBox = declare("dijit.form.TextBox" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormValueWidget, _TextBoxMixin], {
		// summary:
		//		A base class for textbox form inputs

		templateString: template,
		_singleNodeTemplate: '<input class="dijit dijitReset dijitLeft dijitInputField" data-dojo-attach-point="textbox,focusNode" autocomplete="off" type="${type}" ${!nameAttrSetting} />',

		_buttonInputDisabled: has("ie") ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		baseClass: "dijitTextBox",

		postMixInProperties: function(){
			var type = this.type.toLowerCase();
			if(this.templateString && this.templateString.toLowerCase() == "input" || ((type == "hidden" || type == "file") && this.templateString == this.constructor.prototype.templateString)){
				this.templateString = this._singleNodeTemplate;
			}
			this.inherited(arguments);
		},

		postCreate: function(){
			this.inherited(arguments);

			if(has("ie") < 9){
				// IE INPUT tag fontFamily has to be set directly using STYLE
				// the defer gives IE a chance to render the TextBox and to deal with font inheritance
				this.defer(function(){
					try{
						var s = domStyle.getComputedStyle(this.domNode); // can throw an exception if widget is immediately destroyed
						if(s){
							var ff = s.fontFamily;
							if(ff){
								var inputs = this.domNode.getElementsByTagName("INPUT");
								if(inputs){
									for(var i=0; i < inputs.length; i++){
										inputs[i].style.fontFamily = ff;
									}
								}
							}
						}
					}catch(e){/*when used in a Dialog, and this is called before the dialog is
					 shown, s.fontFamily would trigger "Invalid Argument" error.*/}
				});
			}
		},

		_setPlaceHolderAttr: function(v){
			this._set("placeHolder", v);
			if(!this._phspan){
				this._attachPoints.push('_phspan');
				this._phspan = domConstruct.create('span', {
					// dijitInputField class gives placeHolder same padding as the input field
					// parent node already has dijitInputField class but it doesn't affect this <span>
					// since it's position: absolute.
					className: 'dijitPlaceHolder dijitInputField'
				}, this.textbox, 'after');
				this.own(
					on(this._phspan, "mousedown", function(evt){ evt.preventDefault(); }),
					on(this._phspan, "touchend, pointerup, MSPointerUp", lang.hitch(this, function(){
						// If the user clicks placeholder rather than the <input>, need programmatic focus.  Normally this
						// is done in _FormWidgetMixin._onFocus() but after [30663] it's done on a delay, which is ineffective.
						this.focus();
					}))
				);
			}
			this._phspan.innerHTML="";
			this._phspan.appendChild(this._phspan.ownerDocument.createTextNode(v));
			this._updatePlaceHolder();
		},

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Called AFTER the input event has happened
			//		See if the placeHolder text should be removed or added while editing.
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		_updatePlaceHolder: function(){
			if(this._phspan){
				this._phspan.style.display = (this.placeHolder && !this.textbox.value) ? "" : "none";
			}
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.  Use get('displayedValue') instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use get('displayedValue') instead.", "", "2.0");
			return this.get('displayedValue');
		},

		setDisplayedValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('displayedValue', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use set('displayedValue', ...) instead.", "", "2.0");
			this.set('displayedValue', value);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();

			if(has("mozilla")){
				if(this.selectOnClick){
					// clear selection so that the next mouse click doesn't reselect
					this.textbox.selectionStart = this.textbox.selectionEnd = undefined;
				}
			}
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();
		}
	});

	if(has("ie") < 9){
		TextBox.prototype._isTextSelected = function(){
			var range = this.ownerDocument.selection.createRange();
			var parent = range.parentElement();
			return parent == this.textbox && range.text.length > 0;
		};

		// Overrides definition of _setSelectionRange from _TextBoxMixin (TODO: move to _TextBoxMixin.js?)
		dijit._setSelectionRange = _TextBoxMixin._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
			if(element.createTextRange){
				var r = element.createTextRange();
				r.collapse(true);
				r.moveStart("character", -99999); // move to 0
				r.moveStart("character", start); // delta from 0 is the correct position
				r.moveEnd("character", stop-start);
				r.select();
			}
		}
	}

	if(has("dojo-bidi")){
		TextBox = declare("dijit.form.TextBox", TextBox, {
			_setPlaceHolderAttr: function(v){
				this.inherited(arguments);
				this.applyTextDir(this._phspan);
			}
		});
	}

	return TextBox;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/form/ValidationTextBox.js":
/*!******************************************************!*\
  !*** ./node_modules/dijit/form/ValidationTextBox.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/_base/kernel */ "./node_modules/dojo/_base/kernel.js"), // kernel.deprecated
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! dojo/i18n */ "./node_modules/dojo/i18n.js"), // i18n.getLocalization
	__webpack_require__(/*! ./TextBox */ "./node_modules/dijit/form/TextBox.js"),
	__webpack_require__(/*! ../Tooltip */ "./node_modules/dijit/Tooltip.js"),
	__webpack_require__(/*! dojo/text!./templates/ValidationTextBox.html */ "./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dijit/form/templates/ValidationTextBox.html"),
	__webpack_require__(/*! dojo/i18n!./nls/validate */ "./node_modules/dojo-webpack-plugin/loaders/dojo/i18n/index.js!./node_modules/dijit/form/nls/validate.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(declare, kernel, lang, i18n, TextBox, Tooltip, template){

	// module:
	//		dijit/form/ValidationTextBox


	var ValidationTextBox = declare("dijit.form.ValidationTextBox", TextBox, {
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.

		templateString: template,

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		//		The message to display if value is invalid.
		//		The translated string value is read from the message file by default.
		//		Set to "" to use the promptMessage instead.
		invalidMessage: "$_unset_$",

		// missingMessage: String
		//		The message to display if value is empty and the field is required.
		//		The translated string value is read from the message file by default.
		//		Set to "" to use the invalidMessage instead.
		missingMessage: "$_unset_$",

		// message: String
		//		Currently error/prompt message.
		//		When using the default tooltip implementation, this will only be
		//		displayed when the field is focused.
		message: "",

		// constraints: ValidationTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input as well as
		//		formatting options.  See `dijit/form/ValidationTextBox.__Constraints` for details.
		constraints:{},

		// pattern: [extension protected] String|Function(constraints) returning a string.
		//		This defines the regular expression used to validate the input.
		//		Do not add leading ^ or $ characters since the widget adds these.
		//		A function may be used to generate a valid pattern when dependent on constraints or other runtime factors.
		//		set('pattern', String|Function).
		pattern: ".*",

		// regExp: Deprecated [extension protected] String.  Use "pattern" instead.
		regExp: "",

		regExpGen: function(/*__Constraints*/ /*===== constraints =====*/){
			// summary:
			//		Deprecated.  Use set('pattern', Function) instead.
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit/Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_deprecateRegExp: function(attr, value){
			if(value != ValidationTextBox.prototype[attr]){
				kernel.deprecated("ValidationTextBox id="+this.id+", set('" + attr + "', ...) is deprecated.  Use set('pattern', ...) instead.", "", "2.0");
				this.set('pattern', value);
			}
		},
		_setRegExpGenAttr: function(/*Function*/ newFcn){
			this._deprecateRegExp("regExpGen", newFcn);
			this._set("regExpGen", this._computeRegexp); // backward compat with this.regExpGen(this.constraints)
		},
		_setRegExpAttr: function(/*String*/ value){
			this._deprecateRegExp("regExp", value);
		},

		_setValueAttr: function(){
			// summary:
			//		Hook so set('value', ...) works.
			this.inherited(arguments);
			this._refreshState();
		},

		validator: function(/*anything*/ value, /*__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			return (new RegExp("^(?:" + this._computeRegexp(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
			return this.validator(this.textbox.value, this.get('constraints'));
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			return (this.trim ? /^\s*$/ : /^$/).test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			var invalid = this.invalidMessage == "$_unset_$" ? this.messages.invalidMessage :
				!this.invalidMessage ? this.promptMessage : this.invalidMessage;
			var missing = this.missingMessage == "$_unset_$" ? this.messages.missingMessage :
				!this.missingMessage ? invalid : this.missingMessage;
			return (this.required && this._isEmpty(this.textbox.value)) ? missing : invalid; // String
		},

		getPromptMessage: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			if(isValid){ this._maskValidSubsetError = true; }
			var isEmpty = this._isEmpty(this.textbox.value);
			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			this._set("state", isValid ? "" : (((((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && (this._maskValidSubsetError || (isValidSubset && !this._hasBeenBlurred && isFocused))) ? "Incomplete" : "Error"));
			this.focusNode.setAttribute("aria-invalid", this.state == "Error" ? "true" : "false");

			if(this.state == "Error"){
				this._maskValidSubsetError = isFocused && isValidSubset; // we want the error to show up after a blur and refocus
				message = this.getErrorMessage(isFocused);
			}else if(this.state == "Incomplete"){
				message = this.getPromptMessage(isFocused); // show the prompt whenever the value is not yet complete
				this._maskValidSubsetError = !this._hasBeenBlurred || isFocused; // no Incomplete warnings while focused
			}else if(isEmpty){
				message = this.getPromptMessage(isFocused); // show the prompt whenever there's no error and no text
			}
			this.set("message", message);

			return isValid;
		},

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			if(message && this.focused){
				Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
			}else{
				Tooltip.hide(this.domNode);
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			if(this._created){ // should instead be this._started but that would require all programmatic ValidationTextBox instantiations to call startup()
				this.validate(this.focused);
			}
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(params /*===== , srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.

			this.constraints = lang.clone(this.constraints);
			this.baseClass += ' dijitValidationTextBox';
		},

		startup: function(){
			this.inherited(arguments);
			this._refreshState(); // after all _set* methods have run
		},

		_setConstraintsAttr: function(/*__Constraints*/ constraints){
			if(!constraints.locale && this.lang){
				constraints.locale = this.lang;
			}
			this._set("constraints", constraints);
			this._refreshState();
		},

		_setPatternAttr: function(/*String|Function*/ pattern){
			this._set("pattern", pattern); // don't set on INPUT to avoid native HTML5 validation
			this._refreshState();
		},

		_computeRegexp: function(/*__Constraints*/ constraints){
			// summary:
			//		Hook to get the current regExp and to compute the partial validation RE.

			var p = this.pattern;
			if(typeof p == "function"){
				p = p.call(this, constraints);
			}
			if(p != this._lastRegExp){
				var partialre = "";
				this._lastRegExp = p;
				// parse the regexp and produce a new regexp that matches valid subsets
				// if the regexp is .* then there's no use in matching subsets since everything is valid
				if(p != ".*"){
					p.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
					function(re){
						switch(re.charAt(0)){
							case '{':
							case '+':
							case '?':
							case '*':
							case '^':
							case '$':
							case '|':
							case '(':
								partialre += re;
								break;
							case ")":
								partialre += "|$)";
								break;
							 default:
								partialre += "(?:"+re+"|$)";
								break;
						}
					});
				}
				try{ // this is needed for now since the above regexp parsing needs more test verification
					"".search(partialre);
				}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
					partialre = this.pattern;
					console.warn('RegExp error in ' + this.declaredClass + ': ' + this.pattern);
				} // should never be here unless the original RE is bad or the parsing is bad
				this._partialre = "^(?:" + partialre + ")$";
			}
			return p;
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.messages = i18n.getLocalization("dijit.form", "validate", this.lang);
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls attachPoints
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			this._refreshState();
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this._set("required", value);
			this.focusNode.setAttribute("aria-required", value);
			this._refreshState();
		},

		_setMessageAttr: function(/*String*/ message){
			this._set("message", message);
			this.displayMessage(message);
		},

		reset:function(){
			// Overrides dijit/form/TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		},

		_onBlur: function(){
			// the message still exists but for back-compat, and to erase the tooltip
			// (if the message is being displayed as a tooltip), call displayMessage('')
			this.displayMessage('');

			this.inherited(arguments);
		},

		destroy: function(){
			Tooltip.hide(this.domNode);	// in case tooltip show when ValidationTextBox (or enclosing Dialog) destroyed
			this.inherited(arguments);
		}
	});

	/*=====
	 ValidationTextBox.__Constraints = {
		 // locale: String
		 //		locale used for validation, picks up value from this widget's lang attribute
		 // _flags_: anything
		 //		various flags passed to pattern function
	 };
	 =====*/

	return ValidationTextBox;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/form/_FormMixin.js":
/*!***********************************************!*\
  !*** ./node_modules/dijit/form/_FormMixin.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.every array.filter array.forEach array.indexOf array.map
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/_base/kernel */ "./node_modules/dojo/_base/kernel.js"), // kernel.deprecated
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.hitch lang.isArray
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/window */ "./node_modules/dojo/window.js") // winUtils.scrollIntoView
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(array, declare, kernel, lang, on, winUtils){

	// module:
	//		dijit/form/_FormMixin

	return declare("dijit.form._FormMixin", null, {
		// summary:
		//		Mixin for containers of form widgets (i.e. widgets that represent a single value
		//		and can be children of a `<form>` node or `dijit/form/Form` widget)
		// description:
		//		Can extract all the form widgets
		//		values and combine them into a single javascript object, or alternately
		//		take such an object and set the values for all the contained
		//		form widgets

	/*=====
		// value: Object
		//		Name/value hash for each child widget with a name and value.
		//		Child widgets without names are not part of the hash.
		//
		//		If there are multiple child widgets w/the same name, value is an array,
		//		unless they are radio buttons in which case value is a scalar (since only
		//		one radio button can be checked at a time).
		//
		//		If a child widget's name is a dot separated list (like a.b.c.d), it's a nested structure.
		//
		//		Example:
		//	|	{ name: "John Smith", interests: ["sports", "movies"] }
	=====*/

		// state: [readonly] String
		//		Will be "Error" if one or more of the child widgets has an invalid value,
		//		"Incomplete" if not all of the required child widgets are filled in.  Otherwise, "",
		//		which indicates that the form is ready to be submitted.
		state: "",

		// TODO:
		//	* Repeater
		//	* better handling for arrays.  Often form elements have names with [] like
		//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])


		_getDescendantFormWidgets: function(/*dijit/_WidgetBase[]?*/ children){
			// summary:
			//		Returns all form widget descendants, searching through non-form child widgets like BorderContainer
			var res = [];
			array.forEach(children || this.getChildren(), function(child){
				if("value" in child){
					res.push(child);
				}else{
					res = res.concat(this._getDescendantFormWidgets(child.getChildren()));
				}
			}, this);
			return res;
		},

		reset: function(){
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary:
			//		returns if the form is valid - same as isValid - but
			//		provides a few additional (ui-specific) features:
			//
			//		1. it will highlight any sub-widgets that are not valid
			//		2. it will call focus() on the first invalid sub-widget
			var didFocus = false;
			return array.every(array.map(this._getDescendantFormWidgets(), function(widget){
				// Need to set this so that "required" widgets get their
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if(!valid && !didFocus){
					// Set focus of the first non-valid widget
					winUtils.scrollIntoView(widget.containerNode || widget.domNode);
					widget.focus();
					didFocus = true;
				}
				return valid;
			}), function(item){ return item; });
		},

		setValues: function(val){
			kernel.deprecated(this.declaredClass+"::setValues() is deprecated. Use set('value', val) instead.", "", "2.0");
			return this.set('value', val);
		},
		_setValueAttr: function(/*Object*/ obj){
			// summary:
			//		Fill in form values from according to an Object (in the format returned by get('value'))

			// generate map from name --> [list of widgets with that name]
			var map = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = lang.getObject(name, false, obj);	// list of values for those widgets

				if(values === undefined){
					continue;
				}
				values = [].concat(values);
				if(typeof widgets[0].checked == 'boolean'){
					// for checkbox/radio, values is a list of which widgets should be checked
					array.forEach(widgets, function(w){
						w.set('value', array.indexOf(values, w._get('value')) != -1);
					});
				}else if(widgets[0].multiple){
					// it takes an array (e.g. multi-select)
					widgets[0].set('value', values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					array.forEach(widgets, function(w, i){
						w.set('value', values[i]);
					});
				}
			}

			/***
			 *	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)

			array.forEach(this.containerNode.elements, function(element){
				if(element.name == ''){return};	// like "continue"
				var namePath = element.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == "undefined"){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if(typeof(myObj) == "undefined"){
					return;		// like "continue"
				}
				if(typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
					return;		// like "continue"
				}

				// TODO: widget values (just call set('value', ...) on the widget)

				// TODO: maybe should call dojo.getNodeProp() instead
				switch(element.type){
					case "checkbox":
						element.checked = (name in myObj) &&
							array.some(myObj[name], function(val){ return val == element.value; });
						break;
					case "radio":
						element.checked = (name in myObj) && myObj[name] == element.value;
						break;
					case "select-multiple":
						element.selectedIndex=-1;
						array.forEach(element.options, function(option){
							option.selected = array.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case "select-one":
						element.selectedIndex="0";
						array.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case "hidden":
					case "text":
					case "textarea":
					case "password":
						element.value = myObj[name] || "";
						break;
				}
			});
			*/

			// Note: no need to call this._set("value", ...) as the child updates will trigger onChange events
			// which I am monitoring.
		},

		getValues: function(){
			kernel.deprecated(this.declaredClass+"::getValues() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},
		_getValueAttr: function(){
			// summary:
			//		Returns Object representing form values.   See description of `value` for details.
			// description:

			// The value is updated into this.value every time a child has an onChange event,
			// so in the common case this function could just return this.value.   However,
			// that wouldn't work when:
			//
			// 1. User presses return key to submit a form.  That doesn't fire an onchange event,
			// and even if it did it would come too late due to the defer(...) in _handleOnChange()
			//
			// 2. app for some reason calls this.get("value") while the user is typing into a
			// form field.   Not sure if that case needs to be supported or not.

			// get widget values
			var obj = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				var name = widget.name;
				if(!name || widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain <input> type widget)
				var value = widget.get('value');

				// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == 'boolean'){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							lang.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = lang.getObject(name, false, obj);
							if(value === undefined){
								lang.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=lang.getObject(name, false, obj);
						if(!ary){
							ary=[];
							lang.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					var prev=lang.getObject(name, false, obj);
					if(typeof prev != "undefined"){
						if(lang.isArray(prev)){
							prev.push(value);
						}else{
							lang.setObject(name, [prev, value], obj);
						}
					}else{
						// unique name
						lang.setObject(name, value, obj);
					}
				}
			});

			/***
			 * code for plain input boxes (see also domForm.formToObject, can we use that instead of this code?
			 * but it doesn't understand [] notation, presumably)
			var obj = { };
			array.forEach(this.containerNode.elements, function(elm){
				if(!elm.name)	{
					return;		// like "continue"
				}
				var namePath = elm.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
					}else if(typeof(myObj[nameA[0]]) == "undefined"){
						myObj[nameA[0]] = { }
					} // if

					if(nameA.length == 1){
						myObj=myObj[nameA[0]];
					}else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type == "radio" && elm.checked)){
					if(name == name.split("[")[0]){
						myObj[name]=elm.value;
					}else{
						// can not set value when there is no name
					}
				}else if(elm.type == "checkbox" && elm.checked){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				}else if(elm.type == "select-multiple"){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					for(var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
						if(elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

		isValid: function(){
			// summary:
			//		Returns true if all of the widgets are valid.
			//		Deprecated, will be removed in 2.0.  Use get("state") instead.

			return this.state == "";
		},

		onValidStateChange: function(/*Boolean*/ /*===== isValid =====*/){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid
			//		state changes on the form as a whole.
			//
			//		Deprecated.  Will be removed in 2.0.  Use watch("state", ...) instead.
		},

		_getState: function(){
			// summary:
			//		Compute what this.state should be based on state of children
			var states = array.map(this._descendants, function(w){
				return w.get("state") || "";
			});

			return array.indexOf(states, "Error") >= 0 ? "Error" :
				array.indexOf(states, "Incomplete") >= 0 ? "Incomplete" : "";
		},

		disconnectChildren: function(){
			// summary:
			//		Deprecated method.   Applications no longer need to call this.   Remove for 2.0.
		},

		connectChildren: function(/*Boolean*/ inStartup){
			// summary:
			//		You can call this function directly, ex. in the event that you
			//		programmatically add a widget to the form *after* the form has been
			//		initialized.

			// TODO: rename for 2.0

			this._descendants = this._getDescendantFormWidgets();

			// To get notifications from children they need to be started.   Children didn't used to need to be started,
			// so for back-compat, start them here
			array.forEach(this._descendants, function(child){
				if(!child._started){ child.startup(); }
			});

			if(!inStartup){
				this._onChildChange();
			}
		},

		_onChildChange: function(/*String*/ attr){
			// summary:
			//		Called when child's value or disabled state changes

			// The unit tests expect state update to be synchronous, so update it immediately.
			if(!attr || attr == "state" || attr == "disabled"){
				this._set("state", this._getState());
			}

			// Use defer() to collapse value changes in multiple children into a single
			// update to my value.   Multiple updates will occur on:
			//	1. Form.set()
			//	2. Form.reset()
			//	3. user selecting a radio button (which will de-select another radio button,
			//		 causing two onChange events)
			if(!attr || attr == "value" || attr == "disabled" || attr == "checked"){
				if(this._onChangeDelayTimer){
					this._onChangeDelayTimer.remove();
				}
				this._onChangeDelayTimer = this.defer(function(){
					delete this._onChangeDelayTimer;
					this._set("value", this.get("value"));
				}, 10);
			}
		},

		startup: function(){
			this.inherited(arguments);

			// Set initial this.value and this.state.   Don't emit watch() notifications.
			this._descendants = this._getDescendantFormWidgets();
			this.value = this.get("value");
			this.state = this._getState();

			// Initialize value and valid/invalid state tracking.
			var self = this;
			this.own(
				on(
					this.containerNode,
					"attrmodified-state, attrmodified-disabled, attrmodified-value, attrmodified-checked",
					function(evt){
						if(evt.target == self.domNode){
							return;	// ignore events that I fire on myself because my children changed
						}
						self._onChildChange(evt.type.replace("attrmodified-", ""));
					}
				)
			);

			// Make state change call onValidStateChange(), will be removed in 2.0
			this.watch("state", function(attr, oldVal, newVal){ this.onValidStateChange(newVal == ""); });
		},

		destroy: function(){
			this.inherited(arguments);
		}

	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/form/_FormValueMixin.js":
/*!****************************************************!*\
  !*** ./node_modules/dijit/form/_FormValueMixin.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom-attr */ "./node_modules/dojo/dom-attr.js"), // domAttr.set
	__webpack_require__(/*! dojo/keys */ "./node_modules/dojo/keys.js"), // keys.ESCAPE
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js"), // has("webkit")
	__webpack_require__(/*! ./_FormWidgetMixin */ "./node_modules/dijit/form/_FormWidgetMixin.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(declare, domAttr, keys, lang, on, has, _FormWidgetMixin){

	// module:
	//		dijit/form/_FormValueMixin

	return declare("dijit.form._FormValueMixin", _FormWidgetMixin, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as `<input>` or `<select>`
		//		that have user changeable values.
		// description:
		//		Each _FormValueMixin represents a single input value, and has a (possibly hidden) `<input>` element,
		//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
		//		works as expected.

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,

		_setReadOnlyAttr: function(/*Boolean*/ value){
			// IE has a Caret Browsing mode (hit F7 to activate) where disabled textboxes can be modified
			// focusNode enforced readonly if currently disabled to avoid this issue.
			if (has('trident') && 'disabled' in this) {
				domAttr.set(this.focusNode, 'readOnly', value || this.disabled);
			} else {
				domAttr.set(this.focusNode, 'readOnly', value);
			}
			this._set("readOnly", value);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Update our reset value if it hasn't yet been set (because this.set()
			// is only called when there *is* a value)
			if(this._resetValue === undefined){
				this._lastValueReported = this._resetValue = this.value;
			}
		},

		_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the widget.
			//		If the value has changed, then fire onChange event, unless priorityChange
			//		is specified as null (or false?)
			this._handleOnChange(newValue, priorityChange);
		},

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget has changed.  Saves the new value in this.value,
			//		and calls onChange() if appropriate.   See _FormWidget._handleOnChange() for details.
			this._set("value", newValue);
			this.inherited(arguments);
		},

		undo: function(){
			// summary:
			//		Restore the value to the last value passed to onChange
			this._setValueAttr(this._lastValueReported, false);
		},

		reset: function(){
			// summary:
			//		Reset the widget's value to what it was at initialization time
			this._hasBeenBlurred = false;
			this._setValueAttr(this._resetValue, true);
		}
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/form/_FormValueWidget.js":
/*!*****************************************************!*\
  !*** ./node_modules/dijit/form/_FormValueWidget.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js"), // has("ie")
	__webpack_require__(/*! ./_FormWidget */ "./node_modules/dijit/form/_FormWidget.js"),
	__webpack_require__(/*! ./_FormValueMixin */ "./node_modules/dijit/form/_FormValueMixin.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(declare, has, _FormWidget, _FormValueMixin){

	// module:
	//		dijit/form/_FormValueWidget

	return declare("dijit.form._FormValueWidget", [_FormWidget, _FormValueMixin], {
		// summary:
		//		Base class for widgets corresponding to native HTML elements such as `<input>` or `<select>`
		//		that have user changeable values.
		// description:
		//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) `<input>` element,
		//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
		//		works as expected.

		// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
		// directly in the template as read by the parser in order to function. IE is known to specifically
		// require the 'name' attribute at element creation time.  See #8484, #8660.

		_layoutHackIE7: function(){
			// summary:
			//		Work around table sizing bugs on IE7 by forcing redraw

			if(has("ie") == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
				var domNode = this.domNode;
				var parent = domNode.parentNode;
				var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
				var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
				var _this = this;
				while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
					(function ping(){
						var disconnectHandle = _this.connect(parent, "onscroll",
							function(){
								_this.disconnect(disconnectHandle); // only call once
								pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
								_this.defer(function(){
									pingNode.style.filter = origFilter;
								}); // restore custom filter, if any
							}
						);
					})();
					parent = parent.parentNode;
				}
			}
		}
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/form/_FormWidget.js":
/*!************************************************!*\
  !*** ./node_modules/dijit/form/_FormWidget.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js"), // has("dijit-legacy-requires"), has("msapp")
	__webpack_require__(/*! dojo/_base/kernel */ "./node_modules/dojo/_base/kernel.js"), // kernel.deprecated
	__webpack_require__(/*! dojo/ready */ "./node_modules/dojo/ready.js"),
	__webpack_require__(/*! ../_Widget */ "./node_modules/dijit/_Widget.js"),
	__webpack_require__(/*! ../_CssStateMixin */ "./node_modules/dijit/_CssStateMixin.js"),
	__webpack_require__(/*! ../_TemplatedMixin */ "./node_modules/dijit/_TemplatedMixin.js"),
	__webpack_require__(/*! ./_FormWidgetMixin */ "./node_modules/dijit/form/_FormWidgetMixin.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(declare, has, kernel, ready, _Widget, _CssStateMixin, _TemplatedMixin, _FormWidgetMixin){

	// module:
	//		dijit/form/_FormWidget

	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/form/_FormValueWidget"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.form._FormWidget", [_Widget, _TemplatedMixin, _CssStateMixin, _FormWidgetMixin], {
		// summary:
		//		Base class for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
		//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
		//
		// description:
		//		Represents a single HTML element.
		//		All these widgets should have these attributes just like native HTML input elements.
		//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
		//
		//		They also share some common methods.

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.  Use set('disabled', ...) instead.
			kernel.deprecated("setDisabled(" + disabled + ") is deprecated. Use set('disabled'," + disabled + ") instead.", "", "2.0");
			this.set('disabled', disabled);
		},

		setValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('value', ...) instead.
			kernel.deprecated("dijit.form._FormWidget:setValue(" + value + ") is deprecated.  Use set('value'," + value + ") instead.", "", "2.0");
			this.set('value', value);
		},

		getValue: function(){
			// summary:
			//		Deprecated.  Use get('value') instead.
			kernel.deprecated(this.declaredClass + "::getValue() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified).
			// Unfortunately we can't use _setNameAttr to set the name in IE due to IE limitations, see #8484, #8660.
			// But when IE6 and IE7 are desupported, then we probably don't need this anymore, so should remove it in 2.0.
			// Also, don't do this for Windows 8 Store Apps because it causes a security exception (see #16452).
			// Regarding escaping, see heading "Attribute values" in
			// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
			this.nameAttrSetting = (this.name && !has("msapp")) ? ('name="' + this.name.replace(/"/g, "&quot;") + '"') : '';
			this.inherited(arguments);
		}
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/form/_FormWidgetMixin.js":
/*!*****************************************************!*\
  !*** ./node_modules/dijit/form/_FormWidgetMixin.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.forEach
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom-attr */ "./node_modules/dojo/dom-attr.js"), // domAttr.set
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"), // domStyle.get
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.hitch lang.isArray
	__webpack_require__(/*! dojo/mouse */ "./node_modules/dojo/mouse.js"), // mouse.isLeft
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js"), // has("webkit")
	__webpack_require__(/*! dojo/window */ "./node_modules/dojo/window.js"), // winUtils.scrollIntoView
	__webpack_require__(/*! ../a11y */ "./node_modules/dijit/a11y.js")    // a11y.hasDefaultTabStop
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(array, declare, domAttr, domStyle, lang, mouse, on, has, winUtils, a11y){

	// module:
	//		dijit/form/_FormWidgetMixin

	return declare("dijit.form._FormWidgetMixin", null, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
		//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
		//
		// description:
		//		Represents a single HTML element.
		//		All these widgets should have these attributes just like native HTML input elements.
		//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
		//
		//		They also share some common methods.

		// name: [const] String
		//		Name used when submitting form; same as "name" attribute or plain HTML elements
		name: "",

		// alt: String
		//		Corresponds to the native HTML `<input>` element's attribute.
		alt: "",

		// value: String
		//		Corresponds to the native HTML `<input>` element's attribute.
		value: "",

		// type: [const] String
		//		Corresponds to the native HTML `<input>` element's attribute.
		type: "text",

		// type: String
		//		Apply aria-label in markup to the widget's focusNode
		"aria-label": "focusNode",

		// tabIndex: String
		//		Order fields are traversed when user hits the tab key
		tabIndex: "0",
		_setTabIndexAttr: "focusNode", // force copy even when tabIndex default value, needed since Button is <span>

		// disabled: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "disabled='disabled'", or just "disabled".
		disabled: false,

		// intermediateChanges: Boolean
		//		Fires onChange for each value change or only on demand
		intermediateChanges: false,

		// scrollOnFocus: Boolean
		//		On focus, should this widget scroll into view?
		scrollOnFocus: true,

		// Override _WidgetBase mapping id to this.domNode, needs to be on focusNode so <label> etc.
		// works with screen reader
		_setIdAttr: "focusNode",

		_setDisabledAttr: function(/*Boolean*/ value){
			this._set("disabled", value);

			// Set disabled property if focusNode is an <input>, but aria-disabled attribute if focusNode is a <span>.
			// Can't use "disabled" in this.focusNode as a test because on IE, that's true for all nodes.
			if(/^(button|input|select|textarea|optgroup|option|fieldset)$/i.test(this.focusNode.tagName)){
				domAttr.set(this.focusNode, 'disabled', value);
				// IE has a Caret Browsing mode (hit F7 to activate) where disabled textboxes can be modified
				// textboxes marked readonly if disabled to avoid this issue.
				if (has('trident') && 'readOnly' in this) {
					domAttr.set(this.focusNode, 'readonly', value || this.readOnly);
				}
			}else{
				this.focusNode.setAttribute("aria-disabled", value ? "true" : "false");
			}

			// And also set disabled on the hidden <input> node
			if(this.valueNode){
				domAttr.set(this.valueNode, 'disabled', value);
			}

			if(value){
				// reset these, because after the domNode is disabled, we can no longer receive
				// mouse related events, see #4200
				this._set("hovering", false);
				this._set("active", false);

				// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)
				var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex :
					("_setTabIndexAttr" in this) ? this._setTabIndexAttr : "focusNode";
				array.forEach(lang.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){
					var node = this[attachPointName];
					// complex code because tabIndex=-1 on a <div> doesn't work on FF
					if(has("webkit") || a11y.hasDefaultTabStop(node)){    // see #11064 about webkit bug
						node.setAttribute('tabIndex', "-1");
					}else{
						node.removeAttribute('tabIndex');
					}
				}, this);
			}else{
				if(this.tabIndex != ""){
					this.set('tabIndex', this.tabIndex);
				}
			}
		},

		_onFocus: function(/*String*/ by){
			// If user clicks on the widget, even if the mouse is released outside of it,
			// this widget's focusNode should get focus (to mimic native browser behavior).
			// Browsers often need help to make sure the focus via mouse actually gets to the focusNode.
			// TODO: consider removing all of this for 2.0 or sooner, see #16622 etc.
			if(by == "mouse" && this.isFocusable()){
				// IE exhibits strange scrolling behavior when refocusing a node so only do it when !focused.
				var focusHandle = this.own(on(this.focusNode, "focus", function(){
					mouseUpHandle.remove();
					focusHandle.remove();
				}))[0];
				// Set a global event to handle mouseup, so it fires properly
				// even if the cursor leaves this.domNode before the mouse up event.
				var event = has("pointer-events") ? "pointerup" : has("MSPointer") ? "MSPointerUp" :
					has("touch-events") ? "touchend, mouseup" :		// seems like overkill but see #16622, #16725
					"mouseup";
				var mouseUpHandle = this.own(on(this.ownerDocumentBody, event, lang.hitch(this, function(evt){
					mouseUpHandle.remove();
					focusHandle.remove();
					// if here, then the mousedown did not focus the focusNode as the default action
					if(this.focused){
						if(evt.type == "touchend"){
							this.defer("focus"); // native focus hasn't occurred yet
						}else{
							this.focus(); // native focus already occurred on mousedown
						}
					}
				})))[0];
			}
			if(this.scrollOnFocus){
				this.defer(function(){
					winUtils.scrollIntoView(this.domNode);
				}); // without defer, the input caret position can change on mouse click
			}
			this.inherited(arguments);
		},

		isFocusable: function(){
			// summary:
			//		Tells if this widget is focusable or not.  Used internally by dijit.
			// tags:
			//		protected
			return !this.disabled && this.focusNode && (domStyle.get(this.domNode, "display") != "none");
		},

		focus: function(){
			// summary:
			//		Put focus on this widget
			if(!this.disabled && this.focusNode.focus){
				try{
					this.focusNode.focus();
				}catch(e){
				}
				/*squelch errors from hidden nodes*/
			}
		},

		compare: function(/*anything*/ val1, /*anything*/ val2){
			// summary:
			//		Compare 2 values (as returned by get('value') for this widget).
			// tags:
			//		protected
			if(typeof val1 == "number" && typeof val2 == "number"){
				return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
			}else if(val1 > val2){
				return 1;
			}else if(val1 < val2){
				return -1;
			}else{
				return 0;
			}
		},

		onChange: function(/*===== newValue =====*/){
			// summary:
			//		Callback when this widget's value is changed.
			// tags:
			//		callback
		},

		// _onChangeActive: [private] Boolean
		//		Indicates that changes to the value should call onChange() callback.
		//		This is false during widget initialization, to avoid calling onChange()
		//		when the initial value is set.
		_onChangeActive: false,

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget is set.  Calls onChange() if appropriate
			// newValue:
			//		the new value
			// priorityChange:
			//		For a slider, for example, dragging the slider is priorityChange==false,
			//		but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
			//		onChange is only called form priorityChange=true events.
			// tags:
			//		private
			if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
				// this block executes not for a change, but during initialization,
				// and is used to store away the original value (or for ToggleButton, the original checked state)
				this._resetValue = this._lastValueReported = newValue;
			}
			this._pendingOnChange = this._pendingOnChange
				|| (typeof newValue != typeof this._lastValueReported)
				|| (this.compare(newValue, this._lastValueReported) != 0);
			if((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){
				this._lastValueReported = newValue;
				this._pendingOnChange = false;
				if(this._onChangeActive){
					if(this._onChangeHandle){
						this._onChangeHandle.remove();
					}
					// defer allows hidden value processing to run and
					// also the onChange handler can safely adjust focus, etc
					this._onChangeHandle = this.defer(
						function(){
							this._onChangeHandle = null;
							this.onChange(newValue);
						}); // try to collapse multiple onChange's fired faster than can be processed
				}
			}
		},

		create: function(){
			// Overrides _Widget.create()
			this.inherited(arguments);
			this._onChangeActive = true;
		},

		destroy: function(){
			if(this._onChangeHandle){ // destroy called before last onChange has fired
				this._onChangeHandle.remove();
				this.onChange(this._lastValueReported);
			}
			this.inherited(arguments);
		}
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/form/_TextBoxMixin.js":
/*!**************************************************!*\
  !*** ./node_modules/dijit/form/_TextBoxMixin.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.forEach
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom */ "./node_modules/dojo/dom.js"), // dom.byId
	__webpack_require__(/*! dojo/sniff */ "./node_modules/dojo/sniff.js"),	// has("ie"), has("dojo-bidi")
	__webpack_require__(/*! dojo/keys */ "./node_modules/dojo/keys.js"), // keys.ALT keys.CAPS_LOCK keys.CTRL keys.META keys.SHIFT
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.mixin
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"), // on
	__webpack_require__(/*! ../main */ "./node_modules/dijit/main.js")    // for exporting dijit._setSelectionRange, dijit.selectInputText
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(array, declare, dom, has, keys, lang, on, dijit){

	// module:
	//		dijit/form/_TextBoxMixin

	var _TextBoxMixin = declare("dijit.form._TextBoxMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
		// summary:
		//		A mixin for textbox form input widgets

		// trim: Boolean
		//		Removes leading and trailing whitespace if true.  Default is false.
		trim: false,

		// uppercase: Boolean
		//		Converts all characters to uppercase if true.  Default is false.
		uppercase: false,

		// lowercase: Boolean
		//		Converts all characters to lowercase if true.  Default is false.
		lowercase: false,

		// propercase: Boolean
		//		Converts the first character of each word to uppercase if true.
		propercase: false,

		// maxLength: String
		//		HTML INPUT tag maxLength declaration.
		maxLength: "",

		// selectOnClick: [const] Boolean
		//		If true, all text will be selected when focused with mouse
		selectOnClick: false,

		// placeHolder: String
		//		Defines a hint to help users fill out the input field (as defined in HTML 5).
		//		This should only contain plain text (no html markup).
		placeHolder: "",

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works as we like.
			// description:
			//		For `dijit/form/TextBox` this basically returns the value of the `<input>`.
			//
			//		For `dijit/form/MappedTextBox` subclasses, which have both
			//		a "displayed value" and a separate "submit value",
			//		This treats the "displayed value" as the master value, computing the
			//		submit value from it via this.parse().
			return this.parse(this.get('displayedValue'), this.constraints);
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so set('value', ...) works.
			//
			// description:
			//		Sets the value of the widget to "value" which can be of
			//		any type as determined by the widget.
			//
			// value:
			//		The visual element value is also set to a corresponding,
			//		but not necessarily the same, value.
			//
			// formattedValue:
			//		If specified, used to set the visual element value,
			//		otherwise a computed visual value is used.
			//
			// priorityChange:
			//		If true, an onChange event is fired immediately instead of
			//		waiting for the next blur event.

			var filteredValue;
			if(value !== undefined){
				// TODO: this is calling filter() on both the display value and the actual value.
				// I added a comment to the filter() definition about this, but it should be changed.
				filteredValue = this.filter(value);
				if(typeof formattedValue != "string"){
					if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
						formattedValue = this.filter(this.format(filteredValue, this.constraints));
					}else{
						formattedValue = '';
					}
					// Ensure the filtered value does not change after being formatted. See track #17955.
					//
					// This check is only applied when the formatted value is not specified by the caller in order to allow the 
					// behavior to be overriden. This is needed whenever value synonyms cannot be determined using parse/compare. For
					// example, dijit/form/FilteringSelect determines the formatted value asynchronously and applies it using a 
					// callback to this method.
					//
					// TODO: Should developers be warned that they broke the round trip on format?
					if (this.compare(filteredValue, this.filter(this.parse(formattedValue, this.constraints))) != 0){
						formattedValue = null;
					}
				}
			}
			if(formattedValue != null /* and !undefined */ && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
				this.textbox.value = formattedValue;
				this._set("displayedValue", this.get("displayedValue"));
			}

			this.inherited(arguments, [filteredValue, priorityChange]);
		},

		// displayedValue: String
		//		For subclasses like ComboBox where the displayed value
		//		(ex: Kentucky) and the serialized value (ex: KY) are different,
		//		this represents the displayed value.
		//
		//		Setting 'displayedValue' through set('displayedValue', ...)
		//		updates 'value', and vice-versa.  Otherwise 'value' is updated
		//		from 'displayedValue' periodically, like onBlur etc.
		//
		//		TODO: move declaration to MappedTextBox?
		//		Problem is that ComboBox references displayedValue,
		//		for benefit of FilteringSelect.
		displayedValue: "",

		_getDisplayedValueAttr: function(){
			// summary:
			//		Hook so get('displayedValue') works.
			// description:
			//		Returns the displayed value (what the user sees on the screen),
			//		after filtering (ie, trimming spaces etc.).
			//
			//		For some subclasses of TextBox (like ComboBox), the displayed value
			//		is different from the serialized value that's actually
			//		sent to the server (see `dijit/form/ValidationTextBox.serialize()`)

			// TODO: maybe we should update this.displayedValue on every keystroke so that we don't need
			// this method
			// TODO: this isn't really the displayed value when the user is typing
			return this.filter(this.textbox.value);
		},

		_setDisplayedValueAttr: function(/*String*/ value){
			// summary:
			//		Hook so set('displayedValue', ...) works.
			// description:
			//		Sets the value of the visual element to the string "value".
			//		The widget value is also set to a corresponding,
			//		but not necessarily the same, value.

			if(value == null /* or undefined */){
				value = ''
			}
			else if(typeof value != "string"){
				value = String(value)
			}

			this.textbox.value = value;

			// sets the serialized value to something corresponding to specified displayedValue
			// (if possible), and also updates the textbox.value, for example converting "123"
			// to "123.00"
			this._setValueAttr(this.get('value'), undefined);

			this._set("displayedValue", this.get('displayedValue'));
		},

		format: function(value /*=====, constraints =====*/){
			// summary:
			//		Replaceable function to convert a value to a properly formatted string.
			// value: String
			// constraints: Object
			// tags:
			//		protected extension
			return value == null /* or undefined */ ? "" : (value.toString ? value.toString() : value);
		},

		parse: function(value /*=====, constraints =====*/){
			// summary:
			//		Replaceable function to convert a formatted string to a value
			// value: String
			// constraints: Object
			// tags:
			//		protected extension

			return value;	// String
		},

		_refreshState: function(){
			// summary:
			//		After the user types some characters, etc., this method is
			//		called to check the field for validity etc.  The base method
			//		in `dijit/form/TextBox` does nothing, but subclasses override.
			// tags:
			//		protected
		},

		 onInput: function(/*Event*/ /*===== evt =====*/){
			 // summary:
			 //		Connect to this function to receive notifications of various user data-input events.
			 //		Return false to cancel the event and prevent it from being processed.
			 //		Note that although for historical reasons this method is called `onInput()`, it doesn't
			 //		correspond to the standard DOM "input" event, because it occurs before the input has been processed.
			 // event:
			 //		keydown | keypress | cut | paste | compositionend
			 // tags:
			 //		callback
		 },

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Called AFTER the input event has happened and this.textbox.value has new value.

			this._lastInputEventValue = this.textbox.value;

			// For Combobox, this needs to be called w/the keydown/keypress event that was passed to onInput().
			// As a backup, use the "input" event itself.
			this._processInput(this._lastInputProducingEvent || evt);
			delete this._lastInputProducingEvent;

			if(this.intermediateChanges){
				this._handleOnChange(this.get('value'), false);
			}
		},

		_processInput: function(/*Event*/ /*===== evt =====*/){
			// summary:
			//		Default action handler for user input events.
			//		Called after the "input" event (i.e. after this.textbox.value has been updated),
			//		but `evt` is the keydown/keypress/etc. event that triggered the "input" event.
			// tags:
			//		protected

			this._refreshState();

			// In case someone is watch()'ing for changes to displayedValue
			this._set("displayedValue", this.get("displayedValue"));
		},

		postCreate: function(){
			// setting the value here is needed since value="" in the template causes "undefined"
			// and setting in the DOM (instead of the JS object) helps with form reset actions
			this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values should be the same

			this.inherited(arguments);

			// normalize input events to reduce spurious event processing
			//	keydown: do not forward modifier keys
			//		       set charOrCode to numeric keycode
			//	keypress: do not forward numeric charOrCode keys (already sent through onkeydown)
			//	paste, cut, compositionend: set charOrCode to 229 (IME)
			function handleEvent(e){
				var charOrCode;

				// Filter out keydown events that will be followed by keypress events.  Note that chrome/android
				// w/word suggestion has keydown/229 events on typing with no corresponding keypress events.
				if(e.type == "keydown" && e.keyCode != 229){
					charOrCode = e.keyCode;
					switch(charOrCode){ // ignore state keys
						case keys.SHIFT:
						case keys.ALT:
						case keys.CTRL:
						case keys.META:
						case keys.CAPS_LOCK:
						case keys.NUM_LOCK:
						case keys.SCROLL_LOCK:
							return;
					}
					if(!e.ctrlKey && !e.metaKey && !e.altKey){ // no modifiers
						switch(charOrCode){ // ignore location keys
							case keys.NUMPAD_0:
							case keys.NUMPAD_1:
							case keys.NUMPAD_2:
							case keys.NUMPAD_3:
							case keys.NUMPAD_4:
							case keys.NUMPAD_5:
							case keys.NUMPAD_6:
							case keys.NUMPAD_7:
							case keys.NUMPAD_8:
							case keys.NUMPAD_9:
							case keys.NUMPAD_MULTIPLY:
							case keys.NUMPAD_PLUS:
							case keys.NUMPAD_ENTER:
							case keys.NUMPAD_MINUS:
							case keys.NUMPAD_PERIOD:
							case keys.NUMPAD_DIVIDE:
								return;
						}
						if((charOrCode >= 65 && charOrCode <= 90) || (charOrCode >= 48 && charOrCode <= 57) || charOrCode == keys.SPACE){
							return; // keypress will handle simple non-modified printable keys
						}
						var named = false;
						for(var i in keys){
							if(keys[i] === e.keyCode){
								named = true;
								break;
							}
						}
						if(!named){
							return;
						} // only allow named ones through
					}
				}

				charOrCode = e.charCode >= 32 ? String.fromCharCode(e.charCode) : e.charCode;
				if(!charOrCode){
					charOrCode = (e.keyCode >= 65 && e.keyCode <= 90) || (e.keyCode >= 48 && e.keyCode <= 57) || e.keyCode == keys.SPACE ? String.fromCharCode(e.keyCode) : e.keyCode;
				}
				if(!charOrCode){
					charOrCode = 229; // IME
				}
				if(e.type == "keypress"){
					if(typeof charOrCode != "string"){
						return;
					}
					if((charOrCode >= 'a' && charOrCode <= 'z') || (charOrCode >= 'A' && charOrCode <= 'Z') || (charOrCode >= '0' && charOrCode <= '9') || (charOrCode === ' ')){
						if(e.ctrlKey || e.metaKey || e.altKey){
							return;
						} // can only be stopped reliably in keydown
					}
				}

				// create fake event to set charOrCode and to know if preventDefault() was called
				var faux = { faux: true }, attr;
				for(attr in e){
					if(!/^(layer[XY]|returnValue|keyLocation)$/.test(attr)){ // prevent WebKit warnings
						var v = e[attr];
						if(typeof v != "function" && typeof v != "undefined"){
							faux[attr] = v;
						}
					}
				}
				lang.mixin(faux, {
					charOrCode: charOrCode,
					_wasConsumed: false,
					preventDefault: function(){
						faux._wasConsumed = true;
						e.preventDefault();
					},
					stopPropagation: function(){
						e.stopPropagation();
					}
				});

				this._lastInputProducingEvent = faux;

				// Give web page author a chance to consume the event.  Note that onInput() may be called multiple times
				// for same keystroke: once for keypress event and once for input event.
				//console.log(faux.type + ', charOrCode = (' + (typeof charOrCode) + ') ' + charOrCode + ', ctrl ' + !!faux.ctrlKey + ', alt ' + !!faux.altKey + ', meta ' + !!faux.metaKey + ', shift ' + !!faux.shiftKey);
				if(this.onInput(faux) === false){ // return false means stop
					faux.preventDefault();
					faux.stopPropagation();
				}
				if(faux._wasConsumed){
					return;
				} // if preventDefault was called

				// IE8 doesn't emit the "input" event at all, and IE9 doesn't emit it for backspace, delete, cut, etc.
				// Since the code below (and perhaps user code) depends on that event, emit it synthetically.
				// See http://benalpert.com/2013/06/18/a-near-perfect-oninput-shim-for-ie-8-and-9.html.
				if(has("ie") <= 9){
					switch(e.keyCode){
					case keys.TAB:
					case keys.ESCAPE:
					case keys.DOWN_ARROW:
					case keys.UP_ARROW:
					case keys.LEFT_ARROW:
					case keys.RIGHT_ARROW:
						// These keys may alter the <input>'s value indirectly, but we don't want to emit an "input"
						// event.  For example, the up/down arrows in TimeTextBox or ComboBox will cause the next
						// dropdown item's value to be copied to the <input>.
						break;
					default:
						if(e.keyCode == keys.ENTER && this.textbox.tagName.toLowerCase() != "textarea"){
							break;
						}
						this.defer(function(){
							if(this.textbox.value !== this._lastInputEventValue){
								on.emit(this.textbox, "input", {bubbles: true});
							}
						});
					}
				}
			}
			this.own(
				on(this.textbox, "keydown, keypress, paste, cut, compositionend", lang.hitch(this, handleEvent)),
				on(this.textbox, "input", lang.hitch(this, "_onInput")),

				// Allow keypress to bubble to this.domNode, so that TextBox.on("keypress", ...) works,
				// but prevent it from further propagating, so that typing into a TextBox inside a Toolbar doesn't
				// trigger the Toolbar's letter key navigation.
				on(this.domNode, "keypress", function(e){ e.stopPropagation(); })
			);
		},

		_blankValue: '', // if the textbox is blank, what value should be reported
		filter: function(val){
			// summary:
			//		Auto-corrections (such as trimming) that are applied to textbox
			//		value on blur or form submit.
			// description:
			//		For MappedTextBox subclasses, this is called twice
			//
			//		- once with the display value
			//		- once the value as set/returned by set('value', ...)
			//
			//		and get('value'), ex: a Number for NumberTextBox.
			//
			//		In the latter case it does corrections like converting null to NaN.  In
			//		the former case the NumberTextBox.filter() method calls this.inherited()
			//		to execute standard trimming code in TextBox.filter().
			//
			//		TODO: break this into two methods in 2.0
			//
			// tags:
			//		protected extension
			if(val === null){
				return this._blankValue;
			}
			if(typeof val != "string"){
				return val;
			}
			if(this.trim){
				val = lang.trim(val);
			}
			if(this.uppercase){
				val = val.toUpperCase();
			}
			if(this.lowercase){
				val = val.toLowerCase();
			}
			if(this.propercase){
				val = val.replace(/[^\s]+/g, function(word){
					return word.substring(0, 1).toUpperCase() + word.substring(1);
				});
			}
			return val;
		},

		_setBlurValue: function(){
			// Format the displayed value, for example (for NumberTextBox) convert 1.4 to 1.400,
			// or (for CurrencyTextBox) 2.50 to $2.50

			this._setValueAttr(this.get('value'), true);
		},

		_onBlur: function(e){
			if(this.disabled){
				return;
			}
			this._setBlurValue();
			this.inherited(arguments);
		},

		_isTextSelected: function(){
			return this.textbox.selectionStart != this.textbox.selectionEnd;
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){
				return;
			}

			// Select all text on focus via click if nothing already selected.
			// Since mouse-up will clear the selection, need to defer selection until after mouse-up.
			// Don't do anything on focus by tabbing into the widget since there's no associated mouse-up event.
			if(this.selectOnClick && by == "mouse"){
				// Use on.once() to only select all text on first click only; otherwise users would have no way to clear
				// the selection.
				this._selectOnClickHandle = on.once(this.domNode, "mouseup, touchend", lang.hitch(this, function(evt){
					// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
					// and if not, then select all the text
					if(!this._isTextSelected()){
						_TextBoxMixin.selectInputText(this.textbox);
					}
				}));
				this.own(this._selectOnClickHandle);

				// in case the mouseup never comes
				this.defer(function(){
					if(this._selectOnClickHandle){
						this._selectOnClickHandle.remove();
						this._selectOnClickHandle = null;
					}
				}, 500); // if mouseup not received soon, then treat it as some gesture
			}
			// call this.inherited() before refreshState(), since this.inherited() will possibly scroll the viewport
			// (to scroll the TextBox into view), which will affect how _refreshState() positions the tooltip
			this.inherited(arguments);

			this._refreshState();
		},

		reset: function(){
			// Overrides `dijit/_FormWidget/reset()`.
			// Additionally resets the displayed textbox value to ''
			this.textbox.value = '';
			this.inherited(arguments);
		}
	});

	if(has("dojo-bidi")){
		_TextBoxMixin = declare("dijit.form._TextBoxMixin", _TextBoxMixin, {
			_setValueAttr: function(){
				this.inherited(arguments);
				this.applyTextDir(this.focusNode);
			},
			_setDisplayedValueAttr: function(){
				this.inherited(arguments);
				this.applyTextDir(this.focusNode);
			},
			_onInput: function(){
				this.applyTextDir(this.focusNode);
				this.inherited(arguments);
			}
		});
	}

	_TextBoxMixin._setSelectionRange = dijit._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
		if(element.setSelectionRange){
			element.setSelectionRange(start, stop);
		}
	};

	_TextBoxMixin.selectInputText = dijit.selectInputText = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
		// summary:
		//		Select text in the input element argument, from start (default 0), to stop (default end).

		// TODO: use functions in _editor/selection.js?
		element = dom.byId(element);
		if(isNaN(start)){
			start = 0;
		}
		if(isNaN(stop)){
			stop = element.value ? element.value.length : 0;
		}
		try{
			element.focus();
			_TextBoxMixin._setSelectionRange(element, start, stop);
		}catch(e){ /* squelch random errors (esp. on IE) from unexpected focus changes or DOM nodes being hidden */
		}
	};

	return _TextBoxMixin;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/form/nls/es/validate.js":
/*!****************************************************!*\
  !*** ./node_modules/dijit/form/nls/es/validate.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!(module.exports = {
	invalidMessage: "El valor especificado no es vlido.",
	missingMessage: "Este valor es necesario.",
	rangeMessage: "Este valor est fuera del intervalo."
});


/***/ }),

/***/ "./node_modules/dijit/form/nls/fr/validate.js":
/*!****************************************************!*\
  !*** ./node_modules/dijit/form/nls/fr/validate.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!(module.exports = {
	invalidMessage: "La valeur indique n'est pas correcte.",
	missingMessage: "Cette valeur est requise.",
	rangeMessage: "Cette valeur n'est pas comprise dans la plage autorise."
});


/***/ }),

/***/ "./node_modules/dijit/form/nls/validate.js":
/*!*************************************************!*\
  !*** ./node_modules/dijit/form/nls/validate.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * This module was modified by dojo-webpack-plugin to disable some locales
 * that were excluded by the plugin's 'locales' option
 */
!(module.exports = {'root':({'invalidMessage':'The value entered is not valid.','missingMessage':'This value is required.','rangeMessage':'This value is out of range.'}),'bs':false,'mk':false,'sr':false,'zh':false,'zh-tw':false,'uk':false,'tr':false,'th':false,'sv':false,'sl':false,'sk':false,'ru':false,'ro':false,'pt':false,'pt-pt':false,'pl':false,'nl':false,'nb':false,'ko':false,'kk':false,'ja':false,'it':false,'id':false,'hu':false,'hr':false,'he':false,'fr':true,'fi':false,'eu':false,'es':true,'el':false,'de':false,'da':false,'cs':false,'ca':false,'bg':false,'az':false,'ar':false,'al':false})

/***/ }),

/***/ "./node_modules/dijit/hccss.js":
/*!*************************************!*\
  !*** ./node_modules/dijit/hccss.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/dom-class */ "./node_modules/dojo/dom-class.js"), __webpack_require__(/*! dojo/hccss */ "./node_modules/dojo/hccss.js"), __webpack_require__(/*! dojo/domReady */ "./node_modules/dojo/domReady.js"), __webpack_require__(/*! dojo/_base/window */ "./node_modules/dojo/_base/window.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(domClass, has, domReady, win){

	// module:
	//		dijit/hccss

	/*=====
	return function(){
		// summary:
		//		Test if computer is in high contrast mode, and sets `dijit_a11y` flag on `<body>` if it is.
		//		Deprecated, use ``dojo/hccss`` instead.
	};
	=====*/

	domReady(function(){
		if(has("highcontrast")){
			domClass.add(win.body(), "dijit_a11y");
		}
	});

	return has;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/layout/_ContentPaneResizeMixin.js":
/*!**************************************************************!*\
  !*** ./node_modules/dijit/layout/_ContentPaneResizeMixin.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.filter array.forEach
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom-class */ "./node_modules/dojo/dom-class.js"), // domClass.contains domClass.toggle
	__webpack_require__(/*! dojo/dom-geometry */ "./node_modules/dojo/dom-geometry.js"), // domGeometry.contentBox domGeometry.marginBox
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"),
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"), // lang.mixin
	__webpack_require__(/*! dojo/query */ "./node_modules/dojo/query.js"), // query
	__webpack_require__(/*! ../registry */ "./node_modules/dijit/registry.js"), // registry.byId
	__webpack_require__(/*! ../Viewport */ "./node_modules/dijit/Viewport.js"),
	__webpack_require__(/*! ./utils */ "./node_modules/dijit/layout/utils.js") // marginBox2contextBox
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(array, declare, domClass, domGeometry, domStyle, lang, query,
			registry, Viewport, layoutUtils){

	// module:
	//		dijit/layout/_ContentPaneResizeMixin

	return declare("dijit.layout._ContentPaneResizeMixin", null, {
		// summary:
		//		Resize() functionality of ContentPane.   If there's a single layout widget
		//		child then it will call resize() with the same dimensions as the ContentPane.
		//		Otherwise just calls resize on each child.
		//
		//		Also implements basic startup() functionality, where starting the parent
		//		will start the children

		// doLayout: Boolean
		//		- false - don't adjust size of children
		//		- true - if there is a single visible child widget, set it's size to however big the ContentPane is
		doLayout: true,

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget will call resize() on it's child widgets
		//		when they become visible.
		isLayoutContainer: true,

		startup: function(){
			// summary:
			//		See `dijit/layout/_LayoutWidget.startup()` for description.
			//		Although ContentPane doesn't extend _LayoutWidget, it does implement
			//		the same API.

			if(this._started){
				return;
			}

			var parent = this.getParent();
			this._childOfLayoutWidget = parent && parent.isLayoutContainer;

			// I need to call resize() on my child/children (when I become visible), unless
			// I'm the child of a layout widget in which case my parent will call resize() on me and I'll do it then.
			this._needLayout = !this._childOfLayoutWidget;

			this.inherited(arguments);

			if(this._isShown()){
				this._onShow();
			}

			if(!this._childOfLayoutWidget){
				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when viewport size changes so that I can re-layout.
				// This is more for subclasses of ContentPane than ContentPane itself, although it
				// could be useful for a ContentPane if it has a single child widget inheriting ContentPane's size.
				this.own(Viewport.on("resize", lang.hitch(this, "resize")));
			}
		},

		_checkIfSingleChild: function(){
			// summary:
			//		Test if we have exactly one visible widget as a child,
			//		and if so assume that we are a container for that widget,
			//		and should propagate startup() and resize() calls to it.
			//		Skips over things like data stores since they aren't visible.

			if(!this.doLayout){ return; }

			var candidateWidgets = [],
				otherVisibleNodes = false;

			query("> *", this.containerNode).some(function(node){
				var widget = registry.byNode(node);
				if(widget && widget.resize){
					candidateWidgets.push(widget);
				}else if(!/script|link|style/i.test(node.nodeName) && node.offsetHeight){
					otherVisibleNodes = true;
				}
			});

			this._singleChild = candidateWidgets.length == 1 && !otherVisibleNodes ?
				candidateWidgets[0] : null;

			// So we can set overflow: hidden to avoid a safari bug w/scrollbars showing up (#9449)
			domClass.toggle(this.containerNode, this.baseClass + "SingleChild", !!this._singleChild);
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		See `dijit/layout/_LayoutWidget.resize()` for description.
			//		Although ContentPane doesn't extend _LayoutWidget, it does implement
			//		the same API.

			this._resizeCalled = true;

			this._scheduleLayout(changeSize, resultSize);
		},

		_scheduleLayout: function(changeSize, resultSize){
			// summary:
			//		Resize myself, and call resize() on each of my child layout widgets, either now
			//		(if I'm currently visible) or when I become visible
			if(this._isShown()){
				this._layout(changeSize, resultSize);
			}else{
				this._needLayout = true;
				this._changeSize = changeSize;
				this._resultSize = resultSize;
			}
		},

		_layout: function(changeSize, resultSize){
			// summary:
			//		Resize myself according to optional changeSize/resultSize parameters, like a layout widget.
			//		Also, since I am an isLayoutContainer widget, each of my children expects me to
			//		call resize() or layout() on it.
			//
			//		Should be called on initialization and also whenever we get new content
			//		(from an href, or from set('content', ...))... but deferred until
			//		the ContentPane is visible

			delete this._needLayout;

			// For the TabContainer --> BorderContainer --> ContentPane case, _onShow() is
			// never called directly, so resize() is our trigger to do the initial href download (see [20099]).
			// However, don't load href for closed TitlePanes.
			if(!this._wasShown && this.open !== false){
				this._onShow();
			}

			// Set margin box size, unless it wasn't specified, in which case use current size.
			if(changeSize){
				domGeometry.setMarginBox(this.domNode, changeSize);
			}

			// Compute content box size of containerNode in case we [later] need to size our single child.
			var cn = this.containerNode;
			if(cn === this.domNode){
				// If changeSize or resultSize was passed to this method and this.containerNode ==
				// this.domNode then we can compute the content-box size without querying the node,
				// which is more reliable (similar to LayoutWidget.resize) (see for example #9449).
				var mb = resultSize || {};
				lang.mixin(mb, changeSize || {}); // changeSize overrides resultSize
				if(!("h" in mb) || !("w" in mb)){
					mb = lang.mixin(domGeometry.getMarginBox(cn), mb); // just use domGeometry.setMarginBox() to fill in missing values
				}
				this._contentBox = layoutUtils.marginBox2contentBox(cn, mb);
			}else{
				this._contentBox = domGeometry.getContentBox(cn);
			}

			this._layoutChildren();
		},

		_layoutChildren: function(){
			// Call _checkIfSingleChild() again in case app has manually mucked w/the content
			// of the ContentPane (rather than changing it through the set("content", ...) API.
			this._checkIfSingleChild();

			if(this._singleChild && this._singleChild.resize){
				var cb = this._contentBox || domGeometry.getContentBox(this.containerNode);

				// note: if widget has padding this._contentBox will have l and t set,
				// but don't pass them to resize() or it will doubly-offset the child
				this._singleChild.resize({w: cb.w, h: cb.h});
			}else{
				// All my child widgets are independently sized (rather than matching my size),
				// but I still need to call resize() on each child to make it layout.
				var children = this.getChildren(),
					widget,
					i = 0;
				while(widget = children[i++]){
					if(widget.resize){
						widget.resize();
					}
				}
			}
		},

		_isShown: function(){
			// summary:
			//		Returns true if the content is currently shown.
			// description:
			//		If I am a child of a layout widget then it actually returns true if I've ever been visible,
			//		not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
			//		tree every call, and at least solves the performance problem on page load by deferring loading
			//		hidden ContentPanes until they are first shown

			if(this._childOfLayoutWidget){
				// If we are TitlePane, etc - we return that only *IF* we've been resized
				if(this._resizeCalled && "open" in this){
					return this.open;
				}
				return this._resizeCalled;
			}else if("open" in this){
				return this.open;		// for TitlePane, etc.
			}else{
				var node = this.domNode, parent = this.domNode.parentNode;
				return (node.style.display != 'none') && (node.style.visibility != 'hidden') && !domClass.contains(node, "dijitHidden") &&
					parent && parent.style && (parent.style.display != 'none');
			}
		},

		_onShow: function(){
			// summary:
			//		Called when the ContentPane is made visible
			// description:
			//		For a plain ContentPane, this is called on initialization, from startup().
			//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
			//		called whenever the pane is made visible.
			//
			//		Does layout/resize of child widget(s)

			// Need to keep track of whether ContentPane has been shown (which is different than
			// whether or not it's currently visible).
			this._wasShown = true;

			if(this._needLayout){
				// If a layout has been scheduled for when we become visible, do it now
				this._layout(this._changeSize, this._resultSize);
			}

			this.inherited(arguments);
		}
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/layout/utils.js":
/*!********************************************!*\
  !*** ./node_modules/dijit/layout/utils.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.filter array.forEach
	__webpack_require__(/*! dojo/dom-class */ "./node_modules/dojo/dom-class.js"), // domClass.add domClass.remove
	__webpack_require__(/*! dojo/dom-geometry */ "./node_modules/dojo/dom-geometry.js"), // domGeometry.marginBox
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"), // domStyle.getComputedStyle
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js") // lang.mixin, lang.setObject
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(array, domClass, domGeometry, domStyle, lang){

	// module:
	//		dijit/layout/utils

	function capitalize(word){
		return word.substring(0,1).toUpperCase() + word.substring(1);
	}

	function size(widget, dim){
		// size the child
		var newSize = widget.resize ? widget.resize(dim) : domGeometry.setMarginBox(widget.domNode, dim);

		// record child's size
		if(newSize){
			// if the child returned it's new size then use that
			lang.mixin(widget, newSize);
		}else{
			// otherwise, call getMarginBox(), but favor our own numbers when we have them.
			// the browser lies sometimes
			lang.mixin(widget, domGeometry.getMarginBox(widget.domNode));
			lang.mixin(widget, dim);
		}
	}

	var utils = {
		// summary:
		//		Utility functions for doing layout

		marginBox2contentBox: function(/*DomNode*/ node, /*Object*/ mb){
			// summary:
			//		Given the margin-box size of a node, return its content box size.
			//		Functions like domGeometry.contentBox() but is more reliable since it doesn't have
			//		to wait for the browser to compute sizes.
			var cs = domStyle.getComputedStyle(node);
			var me = domGeometry.getMarginExtents(node, cs);
			var pb = domGeometry.getPadBorderExtents(node, cs);
			return {
				l: domStyle.toPixelValue(node, cs.paddingLeft),
				t: domStyle.toPixelValue(node, cs.paddingTop),
				w: mb.w - (me.w + pb.w),
				h: mb.h - (me.h + pb.h)
			};
		},


		layoutChildren: function(/*DomNode*/ container, /*Object*/ dim, /*Widget[]*/ children,
				/*String?*/ changedRegionId, /*Number?*/ changedRegionSize){
			// summary:
			//		Layout a bunch of child dom nodes within a parent dom node
			// container:
			//		parent node
			// dim:
			//		{l, t, w, h} object specifying dimensions of container into which to place children
			// children:
			//		An array of Widgets or at least objects containing:
			//
			//		- domNode: pointer to DOM node to position
			//		- region or layoutAlign: position to place DOM node
			//		- resize(): (optional) method to set size of node
			//		- id: (optional) Id of widgets, referenced from resize object, below.
			//
			//		The widgets in this array should be ordered according to how they should be laid out
			//		(each element will be processed in order, and take up as much remaining space as needed),
			//		with the center widget last.
			// changedRegionId:
			//		If specified, the slider for the region with the specified id has been dragged, and thus
			//		the region's height or width should be adjusted according to changedRegionSize
			// changedRegionSize:
			//		See changedRegionId.

			// copy dim because we are going to modify it
			dim = lang.mixin({}, dim);

			domClass.add(container, "dijitLayoutContainer");

			// Move "client" elements to the end of the array for layout.  a11y dictates that the author
			// needs to be able to put them in the document in tab-order, but this algorithm requires that
			// client be last.    TODO: remove for 2.0, all dijit client code already sends children as last item.
			children = array.filter(children, function(item){ return item.region != "center" && item.layoutAlign != "client"; })
				.concat(array.filter(children, function(item){ return item.region == "center" || item.layoutAlign == "client"; }));

			// set positions/sizes
			array.forEach(children, function(child){
				var elm = child.domNode,
					pos = (child.region || child.layoutAlign);
				if(!pos){
					throw new Error("No region setting for " + child.id)
				}

				// set elem to upper left corner of unused space; may move it later
				var elmStyle = elm.style;
				elmStyle.left = dim.l+"px";
				elmStyle.top = dim.t+"px";
				elmStyle.position = "absolute";

				domClass.add(elm, "dijitAlign" + capitalize(pos));

				// Size adjustments to make to this child widget
				var sizeSetting = {};

				// Check for optional size adjustment due to splitter drag (height adjustment for top/bottom align
				// panes and width adjustment for left/right align panes.
				if(changedRegionId && changedRegionId == child.id){
					sizeSetting[child.region == "top" || child.region == "bottom" ? "h" : "w"] = changedRegionSize;
				}

				if(pos == "leading"){
					pos = child.isLeftToRight() ? "left" : "right";
				}
				if(pos == "trailing"){
					pos = child.isLeftToRight() ? "right" : "left";
				}

				// set size && adjust record of remaining space.
				// note that setting the width of a <div> may affect its height.
				if(pos == "top" || pos == "bottom"){
					sizeSetting.w = dim.w;
					size(child, sizeSetting);
					dim.h -= child.h;
					if(pos == "top"){
						dim.t += child.h;
					}else{
						elmStyle.top = dim.t + dim.h + "px";
					}
				}else if(pos == "left" || pos == "right"){
					sizeSetting.h = dim.h;
					size(child, sizeSetting);
					dim.w -= child.w;
					if(pos == "left"){
						dim.l += child.w;
					}else{
						elmStyle.left = dim.l + dim.w + "px";
					}
				}else if(pos == "client" || pos == "center"){
					size(child, dim);
				}
			});
		}
	};

	lang.setObject("dijit.layout.utils", utils);	// remove for 2.0

	return utils;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/main.js":
/*!************************************!*\
  !*** ./node_modules/dijit/main.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/kernel */ "./node_modules/dojo/_base/kernel.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo){
	// module:
	//		dijit/main

/*=====
return {
	// summary:
	//		The dijit package main module.
	//		Deprecated.   Users should access individual modules (ex: dijit/registry) directly.
};
=====*/

	return dojo.dijit;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/place.js":
/*!*************************************!*\
  !*** ./node_modules/dijit/place.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.forEach array.map array.some
	__webpack_require__(/*! dojo/dom-geometry */ "./node_modules/dojo/dom-geometry.js"), // domGeometry.position
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"), // domStyle.getComputedStyle
	__webpack_require__(/*! dojo/_base/kernel */ "./node_modules/dojo/_base/kernel.js"), // kernel.deprecated
	__webpack_require__(/*! dojo/_base/window */ "./node_modules/dojo/_base/window.js"), // win.body
	__webpack_require__(/*! ./Viewport */ "./node_modules/dijit/Viewport.js"), // getEffectiveBox
	__webpack_require__(/*! ./main */ "./node_modules/dijit/main.js")	// dijit (defining dijit.place to match API doc)
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(array, domGeometry, domStyle, kernel, win, Viewport, dijit){

	// module:
	//		dijit/place


	function _place(/*DomNode*/ node, choices, layoutNode, aroundNodeCoords){
		// summary:
		//		Given a list of spots to put node, put it at the first spot where it fits,
		//		of if it doesn't fit anywhere then the place with the least overflow
		// choices: Array
		//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
		//		Above example says to put the top-left corner of the node at (10,20)
		// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
		//		for things like tooltip, they are displayed differently (and have different dimensions)
		//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
		//		It also passes in the available size for the popup, which is useful for tooltips to
		//		tell them that their width is limited to a certain amount.	 layoutNode() may return a value expressing
		//		how much the popup had to be modified to fit into the available space.	 This is used to determine
		//		what the best placement is.
		// aroundNodeCoords: Object
		//		Size of aroundNode, ex: {w: 200, h: 50}

		// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
		// viewport over document
		var view = Viewport.getEffectiveBox(node.ownerDocument);

		// This won't work if the node is inside a <div style="position: relative">,
		// so reattach it to <body>.	 (Otherwise, the positioning will be wrong
		// and also it might get cutoff.)
		if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
			win.body(node.ownerDocument).appendChild(node);
		}

		var best = null;
		array.some(choices, function(choice){
			var corner = choice.corner;
			var pos = choice.pos;
			var overflow = 0;

			// calculate amount of space available given specified position of node
			var spaceAvailable = {
				w: {
					'L': view.l + view.w - pos.x,
					'R': pos.x - view.l,
					'M': view.w
				}[corner.charAt(1)],
				h: {
					'T': view.t + view.h - pos.y,
					'B': pos.y - view.t,
					'M': view.h
				}[corner.charAt(0)]
			};

			// Clear left/right position settings set earlier so they don't interfere with calculations,
			// specifically when layoutNode() (a.k.a. Tooltip.orient()) measures natural width of Tooltip
			var s = node.style;
			s.left = s.right = "auto";

			// configure node to be displayed in given position relative to button
			// (need to do this in order to get an accurate size for the node, because
			// a tooltip's size changes based on position, due to triangle)
			if(layoutNode){
				var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
				overflow = typeof res == "undefined" ? 0 : res;
			}

			// get node's size
			var style = node.style;
			var oldDisplay = style.display;
			var oldVis = style.visibility;
			if(style.display == "none"){
				style.visibility = "hidden";
				style.display = "";
			}
			var bb = domGeometry.position(node);
			style.display = oldDisplay;
			style.visibility = oldVis;

			// coordinates and size of node with specified corner placed at pos,
			// and clipped by viewport
			var
				startXpos = {
					'L': pos.x,
					'R': pos.x - bb.w,
					'M': Math.max(view.l, Math.min(view.l + view.w, pos.x + (bb.w >> 1)) - bb.w) // M orientation is more flexible
				}[corner.charAt(1)],
				startYpos = {
					'T': pos.y,
					'B': pos.y - bb.h,
					'M': Math.max(view.t, Math.min(view.t + view.h, pos.y + (bb.h >> 1)) - bb.h)
				}[corner.charAt(0)],
				startX = Math.max(view.l, startXpos),
				startY = Math.max(view.t, startYpos),
				endX = Math.min(view.l + view.w, startXpos + bb.w),
				endY = Math.min(view.t + view.h, startYpos + bb.h),
				width = endX - startX,
				height = endY - startY;

			overflow += (bb.w - width) + (bb.h - height);

			if(best == null || overflow < best.overflow){
				best = {
					corner: corner,
					aroundCorner: choice.aroundCorner,
					x: startX,
					y: startY,
					w: width,
					h: height,
					overflow: overflow,
					spaceAvailable: spaceAvailable
				};
			}

			return !overflow;
		});

		// In case the best position is not the last one we checked, need to call
		// layoutNode() again.
		if(best.overflow && layoutNode){
			layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
		}

		// And then position the node.  Do this last, after the layoutNode() above
		// has sized the node, due to browser quirks when the viewport is scrolled
		// (specifically that a Tooltip will shrink to fit as though the window was
		// scrolled to the left).

		var top = best.y,
			side = best.x,
			body = win.body(node.ownerDocument);

		if(/relative|absolute/.test(domStyle.get(body, "position"))){
			// compensate for margin on <body>, see #16148
			top -= domStyle.get(body, "marginTop");
			side -= domStyle.get(body, "marginLeft");
		}

		var s = node.style;
		s.top = top + "px";
		s.left = side + "px";
		s.right = "auto";	// needed for FF or else tooltip goes to far left

		return best;
	}

	var reverse = {
		// Map from corner to kitty-corner
		"TL": "BR",
		"TR": "BL",
		"BL": "TR",
		"BR": "TL"
	};

	var place = {
		// summary:
		//		Code to place a DOMNode relative to another DOMNode.
		//		Load using require(["dijit/place"], function(place){ ... }).

		at: function(node, pos, corners, padding, layoutNode){
			// summary:
			//		Positions node kitty-corner to the rectangle centered at (pos.x, pos.y) with width and height of
			//		padding.x * 2 and padding.y * 2, or zero if padding not specified.  Picks first corner in corners[]
			//		where node is fully visible, or the corner where it's most visible.
			//
			//		Node is assumed to be absolutely or relatively positioned.
			// node: DOMNode
			//		The node to position
			// pos: dijit/place.__Position
			//		Object like {x: 10, y: 20}
			// corners: String[]
			//		Array of Strings representing order to try corners of the node in, like ["TR", "BL"].
			//		Possible values are:
			//
			//		- "BL" - bottom left
			//		- "BR" - bottom right
			//		- "TL" - top left
			//		- "TR" - top right
			// padding: dijit/place.__Position?
			//		Optional param to set padding, to put some buffer around the element you want to position.
			//		Defaults to zero.
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.  This adjusts the popup based on orientation.
			// example:
			//		Try to place node's top right corner at (10,20).
			//		If that makes node go (partially) off screen, then try placing
			//		bottom left corner at (10,20).
			//	|	place(node, {x: 10, y: 20}, ["TR", "BL"])
			var choices = array.map(corners, function(corner){
				var c = {
					corner: corner,
					aroundCorner: reverse[corner],	// so TooltipDialog.orient() gets aroundCorner argument set
					pos: {x: pos.x,y: pos.y}
				};
				if(padding){
					c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
					c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
				}
				return c;
			});

			return _place(node, choices, layoutNode);
		},

		around: function(
			/*DomNode*/		node,
			/*DomNode|dijit/place.__Rectangle*/ anchor,
			/*String[]*/	positions,
			/*Boolean*/		leftToRight,
			/*Function?*/	layoutNode){

			// summary:
			//		Position node adjacent or kitty-corner to anchor
			//		such that it's fully visible in viewport.
			// description:
			//		Place node such that corner of node touches a corner of
			//		aroundNode, and that node is fully visible.
			// anchor:
			//		Either a DOMNode or a rectangle (object with x, y, width, height).
			// positions:
			//		Ordered list of positions to try matching up.
			//
			//		- before: places drop down to the left of the anchor node/widget, or to the right in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- after: places drop down to the right of the anchor node/widget, or to the left in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- before-centered: centers drop down to the left of the anchor node/widget, or to the right
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- after-centered: centers drop down to the right of the anchor node/widget, or to the left
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- above-centered: drop down is centered above anchor node
			//		- above: drop down goes above anchor node, left sides aligned
			//		- above-alt: drop down goes above anchor node, right sides aligned
			//		- below-centered: drop down is centered above anchor node
			//		- below: drop down goes below anchor node
			//		- below-alt: drop down goes below anchor node, right sides aligned
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
			// leftToRight:
			//		True if widget is LTR, false if widget is RTL.   Affects the behavior of "above" and "below"
			//		positions slightly.
			// example:
			//	|	placeAroundNode(node, aroundNode, ['below', 'above-alt']);
			//		This will try to position node such that node's top-left corner is at the same position
			//		as the bottom left corner of the aroundNode (ie, put node below
			//		aroundNode, with left edges aligned).	If that fails it will try to put
			//		the bottom-right corner of node where the top right corner of aroundNode is
			//		(ie, put node above aroundNode, with right edges aligned)
			//

			// If around is a DOMNode (or DOMNode id), convert to coordinates.
			var aroundNodePos;
			if(typeof anchor == "string" || "offsetWidth" in anchor || "ownerSVGElement" in anchor){
				aroundNodePos = domGeometry.position(anchor, true);

				// For above and below dropdowns, subtract width of border so that popup and aroundNode borders
				// overlap, preventing a double-border effect.  Unfortunately, difficult to measure the border
				// width of either anchor or popup because in both cases the border may be on an inner node.
				if(/^(above|below)/.test(positions[0])){
					var anchorBorder = domGeometry.getBorderExtents(anchor),
						anchorChildBorder = anchor.firstChild ? domGeometry.getBorderExtents(anchor.firstChild) : {t:0,l:0,b:0,r:0},
						nodeBorder =  domGeometry.getBorderExtents(node),
						nodeChildBorder = node.firstChild ? domGeometry.getBorderExtents(node.firstChild) : {t:0,l:0,b:0,r:0};
					aroundNodePos.y += Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t + nodeChildBorder.t);
					aroundNodePos.h -=  Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t+ nodeChildBorder.t) +
						Math.min(anchorBorder.b + anchorChildBorder.b, nodeBorder.b + nodeChildBorder.b);
				}
			}else{
				aroundNodePos = anchor;
			}

			// Compute position and size of visible part of anchor (it may be partially hidden by ancestor nodes w/scrollbars)
			if(anchor.parentNode){
				// ignore nodes between position:relative and position:absolute
				var sawPosAbsolute = domStyle.getComputedStyle(anchor).position == "absolute";
				var parent = anchor.parentNode;
				while(parent && parent.nodeType == 1 && parent.nodeName != "BODY"){  //ignoring the body will help performance
					var parentPos = domGeometry.position(parent, true),
						pcs = domStyle.getComputedStyle(parent);
					if(/relative|absolute/.test(pcs.position)){
						sawPosAbsolute = false;
					}
					if(!sawPosAbsolute && /hidden|auto|scroll/.test(pcs.overflow)){
						var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);
						var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);
						aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);
						aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);
						aroundNodePos.h = bottomYCoord - aroundNodePos.y;
						aroundNodePos.w = rightXCoord - aroundNodePos.x;
					}
					if(pcs.position == "absolute"){
						sawPosAbsolute = true;
					}
					parent = parent.parentNode;
				}
			}

			var x = aroundNodePos.x,
				y = aroundNodePos.y,
				width = "w" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width),
				height = "h" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated("place.around: dijit/place.__Rectangle: { x:"+x+", y:"+y+", height:"+aroundNodePos.height+", width:"+width+" } has been deprecated.  Please use { x:"+x+", y:"+y+", h:"+aroundNodePos.height+", w:"+width+" }", "", "2.0"), aroundNodePos.h = aroundNodePos.height);

			// Convert positions arguments into choices argument for _place()
			var choices = [];
			function push(aroundCorner, corner){
				choices.push({
					aroundCorner: aroundCorner,
					corner: corner,
					pos: {
						x: {
							'L': x,
							'R': x + width,
							'M': x + (width >> 1)
						}[aroundCorner.charAt(1)],
						y: {
							'T': y,
							'B': y + height,
							'M': y + (height >> 1)
						}[aroundCorner.charAt(0)]
					}
				})
			}
			array.forEach(positions, function(pos){
				var ltr =  leftToRight;
				switch(pos){
					case "above-centered":
						push("TM", "BM");
						break;
					case "below-centered":
						push("BM", "TM");
						break;
					case "after-centered":
						ltr = !ltr;
						// fall through
					case "before-centered":
						push(ltr ? "ML" : "MR", ltr ? "MR" : "ML");
						break;
					case "after":
						ltr = !ltr;
						// fall through
					case "before":
						push(ltr ? "TL" : "TR", ltr ? "TR" : "TL");
						push(ltr ? "BL" : "BR", ltr ? "BR" : "BL");
						break;
					case "below-alt":
						ltr = !ltr;
						// fall through
					case "below":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "BL" : "BR", ltr ? "TL" : "TR");
						push(ltr ? "BR" : "BL", ltr ? "TR" : "TL");
						break;
					case "above-alt":
						ltr = !ltr;
						// fall through
					case "above":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "TL" : "TR", ltr ? "BL" : "BR");
						push(ltr ? "TR" : "TL", ltr ? "BR" : "BL");
						break;
					default:
						// To assist dijit/_base/place, accept arguments of type {aroundCorner: "BL", corner: "TL"}.
						// Not meant to be used directly.  Remove for 2.0.
						push(pos.aroundCorner, pos.corner);
				}
			});

			var position = _place(node, choices, layoutNode, {w: width, h: height});
			position.aroundNodePos = aroundNodePos;

			return position;
		}
	};

	/*=====
	place.__Position = {
		// x: Integer
		//		horizontal coordinate in pixels, relative to document body
		// y: Integer
		//		vertical coordinate in pixels, relative to document body
	};
	place.__Rectangle = {
		// x: Integer
		//		horizontal offset in pixels, relative to document body
		// y: Integer
		//		vertical offset in pixels, relative to document body
		// w: Integer
		//		width in pixels.   Can also be specified as "width" for backwards-compatibility.
		// h: Integer
		//		height in pixels.   Can also be specified as "height" for backwards-compatibility.
	};
	=====*/

	return dijit.place = place;	// setting dijit.place for back-compat, remove for 2.0
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dijit/registry.js":
/*!****************************************!*\
  !*** ./node_modules/dijit/registry.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"), // array.forEach array.map
	__webpack_require__(/*! dojo/_base/window */ "./node_modules/dojo/_base/window.js"), // win.body
	__webpack_require__(/*! ./main */ "./node_modules/dijit/main.js")	// dijit._scopeName
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(array, win, dijit){

	// module:
	//		dijit/registry

	var _widgetTypeCtr = {}, hash = {};

	var registry =  {
		// summary:
		//		Registry of existing widget on page, plus some utility methods.

		// length: Number
		//		Number of registered widgets
		length: 0,

		add: function(widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from the registry. Does not destroy the widget; simply
			//		removes the reference.
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},

		byId: function(/*String|Widget*/ id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
		},

		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
		},

		toArray: function(){
			// summary:
			//		Convert registry into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	array.map(registry.toArray(), function(w){ return w.domNode; });

			var ar = [];
			for(var id in hash){
				ar.push(hash[id]);
			}
			return ar;	// dijit/_WidgetBase[]
		},

		getUniqueId: function(/*String*/widgetType){
			// summary:
			//		Generates a unique id for a given widgetType

			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
		},

		findWidgets: function(root, skipNode){
			// summary:
			//		Search subtree under root returning widgets found.
			//		Doesn't search for nested widgets (ie, widgets inside other widgets).
			// root: DOMNode
			//		Node to search under.
			// skipNode: DOMNode
			//		If specified, don't search beneath this node (usually containerNode).

			var outAry = [];

			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else if(node !== skipNode){
							getChildrenHelper(node);
						}
					}
				}
			}

			getChildrenHelper(root);
			return outAry;
		},

		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			dijit._curFocus = null;
			dijit._prevFocus = null;
			dijit._activeStack = [];

			// Destroy all the widgets, top down
			array.forEach(registry.findWidgets(win.body()), function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},

		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.nodeType == 1 && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};

	dijit.registry = registry;

	return registry;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo-webpack-plugin/lib/NoModule.js":
/*!**********************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/lib/NoModule.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * (C) Copyright IBM Corp. 2012, 2016 All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
module.exports = undefined;


/***/ }),

/***/ "./node_modules/dojo-webpack-plugin/loaders/dojo/i18n/index.js!./node_modules/dijit/form/nls/validate.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/loaders/dojo/i18n!./node_modules/dijit/form/nls/validate.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/i18n */ "./node_modules/dojo/i18n.js"), __webpack_require__(/*! ./node_modules/dojo-webpack-plugin/loaders/dojo/runner.js */ "./node_modules/dojo-webpack-plugin/loaders/dojo/runner.js")
,__webpack_require__(/*! ./node_modules/dijit/form/nls/es/validate.js?absMid=dijit/form/nls/es/validate */ "./node_modules/dijit/form/nls/es/validate.js")
,__webpack_require__(/*! ./node_modules/dijit/form/nls/fr/validate.js?absMid=dijit/form/nls/fr/validate */ "./node_modules/dijit/form/nls/fr/validate.js")
,__webpack_require__(/*! ./node_modules/dijit/form/nls/validate.js?absMid=dijit/form/nls/validate */ "./node_modules/dijit/form/nls/validate.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(loader, runner) {
   return runner(loader, "dijit/form/nls/validate", __webpack_require__.dj.c(), false);
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/dojo-webpack-plugin/loaders/dojo/runner.js":
/*!*****************************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/loaders/dojo/runner.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * (C) Copyright HCL Technologies Ltd. 2019
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
	return function(ldr, name, req, async) {
		var resolveFn, result, resultSet;
		ldr.load(name,  req, function(data) {
			result = data;
			resultSet = true;
			if (resolveFn) {
				resolveFn(data);
			}
		}, {isBuild:true});
		if (resultSet) {
			return result;
		} else if (!async) {
			throw new Error(name + ' unavailable');
		}
		result = new Promise(function(resolve) {
			resolveFn = resolve;
		});
		result.__DOJO_WEBPACK_DEFINE_PROMISE__ = true;
		return result;
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dijit/form/templates/TextBox.html":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/loaders/dojo/text!./node_modules/dijit/form/templates/TextBox.html ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n"

/***/ }),

/***/ "./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dijit/form/templates/ValidationTextBox.html":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/loaders/dojo/text!./node_modules/dijit/form/templates/ValidationTextBox.html ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n"

/***/ }),

/***/ "./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dijit/templates/Tooltip.html":
/*!********************************************************************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/loaders/dojo/text!./node_modules/dijit/templates/Tooltip.html ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\" data-dojo-attach-event=\"mouseenter:onMouseEnter,mouseleave:onMouseLeave\"\n\t><div class=\"dijitTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" data-dojo-attach-point=\"containerNode\" role='alert'></div\n></div>\n"

/***/ }),

/***/ "./node_modules/dojo/Deferred.js":
/*!***************************************!*\
  !*** ./node_modules/dojo/Deferred.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./has */ "./node_modules/dojo/has.js"),
	__webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! ./errors/CancelError */ "./node_modules/dojo/errors/CancelError.js"),
	__webpack_require__(/*! ./promise/Promise */ "./node_modules/dojo/promise/Promise.js"),
	__webpack_require__(/*! ./promise/instrumentation */ "./node_modules/dojo/promise/instrumentation.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has, lang, CancelError, Promise, instrumentation){
	"use strict";

	// module:
	//		dojo/Deferred

	var PROGRESS = 0,
			RESOLVED = 1,
			REJECTED = 2;
	var FULFILLED_ERROR_MESSAGE = "This deferred has already been fulfilled.";

	var freezeObject = Object.freeze || function(){};

	var signalWaiting = function(waiting, type, result, rejection, deferred){
		if(has("config-deferredInstrumentation")){
			if(type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){
				Deferred.instrumentRejected(result, false, rejection, deferred);
			}
		}

		for(var i = 0; i < waiting.length; i++){
			signalListener(waiting[i], type, result, rejection);
		}
	};

	var signalListener = function(listener, type, result, rejection){
		var func = listener[type];
		var deferred = listener.deferred;
		if(func){
			try{
				var newResult = func(result);
				if(type === PROGRESS){
					if(typeof newResult !== "undefined"){
						signalDeferred(deferred, type, newResult);
					}
				}else{
					if(newResult && typeof newResult.then === "function"){
						listener.cancel = newResult.cancel;
						newResult.then(
								// Only make resolvers if they're actually going to be used
								makeDeferredSignaler(deferred, RESOLVED),
								makeDeferredSignaler(deferred, REJECTED),
								makeDeferredSignaler(deferred, PROGRESS));
						return;
					}
					signalDeferred(deferred, RESOLVED, newResult);
				}
			}catch(error){
				signalDeferred(deferred, REJECTED, error);
			}
		}else{
			signalDeferred(deferred, type, result);
		}

		if(has("config-deferredInstrumentation")){
			if(type === REJECTED && Deferred.instrumentRejected){
				Deferred.instrumentRejected(result, !!func, rejection, deferred.promise);
			}
		}
	};

	var makeDeferredSignaler = function(deferred, type){
		return function(value){
			signalDeferred(deferred, type, value);
		};
	};

	var signalDeferred = function(deferred, type, result){
		if(!deferred.isCanceled()){
			switch(type){
				case PROGRESS:
					deferred.progress(result);
					break;
				case RESOLVED:
					deferred.resolve(result);
					break;
				case REJECTED:
					deferred.reject(result);
					break;
			}
		}
	};

	var Deferred = function(canceler){
		// summary:
		//		Creates a new deferred. This API is preferred over
		//		`dojo/_base/Deferred`.
		// description:
		//		Creates a new deferred, as an abstraction over (primarily)
		//		asynchronous operations. The deferred is the private interface
		//		that should not be returned to calling code. That's what the
		//		`promise` is for. See `dojo/promise/Promise`.
		// canceler: Function?
		//		Will be invoked if the deferred is canceled. The canceler
		//		receives the reason the deferred was canceled as its argument.
		//		The deferred is rejected with its return value, or a new
		//		`dojo/errors/CancelError` instance.

		// promise: dojo/promise/Promise
		//		The public promise object that clients can add callbacks to. 
		var promise = this.promise = new Promise();

		var deferred = this;
		var fulfilled, result, rejection;
		var canceled = false;
		var waiting = [];

		if(has("config-deferredInstrumentation") && Error.captureStackTrace){
			Error.captureStackTrace(deferred, Deferred);
			Error.captureStackTrace(promise, Deferred);
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fulfilled === RESOLVED;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fulfilled === REJECTED;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return !!fulfilled;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		this.progress = function(update, strict){
			// summary:
			//		Emit a progress update on the deferred.
			// description:
			//		Emit a progress update on the deferred. Progress updates
			//		can be used to communicate updates about the asynchronous
			//		operation before it has finished.
			// update: any
			//		The progress update. Passed to progbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently no progress can be emitted.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				signalWaiting(waiting, PROGRESS, update, null, deferred);
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.resolve = function(value, strict){
			// summary:
			//		Resolve the deferred.
			// description:
			//		Resolve the deferred, putting it in a success state.
			// value: any
			//		The result of the deferred. Passed to callbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be resolved.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				// Set fulfilled, store value. After signaling waiting listeners unset
				// waiting.
				signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		var reject = this.reject = function(error, strict){
			// summary:
			//		Reject the deferred.
			// description:
			//		Reject the deferred, putting it in an error state.
			// error: any
			//		The error result of the deferred. Passed to errbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be rejected.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				if(has("config-deferredInstrumentation") && Error.captureStackTrace){
					Error.captureStackTrace(rejection = {}, reject);
				}
				signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.then = promise.then = function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the deferred.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			var listener = [progback, callback, errback];
			// Ensure we cancel the promise we're waiting for, or if callback/errback
			// have returned a promise, cancel that one.
			listener.cancel = promise.cancel;
			listener.deferred = new Deferred(function(reason){
				// Check whether cancel is really available, returned promises are not
				// required to expose `cancel`
				return listener.cancel && listener.cancel(reason);
			});
			if(fulfilled && !waiting){
				signalListener(listener, fulfilled, result, rejection);
			}else{
				waiting.push(listener);
			}
			return listener.deferred.promise;
		};

		this.cancel = promise.cancel = function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			if(!fulfilled){
				// Cancel can be called even after the deferred is fulfilled
				if(canceler){
					var returnedReason = canceler(reason);
					reason = typeof returnedReason === "undefined" ? reason : returnedReason;
				}
				canceled = true;
				if(!fulfilled){
					// Allow canceler to provide its own reason, but fall back to a CancelError
					if(typeof reason === "undefined"){
						reason = new CancelError();
					}
					reject(reason);
					return reason;
				}else if(fulfilled === REJECTED && result === reason){
					return reason;
				}
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}
		};

		freezeObject(promise);
	};

	Deferred.prototype.toString = function(){
		// returns: String
		//		Returns `[object Deferred]`.

		return "[object Deferred]";
	};

	if(instrumentation){
		instrumentation(Deferred);
	}

	return Deferred;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/Evented.js":
/*!**************************************!*\
  !*** ./node_modules/dojo/Evented.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./aspect */ "./node_modules/dojo/aspect.js"), __webpack_require__(/*! ./on */ "./node_modules/dojo/on.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(aspect, on){
	// module:
	//		dojo/Evented

 	"use strict";
 	var after = aspect.after;
	function Evented(){
		// summary:
		//		A class that can be used as a mixin or base class,
		//		to add on() and emit() methods to a class
		//		for listening for events and emitting events:
		// example:
		//		|	define(["dojo/Evented", "dojo/_base/declare", "dojo/Stateful"
		//		|	], function(Evented, declare, Stateful){
		//		|		var EventedStateful = declare([Evented, Stateful], {...});
		//		|		var instance = new EventedStateful();
		//		|		instance.on("open", function(event){
		//		|		... do something with event
		//		|	 });
		//		|
		//		|	instance.emit("open", {name:"some event", ...});
	}
	Evented.prototype = {
		on: function(type, listener){
			return on.parse(this, type, listener, function(target, type){
				return after(target, 'on' + type, listener, true);
			});
		},
		emit: function(type, event){
			var args = [this];
			args.push.apply(args, arguments);
			return on.emit.apply(on, args);
		}
	};
	return Evented;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/Stateful.js":
/*!***************************************!*\
  !*** ./node_modules/dojo/Stateful.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/declare */ "./node_modules/dojo/_base/declare.js"), __webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ./_base/array */ "./node_modules/dojo/_base/array.js"), __webpack_require__(/*! ./when */ "./node_modules/dojo/when.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(declare, lang, array, when){
	// module:
	//		dojo/Stateful

return declare("dojo.Stateful", null, {
	// summary:
	//		Base class for objects that provide named properties with optional getter/setter
	//		control and the ability to watch for property changes
	//
	//		The class also provides the functionality to auto-magically manage getters
	//		and setters for object attributes/properties.
	//		
	//		Getters and Setters should follow the format of _xxxGetter or _xxxSetter where 
	//		the xxx is a name of the attribute to handle.  So an attribute of "foo" 
	//		would have a custom getter of _fooGetter and a custom setter of _fooSetter.
	//
	// example:
	//	|	require(["dojo/Stateful", function(Stateful) {
	//	|		var obj = new Stateful();
	//	|		obj.watch("foo", function(){
	//	|			console.log("foo changed to " + this.get("foo"));
	//	|		});
	//	|		obj.set("foo","bar");
	//	|	});

	// _attrPairNames: Hash
	//		Used across all instances a hash to cache attribute names and their getter 
	//		and setter names.
	_attrPairNames: {},

	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		return (apn[name] = {
			s: "_" + name + "Setter",
			g: "_" + name + "Getter"
		});
	},

	postscript: function(/*Object?*/ params){
		// Automatic setting of params during construction
		if (params){ this.set(params); }
	},

	_get: function(name, names){
		// summary:
		//		Private function that does a get based off a hash of names
		// names:
		//		Hash of names of custom attributes
		return typeof this[names.g] === "function" ? this[names.g]() : this[name];
	},
	get: function(/*String*/name){
		// summary:
		//		Get a property on a Stateful instance.
		// name:
		//		The property to get.
		// returns:
		//		The property value on this Stateful instance.
		// description:
		//		Get a named property on a Stateful object. The property may
		//		potentially be retrieved via a getter method in subclasses. In the base class
		//		this just retrieves the object's property.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful({foo: 3});
		//	|		stateful.get("foo") // returns 3
		//	|		stateful.foo // returns 3
		//	|	});

		return this._get(name, this._getAttrNames(name)); //Any
	},
	set: function(/*String*/name, /*Object*/value){
		// summary:
		//		Set a property on a Stateful instance
		// name:
		//		The property to set.
		// value:
		//		The value to set in the property.
		// returns:
		//		The function returns this dojo.Stateful instance.
		// description:
		//		Sets named properties on a stateful object and notifies any watchers of
		//		the property. A programmatic setter may be defined in subclasses.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful();
		//	|		stateful.watch(function(name, oldValue, value){
		//	|			// this will be called on the set below
		//	|		}
		//	|		stateful.set(foo, 5);
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|		stateful.set({
		//	|			foo: "Howdy",
		//	|			bar: 3
		//	|		});
		//	|	});
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)

		// If an object is used, iterate through object
		if(typeof name === "object"){
			for(var x in name){
				if(name.hasOwnProperty(x) && x !="_watchCallbacks"){
					this.set(x, name[x]);
				}
			}
			return this;
		}

		var names = this._getAttrNames(name),
			oldValue = this._get(name, names),
			setter = this[names.s],
			result;
		if(typeof setter === "function"){
			// use the explicit setter
			result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			// no setter so set attribute directly
			this[name] = value;
		}
		if(this._watchCallbacks){
			var self = this;
			// If setter returned a promise, wait for it to complete, otherwise call watches immediately
			when(result, function(){
				self._watchCallbacks(name, oldValue, value);
			});
		}
		return this; // dojo/Stateful
	},
	_changeAttrValue: function(name, value){
		// summary:
		//		Internal helper for directly changing an attribute value.
		//
		// name: String
		//		The property to set.
		// value: Mixed
		//		The value to set in the property.
		//
		// description:
		//		Directly change the value of an attribute on an object, bypassing any 
		//		accessor setter.  Also handles the calling of watch and emitting events. 
		//		It is designed to be used by descendant class when there are two values 
		//		of attributes that are linked, but calling .set() is not appropriate.

		var oldValue = this.get(name);
		this[name] = value;
		if(this._watchCallbacks){
			this._watchCallbacks(name, oldValue, value);
		}
		return this; // dojo/Stateful
	},
	watch: function(/*String?*/name, /*Function*/callback){
		// summary:
		//		Watches a property for changes
		// name:
		//		Indicates the property to watch. This is optional (the callback may be the
		//		only parameter), and if omitted, all the properties will be watched
		// returns:
		//		An object handle for the watch. The unwatch method of this object
		//		can be used to discontinue watching this property:
		//		|	var watchHandle = obj.watch("foo", callback);
		//		|	watchHandle.unwatch(); // callback won't be called now
		// callback:
		//		The function to execute when the property changes. This will be called after
		//		the property has been changed. The callback will be called with the |this|
		//		set to the instance, the first argument as the name of the property, the
		//		second argument as the old value and the third argument as the new value.

		var callbacks = this._watchCallbacks;
		if(!callbacks){
			var self = this;
			callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
				var notify = function(propertyCallbacks){
					if(propertyCallbacks){
						propertyCallbacks = propertyCallbacks.slice();
						for(var i = 0, l = propertyCallbacks.length; i < l; i++){
							propertyCallbacks[i].call(self, name, oldValue, value);
						}
					}
				};
				notify(callbacks['_' + name]);
				if(!ignoreCatchall){
					notify(callbacks["*"]); // the catch-all
				}
			}; // we use a function instead of an object so it will be ignored by JSON conversion
		}
		if(!callback && typeof name === "function"){
			callback = name;
			name = "*";
		}else{
			// prepend with dash to prevent name conflicts with function (like "name" property)
			name = '_' + name;
		}
		var propertyCallbacks = callbacks[name];
		if(typeof propertyCallbacks !== "object"){
			propertyCallbacks = callbacks[name] = [];
		}
		propertyCallbacks.push(callback);

		// TODO: Remove unwatch in 2.0
		var handle = {};
		handle.unwatch = handle.remove = function(){
			var index = array.indexOf(propertyCallbacks, callback);
			if(index > -1){
				propertyCallbacks.splice(index, 1);
			}
		};
		return handle; //Object
	}

});

}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/Color.js":
/*!******************************************!*\
  !*** ./node_modules/dojo/_base/Color.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ./array */ "./node_modules/dojo/_base/array.js"), __webpack_require__(/*! ./config */ "./node_modules/dojo/_base/config.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, lang, ArrayUtil, config){

	var Color = dojo.Color = function(/*Array|String|Object*/ color){
		// summary:
		//		Takes a named string, hex string, array of rgb or rgba values,
		//		an object with r, g, b, and a properties, or another `Color` object
		//		and creates a new Color instance to work from.
		//
		// example:
		//		Work with a Color instance:
		//	|	require(["dojo/_base/color"], function(Color){
		//	|		var c = new Color();
		//	|		c.setColor([0,0,0]); // black
		//	|		var hex = c.toHex(); // #000000
		//	|	});
		//
		// example:
		//		Work with a node's color:
		//	| 
		//	|	require(["dojo/_base/color", "dojo/dom-style"], function(Color, domStyle){
		//	|		var color = domStyle("someNode", "backgroundColor");
		//	|		var n = new Color(color);
		//	|		// adjust the color some
		//	|		n.r *= .5;
		//	|		console.log(n.toString()); // rgb(128, 255, 255);
		//	|	});
		if(color){ this.setColor(color); }
	};

	// FIXME:
	// there's got to be a more space-efficient way to encode or discover
	// these!! Use hex?
	Color.named = {
		// summary:
		//		Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.
		"black":  [0,0,0],
		"silver": [192,192,192],
		"gray":	  [128,128,128],
		"white":  [255,255,255],
		"maroon": [128,0,0],
		"red":	  [255,0,0],
		"purple": [128,0,128],
		"fuchsia":[255,0,255],
		"green":  [0,128,0],
		"lime":	  [0,255,0],
		"olive":  [128,128,0],
		"yellow": [255,255,0],
		"navy":	  [0,0,128],
		"blue":	  [0,0,255],
		"teal":	  [0,128,128],
		"aqua":	  [0,255,255],
		"transparent": config.transparentColor || [0,0,0,0]
	};

	lang.extend(Color, {
		r: 255, g: 255, b: 255, a: 1,
		_set: function(r, g, b, a){
			var t = this; t.r = r; t.g = g; t.b = b; t.a = a;
		},
		setColor: function(/*Array|String|Object*/ color){
			// summary:
			//		Takes a named string, hex string, array of rgb or rgba values,
			//		an object with r, g, b, and a properties, or another `Color` object
			//		and sets this color instance to that value.
			//
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color(); // no color
			//	|		c.setColor("#ededed"); // greyish
			//	|	});
			if(lang.isString(color)){
				Color.fromString(color, this);
			}else if(lang.isArray(color)){
				Color.fromArray(color, this);
			}else{
				this._set(color.r, color.g, color.b, color.a);
				if(!(color instanceof Color)){ this.sanitize(); }
			}
			return this;	// Color
		},
		sanitize: function(){
			// summary:
			//		Ensures the object has correct attributes
			// description:
			//		the default implementation does nothing, include dojo.colors to
			//		augment it with real checks
			return this;	// Color
		},
		toRgb: function(){
			// summary:
			//		Returns 3 component array of rgb values
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color("#000000");
			//	|		console.log(c.toRgb()); // [0,0,0]
			//	|	});
			var t = this;
			return [t.r, t.g, t.b]; // Array
		},
		toRgba: function(){
			// summary:
			//		Returns a 4 component array of rgba values from the color
			//		represented by this object.
			var t = this;
			return [t.r, t.g, t.b, t.a];	// Array
		},
		toHex: function(){
			// summary:
			//		Returns a CSS color string in hexadecimal representation
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		console.log(new Color([0,0,0]).toHex()); // #000000
			//	|	});
			var arr = ArrayUtil.map(["r", "g", "b"], function(x){
				var s = this[x].toString(16);
				return s.length < 2 ? "0" + s : s;
			}, this);
			return "#" + arr.join("");	// String
		},
		toCss: function(/*Boolean?*/ includeAlpha){
			// summary:
			//		Returns a css color string in rgb(a) representation
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color("#FFF").toCss();
			//	|		console.log(c); // rgb('255','255','255')
			//	|	});
			var t = this, rgb = t.r + ", " + t.g + ", " + t.b;
			return (includeAlpha ? "rgba(" + rgb + ", " + t.a : "rgb(" + rgb) + ")";	// String
		},
		toString: function(){
			// summary:
			//		Returns a visual representation of the color
			return this.toCss(true); // String
		}
	});

	Color.blendColors = dojo.blendColors = function(
		/*Color*/ start,
		/*Color*/ end,
		/*Number*/ weight,
		/*Color?*/ obj
	){
		// summary:
		//		Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
		//		can reuse a previously allocated Color object for the result
		var t = obj || new Color();
		t.r = Math.round(start.r + (end.r - start.r) * weight);
		t.g = Math.round(start.g + (end.g - start.g) * weight);
		t.b = Math.round(start.b + (end.b - start.b) * weight);
		t.a = start.a + (end.a - start.a) * weight;
		return t.sanitize();	// Color
	};

	Color.fromRgb = dojo.colorFromRgb = function(/*String*/ color, /*Color?*/ obj){
		// summary:
		//		Returns a `Color` instance from a string of the form
		//		"rgb(...)" or "rgba(...)". Optionally accepts a `Color`
		//		object to update with the parsed value and return instead of
		//		creating a new object.
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var m = color.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);
		return m && Color.fromArray(m[1].split(/\s*,\s*/), obj);	// Color
	};

	Color.fromHex = dojo.colorFromHex = function(/*String*/ color, /*Color?*/ obj){
		// summary:
		//		Converts a hex string with a '#' prefix to a color object.
		//		Supports 12-bit #rgb shorthand. Optionally accepts a
		//		`Color` object to update with the parsed value.
		//
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		//
		// example:
		//	|	require(["dojo/_base/color"], function(Color){
		//	|		var thing = new Color().fromHex("#ededed"); // grey, longhand
		//	|		var thing2 = new Color().fromHex("#000"); // black, shorthand
		//	|	});
		var t = obj || new Color(),
			bits = (color.length == 4) ? 4 : 8,
			mask = (1 << bits) - 1;
		color = Number("0x" + color.substr(1));
		if(isNaN(color)){
			return null; // Color
		}
		ArrayUtil.forEach(["b", "g", "r"], function(x){
			var c = color & mask;
			color >>= bits;
			t[x] = bits == 4 ? 17 * c : c;
		});
		t.a = 1;
		return t;	// Color
	};

	Color.fromArray = dojo.colorFromArray = function(/*Array*/ a, /*Color?*/ obj){
		// summary:
		//		Builds a `Color` from a 3 or 4 element array, mapping each
		//		element in sequence to the rgb(a) values of the color.
		// example:
		//		|	require(["dojo/_base/color"], function(Color){
		//		|		var myColor = new Color().fromArray([237,237,237,0.5]); // grey, 50% alpha
		//		|	});
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var t = obj || new Color();
		t._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));
		if(isNaN(t.a)){ t.a = 1; }
		return t.sanitize();	// Color
	};

	Color.fromString = dojo.colorFromString = function(/*String*/ str, /*Color?*/ obj){
		// summary:
		//		Parses `str` for a color value. Accepts hex, rgb, and rgba
		//		style color values.
		// description:
		//		Acceptable input values for str may include arrays of any form
		//		accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
		//		rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
		//		10, 50)"
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var a = Color.named[str];
		return a && Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj);	// Color
	};

	return Color;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/Deferred.js":
/*!*********************************************!*\
  !*** ./node_modules/dojo/_base/Deferred.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"),
	__webpack_require__(/*! ../Deferred */ "./node_modules/dojo/Deferred.js"),
	__webpack_require__(/*! ../promise/Promise */ "./node_modules/dojo/promise/Promise.js"),
	__webpack_require__(/*! ../errors/CancelError */ "./node_modules/dojo/errors/CancelError.js"),
	__webpack_require__(/*! ../has */ "./node_modules/dojo/has.js"),
	__webpack_require__(/*! ./lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! ../when */ "./node_modules/dojo/when.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, NewDeferred, Promise, CancelError, has, lang, when){
	// module:
	//		dojo/_base/Deferred

	var mutator = function(){};
	var freeze = Object.freeze || function(){};
	// A deferred provides an API for creating and resolving a promise.
	var Deferred = dojo.Deferred = function(/*Function?*/ canceller){
		// summary:
		//		Deprecated.   This module defines the legacy dojo/_base/Deferred API.
		//		New code should use dojo/Deferred instead.
		// description:
		//		The Deferred API is based on the concept of promises that provide a
		//		generic interface into the eventual completion of an asynchronous action.
		//		The motivation for promises fundamentally is about creating a
		//		separation of concerns that allows one to achieve the same type of
		//		call patterns and logical data flow in asynchronous code as can be
		//		achieved in synchronous code. Promises allows one
		//		to be able to call a function purely with arguments needed for
		//		execution, without conflating the call with concerns of whether it is
		//		sync or async. One shouldn't need to alter a call's arguments if the
		//		implementation switches from sync to async (or vice versa). By having
		//		async functions return promises, the concerns of making the call are
		//		separated from the concerns of asynchronous interaction (which are
		//		handled by the promise).
		//
		//		The Deferred is a type of promise that provides methods for fulfilling the
		//		promise with a successful result or an error. The most important method for
		//		working with Dojo's promises is the then() method, which follows the
		//		CommonJS proposed promise API. An example of using a Dojo promise:
		//
		//		|	var resultingPromise = someAsyncOperation.then(function(result){
		//		|		... handle result ...
		//		|	},
		//		|	function(error){
		//		|		... handle error ...
		//		|	});
		//
		//		The .then() call returns a new promise that represents the result of the
		//		execution of the callback. The callbacks will never affect the original promises value.
		//
		//		The Deferred instances also provide the following functions for backwards compatibility:
		//
		//		- addCallback(handler)
		//		- addErrback(handler)
		//		- callback(result)
		//		- errback(result)
		//
		//		Callbacks are allowed to return promises themselves, so
		//		you can build complicated sequences of events with ease.
		//
		//		The creator of the Deferred may specify a canceller.  The canceller
		//		is a function that will be called if Deferred.cancel is called
		//		before the Deferred fires. You can use this to implement clean
		//		aborting of an XMLHttpRequest, etc. Note that cancel will fire the
		//		deferred with a CancelledError (unless your canceller returns
		//		another kind of error), so the errbacks should be prepared to
		//		handle that error for cancellable Deferreds.
		// example:
		//	|	var deferred = new Deferred();
		//	|	setTimeout(function(){ deferred.callback({success: true}); }, 1000);
		//	|	return deferred;
		// example:
		//		Deferred objects are often used when making code asynchronous. It
		//		may be easiest to write functions in a synchronous manner and then
		//		split code using a deferred to trigger a response to a long-lived
		//		operation. For example, instead of register a callback function to
		//		denote when a rendering operation completes, the function can
		//		simply return a deferred:
		//
		//		|	// callback style:
		//		|	function renderLotsOfData(data, callback){
		//		|		var success = false
		//		|		try{
		//		|			for(var x in data){
		//		|				renderDataitem(data[x]);
		//		|			}
		//		|			success = true;
		//		|		}catch(e){ }
		//		|		if(callback){
		//		|			callback(success);
		//		|		}
		//		|	}
		//
		//		|	// using callback style
		//		|	renderLotsOfData(someDataObj, function(success){
		//		|		// handles success or failure
		//		|		if(!success){
		//		|			promptUserToRecover();
		//		|		}
		//		|	});
		//		|	// NOTE: no way to add another callback here!!
		// example:
		//		Using a Deferred doesn't simplify the sending code any, but it
		//		provides a standard interface for callers and senders alike,
		//		providing both with a simple way to service multiple callbacks for
		//		an operation and freeing both sides from worrying about details
		//		such as "did this get called already?". With Deferreds, new
		//		callbacks can be added at any time.
		//
		//		|	// Deferred style:
		//		|	function renderLotsOfData(data){
		//		|		var d = new Deferred();
		//		|		try{
		//		|			for(var x in data){
		//		|				renderDataitem(data[x]);
		//		|			}
		//		|			d.callback(true);
		//		|		}catch(e){
		//		|			d.errback(new Error("rendering failed"));
		//		|		}
		//		|		return d;
		//		|	}
		//
		//		|	// using Deferred style
		//		|	renderLotsOfData(someDataObj).then(null, function(){
		//		|		promptUserToRecover();
		//		|	});
		//		|	// NOTE: addErrback and addCallback both return the Deferred
		//		|	// again, so we could chain adding callbacks or save the
		//		|	// deferred for later should we need to be notified again.
		// example:
		//		In this example, renderLotsOfData is synchronous and so both
		//		versions are pretty artificial. Putting the data display on a
		//		timeout helps show why Deferreds rock:
		//
		//		|	// Deferred style and async func
		//		|	function renderLotsOfData(data){
		//		|		var d = new Deferred();
		//		|		setTimeout(function(){
		//		|			try{
		//		|				for(var x in data){
		//		|					renderDataitem(data[x]);
		//		|				}
		//		|				d.callback(true);
		//		|			}catch(e){
		//		|				d.errback(new Error("rendering failed"));
		//		|			}
		//		|		}, 100);
		//		|		return d;
		//		|	}
		//
		//		|	// using Deferred style
		//		|	renderLotsOfData(someDataObj).then(null, function(){
		//		|		promptUserToRecover();
		//		|	});
		//
		//		Note that the caller doesn't have to change his code at all to
		//		handle the asynchronous case.

		var result, finished, canceled, fired, isError, head, nextListener;
		var promise = (this.promise = new Promise());

		function complete(value){
			if(finished){
				throw new Error("This deferred has already been resolved");
			}
			result = value;
			finished = true;
			notify();
		}
		function notify(){
			var mutated;
			while(!mutated && nextListener){
				var listener = nextListener;
				nextListener = nextListener.next;
				if((mutated = (listener.progress == mutator))){ // assignment and check
					finished = false;
				}

				var func = (isError ? listener.error : listener.resolved);
				if(has("config-useDeferredInstrumentation")){
					if(isError && NewDeferred.instrumentRejected){
						NewDeferred.instrumentRejected(result, !!func);
					}
				}
				if(func){
					try{
						var newResult = func(result);
						if (newResult && typeof newResult.then === "function"){
							newResult.then(lang.hitch(listener.deferred, "resolve"), lang.hitch(listener.deferred, "reject"), lang.hitch(listener.deferred, "progress"));
							continue;
						}
						var unchanged = mutated && newResult === undefined;
						if(mutated && !unchanged){
							isError = newResult instanceof Error;
						}
						listener.deferred[unchanged && isError ? "reject" : "resolve"](unchanged ? result : newResult);
					}catch(e){
						listener.deferred.reject(e);
					}
				}else{
					if(isError){
						listener.deferred.reject(result);
					}else{
						listener.deferred.resolve(result);
					}
				}
			}
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fired == 0;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fired == 1;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return fired >= 0;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		// calling resolve will resolve the promise
		this.resolve = this.callback = function(value){
			// summary:
			//		Fulfills the Deferred instance successfully with the provide value
			this.fired = fired = 0;
			this.results = [value, null];
			complete(value);
		};


		// calling error will indicate that the promise failed
		this.reject = this.errback = function(error){
			// summary:
			//		Fulfills the Deferred instance as an error with the provided error
			isError = true;
			this.fired = fired = 1;
			if(has("config-useDeferredInstrumentation")){
				if(NewDeferred.instrumentRejected){
					NewDeferred.instrumentRejected(error, !!nextListener);
				}
			}
			complete(error);
			this.results = [null, error];
		};
		// call progress to provide updates on the progress on the completion of the promise
		this.progress = function(update){
			// summary:
			//		Send progress events to all listeners
			var listener = nextListener;
			while(listener){
				var progress = listener.progress;
				progress && progress(update);
				listener = listener.next;
			}
		};
		this.addCallbacks = function(callback, errback){
			// summary:
			//		Adds callback and error callback for this deferred instance.
			// callback: Function?
			//		The callback attached to this deferred object.
			// errback: Function?
			//		The error callback attached to this deferred object.
			// returns:
			//		Returns this deferred object.
			this.then(callback, errback, mutator);
			return this;	// Deferred
		};
		// provide the implementation of the promise
		promise.then = this.then = function(/*Function?*/resolvedCallback, /*Function?*/errorCallback, /*Function?*/progressCallback){
			// summary:
			//		Adds a fulfilledHandler, errorHandler, and progressHandler to be called for
			//		completion of a promise. The fulfilledHandler is called when the promise
			//		is fulfilled. The errorHandler is called when a promise fails. The
			//		progressHandler is called for progress events. All arguments are optional
			//		and non-function values are ignored. The progressHandler is not only an
			//		optional argument, but progress events are purely optional. Promise
			//		providers are not required to ever create progress events.
			//
			//		This function will return a new promise that is fulfilled when the given
			//		fulfilledHandler or errorHandler callback is finished. This allows promise
			//		operations to be chained together. The value returned from the callback
			//		handler is the fulfillment value for the returned promise. If the callback
			//		throws an error, the returned promise will be moved to failed state.
			//
			// returns:
			//		Returns a new promise that represents the result of the
			//		execution of the callback. The callbacks will never affect the original promises value.
			// example:
			//		An example of using a CommonJS compliant promise:
			//		|	asyncComputeTheAnswerToEverything().
			//		|		then(addTwo).
			//		|		then(printResult, onError);
			//		|	>44
			//
			var returnDeferred = progressCallback == mutator ? this : new Deferred(promise.cancel);
			var listener = {
				resolved: resolvedCallback,
				error: errorCallback,
				progress: progressCallback,
				deferred: returnDeferred
			};
			if(nextListener){
				head = head.next = listener;
			}
			else{
				nextListener = head = listener;
			}
			if(finished){
				notify();
			}
			return returnDeferred.promise; // Promise
		};
		var deferred = this;
		promise.cancel = this.cancel = function(){
			// summary:
			//		Cancels the asynchronous operation
			if(!finished){
				var error = canceller && canceller(deferred);
				if(!finished){
					if (!(error instanceof Error)){
						error = new CancelError(error);
					}
					error.log = false;
					deferred.reject(error);
				}
			}
			canceled = true;
		};
		freeze(promise);
	};
	lang.extend(Deferred, {
		addCallback: function(/*Function*/ callback){
			// summary:
			//		Adds successful callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			return this.addCallbacks(lang.hitch.apply(dojo, arguments));	// Deferred
		},

		addErrback: function(/*Function*/ errback){
			// summary:
			//		Adds error callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			return this.addCallbacks(null, lang.hitch.apply(dojo, arguments));	// Deferred
		},

		addBoth: function(/*Function*/ callback){
			// summary:
			//		Add handler as both successful callback and error callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			var enclosed = lang.hitch.apply(dojo, arguments);
			return this.addCallbacks(enclosed, enclosed);	// Deferred
		},
		fired: -1
	});

	Deferred.when = dojo.when = when;

	return Deferred;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/array.js":
/*!******************************************!*\
  !*** ./node_modules/dojo/_base/array.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ../has */ "./node_modules/dojo/has.js"), __webpack_require__(/*! ./lang */ "./node_modules/dojo/_base/lang.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has, lang){
	// module:
	//		dojo/_base/array

	// our old simple function builder stuff
	var cache = {}, u;

	function buildFn(fn){
		return cache[fn] = new Function("item", "index", "array", fn); // Function
	}
	// magic snippet: if(typeof fn == "string") fn = cache[fn] || buildFn(fn);

	// every & some

	function everyOrSome(some){
		var every = !some;
		return function(a, fn, o){
			var i = 0, l = a && a.length || 0, result;
			if(l && typeof a == "string") a = a.split("");
			if(typeof fn == "string") fn = cache[fn] || buildFn(fn);
			if(o){
				for(; i < l; ++i){
					result = !fn.call(o, a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}else{
				for(; i < l; ++i){
					result = !fn(a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}
			return every; // Boolean
		};
	}

	// indexOf, lastIndexOf

	function index(up){
		var delta = 1, lOver = 0, uOver = 0;
		if(!up){
			delta = lOver = uOver = -1;
		}
		return function(a, x, from, last){
			if(last && delta > 0){
				// TODO: why do we use a non-standard signature? why do we need "last"?
				return array.lastIndexOf(a, x, from);
			}
			var l = a && a.length || 0, end = up ? l + uOver : lOver, i;
			if(from === u){
				i = up ? lOver : l + uOver;
			}else{
				if(from < 0){
					i = l + from;
					if(i < 0){
						i = lOver;
					}
				}else{
					i = from >= l ? l + uOver : from;
				}
			}
			if(l && typeof a == "string") a = a.split("");
			for(; i != end; i += delta){
				if(a[i] == x){
					return i; // Number
				}
			}
			return -1; // Number
		};
	}

	var array = {
		// summary:
		//		The Javascript v1.6 array extensions.

		every: everyOrSome(false),
		/*=====
		 every: function(arr, callback, thisObject){
			 // summary:
			 //		Determines whether or not every item in arr satisfies the
			 //		condition implemented by callback.
			 // arr: Array|String
			 //		the array to iterate on. If a string, operates on individual characters.
			 // callback: Function|String
			 //		a function is invoked with three arguments: item, index,
			 //		and array and returns true if the condition is met.
			 // thisObject: Object?
			 //		may be used to scope the call to callback
			 // returns: Boolean
			 // description:
			 //		This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
			 //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			 //		the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
			 //		For more details, see:
			 //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
			 // example:
			 //	|	// returns false
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>1; });
			 // example:
			 //	|	// returns true
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>0; });
		 },
		 =====*/

		some: everyOrSome(true),
		/*=====
		some: function(arr, callback, thisObject){
			// summary:
			//		Determines whether or not any item in arr satisfies the
			//		condition implemented by callback.
			// arr: Array|String
			//		the array to iterate over. If a string, operates on individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments: item, index,
			//		and array and returns true if the condition is met.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Boolean
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
			// example:
			//	| // is true
			//	| array.some([1, 2, 3, 4], function(item){ return item>1; });
			// example:
			//	| // is false
			//	| array.some([1, 2, 3, 4], function(item){ return item<1; });
		},
		=====*/

		indexOf: index(true),
		/*=====
		indexOf: function(arr, value, fromIndex, findLast){
			// summary:
			//		locates the first index of the provided value in the
			//		passed array. If the value is not found, -1 is returned.
			// description:
			//		This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
			//
			//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
			//		   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
			//		2. uses equality (==) rather than strict equality (===)
			//
			//		For details on this method, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
			// arr: Array
			// value: Object
			// fromIndex: Integer?
			// findLast: Boolean?
			//		Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
			// returns: Number
		},
		=====*/

		lastIndexOf: index(false),
		/*=====
		lastIndexOf: function(arr, value, fromIndex){
			// summary:
			//		locates the last index of the provided value in the passed
			//		array. If the value is not found, -1 is returned.
			// description:
		 	//		This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
		 	//
		 	//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
		 	//		   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
		 	//		2. uses equality (==) rather than strict equality (===)
		 	//
		 	//		For details on this method, see:
		 	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
			// arr: Array,
			// value: Object,
			// fromIndex: Integer?
			// returns: Number
		},
		=====*/

		forEach: function(arr, callback, thisObject){
			// summary:
			//		for every item in arr, callback is invoked. Return values are ignored.
			//		If you want to break out of the loop, consider using array.every() or array.some().
			//		forEach does not allow breaking out of the loop over the items in arr.
			// arr:
			//		the array to iterate over. If a string, operates on individual characters.
			// callback:
			//		a function is invoked with three arguments: item, index, and array
			// thisObject:
			//		may be used to scope the call to callback
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
			// example:
			//	| // log out all members of the array:
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item){
			//	|			console.log(item);
			//	|		}
			//	| );
			// example:
			//	| // log out the members and their indexes
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item, idx, arr){
			//	|			console.log(item, "at index:", idx);
			//	|		}
			//	| );
			// example:
			//	| // use a scoped object member as the callback
			//	|
			//	| var obj = {
			//	|		prefix: "logged via obj.callback:",
			//	|		callback: function(item){
			//	|			console.log(this.prefix, item);
			//	|		}
			//	| };
			//	|
			//	| // specifying the scope function executes the callback in that scope
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		obj.callback,
			//	|		obj
			//	| );
			//	|
			//	| // alternately, we can accomplish the same thing with lang.hitch()
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		lang.hitch(obj, "callback")
			//	| );
			// arr: Array|String
			// callback: Function|String
			// thisObject: Object?

			var i = 0, l = arr && arr.length || 0;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					callback(arr[i], i, arr);
				}
			}
		},

		map: function(arr, callback, thisObject, Ctr){
			// summary:
			//		applies callback to each element of arr and returns
			//		an Array with the results
			// arr: Array|String
			//		the array to iterate on. If a string, operates on
			//		individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments, (item, index,
			//		array),	 and returns a value
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
			// example:
			//	| // returns [2, 3, 4, 5]
			//	| array.map([1, 2, 3, 4], function(item){ return item+1 });

			// TODO: why do we have a non-standard signature here? do we need "Ctr"?
			var i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					out[i] = callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					out[i] = callback(arr[i], i, arr);
				}
			}
			return out; // Array
		},

		filter: function(arr, callback, thisObject){
			// summary:
			//		Returns a new Array with those items from arr that match the
			//		condition implemented by callback.
			// arr: Array
			//		the array to iterate over.
			// callback: Function|String
			//		a function that is invoked with three arguments (item,
			//		index, array). The return of this function is expected to
			//		be a boolean which determines whether the passed-in item
			//		will be included in the returned array.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
			// example:
			//	| // returns [2, 3, 4]
			//	| array.filter([1, 2, 3, 4], function(item){ return item>1; });

			// TODO: do we need "Ctr" here like in map()?
			var i = 0, l = arr && arr.length || 0, out = [], value;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					value = arr[i];
					if(callback.call(thisObject, value, i, arr)){
						out.push(value);
					}
				}
			}else{
				for(; i < l; ++i){
					value = arr[i];
					if(callback(value, i, arr)){
						out.push(value);
					}
				}
			}
			return out; // Array
		},

		clearCache: function(){
			cache = {};
		}
	};


	has("extend-dojo") && lang.mixin(dojo, array);

	return array;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/config.js":
/*!*******************************************!*\
  !*** ./node_modules/dojo/_base/config.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../global */ "./node_modules/dojo/global.js"), __webpack_require__(/*! ../has */ "./node_modules/dojo/has.js"), __webpack_require__.dj.c(module.i)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(global, has, require){
	// module:
	//		dojo/_base/config

/*=====
return {
	// summary:
	//		This module defines the user configuration during bootstrap.
	// description:
	//		By defining user configuration as a module value, an entire configuration can be specified in a build,
	//		thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
	//		Also, when multiple instances of dojo exist in a single application, each will necessarily be located
	//		at an unique absolute module identifier as given by the package configuration. Implementing configuration
	//		as a module allows for specifying unique, per-instance configurations.
	// example:
	//		Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
	//		dojo.js are already loaded).
	//		|	// specify a configuration that creates a new instance of dojo at the absolute module identifier "myDojo"
	//		|	require({
	//		|		packages:[{
	//		|			name:"myDojo",
	//		|			location:".", //assume baseUrl points to dojo.js
	//		|		}]
	//		|	});
	//		|
	//		|	// specify a configuration for the myDojo instance
	//		|	define("myDojo/config", {
	//		|		// normal configuration variables go here, e.g.,
	//		|		locale:"fr-ca"
	//		|	});
	//		|
	//		|	// load and use the new instance of dojo
	//		|	require(["myDojo"], function(dojo){
	//		|		// dojo is the new instance of dojo
	//		|		// use as required
	//		|	});

	// isDebug: Boolean
	//		Defaults to `false`. If set to `true`, ensures that Dojo provides
	//		extended debugging feedback to the console.
	isDebug: false,

	// locale: String
	//		The locale to assume for loading localized resources in this page,
	//		specified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		Must be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.
	//		See the documentation for `dojo.i18n` and `dojo.requireLocalization`
	//		for details on loading localized resources. If no locale is specified,
	//		Dojo assumes the locale of the user agent, according to `navigator.userLanguage`
	//		or `navigator.language` properties.
	locale: undefined,

	// extraLocale: Array
	//		No default value. Specifies additional locales whose
	//		resources should also be loaded alongside the default locale when
	//		calls to `dojo.requireLocalization()` are processed.
	extraLocale: undefined,

	// baseUrl: String
	//		The directory in which `dojo.js` is located. Under normal
	//		conditions, Dojo auto-detects the correct location from which it
	//		was loaded. You may need to manually configure `baseUrl` in cases
	//		where you have renamed `dojo.js` or in which `<base>` tags confuse
	//		some browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned
	//		either the value of `djConfig.baseUrl` if one is provided or the
	//		auto-detected root if not. Other modules are located relative to
	//		this path. The path should end in a slash.
	baseUrl: undefined,

	// modulePaths: [deprecated] Object
	//		A map of module names to paths relative to `dojo.baseUrl`. The
	//		key/value pairs correspond directly to the arguments which
	//		`dojo.registerModulePath` accepts. Specifying
	//		`djConfig.modulePaths = { "foo": "../../bar" }` is the equivalent
	//		of calling `dojo.registerModulePath("foo", "../../bar");`. Multiple
	//		modules may be configured via `djConfig.modulePaths`.
	modulePaths: {},

	// addOnLoad: Function|Array
	//		Adds a callback via dojo/ready. Useful when Dojo is added after
	//		the page loads and djConfig.afterOnLoad is true. Supports the same
	//		arguments as dojo/ready. When using a function reference, use
	//		`djConfig.addOnLoad = function(){};`. For object with function name use
	//		`djConfig.addOnLoad = [myObject, "functionName"];` and for object with
	//		function reference use
	//		`djConfig.addOnLoad = [myObject, function(){}];`
	addOnLoad: null,

	// parseOnLoad: Boolean
	//		Run the parser after the page is loaded
	parseOnLoad: false,

	// require: String[]
	//		An array of module names to be loaded immediately after dojo.js has been included
	//		in a page.
	require: [],

	// defaultDuration: Number
	//		Default duration, in milliseconds, for wipe and fade animations within dijits.
	//		Assigned to dijit.defaultDuration.
	defaultDuration: 200,

	// dojoBlankHtmlUrl: String
	//		Used by some modules to configure an empty iframe. Used by dojo/io/iframe and
	//		dojo/back, and dijit/popup support in IE where an iframe is needed to make sure native
	//		controls do not bleed through the popups. Normally this configuration variable
	//		does not need to be set, except when using cross-domain/CDN Dojo builds.
	//		Save dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`
	//		to the path on your domain your copy of blank.html.
	dojoBlankHtmlUrl: undefined,

	// ioPublish: Boolean?
	//		Set this to true to enable publishing of topics for the different phases of
	//		IO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list
	//		of topics that are published.
	ioPublish: false,

	// transparentColor: Array
	//		Array containing the r, g, b components used as transparent color in dojo.Color;
	//		if undefined, [255,255,255] (white) will be used.
	transparentColor: undefined,
	
	// deps: Function|Array
	//		Defines dependencies to be used before the loader has been loaded.
	//		When provided, they cause the loader to execute require(deps, callback) 
	//		once it has finished loading. Should be used with callback.
	deps: undefined,
	
	// callback: Function|Array
	//		Defines a callback to be used when dependencies are defined before 
	//		the loader has been loaded. When provided, they cause the loader to 
	//		execute require(deps, callback) once it has finished loading. 
	//		Should be used with deps.
	callback: undefined,
	
	// deferredInstrumentation: Boolean
	//		Whether deferred instrumentation should be loaded or included
	//		in builds.
	deferredInstrumentation: true,

	// useDeferredInstrumentation: Boolean|String
	//		Whether the deferred instrumentation should be used.
	//
	//		* `"report-rejections"`: report each rejection as it occurs.
	//		* `true` or `1` or `"report-unhandled-rejections"`: wait 1 second
	//			in an attempt to detect unhandled rejections.
	useDeferredInstrumentation: "report-unhandled-rejections"
};
=====*/

	var result = {};
	if(has("dojo-config-api")){
		// must be the dojo loader; take a shallow copy of require.rawConfig
		var src = require.rawConfig, p;
		for(p in src){
			result[p] = src[p];
		}
	}else{
		var adviseHas = function(featureSet, prefix, booting){
			for(p in featureSet){
				p!="has" && has.add(prefix + p, featureSet[p], 0, booting);
			}
		};
		result = has("dojo-loader") ?
			// must be a built version of the dojo loader; all config stuffed in require.rawConfig
			require.rawConfig :
			// a foreign loader
			global.dojoConfig || global.djConfig || {};
		adviseHas(result, "config", 1);
		adviseHas(result.has, "", 1);
	}

	if(!result.locale && typeof navigator != "undefined"){
		// Default locale for browsers (ensure it's read from user-settings not download locale).
		var language = (navigator.languages && navigator.languages.length) ? navigator.languages[0] :
			(navigator.language || navigator.userLanguage);
		if(language){
			result.locale = language.toLowerCase();
		}
	}

	return result;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));



/***/ }),

/***/ "./node_modules/dojo/_base/connect.js":
/*!********************************************!*\
  !*** ./node_modules/dojo/_base/connect.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ../on */ "./node_modules/dojo/on.js"), __webpack_require__(/*! ../topic */ "./node_modules/dojo/topic.js"), __webpack_require__(/*! ../aspect */ "./node_modules/dojo/aspect.js"), __webpack_require__(/*! ./event */ "./node_modules/dojo/_base/event.js"), __webpack_require__(/*! ../mouse */ "./node_modules/dojo/mouse.js"), __webpack_require__(/*! ./sniff */ "./node_modules/dojo/_base/sniff.js"), __webpack_require__(/*! ./lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ../keys */ "./node_modules/dojo/keys.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, on, hub, aspect, eventModule, mouse, has, lang){
// module:
//		dojo/_base/connect

has.add("events-keypress-typed", function(){ // keypresses should only occur a printable character is hit
	var testKeyEvent = {charCode: 0};
	try{
		testKeyEvent = document.createEvent("KeyboardEvent");
		(testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, "keypress", true, true, null, false, false, false, false, 9, 3);
	}catch(e){}
	return testKeyEvent.charCode == 0 && !has("opera");
});

function connect_(obj, event, context, method, dontFix){
	method = lang.hitch(context, method);
	if(!obj || !(obj.addEventListener || obj.attachEvent)){
		// it is a not a DOM node and we are using the dojo.connect style of treating a
		// method like an event, must go right to aspect
		return aspect.after(obj || dojo.global, event, method, true);
	}
	if(typeof event == "string" && event.substring(0, 2) == "on"){
		event = event.substring(2);
	}
	if(!obj){
		obj = dojo.global;
	}
	if(!dontFix){
		switch(event){
			// dojo.connect has special handling for these event types
			case "keypress":
				event = keypress;
				break;
			case "mouseenter":
				event = mouse.enter;
				break;
			case "mouseleave":
				event = mouse.leave;
				break;
		}
	}
	return on(obj, event, method, dontFix);
}

var _punctMap = {
	106:42,
	111:47,
	186:59,
	187:43,
	188:44,
	189:45,
	190:46,
	191:47,
	192:96,
	219:91,
	220:92,
	221:93,
	222:39,
	229:113
};
var evtCopyKey = has("mac") ? "metaKey" : "ctrlKey";


var _synthesizeEvent = function(evt, props){
	var faux = lang.mixin({}, evt, props);
	setKeyChar(faux);
	// FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);
	// but it throws an error when preventDefault is invoked on Safari
	// does Event.preventDefault not support "apply" on Safari?
	faux.preventDefault = function(){ evt.preventDefault(); };
	faux.stopPropagation = function(){ evt.stopPropagation(); };
	return faux;
};
function setKeyChar(evt){
	evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
	evt.charOrCode = evt.keyChar || evt.keyCode;
}
var keypress;
if(has("events-keypress-typed")){
	// this emulates Firefox's keypress behavior where every keydown can correspond to a keypress
	var _trySetKeyCode = function(e, code){
		try{
			// squelch errors when keyCode is read-only
			// (e.g. if keyCode is ctrl or shift)
			return (e.keyCode = code);
		}catch(e){
			return 0;
		}
	};
	keypress = function(object, listener){
		var keydownSignal = on(object, "keydown", function(evt){
			// munge key/charCode
			var k=evt.keyCode;
			// These are Windows Virtual Key Codes
			// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp
			var unprintable = (k!=13) && k!=32 && (k!=27||!has("ie")) && (k<48||k>90) && (k<96||k>111) && (k<186||k>192) && (k<219||k>222) && k!=229;
			// synthesize keypress for most unprintables and CTRL-keys
			if(unprintable||evt.ctrlKey){
				var c = unprintable ? 0 : k;
				if(evt.ctrlKey){
					if(k==3 || k==13){
						return listener.call(evt.currentTarget, evt); // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively
					}else if(c>95 && c<106){
						c -= 48; // map CTRL-[numpad 0-9] to ASCII
					}else if((!evt.shiftKey)&&(c>=65&&c<=90)){
						c += 32; // map CTRL-[A-Z] to lowercase
					}else{
						c = _punctMap[c] || c; // map other problematic CTRL combinations to ASCII
					}
				}
				// simulate a keypress event
				var faux = _synthesizeEvent(evt, {type: 'keypress', faux: true, charCode: c});
				listener.call(evt.currentTarget, faux);
				if(has("ie")){
					_trySetKeyCode(evt, faux.keyCode);
				}
			}
		});
		var keypressSignal = on(object, "keypress", function(evt){
			var c = evt.charCode;
			c = c>=32 ? c : 0;
			evt = _synthesizeEvent(evt, {charCode: c, faux: true});
			return listener.call(this, evt);
		});
		return {
			remove: function(){
				keydownSignal.remove();
				keypressSignal.remove();
			}
		};
	};
}else{
	if(has("opera")){
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				var c = evt.which;
				if(c==3){
					c=99; // Mozilla maps CTRL-BREAK to CTRL-c
				}
				// can't trap some keys at all, like INSERT and DELETE
				// there is no differentiating info between DELETE and ".", or INSERT and "-"
				c = c<32 && !evt.shiftKey ? 0 : c;
				if(evt.ctrlKey && !evt.shiftKey && c>=65 && c<=90){
					// lowercase CTRL-[A-Z] keys
					c += 32;
				}
				return listener.call(this, _synthesizeEvent(evt, { charCode: c }));
			});
		};
	}else{
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				setKeyChar(evt);
				return listener.call(this, evt);
			});
		};
	}
}

var connect = {
	// summary:
	//		This module defines the dojo.connect API.
	//		This modules also provides keyboard event handling helpers.
	//		This module exports an extension event for emulating Firefox's keypress handling.
	//		However, this extension event exists primarily for backwards compatibility and
	//		is not recommended. WebKit and IE uses an alternate keypress handling (only
	//		firing for printable characters, to distinguish from keydown events), and most
	//		consider the WebKit/IE behavior more desirable.

	_keypress:keypress,

	connect:function(obj, event, context, method, dontFix){
		// summary:
		//		`dojo.connect` is a deprecated event handling and delegation method in
		//		Dojo. It allows one function to "listen in" on the execution of
		//		any other, triggering the second whenever the first is called. Many
		//		listeners may be attached to a function, and source functions may
		//		be either regular function calls or DOM events.
		//
		// description:
		//		Connects listeners to actions, so that after event fires, a
		//		listener is called with the same arguments passed to the original
		//		function.
		//
		//		Since `dojo.connect` allows the source of events to be either a
		//		"regular" JavaScript function or a DOM event, it provides a uniform
		//		interface for listening to all the types of events that an
		//		application is likely to deal with though a single, unified
		//		interface. DOM programmers may want to think of it as
		//		"addEventListener for everything and anything".
		//
		//		When setting up a connection, the `event` parameter must be a
		//		string that is the name of the method/event to be listened for. If
		//		`obj` is null, `kernel.global` is assumed, meaning that connections
		//		to global methods are supported but also that you may inadvertently
		//		connect to a global by passing an incorrect object name or invalid
		//		reference.
		//
		//		`dojo.connect` generally is forgiving. If you pass the name of a
		//		function or method that does not yet exist on `obj`, connect will
		//		not fail, but will instead set up a stub method. Similarly, null
		//		arguments may simply be omitted such that fewer than 4 arguments
		//		may be required to set up a connection See the examples for details.
		//
		//		The return value is a handle that is needed to
		//		remove this connection with `dojo.disconnect`.
		//
		// obj: Object?
		//		The source object for the event function.
		//		Defaults to `kernel.global` if null.
		//		If obj is a DOM node, the connection is delegated
		//		to the DOM event manager (unless dontFix is true).
		//
		// event: String
		//		String name of the event function in obj.
		//		I.e. identifies a property `obj[event]`.
		//
		// context: Object|null
		//		The object that method will receive as "this".
		//
		//		If context is null and method is a function, then method
		//		inherits the context of event.
		//
		//		If method is a string then context must be the source
		//		object object for method (context[method]). If context is null,
		//		kernel.global is used.
		//
		// method: String|Function
		//		A function reference, or name of a function in context.
		//		The function identified by method fires after event does.
		//		method receives the same arguments as the event.
		//		See context argument comments for information on method's scope.
		//
		// dontFix: Boolean?
		//		If obj is a DOM node, set dontFix to true to prevent delegation
		//		of this connection to the DOM event manager.
		//
		// example:
		//		When obj.onchange(), do ui.update():
		//	|	dojo.connect(obj, "onchange", ui, "update");
		//	|	dojo.connect(obj, "onchange", ui, ui.update); // same
		//
		// example:
		//		Using return value for disconnect:
		//	|	var link = dojo.connect(obj, "onchange", ui, "update");
		//	|	...
		//	|	dojo.disconnect(link);
		//
		// example:
		//		When onglobalevent executes, watcher.handler is invoked:
		//	|	dojo.connect(null, "onglobalevent", watcher, "handler");
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked:
		//	|	dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
		//	|	dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(ob, "onCustomEvent", null, customEventHandler);
		//	|	dojo.connect(ob, "onCustomEvent", customEventHandler); // same
		//
		// example:
		//		When globalEvent executes, globalHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(null, "globalEvent", null, globalHandler);
		//	|	dojo.connect("globalEvent", globalHandler); // same

		// normalize arguments
		var a=arguments, args=[], i=0;
		// if a[0] is a String, obj was omitted
		args.push(typeof a[0] == "string" ? null : a[i++], a[i++]);
		// if the arg-after-next is a String or Function, context was NOT omitted
		var a1 = a[i+1];
		args.push(typeof a1 == "string" || typeof a1 == "function" ? a[i++] : null, a[i++]);
		// absorb any additional arguments
		for(var l=a.length; i<l; i++){	args.push(a[i]); }
		return connect_.apply(this, args);
	},

	disconnect:function(handle){
		// summary:
		//		Remove a link created by dojo.connect.
		// description:
		//		Removes the connection between event and the method referenced by handle.
		// handle: Handle
		//		the return value of the dojo.connect call that created the connection.

		if(handle){
			handle.remove();
		}
	},

	subscribe:function(topic, context, method){
		// summary:
		//		Attach a listener to a named topic. The listener function is invoked whenever the
		//		named topic is published (see: dojo.publish).
		//		Returns a handle which is needed to unsubscribe this listener.
		// topic: String
		//		The topic to which to subscribe.
		// context: Object?
		//		Scope in which method will be invoked, or null for default scope.
		// method: String|Function
		//		The name of a function in context, or a function reference. This is the function that
		//		is invoked when topic is published.
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); });
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.subscribe(topic, lang.hitch(context, method));
	},

	publish:function(topic, args){
		// summary:
		//		Invoke all listener method subscribed to topic.
		// topic: String
		//		The name of the topic to publish.
		// args: Array?
		//		An array of arguments. The arguments will be applied
		//		to each topic subscriber (as first class parameters, via apply).
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.publish.apply(hub, [topic].concat(args));
	},

	connectPublisher:function(topic, obj, event){
		// summary:
		//		Ensure that every time obj.event() is called, a message is published
		//		on the topic. Returns a handle which can be passed to
		//		dojo.disconnect() to disable subsequent automatic publication on
		//		the topic.
		// topic: String
		//		The name of the topic to publish.
		// obj: Object?
		//		The source object for the event function. Defaults to kernel.global
		//		if null.
		// event: String
		//		The name of the event function in obj.
		//		I.e. identifies a property obj[event].
		// example:
		//	|	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");
		var pf = function(){ connect.publish(topic, arguments); };
		return event ? connect.connect(obj, event, pf) : connect.connect(obj, pf); //Handle
	},

	isCopyKey: function(e){
		// summary:
		//		Checks an event for the copy key (meta on Mac, and ctrl anywhere else)
		// e: Event
		//		Event object to examine
		return e[evtCopyKey];	// Boolean
	}
};

connect.unsubscribe = connect.disconnect;
/*=====
 connect.unsubscribe = function(handle){
	 // summary:
	 //		Remove a topic listener.
	 // handle: Handle
	 //		The handle returned from a call to subscribe.
	 // example:
	 //	|	var alerter = dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
	 //	|	...
	 //	|	dojo.unsubscribe(alerter);
 };
 =====*/

has("extend-dojo") && lang.mixin(dojo, connect);
return connect;

}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));




/***/ }),

/***/ "./node_modules/dojo/_base/declare.js":
/*!********************************************!*\
  !*** ./node_modules/dojo/_base/declare.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ../has */ "./node_modules/dojo/has.js"), __webpack_require__(/*! ./lang */ "./node_modules/dojo/_base/lang.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has, lang){
	// module:
	//		dojo/_base/declare

	var mix = lang.mixin, op = Object.prototype, opts = op.toString,
		xtor, counter = 0, cname = "constructor";

	if(!has("csp-restrictions")){
		// 'new Function()' is preferable when available since it does not create a closure
		xtor = new Function;
	}else{
		xtor = function(){};
	}

	function err(msg, cls){ throw new Error("declare" + (cls ? " " + cls : "") + ": " + msg); }

	// C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)
	function c3mro(bases, className){
		var result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,
			l = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;

		// build a list of bases naming them if needed
		for(; i < l; ++i){
			base = bases[i];
			if(!base){
				err("mixin #" + i + " is unknown. Did you use dojo.require to pull it in?", className);
			}else if(opts.call(base) != "[object Function]"){
				err("mixin #" + i + " is not a callable constructor.", className);
			}
			lin = base._meta ? base._meta.bases : [base];
			top = 0;
			// add bases to the name map
			for(j = lin.length - 1; j >= 0; --j){
				proto = lin[j].prototype;
				if(!proto.hasOwnProperty("declaredClass")){
					proto.declaredClass = "uniqName_" + (counter++);
				}
				name = proto.declaredClass;
				if(!nameMap.hasOwnProperty(name)){
					nameMap[name] = {count: 0, refs: [], cls: lin[j]};
					++clsCount;
				}
				rec = nameMap[name];
				if(top && top !== rec){
					rec.refs.push(top);
					++top.count;
				}
				top = rec;
			}
			++top.count;
			roots[0].refs.push(top);
		}

		// remove classes without external references recursively
		while(roots.length){
			top = roots.pop();
			result.push(top.cls);
			--clsCount;
			// optimization: follow a single-linked chain
			while(refs = top.refs, refs.length == 1){
				top = refs[0];
				if(!top || --top.count){
					// branch or end of chain => do not end to roots
					top = 0;
					break;
				}
				result.push(top.cls);
				--clsCount;
			}
			if(top){
				// branch
				for(i = 0, l = refs.length; i < l; ++i){
					top = refs[i];
					if(!--top.count){
						roots.push(top);
					}
				}
			}
		}
		if(clsCount){
			err("can't build consistent linearization", className);
		}

		// calculate the superclass offset
		base = bases[0];
		result[0] = base ?
			base._meta && base === result[result.length - base._meta.bases.length] ?
				base._meta.bases.length : 1 : 0;

		return result;
	}

	function inherited(args, a, f, g){
		var name, chains, bases, caller, meta, base, proto, opf, pos,
			cache = this._inherited = this._inherited || {};

		// crack arguments
		if(typeof args === "string"){
			name = args;
			args = a;
			a = f;
			f = g;
		}

		if(typeof args === "function"){
			// support strict mode
			caller = args;
			args = a;
			a = f;
		}else{
			try{
				caller = args.callee;
			}catch (e){
				if(e instanceof TypeError){
					// caller was defined in a strict-mode context
					err("strict mode inherited() requires the caller function to be passed before arguments", this.declaredClass);
				}else{
					throw e;
				}
			}
		}

		name = name || caller.nom;
		if(!name){
			err("can't deduce a name to call inherited()", this.declaredClass);
		}
		f = g = 0;

		meta = this.constructor._meta;
		bases = meta.bases;

		pos = cache.p;
		if(name != cname){
			// method
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				base = bases[0];
				meta = base._meta;
				if(meta.hidden[name] !== caller){
					// error detection
					chains = meta.chains;
					if(chains && typeof chains[name] == "string"){
						err("calling chained method with inherited: " + name, this.declaredClass);
					}
					// find caller
					do{
						meta = base._meta;
						proto = base.prototype;
						if(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
					pos = base ? pos : -1;
				}
			}
			// find next
			base = bases[++pos];
			if(base){
				proto = base.prototype;
				if(base._meta && proto.hasOwnProperty(name)){
					f = proto[name];
				}else{
					opf = op[name];
					do{
						proto = base.prototype;
						f = proto[name];
						if(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
				}
			}
			f = base && f || op[name];
		}else{
			// constructor
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				meta = bases[0]._meta;
				if(meta && meta.ctor !== caller){
					// error detection
					chains = meta.chains;
					if(!chains || chains.constructor !== "manual"){
						err("calling chained constructor with inherited", this.declaredClass);
					}
					// find caller
					while(base = bases[++pos]){ // intentional assignment
						meta = base._meta;
						if(meta && meta.ctor === caller){
							break;
						}
					}
					pos = base ? pos : -1;
				}
			}
			// find next
			while(base = bases[++pos]){	// intentional assignment
				meta = base._meta;
				f = meta ? meta.ctor : base;
				if(f){
					break;
				}
			}
			f = base && f;
		}

		// cache the found super method
		cache.c = f;
		cache.p = pos;

		// now we have the result
		if(f){
			return a === true ? f : f.apply(this, a || args);
		}
		// intentionally no return if a super method was not found
	}

	function getInherited(name, args, a){
		if(typeof name === "string"){
			if (typeof args === "function") {
				return this.__inherited(name, args, a, true);
			}
			return this.__inherited(name, args, true);
		}
		else if (typeof name === "function") {
			return this.__inherited(name, args, true);
		}
		return this.__inherited(name, true);
	}

	function inherited__debug(args, a1, a2, a3){
		var f = this.getInherited(args, a1, a2);
		if(f){
			return f.apply(this, a3 || a2 || a1 || args);
		}
		// intentionally no return if a super method was not found
	}

	var inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;

	// emulation of "instanceof"
	function isInstanceOf(cls){
		var bases = this.constructor._meta.bases;
		for(var i = 0, l = bases.length; i < l; ++i){
			if(bases[i] === cls){
				return true;
			}
		}
		return this instanceof cls;
	}

	function mixOwn(target, source){
		// add props adding metadata for incoming functions skipping a constructor
		for(var name in source){
			if(name != cname && source.hasOwnProperty(name)){
				target[name] = source[name];
			}
		}
		if(has("bug-for-in-skips-shadowed")){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				if(name != cname && source.hasOwnProperty(name)){
					  target[name] = source[name];
				}
			}
		}
	}

	// implementation of safe mixin function
	function safeMixin(target, source){
		// summary:
		//		Mix in properties skipping a constructor and decorating functions
		//		like it is done by declare().
		// target: Object
		//		Target object to accept new properties.
		// source: Object
		//		Source object for new properties.
		// description:
		//		This function is used to mix in properties like lang.mixin does,
		//		but it skips a constructor property and decorates functions like
		//		declare() does.
		//
		//		It is meant to be used with classes and objects produced with
		//		declare. Functions mixed in with dojo.safeMixin can use
		//		this.inherited() like normal methods.
		//
		//		This function is used to implement extend() method of a constructor
		//		produced with declare().
		//
		// example:
		//	|	var A = declare(null, {
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m1");
		//	|		}
		//	|	});
		//	|	B.extend({
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	dojo.safeMixin(x, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m1");
		//	|		},
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m2");
		//	|		}
		//	|	});
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m1
		//	|	// B.m1
		//	|	// X.m1

		var name, t;
		// add props adding metadata for incoming functions skipping a constructor
		for(name in source){
			t = source[name];
			if((t !== op[name] || !(name in op)) && name != cname){
				if(opts.call(t) == "[object Function]"){
					// non-trivial function method => attach its name
					t.nom = name;
				}
				target[name] = t;
			}
		}
		if(has("bug-for-in-skips-shadowed") && source){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				t = source[name];
				if((t !== op[name] || !(name in op)) && name != cname){
					if(opts.call(t) == "[object Function]"){
						// non-trivial function method => attach its name
						  t.nom = name;
					}
					target[name] = t;
				}
			}
		}
		return target;
	}

	function extend(source){
		declare.safeMixin(this.prototype, source);
		return this;
	}

	function createSubclass(mixins, props){
		// crack parameters
		if(!(mixins instanceof Array || typeof mixins === 'function')){
			props = mixins;
			mixins = undefined;
		}

		props = props || {};
		mixins = mixins || [];

		return declare([this].concat(mixins), props);
	}

	// chained constructor compatible with the legacy declare()
	function chainedConstructor(bases, ctorSpecial){
		return function(){
			var a = arguments, args = a, a0 = a[0], f, i, m,
				l = bases.length, preArgs;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial && (a0 && a0.preamble || this.preamble)){
				// full blown ritual
				preArgs = new Array(bases.length);
				// prepare parameters
				preArgs[0] = a;
				for(i = 0;;){
					// process the preamble of the 1st argument
					a0 = a[0];
					if(a0){
						f = a0.preamble;
						if(f){
							a = f.apply(this, a) || a;
						}
					}
					// process the preamble of this class
					f = bases[i].prototype;
					f = f.hasOwnProperty("preamble") && f.preamble;
					if(f){
						a = f.apply(this, a) || a;
					}
					// one peculiarity of the preamble:
					// it is called if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
					if(++i == l){
						break;
					}
					preArgs[i] = a;
				}
			}
			// 2) call all non-trivial constructors using prepared arguments
			for(i = l - 1; i >= 0; --i){
				f = bases[i];
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, preArgs ? preArgs[i] : a);
				}
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, args);
			}
		};
	}


	// chained constructor compatible with the legacy declare()
	function singleConstructor(ctor, ctorSpecial){
		return function(){
			var a = arguments, t = a, a0 = a[0], f;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial){
				// full blown ritual
				if(a0){
					// process the preamble of the 1st argument
					f = a0.preamble;
					if(f){
						t = f.apply(this, t) || t;
					}
				}
				f = this.preamble;
				if(f){
					// process the preamble of this class
					f.apply(this, t);
					// one peculiarity of the preamble:
					// it is called even if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
				}
			}
			// 2) call a constructor
			if(ctor){
				ctor.apply(this, a);
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	// plain vanilla constructor (can use inherited() to call its base constructor)
	function simpleConstructor(bases){
		return function(){
			var a = arguments, i = 0, f, m;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) do not call the preamble
			// 2) call the top constructor (it can use this.inherited())
			for(; f = bases[i]; ++i){ // intentional assignment
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, a);
					break;
				}
			}
			// 3) call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	function chain(name, bases, reversed){
		return function(){
			var b, m, f, i = 0, step = 1;
			if(reversed){
				i = bases.length - 1;
				step = -1;
			}
			for(; b = bases[i]; i += step){ // intentional assignment
				m = b._meta;
				f = (m ? m.hidden : b.prototype)[name];
				if(f){
					f.apply(this, arguments);
				}
			}
		};
	}

	// forceNew(ctor)
	// return a new object that inherits from ctor.prototype but
	// without actually running ctor on the object.
	function forceNew(ctor){
		// create object with correct prototype using a do-nothing
		// constructor
		xtor.prototype = ctor.prototype;
		var t = new xtor;
		xtor.prototype = null;	// clean up
		return t;
	}

	// applyNew(args)
	// just like 'new ctor()' except that the constructor and its arguments come
	// from args, which must be an array or an arguments object
	function applyNew(args){
		// create an object with ctor's prototype but without
		// calling ctor on it.
		var ctor = args.callee, t = forceNew(ctor);
		// execute the real constructor on the new object
		ctor.apply(t, args);
		return t;
	}

	function declare(className, superclass, props){
		// summary:
		//		Create a feature-rich constructor from compact notation.
		// className: String?
		//		The optional name of the constructor (loosely, a "class")
		//		stored in the "declaredClass" property in the created prototype.
		//		It will be used as a global name for a created constructor.
		// superclass: Function|Function[]
		//		May be null, a Function, or an Array of Functions. This argument
		//		specifies a list of bases (the left-most one is the most deepest
		//		base).
		// props: Object
		//		An object whose properties are copied to the created prototype.
		//		Add an instance-initialization function by making it a property
		//		named "constructor".
		// returns: dojo/_base/declare.__DeclareCreatedObject
		//		New constructor function.
		// description:
		//		Create a constructor using a compact notation for inheritance and
		//		prototype extension.
		//
		//		Mixin ancestors provide a type of multiple inheritance.
		//		Prototypes of mixin ancestors are copied to the new class:
		//		changes to mixin prototypes will not affect classes to which
		//		they have been mixed in.
		//
		//		Ancestors can be compound classes created by this version of
		//		declare(). In complex cases all base classes are going to be
		//		linearized according to C3 MRO algorithm
		//		(see http://www.python.org/download/releases/2.3/mro/ for more
		//		details).
		//
		//		"className" is cached in "declaredClass" property of the new class,
		//		if it was supplied. The immediate super class will be cached in
		//		"superclass" property of the new class.
		//
		//		Methods in "props" will be copied and modified: "nom" property
		//		(the declared name of the method) will be added to all copied
		//		functions to help identify them for the internal machinery. Be
		//		very careful, while reusing methods: if you use the same
		//		function under different names, it can produce errors in some
		//		cases.
		//
		//		It is possible to use constructors created "manually" (without
		//		declare()) as bases. They will be called as usual during the
		//		creation of an instance, their methods will be chained, and even
		//		called by "this.inherited()".
		//
		//		Special property "-chains-" governs how to chain methods. It is
		//		a dictionary, which uses method names as keys, and hint strings
		//		as values. If a hint string is "after", this method will be
		//		called after methods of its base classes. If a hint string is
		//		"before", this method will be called before methods of its base
		//		classes.
		//
		//		If "constructor" is not mentioned in "-chains-" property, it will
		//		be chained using the legacy mode: using "after" chaining,
		//		calling preamble() method before each constructor, if available,
		//		and calling postscript() after all constructors were executed.
		//		If the hint is "after", it is chained as a regular method, but
		//		postscript() will be called after the chain of constructors.
		//		"constructor" cannot be chained "before", but it allows
		//		a special hint string: "manual", which means that constructors
		//		are not going to be chained in any way, and programmer will call
		//		them manually using this.inherited(). In the latter case
		//		postscript() will be called after the construction.
		//
		//		All chaining hints are "inherited" from base classes and
		//		potentially can be overridden. Be very careful when overriding
		//		hints! Make sure that all chained methods can work in a proposed
		//		manner of chaining.
		//
		//		Once a method was chained, it is impossible to unchain it. The
		//		only exception is "constructor". You don't need to define a
		//		method in order to supply a chaining hint.
		//
		//		If a method is chained, it cannot use this.inherited() because
		//		all other methods in the hierarchy will be called automatically.
		//
		//		Usually constructors and initializers of any kind are chained
		//		using "after" and destructors of any kind are chained as
		//		"before". Note that chaining assumes that chained methods do not
		//		return any value: any returned value will be discarded.
		//
		// example:
		//	|	declare("my.classes.bar", my.classes.foo, {
		//	|		// properties to be added to the class prototype
		//	|		someValue: 2,
		//	|		// initialization function
		//	|		constructor: function(){
		//	|			this.myComplicatedObject = new ReallyComplicatedObject();
		//	|		},
		//	|		// other functions
		//	|		someMethod: function(){
		//	|			doStuff();
		//	|		}
		//	|	});
		//
		// example:
		//	|	var MyBase = declare(null, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass1 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass2 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyDiamond = declare([MyClass1, MyClass2], {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//
		// example:
		//	|	var F = function(){ console.log("raw constructor"); };
		//	|	F.prototype.method = function(){
		//	|		console.log("raw method");
		//	|	};
		//	|	var A = declare(F, {
		//	|		constructor: function(){
		//	|			console.log("A.constructor");
		//	|		},
		//	|		method: function(){
		//	|			console.log("before calling F.method...");
		//	|			this.inherited(arguments);
		//	|			console.log("...back in A");
		//	|		}
		//	|	});
		//	|	new A().method();
		//	|	// will print:
		//	|	// raw constructor
		//	|	// A.constructor
		//	|	// before calling F.method...
		//	|	// raw method
		//	|	// ...back in A
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			destroy: "before"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			console.log("B.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("B.destroy");
		//	|		}
		//	|	});
		//	|	var C = declare(B, {
		//	|		constructor: function(){
		//	|			console.log("C.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("C.destroy");
		//	|		}
		//	|	});
		//	|	new C().destroy();
		//	|	// prints:
		//	|	// B.constructor
		//	|	// C.constructor
		//	|	// C.destroy
		//	|	// B.destroy
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			constructor: "manual"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			// ...
		//	|			// call the base constructor with new parameters
		//	|			this.inherited(arguments, [1, 2, 3]);
		//	|			// ...
		//	|		}
		//	|	});
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			m1: "before"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		"-chains-": {
		//	|			m2: "after"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("B.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	x.m1();
		//	|	// prints:
		//	|	// B.m1
		//	|	// A.m1
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m2
		//	|	// B.m2

		// crack parameters
		if(typeof className != "string"){
			props = superclass;
			superclass = className;
			className = "";
		}
		props = props || {};

		var proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;

		// build a prototype
		if(opts.call(superclass) == "[object Array]"){
			// C3 MRO
			bases = c3mro(superclass, className);
			t = bases[0];
			mixins = bases.length - t;
			superclass = bases[mixins];
		}else{
			bases = [0];
			if(superclass){
				if(opts.call(superclass) == "[object Function]"){
					t = superclass._meta;
					bases = bases.concat(t ? t.bases : superclass);
				}else{
					err("base class is not a callable constructor.", className);
				}
			}else if(superclass !== null){
				err("unknown base class. Did you use dojo.require to pull it in?", className);
			}
		}
		if(superclass){
			for(i = mixins - 1;; --i){
				proto = forceNew(superclass);
				if(!i){
					// stop if nothing to add (the last base)
					break;
				}
				// mix in properties
				t = bases[i];
				(t._meta ? mixOwn : mix)(proto, t.prototype);
				// chain in new constructor
				if (has("csp-restrictions")) {
					ctor = function () {};
				}
				else {
					ctor = new Function;
				}
				ctor.superclass = superclass;
				ctor.prototype = proto;
				superclass = proto.constructor = ctor;
			}
		}else{
			proto = {};
		}
		// add all properties
		declare.safeMixin(proto, props);
		// add constructor
		t = props.constructor;
		if(t !== op.constructor){
			t.nom = cname;
			proto.constructor = t;
		}

		// collect chains and flags
		for(i = mixins - 1; i; --i){ // intentional assignment
			t = bases[i]._meta;
			if(t && t.chains){
				chains = mix(chains || {}, t.chains);
			}
		}
		if(proto["-chains-"]){
			chains = mix(chains || {}, proto["-chains-"]);
		}

		if(superclass && superclass.prototype && superclass.prototype["-chains-"]) {
			chains = mix(chains || {}, superclass.prototype["-chains-"]);
		}

		// build ctor
		t = !chains || !chains.hasOwnProperty(cname);
		bases[0] = ctor = (chains && chains.constructor === "manual") ? simpleConstructor(bases) :
			(bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));

		// add meta information to the constructor
		ctor._meta  = {bases: bases, hidden: props, chains: chains,
			parents: parents, ctor: props.constructor};
		ctor.superclass = superclass && superclass.prototype;
		ctor.extend = extend;
		ctor.createSubclass = createSubclass;
		ctor.prototype = proto;
		proto.constructor = ctor;

		// add "standard" methods to the prototype
		proto.getInherited = getInherited;
		proto.isInstanceOf = isInstanceOf;
		proto.inherited    = inheritedImpl;
		proto.__inherited  = inherited;

		// add name if specified
		if(className){
			proto.declaredClass = className;
			lang.setObject(className, ctor);
		}

		// build chains and add them to the prototype
		if(chains){
			for(name in chains){
				if(proto[name] && typeof chains[name] == "string" && name != cname){
					t = proto[name] = chain(name, bases, chains[name] === "after");
					t.nom = name;
				}
			}
		}
		// chained methods do not return values
		// no need to chain "invisible" functions

		return ctor;	// Function
	}

	/*=====
	declare.__DeclareCreatedObject = {
		// summary:
		//		dojo/_base/declare() returns a constructor `C`.   `new C()` returns an Object with the following
		//		methods, in addition to the methods and properties specified via the arguments passed to declare().

		inherited: function(name, caller, args, newArgs){
			// summary:
			//		Calls a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// caller: Function?
			//		The reference to the calling function. Required only if the
			//		call to "this.inherited" occurs from within strict-mode code.
			//		If the caller is omitted within strict-mode code, an error will
			//		be thrown.
			//		The best way to obtain a reference to the calling function is to
			//		use a named function expression (i.e. place a function name
			//		after the "function" keyword and before the open paren, as in
			//		"function fn(a, b)"). If the function is parsed as an expression
			//		and not a statement (i.e. it's not by itself on its own line),
			//		the function name will only be accessible as an identifier from
			//		within the body of the function.
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// newArgs: Object?
			//		If "true", the found function will be returned without
			//		executing it.
			//		If Array, it will be used to call a super method. Otherwise
			//		"args" will be used.
			// returns:
			//		Whatever is returned by a super method, or a super method itself,
			//		if "true" was specified as newArgs.
			// description:
			//		This method is used inside method of classes produced with
			//		declare() to call a super method (next in the chain). It is
			//		used for manually controlled chaining. Consider using the regular
			//		chaining, because it is faster. Use "this.inherited()" only in
			//		complex cases.
			//
			//		This method cannot me called from automatically chained
			//		constructors including the case of a special (legacy)
			//		constructor chaining. It cannot be called from chained methods.
			//
			//		If "this.inherited()" cannot find the next-in-chain method, it
			//		does nothing and returns "undefined". The last method in chain
			//		can be a default method implemented in Object, which will be
			//		called last.
			//
			//		If "name" is specified, it is assumed that the method that
			//		received "args" is the parent method for this call. It is looked
			//		up in the chain list and if it is found the next-in-chain method
			//		is called. If it is not found, the first-in-chain method is
			//		called.
			//
			//		If "name" is not specified, it will be derived from the calling
			//		method (using a methoid property "nom").
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method1: function(a, b, c){
			//	|			this.inherited(arguments);
			//	|		},
			//	|		method2: function(a, b){
			//	|			return this.inherited(arguments, [a + b]);
			//	|		}
			//	|	});
			//	|	// next method is not in the chain list because it is added
			//	|	// manually after the class was created.
			//	|	B.prototype.method3 = function(){
			//	|		console.log("This is a dynamically-added method.");
			//	|		this.inherited("method3", arguments);
			//	|	};
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.inherited(arguments, true);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			// example:
			//	|	"use strict";
			//	|	// class is defined in strict-mode code,
			//	|	// so caller must be passed before arguments.
			//	|	var B = declare(A, {
			//	|		// using a named function expression with "fn" as the name.
			//	|		method: function fn(a, b) {
			//	|			this.inherited(fn, arguments);
			//	|		}
			//	|	});
			return	{};	// Object
		},

		getInherited: function(name, caller, args){
			// summary:
			//		Returns a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// caller: Function?
			//		The caller function. This is required when running in
			//		strict-mode code. A reference to the caller function
			//		can be obtained by using a named function expression
			//		(e.g. function fn(a,b) {...}).
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// returns:
			//		Returns a super method (Function) or "undefined".
			// description:
			//		This method is a convenience method for "this.inherited()".
			//		It uses the same algorithm but instead of executing a super
			//		method, it returns it, or "undefined" if not found.
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.getInherited(arguments);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			// example:
			//	|	"use strict;" // first line of function or file
			//	|	//...
			//	|	var B = declare(A, {
			//	|		// Using a named function expression with "fn" as the name,
			//	|		// since we're in strict mode.
			//	|		method: function fn(a, b){
			//	|			var super = this.getInherited(fn, arguments);
			//	|			if(super){
			//	|				return super.apply(this, arguments);
			//	|			}
			//	|		}
			//	|	});
			return	{};	// Object
		},

		isInstanceOf: function(cls){
			// summary:
			//		Checks the inheritance chain to see if it is inherited from this
			//		class.
			// cls: Function
			//		Class constructor.
			// returns:
			//		"true", if this object is inherited from this class, "false"
			//		otherwise.
			// description:
			//		This method is used with instances of classes produced with
			//		declare() to determine of they support a certain interface or
			//		not. It models "instanceof" operator.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var B = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var C = declare([A, B], {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var D = declare(A, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|
			//	|	var a = new A(), b = new B(), c = new C(), d = new D();
			//	|
			//	|	console.log(a.isInstanceOf(A)); // true
			//	|	console.log(b.isInstanceOf(A)); // false
			//	|	console.log(c.isInstanceOf(A)); // true
			//	|	console.log(d.isInstanceOf(A)); // true
			//	|
			//	|	console.log(a.isInstanceOf(B)); // false
			//	|	console.log(b.isInstanceOf(B)); // true
			//	|	console.log(c.isInstanceOf(B)); // true
			//	|	console.log(d.isInstanceOf(B)); // false
			//	|
			//	|	console.log(a.isInstanceOf(C)); // false
			//	|	console.log(b.isInstanceOf(C)); // false
			//	|	console.log(c.isInstanceOf(C)); // true
			//	|	console.log(d.isInstanceOf(C)); // false
			//	|
			//	|	console.log(a.isInstanceOf(D)); // false
			//	|	console.log(b.isInstanceOf(D)); // false
			//	|	console.log(c.isInstanceOf(D)); // false
			//	|	console.log(d.isInstanceOf(D)); // true
			return	{};	// Object
		},

		extend: function(source){
			// summary:
			//		Adds all properties and methods of source to constructor's
			//		prototype, making them available to all instances created with
			//		constructor. This method is specific to constructors created with
			//		declare().
			// source: Object
			//		Source object which properties are going to be copied to the
			//		constructor's prototype.
			// description:
			//		Adds source properties to the constructor's prototype. It can
			//		override existing properties.
			//
			//		This method is similar to dojo.extend function, but it is specific
			//		to constructors produced by declare(). It is implemented
			//		using dojo.safeMixin, and it skips a constructor property,
			//		and properly decorates copied functions.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "Popokatepetl"
			//	|	});
			//	|	A.extend({
			//	|		m1: function(){},
			//	|		m2: function(){},
			//	|		f1: true,
			//	|		d1: 42
			//	|	});
		},

		createSubclass: function(mixins, props){
			// summary:
			//		Create a subclass of the declared class from a list of base classes.
			// mixins: Function[]
			//		Specifies a list of bases (the left-most one is the most deepest
			//		base).
			// props: Object?
			//		An optional object whose properties are copied to the created prototype.
			// returns: dojo/_base/declare.__DeclareCreatedObject
			//		New constructor function.
			// description:
			//		Create a constructor using a compact notation for inheritance and
			//		prototype extension.
			//
			//		Mixin ancestors provide a type of multiple inheritance.
			//		Prototypes of mixin ancestors are copied to the new class:
			//		changes to mixin prototypes will not affect classes to which
			//		they have been mixed in.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "bar"
			//	|	});
			//	|	var B = declare(null, {
			//	|		m2: function(){},
			//	|		s2: "foo"
			//	|	});
			//	|	var C = declare(null, {
			//	|	});
			//	|	var D1 = A.createSubclass([B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d1 = new D1();
			//	|
			//	|	// this is equivalent to:
			//	|	var D2 = declare([A, B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d2 = new D2();
		}
	};
	=====*/

	// For back-compat, remove for 2.0
	dojo.safeMixin = declare.safeMixin = safeMixin;
	dojo.declare = declare;

	return declare;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/event.js":
/*!******************************************!*\
  !*** ./node_modules/dojo/_base/event.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ../on */ "./node_modules/dojo/on.js"), __webpack_require__(/*! ../has */ "./node_modules/dojo/has.js"), __webpack_require__(/*! ../dom-geometry */ "./node_modules/dojo/dom-geometry.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, on, has, dom){
	// module:
	//		dojo/_base/event

	if(on._fixEvent){
		var fixEvent = on._fixEvent;
		on._fixEvent = function(evt, se){
			// add some additional normalization for back-compat, this isn't in on.js because it is somewhat more expensive
			evt = fixEvent(evt, se);
			if(evt){
				dom.normalizeEvent(evt);
			}
			return evt;
		};		
	}
	
	var ret = {
		// summary:
		//		This module defines dojo DOM event API.   Usually you should use dojo/on, and evt.stopPropagation() +
		//		evt.preventDefault(), rather than this module.

		fix: function(/*Event*/ evt, /*DOMNode*/ sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt: Event
			//		native event object
			// sender: DOMNode
			//		node to treat as "currentTarget"
			if(on._fixEvent){
				return on._fixEvent(evt, sender);
			}
			return evt;	// Event
		},
	
		stop: function(/*Event*/ evt){
			// summary:
			//		prevents propagation and clobbers the default action of the
			//		passed event
			// evt: Event
			//		The event object. If omitted, window.event is used on IE.
			if(has("dom-addeventlistener") || (evt && evt.preventDefault)){
				evt.preventDefault();
				evt.stopPropagation();
			}else{
				evt = evt || window.event;
				evt.cancelBubble = true;
				on._preventDefault.call(evt);
			}
		}
	};

	if(has("extend-dojo")){
		dojo.fixEvent = ret.fix;
		dojo.stopEvent = ret.stop;
	}

	return ret;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/fx.js":
/*!***************************************!*\
  !*** ./node_modules/dojo/_base/fx.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./config */ "./node_modules/dojo/_base/config.js"), /*===== "./declare", =====*/ __webpack_require__(/*! ./lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ../Evented */ "./node_modules/dojo/Evented.js"), __webpack_require__(/*! ./Color */ "./node_modules/dojo/_base/Color.js"), __webpack_require__(/*! ../aspect */ "./node_modules/dojo/aspect.js"), __webpack_require__(/*! ../sniff */ "./node_modules/dojo/sniff.js"), __webpack_require__(/*! ../dom */ "./node_modules/dojo/dom.js"), __webpack_require__(/*! ../dom-style */ "./node_modules/dojo/dom-style.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, config, /*===== declare, =====*/ lang, Evented, Color, aspect, has, dom, style){
	// module:
	//		dojo/_base/fx
	// notes:
	//		Animation loosely package based on Dan Pupius' work, contributed under CLA; see
	//		http://pupius.co.uk/js/Toolkit.Drawing.js

	var _mixin = lang.mixin;

	// Module export
	var basefx = {
		// summary:
		//		This module defines the base dojo/_base/fx implementation.
	};

	var _Line = basefx._Line = function(/*int*/ start, /*int*/ end){
		// summary:
		//		Object used to generate values from a start value to an end value
		// start: int
		//		Beginning value for range
		// end: int
		//		Ending value for range
		this.start = start;
		this.end = end;
	};

	_Line.prototype.getValue = function(/*float*/ n){
		// summary:
		//		Returns the point on the line
		// n:
		//		a floating point number greater than 0 and less than 1
		return ((this.end - this.start) * n) + this.start; // Decimal
	};

	var Animation = basefx.Animation = function(args){
		// summary:
		//		A generic animation class that fires callbacks into its handlers
		//		object at various states.
		// description:
		//		A generic animation class that fires callbacks into its handlers
		//		object at various states. Nearly all dojo animation functions
		//		return an instance of this method, usually without calling the
		//		.play() method beforehand. Therefore, you will likely need to
		//		call .play() on instances of `Animation` when one is
		//		returned.
		// args: Object
		//		The 'magic argument', mixing all the properties into this
		//		animation instance.

		_mixin(this, args);
		if(lang.isArray(this.curve)){
			this.curve = new _Line(this.curve[0], this.curve[1]);
		}

	};
	Animation.prototype = new Evented();

	lang.extend(Animation, {
		// duration: Integer
		//		The time in milliseconds the animation will take to run
		duration: 350,

	/*=====
		// curve: _Line|Array
		//		A two element array of start and end values, or a `_Line` instance to be
		//		used in the Animation.
		curve: null,

		// easing: Function?
		//		A Function to adjust the acceleration (or deceleration) of the progress
		//		across a _Line
		easing: null,
	=====*/

		// repeat: Integer?
		//		The number of times to loop the animation
		repeat: 0,

		// rate: Integer?
		//		the time in milliseconds to wait before advancing to next frame
		//		(used as a fps timer: 1000/rate = fps)
		rate: 20 /* 50 fps */,

	/*=====
		// delay: Integer?
		//		The time in milliseconds to wait before starting animation after it
		//		has been .play()'ed
		delay: null,

		// beforeBegin: Event?
		//		Synthetic event fired before a Animation begins playing (synchronous)
		beforeBegin: null,

		// onBegin: Event?
		//		Synthetic event fired as a Animation begins playing (useful?)
		onBegin: null,

		// onAnimate: Event?
		//		Synthetic event fired at each interval of the Animation
		onAnimate: null,

		// onEnd: Event?
		//		Synthetic event fired after the final frame of the Animation
		onEnd: null,

		// onPlay: Event?
		//		Synthetic event fired any time the Animation is play()'ed
		onPlay: null,

		// onPause: Event?
		//		Synthetic event fired when the Animation is paused
		onPause: null,

		// onStop: Event
		//		Synthetic event fires when the Animation is stopped
		onStop: null,

	=====*/

		_percent: 0,
		_startRepeatCount: 0,

		_getStep: function(){
			var _p = this._percent,
				_e = this.easing
			;
			return _e ? _e(_p) : _p;
		},
		_fire: function(/*Event*/ evt, /*Array?*/ args){
			// summary:
			//		Convenience function.  Fire event "evt" and pass it the
			//		arguments specified in "args".
			// description:
			//		Convenience function.  Fire event "evt" and pass it the
			//		arguments specified in "args".
			//		Fires the callback in the scope of this Animation
			//		instance.
			// evt:
			//		The event to fire.
			// args:
			//		The arguments to pass to the event.
			var a = args||[];
			if(this[evt]){
				if(config.debugAtAllCosts){
					this[evt].apply(this, a);
				}else{
					try{
						this[evt].apply(this, a);
					}catch(e){
						// squelch and log because we shouldn't allow exceptions in
						// synthetic event handlers to cause the internal timer to run
						// amuck, potentially pegging the CPU. I'm not a fan of this
						// squelch, but hopefully logging will make it clear what's
						// going on
						console.error("exception in animation handler for:", evt);
						console.error(e);
					}
				}
			}
			return this; // Animation
		},

		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			// summary:
			//		Start the animation.
			// delay:
			//		How many milliseconds to delay before starting.
			// gotoStart:
			//		If true, starts the animation from the beginning; otherwise,
			//		starts it from its current position.
			// returns: Animation
			//		The instance to allow chaining.

			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			if(gotoStart){
				_t._stopTimer();
				_t._active = _t._paused = false;
				_t._percent = 0;
			}else if(_t._active && !_t._paused){
				return _t;
			}

			_t._fire("beforeBegin", [_t.node]);

			var de = delay || _t.delay,
				_p = lang.hitch(_t, "_play", gotoStart);

			if(de > 0){
				_t._delayTimer = setTimeout(_p, de);
				return _t;
			}
			_p();
			return _t;	// Animation
		},

		_play: function(gotoStart){
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			_t._startTime = new Date().valueOf();
			if(_t._paused){
				_t._startTime -= _t.duration * _t._percent;
			}

			_t._active = true;
			_t._paused = false;
			var value = _t.curve.getValue(_t._getStep());
			if(!_t._percent){
				if(!_t._startRepeatCount){
					_t._startRepeatCount = _t.repeat;
				}
				_t._fire("onBegin", [value]);
			}

			_t._fire("onPlay", [value]);

			_t._cycle();
			return _t; // Animation
		},

		pause: function(){
			// summary:
			//		Pauses a running animation.
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			_t._stopTimer();
			if(!_t._active){ return _t; /*Animation*/ }
			_t._paused = true;
			_t._fire("onPause", [_t.curve.getValue(_t._getStep())]);
			return _t; // Animation
		},

		gotoPercent: function(/*Decimal*/ percent, /*Boolean?*/ andPlay){
			// summary:
			//		Sets the progress of the animation.
			// percent:
			//		A percentage in decimal notation (between and including 0.0 and 1.0).
			// andPlay:
			//		If true, play the animation after setting the progress.
			var _t = this;
			_t._stopTimer();
			_t._active = _t._paused = true;
			_t._percent = percent;
			if(andPlay){ _t.play(); }
			return _t; // Animation
		},

		stop: function(/*boolean?*/ gotoEnd){
			// summary:
			//		Stops a running animation.
			// gotoEnd:
			//		If true, the animation will end.
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			if(!_t._timer){ return _t; /* Animation */ }
			_t._stopTimer();
			if(gotoEnd){
				_t._percent = 1;
			}
			_t._fire("onStop", [_t.curve.getValue(_t._getStep())]);
			_t._active = _t._paused = false;
			return _t; // Animation
		},

		destroy: function(){
			// summary:
			//		cleanup the animation
			this.stop();
		},

		status: function(){
			// summary:
			//		Returns a string token representation of the status of
			//		the animation, one of: "paused", "playing", "stopped"
			if(this._active){
				return this._paused ? "paused" : "playing"; // String
			}
			return "stopped"; // String
		},

		_cycle: function(){
			var _t = this;
			if(_t._active){
				var curr = new Date().valueOf();
				// Allow durations of 0 (instant) by setting step to 1 - see #13798
				var step = _t.duration === 0 ? 1 : (curr - _t._startTime) / (_t.duration);

				if(step >= 1){
					step = 1;
				}
				_t._percent = step;

				// Perform easing
				if(_t.easing){
					step = _t.easing(step);
				}

				_t._fire("onAnimate", [_t.curve.getValue(step)]);

				if(_t._percent < 1){
					_t._startTimer();
				}else{
					_t._active = false;

					if(_t.repeat > 0){
						_t.repeat--;
						_t.play(null, true);
					}else if(_t.repeat == -1){
						_t.play(null, true);
					}else{
						if(_t._startRepeatCount){
							_t.repeat = _t._startRepeatCount;
							_t._startRepeatCount = 0;
						}
					}
					_t._percent = 0;
					_t._fire("onEnd", [_t.node]);
					!_t.repeat && _t._stopTimer();
				}
			}
			return _t; // Animation
		},

		_clearTimer: function(){
			// summary:
			//		Clear the play delay timer
			clearTimeout(this._delayTimer);
			delete this._delayTimer;
		}

	});

	// the local timer, stubbed into all Animation instances
	var ctr = 0,
		timer = null,
		runner = {
			run: function(){}
		};

	lang.extend(Animation, {

		_startTimer: function(){
			if(!this._timer){
				this._timer = aspect.after(runner, "run", lang.hitch(this, "_cycle"), true);
				ctr++;
			}
			if(!timer){
				timer = setInterval(lang.hitch(runner, "run"), this.rate);
			}
		},

		_stopTimer: function(){
			if(this._timer){
				this._timer.remove();
				this._timer = null;
				ctr--;
			}
			if(ctr <= 0){
				clearInterval(timer);
				timer = null;
				ctr = 0;
			}
		}

	});

	var _makeFadeable =
		has("ie") ? function(node){
			// only set the zoom if the "tickle" value would be the same as the
			// default
			var ns = node.style;
			// don't set the width to auto if it didn't already cascade that way.
			// We don't want to f anyones designs
			if(!ns.width.length && style.get(node, "width") == "auto"){
				ns.width = "auto";
			}
		} :
		function(){};

	basefx._fade = function(/*Object*/ args){
		// summary:
		//		Returns an animation that will fade the node defined by
		//		args.node from the start to end values passed (args.start
		//		args.end) (end is mandatory, start is optional)

		args.node = dom.byId(args.node);
		var fArgs = _mixin({ properties: {} }, args),
			props = (fArgs.properties.opacity = {});

		props.start = !("start" in fArgs) ?
			function(){
				return +style.get(fArgs.node, "opacity")||0;
			} : fArgs.start;
		props.end = fArgs.end;

		var anim = basefx.animateProperty(fArgs);
		aspect.after(anim, "beforeBegin", lang.partial(_makeFadeable, fArgs.node), true);

		return anim; // Animation
	};

	/*=====
	var __FadeArgs = declare(null, {
		// node: DOMNode|String
		//		The node referenced in the animation
		// duration: Integer?
		//		Duration of the animation in milliseconds.
		// easing: Function?
		//		An easing function.
	});
	=====*/

	basefx.fadeIn = function(/*__FadeArgs*/ args){
		// summary:
		//		Returns an animation that will fade node defined in 'args' from
		//		its current opacity to fully opaque.
		return basefx._fade(_mixin({ end: 1 }, args)); // Animation
	};

	basefx.fadeOut = function(/*__FadeArgs*/ args){
		// summary:
		//		Returns an animation that will fade node defined in 'args'
		//		from its current opacity to fully transparent.
		return basefx._fade(_mixin({ end: 0 }, args)); // Animation
	};

	basefx._defaultEasing = function(/*Decimal?*/ n){
		// summary:
		//		The default easing function for Animation(s)
		return 0.5 + ((Math.sin((n + 1.5) * Math.PI)) / 2);	// Decimal
	};

	var PropLine = function(properties){
		// PropLine is an internal class which is used to model the values of
		// an a group of CSS properties across an animation lifecycle. In
		// particular, the "getValue" function handles getting interpolated
		// values between start and end for a particular CSS value.
		this._properties = properties;
		for(var p in properties){
			var prop = properties[p];
			if(prop.start instanceof Color){
				// create a reusable temp color object to keep intermediate results
				prop.tempColor = new Color();
			}
		}
	};

	PropLine.prototype.getValue = function(r){
		var ret = {};
		for(var p in this._properties){
			var prop = this._properties[p],
				start = prop.start;
			if(start instanceof Color){
				ret[p] = Color.blendColors(start, prop.end, r, prop.tempColor).toCss();
			}else if(!lang.isArray(start)){
				ret[p] = ((prop.end - start) * r) + start + (p != "opacity" ? prop.units || "px" : 0);
			}
		}
		return ret;
	};

	/*=====
	var __AnimArgs = declare(__FadeArgs, {
		// properties: Object?
		//		A hash map of style properties to Objects describing the transition,
		//		such as the properties of _Line with an additional 'units' property
		properties: {}

		//TODOC: add event callbacks
	});
	=====*/

	basefx.animateProperty = function(/*__AnimArgs*/ args){
		// summary:
		//		Returns an animation that will transition the properties of
		//		node defined in `args` depending how they are defined in
		//		`args.properties`
		//
		// description:
		//		Foundation of most `dojo/_base/fx`
		//		animations. It takes an object of "properties" corresponding to
		//		style properties, and animates them in parallel over a set
		//		duration.
		//
		// example:
		//		A simple animation that changes the width of the specified node.
		//	|	basefx.animateProperty({
		//	|		node: "nodeId",
		//	|		properties: { width: 400 },
		//	|	}).play();
		//		Dojo figures out the start value for the width and converts the
		//		integer specified for the width to the more expressive but
		//		verbose form `{ width: { end: '400', units: 'px' } }` which you
		//		can also specify directly. Defaults to 'px' if omitted.
		//
		// example:
		//		Animate width, height, and padding over 2 seconds... the
		//		pedantic way:
		//	|	basefx.animateProperty({ node: node, duration:2000,
		//	|		properties: {
		//	|			width: { start: '200', end: '400', units:"px" },
		//	|			height: { start:'200', end: '400', units:"px" },
		//	|			paddingTop: { start:'5', end:'50', units:"px" }
		//	|		}
		//	|	}).play();
		//		Note 'paddingTop' is used over 'padding-top'. Multi-name CSS properties
		//		are written using "mixed case", as the hyphen is illegal as an object key.
		//
		// example:
		//		Plug in a different easing function and register a callback for
		//		when the animation ends. Easing functions accept values between
		//		zero and one and return a value on that basis. In this case, an
		//		exponential-in curve.
		//	|	basefx.animateProperty({
		//	|		node: "nodeId",
		//	|		// dojo figures out the start value
		//	|		properties: { width: { end: 400 } },
		//	|		easing: function(n){
		//	|			return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
		//	|		},
		//	|		onEnd: function(node){
		//	|			// called when the animation finishes. The animation
		//	|			// target is passed to this function
		//	|		}
		//	|	}).play(500); // delay playing half a second
		//
		// example:
		//		Like all `Animation`s, animateProperty returns a handle to the
		//		Animation instance, which fires the events common to Dojo FX. Use `aspect.after`
		//		to access these events outside of the Animation definition:
		//	|	var anim = basefx.animateProperty({
		//	|		node:"someId",
		//	|		properties:{
		//	|			width:400, height:500
		//	|		}
		//	|	});
		//	|	aspect.after(anim, "onEnd", function(){
		//	|		console.log("animation ended");
		//	|	}, true);
		//	|	// play the animation now:
		//	|	anim.play();
		//
		// example:
		//		Each property can be a function whose return value is substituted along.
		//		Additionally, each measurement (eg: start, end) can be a function. The node
		//		reference is passed directly to callbacks.
		//	|	basefx.animateProperty({
		//	|		node:"mine",
		//	|		properties:{
		//	|			height:function(node){
		//	|				// shrink this node by 50%
		//	|				return domGeom.position(node).h / 2
		//	|			},
		//	|			width:{
		//	|				start:function(node){ return 100; },
		//	|				end:function(node){ return 200; }
		//	|			}
		//	|		}
		//	|	}).play();
		//

		var n = args.node = dom.byId(args.node);
		if(!args.easing){ args.easing = dojo._defaultEasing; }

		var anim = new Animation(args);
		aspect.after(anim, "beforeBegin", lang.hitch(anim, function(){
			var pm = {};
			for(var p in this.properties){
				// Make shallow copy of properties into pm because we overwrite
				// some values below. In particular if start/end are functions
				// we don't want to overwrite them or the functions won't be
				// called if the animation is reused.
				if(p == "width" || p == "height"){
					this.node.display = "block";
				}
				var prop = this.properties[p];
				if(lang.isFunction(prop)){
					prop = prop(n);
				}
				prop = pm[p] = _mixin({}, (lang.isObject(prop) ? prop: { end: prop }));

				if(lang.isFunction(prop.start)){
					prop.start = prop.start(n);
				}
				if(lang.isFunction(prop.end)){
					prop.end = prop.end(n);
				}
				var isColor = (p.toLowerCase().indexOf("color") >= 0);
				function getStyle(node, p){
					// domStyle.get(node, "height") can return "auto" or "" on IE; this is more reliable:
					var v = { height: node.offsetHeight, width: node.offsetWidth }[p];
					if(v !== undefined){ return v; }
					v = style.get(node, p);
					return (p == "opacity") ? +v : (isColor ? v : parseFloat(v));
				}
				if(!("end" in prop)){
					prop.end = getStyle(n, p);
				}else if(!("start" in prop)){
					prop.start = getStyle(n, p);
				}

				if(isColor){
					prop.start = new Color(prop.start);
					prop.end = new Color(prop.end);
				}else{
					prop.start = (p == "opacity") ? +prop.start : parseFloat(prop.start);
				}
			}
			this.curve = new PropLine(pm);
		}), true);
		aspect.after(anim, "onAnimate", lang.hitch(style, "set", anim.node), true);
		return anim; // Animation
	};

	basefx.anim = function(	/*DOMNode|String*/	node,
							/*Object*/			properties,
							/*Integer?*/		duration,
							/*Function?*/		easing,
							/*Function?*/		onEnd,
							/*Integer?*/		delay){
		// summary:
		//		A simpler interface to `animateProperty()`, also returns
		//		an instance of `Animation` but begins the animation
		//		immediately, unlike nearly every other Dojo animation API.
		// description:
		//		Simpler (but somewhat less powerful) version
		//		of `animateProperty`.  It uses defaults for many basic properties
		//		and allows for positional parameters to be used in place of the
		//		packed "property bag" which is used for other Dojo animation
		//		methods.
		//
		//		The `Animation` object returned will be already playing, so
		//		calling play() on it again is (usually) a no-op.
		// node:
		//		a DOM node or the id of a node to animate CSS properties on
		// duration:
		//		The number of milliseconds over which the animation
		//		should run. Defaults to the global animation default duration
		//		(350ms).
		// easing:
		//		An easing function over which to calculate acceleration
		//		and deceleration of the animation through its duration.
		//		A default easing algorithm is provided, but you may
		//		plug in any you wish. A large selection of easing algorithms
		//		are available in `dojo/fx/easing`.
		// onEnd:
		//		A function to be called when the animation finishes
		//		running.
		// delay:
		//		The number of milliseconds to delay beginning the
		//		animation by. The default is 0.
		// example:
		//		Fade out a node
		//	|	basefx.anim("id", { opacity: 0 });
		// example:
		//		Fade out a node over a full second
		//	|	basefx.anim("id", { opacity: 0 }, 1000);
		return basefx.animateProperty({ // Animation
			node: node,
			duration: duration || Animation.prototype.duration,
			properties: properties,
			easing: easing,
			onEnd: onEnd
		}).play(delay || 0);
	};


	if(has("extend-dojo")){
		_mixin(dojo, basefx);
		// Alias to drop come 2.0:
		dojo._Animation = Animation;
	}

	return basefx;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/json.js":
/*!*****************************************!*\
  !*** ./node_modules/dojo/_base/json.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ../json */ "./node_modules/dojo/json.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, json){

// module:
//		dojo/_base/json

/*=====
return {
	// summary:
	//		This module defines the dojo JSON API.
};
=====*/

dojo.fromJson = function(/*String*/ js){
	// summary:
	//		Parses a JavaScript expression and returns a JavaScript value.
	// description:
	//		Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
	//		always delegates to eval(). The content passed to this method must therefore come
	//		from a trusted source.
	//		It is recommend that you use dojo/json's parse function for an
	//		implementation uses the (faster) native JSON parse when available.
	// js:
	//		a string literal of a JavaScript expression, for instance:
	//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`

	return eval("(" + js + ")"); // Object
};

/*=====
dojo._escapeString = function(){
	// summary:
	//		Adds escape sequences for non-visual characters, double quote and
	//		backslash and surrounds with double quotes to form a valid string
	//		literal.
};
=====*/
dojo._escapeString = json.stringify; // just delegate to json.stringify

dojo.toJsonIndentStr = "\t";
dojo.toJson = function(/*Object*/ it, /*Boolean?*/ prettyPrint){
	// summary:
	//		Returns a [JSON](http://json.org) serialization of an object.
	// description:
	//		Returns a [JSON](http://json.org) serialization of an object.
	//		Note that this doesn't check for infinite recursion, so don't do that!
	//		It is recommend that you use dojo/json's stringify function for an lighter
	//		and faster implementation that matches the native JSON API and uses the
	//		native JSON serializer when available.
	// it:
	//		an object to be serialized. Objects may define their own
	//		serialization via a special "__json__" or "json" function
	//		property. If a specialized serializer has been defined, it will
	//		be used as a fallback.
	//		Note that in 1.6, toJson would serialize undefined, but this no longer supported
	//		since it is not supported by native JSON serializer.
	// prettyPrint:
	//		if true, we indent objects and arrays to make the output prettier.
	//		The variable `dojo.toJsonIndentStr` is used as the indent string --
	//		to use something other than the default (tab), change that variable
	//		before calling dojo.toJson().
	//		Note that if native JSON support is available, it will be used for serialization,
	//		and native implementations vary on the exact spacing used in pretty printing.
	// returns:
	//		A JSON string serialization of the passed-in object.
	// example:
	//		simple serialization of a trivial object
	//		|	var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
	//		|	doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
	// example:
	//		a custom serializer for an objects of a particular class:
	//		|	dojo.declare("Furby", null, {
	//		|		furbies: "are strange",
	//		|		furbyCount: 10,
	//		|		__json__: function(){
	//		|		},
	//		|	});

	// use dojo/json
	return json.stringify(it, function(key, value){
		if(value){
			var tf = value.__json__||value.json;
			if(typeof tf == "function"){
				return tf.call(value);
			}
		}
		return value;
	}, prettyPrint && dojo.toJsonIndentStr);	// String
};

return dojo;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/kernel.js":
/*!*******************************************!*\
  !*** ./node_modules/dojo/_base/kernel.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../global */ "./node_modules/dojo/global.js"), __webpack_require__(/*! ../has */ "./node_modules/dojo/has.js"), __webpack_require__(/*! ./config */ "./node_modules/dojo/_base/config.js"), __webpack_require__.dj.c(module.i), __webpack_require__.dj.m(module)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(global, has, config, require, module){
	// module:
	//		dojo/_base/kernel

	// This module is the foundational module of the dojo boot sequence; it defines the dojo object.

	var
		// loop variables for this module
		i, p,

		// create dojo, dijit, and dojox
		// FIXME: in 2.0 remove dijit, dojox being created by dojo
		dijit = {},
		dojox = {},
		dojo = {
			// summary:
			//		This module is the foundational module of the dojo boot sequence; it defines the dojo object.

			// notice dojo takes ownership of the value of the config module
			config:config,
			global:global,
			dijit:dijit,
			dojox:dojox
		};


	// Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide
	// a _scopeName property for the dojo, dijit, and dojox root object so those packages can create
	// unique names in the global space.
	//
	// Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,
	// where global when in fact they are either global under different names or not global at all. In v1.6-, the
	// config variable "scopeMap" was used to map names as used within a module to global names. This has been
	// subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,
	// only the "*" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.
	//
	// The following computations contort the packageMap for this dojo instance into a scopeMap.
	var scopeMap =
			// a map from a name used in a legacy module to the (global variable name, object addressed by that name)
			// always map dojo, dijit, and dojox
			{
				dojo:["dojo", dojo],
				dijit:["dijit", dijit],
				dojox:["dojox", dojox]
			},

		packageMap =
			// the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config
			(require.map && require.map[module.id.match(/[^\/]+/)[0]]),

		item;


	// process all mapped top-level names for this instance of dojo
	for(p in packageMap){
		if(scopeMap[p]){
			// mapped dojo, dijit, or dojox
			scopeMap[p][0] = packageMap[p];
		}else{
			// some other top-level name
			scopeMap[p] = [packageMap[p], {}];
		}
	}

	// publish those names to _scopeName and, optionally, the global namespace
	for(p in scopeMap){
		item = scopeMap[p];
		item[1]._scopeName = item[0];
		if(!config.noGlobals){
			global[item[0]] = item[1];
		}
	}
	dojo.scopeMap = scopeMap;

	/*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/

	// FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated
	dojo.baseUrl = dojo.config.baseUrl = require.baseUrl;
	dojo.isAsync = !has("dojo-loader") || require.async;
	dojo.locale = config.locale;

	var rev = "$Rev:$".match(/[0-9a-f]{7,}/);
	dojo.version = {
		// summary:
		//		Version number of the Dojo Toolkit
		// description:
		//		Hash about the version, including
		//
		//		- major: Integer: Major version. If total version is "1.2.0beta1", will be 1
		//		- minor: Integer: Minor version. If total version is "1.2.0beta1", will be 2
		//		- patch: Integer: Patch version. If total version is "1.2.0beta1", will be 0
		//		- flag: String: Descriptor flag. If total version is "1.2.0beta1", will be "beta1"
		//		- revision: Number: The Git rev from which dojo was pulled

		major: 1, minor: 15, patch: 0, flag: "",
		revision: rev ? rev[0] : NaN,
		toString: function(){
			var v = dojo.version;
			return v.major + "." + v.minor + "." + v.patch + v.flag + " (" + v.revision + ")";	// String
		}
	};

	// If has("extend-dojo") is truthy, then as a dojo module is defined it should push it's definitions
	// into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object
	// as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code
	// is migrated. Absent specific advice otherwise, set extend-dojo to truthy.
	has.add("extend-dojo", 1);

	if(!has("csp-restrictions")){
		(Function("d", "d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}"))(dojo);
	}
	/*=====
	dojo.eval = function(scriptText){
		// summary:
		//		A legacy method created for use exclusively by internal Dojo methods. Do not use this method
		//		directly unless you understand its possibly-different implications on the platforms your are targeting.
		// description:
		//		Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
		//		that support indirect eval.
		//
		//		As usual, IE does not. On IE, the only way to implement global eval is to
		//		use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
		//		This implementation uses the technique of executing eval in the scope of a function that is a single scope
		//		frame below the global scope; thereby coming close to the global scope. Note carefully that
		//
		//		dojo.eval("var pi = 3.14;");
		//
		//		will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
		//		to define a global variable using dojo.eval, write something like
		//
		//		dojo.eval("window.pi = 3.14;")
		// scriptText:
		//		The text to evaluation.
		// returns:
		//		The result of the evaluation. Often `undefined`
	};
	=====*/


	if(has("host-rhino")){
		dojo.exit = function(exitcode){
			quit(exitcode);
		};
	}else{
		dojo.exit = function(){
		};
	}

	if(!has("host-webworker")){
		// console is immutable in FF30+, https://bugs.dojotoolkit.org/ticket/18100
		has.add("dojo-guarantee-console",
			// ensure that console.log, console.warn, etc. are defined
			1
		);
	}

	if(has("dojo-guarantee-console")){
		// IE 9 bug: https://bugs.dojotoolkit.org/ticket/18197
		has.add("console-as-object", function () {
			return Function.prototype.bind && console && typeof console.log === "object";
		});

		typeof console != "undefined" || (console = {});  // intentional assignment
		//	Be careful to leave 'log' always at the end
		var cn = [
			"assert", "count", "debug", "dir", "dirxml", "error", "group",
			"groupEnd", "info", "profile", "profileEnd", "time", "timeEnd",
			"trace", "warn", "log"
		];
		var tn;
		i = 0;
		while((tn = cn[i++])){
			if(!console[tn]){
				(function(){
					var tcn = tn + "";
					console[tcn] = ('log' in console) ? function(){
						var a = Array.prototype.slice.call(arguments);
						a.unshift(tcn + ":");
						console["log"](a.join(" "));
					} : function(){};
					console[tcn]._fake = true;
				})();
			}else if(has("console-as-object")){
				console[tn] = Function.prototype.bind.call(console[tn], console);
			}
		}
	}

	has.add("dojo-debug-messages",
		// include dojo.deprecated/dojo.experimental implementations
		!!config.isDebug
	);
	dojo.deprecated = dojo.experimental =  function(){};
	if(has("dojo-debug-messages")){
		dojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){
			// summary:
			//		Log a debug message to indicate that a behavior has been
			//		deprecated.
			// behaviour: String
			//		The API or behavior being deprecated. Usually in the form
			//		of "myApp.someFunction()".
			// extra: String?
			//		Text to append to the message. Often provides advice on a
			//		new function or facility to achieve the same goal during
			//		the deprecation period.
			// removal: String?
			//		Text to indicate when in the future the behavior will be
			//		removed. Usually a version number.
			// example:
			//	| dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");

			var message = "DEPRECATED: " + behaviour;
			if(extra){ message += " " + extra; }
			if(removal){ message += " -- will be removed in version: " + removal; }
			console.warn(message);
		};

		dojo.experimental = function(/* String */ moduleName, /* String? */ extra){
			// summary:
			//		Marks code as experimental.
			// description:
			//		This can be used to mark a function, file, or module as
			//		experimental.	 Experimental code is not ready to be used, and the
			//		APIs are subject to change without notice.	Experimental code may be
			//		completed deleted without going through the normal deprecation
			//		process.
			// moduleName: String
			//		The name of a module, or the name of a module file or a specific
			//		function
			// extra: String?
			//		some additional message for the user
			// example:
			//	| dojo.experimental("dojo.data.Result");
			// example:
			//	| dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");

			var message = "EXPERIMENTAL: " + moduleName + " -- APIs subject to change without notice.";
			if(extra){ message += " " + extra; }
			console.warn(message);
		};
	}

	has.add("dojo-modulePaths",
		// consume dojo.modulePaths processing
		1
	);
	if(has("dojo-modulePaths")){
		// notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;
		// this is the v1.6- behavior.
		if(config.modulePaths){
			dojo.deprecated("dojo.modulePaths", "use paths configuration");
			var paths = {};
			for(p in config.modulePaths){
				paths[p.replace(/\./g, "/")] = config.modulePaths[p];
			}
			require({paths:paths});
		}
	}

	has.add("dojo-moduleUrl",
		// include dojo.moduleUrl
		1
	);
	if(has("dojo-moduleUrl")){
		dojo.moduleUrl = function(/*String*/module, /*String?*/url){
			// summary:
			//		Returns a URL relative to a module.
			// example:
			//	|	var pngPath = dojo.moduleUrl("acme","images/small.png");
			//	|	console.dir(pngPath); // list the object properties
			//	|	// create an image and set it's source to pngPath's value:
			//	|	var img = document.createElement("img");
			//	|	img.src = pngPath;
			//	|	// add our image to the document
			//	|	dojo.body().appendChild(img);
			// example:
			//		you may de-reference as far as you like down the package
			//		hierarchy.  This is sometimes handy to avoid lengthy relative
			//		urls or for building portable sub-packages. In this example,
			//		the `acme.widget` and `acme.util` directories may be located
			//		under different roots (see `dojo.registerModulePath`) but the
			//		the modules which reference them can be unaware of their
			//		relative locations on the filesystem:
			//	|	// somewhere in a configuration block
			//	|	dojo.registerModulePath("acme.widget", "../../acme/widget");
			//	|	dojo.registerModulePath("acme.util", "../../util");
			//	|
			//	|	// ...
			//	|
			//	|	// code in a module using acme resources
			//	|	var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
			//	|	var dataPath = dojo.moduleUrl("acme.util","resources/data.json");

			dojo.deprecated("dojo.moduleUrl()", "use require.toUrl", "2.0");

			// require.toUrl requires a filetype; therefore, just append the suffix "/*.*" to guarantee a filetype, then
			// remove the suffix from the result. This way clients can request a url w/out a filetype. This should be
			// rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).
			// Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.
			var result = null;
			if(module){
				result = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : "") + "/*.*").replace(/\/\*\.\*/, "") + (url ? "" : "/");
			}
			return result;
		};
	}

	dojo._hasResource = {}; // for backward compatibility with layers built with 1.6 tooling

	return dojo;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/lang.js":
/*!*****************************************!*\
  !*** ./node_modules/dojo/_base/lang.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ../has */ "./node_modules/dojo/has.js"), __webpack_require__(/*! ../sniff */ "./node_modules/dojo/sniff.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has){
	// module:
	//		dojo/_base/lang

	has.add("bug-for-in-skips-shadowed", function(){
		// if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)
		for(var i in {toString: 1}){
			return 0;
		}
		return 1;
	});

	// Helper methods
	var _extraNames =
			has("bug-for-in-skips-shadowed") ?
				"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor".split(".") : [],

		_extraLen = _extraNames.length,

		getProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){
			if(!context){
				if(parts[0] && dojo.scopeMap[parts[0]]) {
					// Voodoo code from the old days where "dojo" or "dijit" maps to some special object
					// rather than just window.dojo
					context = dojo.scopeMap[parts.shift()][1];
				}else{
					context = dojo.global;
				}
			}

			try{
				for(var i = 0; i < parts.length; i++){
					var p = parts[i];
					if(!(p in context)){
						if(create){
							context[p] = {};
						}else{
							return;		// return undefined
						}
					}
					context = context[p];
				}
				return context; // mixed
			}catch(e){
				// "p in context" throws an exception when context is a number, boolean, etc. rather than an object,
				// so in that corner case just return undefined (by having no return statement)
			}
		},

		opts = Object.prototype.toString,

		efficient = function(obj, offset, startWith){
			return (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));
		},

		_pattern = /\{([^\}]+)\}/g;

	// Module export
	var lang = {
		// summary:
		//		This module defines Javascript language extensions.

		// _extraNames: String[]
		//		Lists property names that must be explicitly processed during for-in iteration
		//		in environments that have has("bug-for-in-skips-shadowed") true.
		_extraNames:_extraNames,

		_mixin: function(dest, source, copyFunc){
			// summary:
			//		Copies/adds all properties of source to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source.
			// source: Object
			//		The object from which to draw all properties to copy into dest.
			// copyFunc: Function?
			//		The process used to copy/add a property in source; defaults to the Javascript assignment operator.
			// returns:
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
			//		delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
			//		Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			var name, s, i, empty = {};
			for(name in source){
				// the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
				// inherited from Object.prototype.	 For example, if dest has a custom toString() method,
				// don't overwrite it with the toString() method that source inherited from Object.prototype
				s = source[name];
				if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
					dest[name] = copyFunc ? copyFunc(s) : s;
				}
			}

			if(has("bug-for-in-skips-shadowed")){
				if(source){
					for(i = 0; i < _extraLen; ++i){
						name = _extraNames[i];
						s = source[name];
						if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
							dest[name] = copyFunc ? copyFunc(s) : s;
						}
					}
				}
			}

			return dest; // Object
		},

		mixin: function(dest, sources){
			// summary:
			//		Copies/adds all properties of one or more sources to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source. If dest is falsy, then
			//		a new object is manufactured before copying/adding properties begins.
			// sources: Object...
			//		One of more objects from which to draw all properties to copy into dest. sources are processed
			//		left-to-right and if more than one of these objects contain the same property name, the right-most
			//		value "wins".
			// returns: Object
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
			//		The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
			//		executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			// example:
			//		make a shallow copy of an object
			//	|	var copy = lang.mixin({}, source);
			// example:
			//		many class constructors often take an object which specifies
			//		values to be configured on the object. In this case, it is
			//		often simplest to call `lang.mixin` on the `this` object:
			//	|	declare("acme.Base", null, {
			//	|		constructor: function(properties){
			//	|			// property configuration:
			//	|			lang.mixin(this, properties);
			//	|
			//	|			console.log(this.quip);
			//	|			//	...
			//	|		},
			//	|		quip: "I wasn't born yesterday, you know - I've seen movies.",
			//	|		// ...
			//	|	});
			//	|
			//	|	// create an instance of the class and configure it
			//	|	var b = new acme.Base({quip: "That's what it does!" });
			// example:
			//		copy in properties from multiple objects
			//	|	var flattened = lang.mixin(
			//	|		{
			//	|			name: "Frylock",
			//	|			braces: true
			//	|		},
			//	|		{
			//	|			name: "Carl Brutanananadilewski"
			//	|		}
			//	|	);
			//	|
			//	|	// will print "Carl Brutanananadilewski"
			//	|	console.log(flattened.name);
			//	|	// will print "true"
			//	|	console.log(flattened.braces);

			if(!dest){ dest = {}; }
			for(var i = 1, l = arguments.length; i < l; i++){
				lang._mixin(dest, arguments[i]);
			}
			return dest; // Object
		},

		setObject: function(name, value, context){
			// summary:
			//		Set a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			//		Objects are created as needed along `path`. Returns the passed
			//		value if setting is successful or `undefined` if not.
			// name: String
			//		Path to a property, in the form "A.B.C".
			// value: anything
			//		value or object to place at location given by name
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		`dojo.global`.
			// example:
			//		set the value of `foo.bar.baz`, regardless of whether
			//		intermediate objects already exist:
			//	| lang.setObject("foo.bar.baz", value);
			// example:
			//		without `lang.setObject`, we often see code like this:
			//	| // ensure that intermediate objects are available
			//	| if(!obj["parent"]){ obj.parent = {}; }
			//	| if(!obj.parent["child"]){ obj.parent.child = {}; }
			//	| // now we can safely set the property
			//	| obj.parent.child.prop = "some value";
			//		whereas with `lang.setObject`, we can shorten that to:
			//	| lang.setObject("parent.child.prop", "some value", obj);

			var parts = name.split("."), p = parts.pop(), obj = getProp(parts, true, context);
			return obj && p ? (obj[p] = value) : undefined; // Object
		},

		getObject: function(name, create, context){
			// summary:
			//		Get a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			// name: String
			//		Path to an property, in the form "A.B.C".
			// create: Boolean?
			//		Optional. Defaults to `false`. If `true`, Objects will be
			//		created at any point along the 'path' that is undefined.
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			return !name ? context : getProp(name.split("."), create, context); // Object
		},

		exists: function(name, obj){
			// summary:
			//		determine if an object supports a given method
			// description:
			//		useful for longer api chains where you have to test each object in
			//		the chain. Useful for object and method detection.
			// name: String
			//		Path to an object, in the form "A.B.C".
			// obj: Object?
			//		Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			// example:
			//	| // define an object
			//	| var foo = {
			//	|		bar: { }
			//	| };
			//	|
			//	| // search the global scope
			//	| lang.exists("foo.bar"); // true
			//	| lang.exists("foo.bar.baz"); // false
			//	|
			//	| // search from a particular scope
			//	| lang.exists("bar", foo); // true
			//	| lang.exists("bar.baz", foo); // false
			return lang.getObject(name, false, obj) !== undefined; // Boolean
		},

		// Crockford (ish) functions

		isString: function(it){
			// summary:
			//		Return true if it is a String
			// it: anything
			//		Item to test.
			return (typeof it == "string" || it instanceof String); // Boolean
		},

		isArray: Array.isArray || function(it){
			// summary:
			//		Return true if it is an Array.
			// it: anything
			//		Item to test.
			return opts.call(it) == "[object Array]"; // Boolean
		},

		isFunction: function(it){
			// summary:
			//		Return true if it is a Function
			// it: anything
			//		Item to test.
			return opts.call(it) === "[object Function]";
		},

		isObject: function(it){
			// summary:
			//		Returns true if it is a JavaScript object (or an Array, a Function
			//		or null)
			// it: anything
			//		Item to test.
			return it !== undefined &&
				(it === null || typeof it == "object" || lang.isArray(it) || lang.isFunction(it)); // Boolean
		},

		isArrayLike: function(it){
			// summary:
			//		similar to isArray() but more permissive
			// it: anything
			//		Item to test.
			// returns:
			//		If it walks like a duck and quacks like a duck, return `true`
			// description:
			//		Doesn't strongly test for "arrayness".  Instead, settles for "isn't
			//		a string or number and has a length property". Arguments objects
			//		and DOM collections will return true when passed to
			//		isArrayLike(), but will return false when passed to
			//		isArray().
			return !!it && // Boolean
				// keep out built-in constructors (Number, String, ...) which have length
				// properties
				!lang.isString(it) && !lang.isFunction(it) &&
				!(it.tagName && it.tagName.toLowerCase() == 'form') &&
				(lang.isArray(it) || isFinite(it.length));
		},

		isAlien: function(it){
			// summary:
			//		Returns true if it is a built-in function or some other kind of
			//		oddball that *should* report as a function but doesn't
			return it && !lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it)); // Boolean
		},

		extend: function(ctor, props){
			// summary:
			//		Adds all properties and methods of props to constructor's
			//		prototype, making them available to all instances created with
			//		constructor.
			// ctor: Object
			//		Target constructor to extend.
			// props: Object
			//		One or more objects to mix into ctor.prototype
			for(var i=1, l=arguments.length; i<l; i++){
				lang._mixin(ctor.prototype, arguments[i]);
			}
			return ctor; // Object
		},

		_hitchArgs: function(scope, method){
			var pre = lang._toArray(arguments, 2);
			var named = lang.isString(method);
			return function(){
				// arrayify arguments
				var args = lang._toArray(arguments);
				// locate our method
				var f = named ? (scope||dojo.global)[method] : method;
				// invoke with collected args
				return f && f.apply(scope || this, pre.concat(args)); // mixed
			}; // Function
		},

		hitch: function(scope, method){
			// summary:
			//		Returns a function that will only ever execute in the given scope.
			//		This allows for easy use of object member functions
			//		in callbacks and other places in which the "this" keyword may
			//		otherwise not reference the expected scope.
			//		Any number of default positional arguments may be passed as parameters
			//		beyond "method".
			//		Each of these values will be used to "placehold" (similar to curry)
			//		for the hitched function.
			// scope: Object
			//		The scope to use when method executes. If method is a string,
			//		scope is also the object containing method.
			// method: Function|String...
			//		A function to be hitched to scope, or the name of the method in
			//		scope to be hitched.
			// example:
			//	|	lang.hitch(foo, "bar")();
			//		runs foo.bar() in the scope of foo
			// example:
			//	|	lang.hitch(foo, myFunction);
			//		returns a function that runs myFunction in the scope of foo
			// example:
			//		Expansion on the default positional arguments passed along from
			//		hitch. Passed args are mixed first, additional args after.
			//	|	var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
			//	|	var fn = lang.hitch(foo, "bar", 1, 2);
			//	|	fn(3); // logs "1, 2, 3"
			// example:
			//	|	var foo = { bar: 2 };
			//	|	lang.hitch(foo, function(){ this.bar = 10; })();
			//		execute an anonymous function in scope of foo
			if(arguments.length > 2){
				return lang._hitchArgs.apply(dojo, arguments); // Function
			}
			if(!method){
				method = scope;
				scope = null;
			}
			if(lang.isString(method)){
				scope = scope || dojo.global;
				if(!scope[method]){ throw(['lang.hitch: scope["', method, '"] is null (scope="', scope, '")'].join('')); }
				return function(){ return scope[method].apply(scope, arguments || []); }; // Function
			}
			return !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function
		},

		delegate: (function(){
			// boodman/crockford delegation w/ cornford optimization
			function TMP(){}
			return function(obj, props){
				TMP.prototype = obj;
				var tmp = new TMP();
				TMP.prototype = null;
				if(props){
					lang._mixin(tmp, props);
				}
				return tmp; // Object
			};
		})(),
		/*=====
		delegate: function(obj, props){
			// summary:
			//		Returns a new object which "looks" to obj for properties which it
			//		does not have a value for. Optionally takes a bag of properties to
			//		seed the returned object with initially.
			// description:
			//		This is a small implementation of the Boodman/Crockford delegation
			//		pattern in JavaScript. An intermediate object constructor mediates
			//		the prototype chain for the returned object, using it to delegate
			//		down to obj for property lookup when object-local lookup fails.
			//		This can be thought of similarly to ES4's "wrap", save that it does
			//		not act on types but rather on pure objects.
			// obj: Object
			//		The object to delegate to for properties not found directly on the
			//		return object or in props.
			// props: Object...
			//		an object containing properties to assign to the returned object
			// returns:
			//		an Object of anonymous type
			// example:
			//	|	var foo = { bar: "baz" };
			//	|	var thinger = lang.delegate(foo, { thud: "xyzzy"});
			//	|	thinger.bar == "baz"; // delegated to foo
			//	|	foo.thud == undefined; // by definition
			//	|	thinger.thud == "xyzzy"; // mixed in from props
			//	|	foo.bar = "thonk";
			//	|	thinger.bar == "thonk"; // still delegated to foo's bar
		},
		=====*/

		_toArray: has("ie") ?
			(function(){
				function slow(obj, offset, startWith){
					var arr = startWith||[];
					for(var x = offset || 0; x < obj.length; x++){
						arr.push(obj[x]);
					}
					return arr;
				}
				return function(obj){
					return ((obj.item) ? slow : efficient).apply(this, arguments);
				};
			})() : efficient,
		/*=====
		 _toArray: function(obj, offset, startWith){
			 // summary:
			 //		Converts an array-like object (i.e. arguments, DOMCollection) to an
			 //		array. Returns a new Array with the elements of obj.
			 // obj: Object
			 //		the object to "arrayify". We expect the object to have, at a
			 //		minimum, a length property which corresponds to integer-indexed
			 //		properties.
			 // offset: Number?
			 //		the location in obj to start iterating from. Defaults to 0.
			 //		Optional.
			 // startWith: Array?
			 //		An array to pack with the properties of obj. If provided,
			 //		properties in obj are appended at the end of startWith and
			 //		startWith is the returned array.
		 },
		 =====*/

		partial: function(/*Function|String*/ method /*, ...*/){
			// summary:
			//		similar to hitch() except that the scope object is left to be
			//		whatever the execution context eventually becomes.
			// description:
			//		Calling lang.partial is the functional equivalent of calling:
			//		|	lang.hitch(null, funcName, ...);
			// method:
			//		The function to "wrap"
			var arr = [ null ];
			return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); // Function
		},

		clone: function(/*anything*/ src){
			// summary:
			//		Clones objects (including DOM nodes) and all children.
			//		Warning: do not clone cyclic structures.
			// src:
			//		The object to clone
			if(!src || typeof src != "object" || lang.isFunction(src)){
				// null, undefined, any non-object, or function
				return src;	// anything
			}
			if(src.nodeType && "cloneNode" in src){
				// DOM Node
				return src.cloneNode(true); // Node
			}
			if(src instanceof Date){
				// Date
				return new Date(src.getTime());	// Date
			}
			if(src instanceof RegExp){
				// RegExp
				return new RegExp(src);   // RegExp
			}
			var r, i, l;
			if(lang.isArray(src)){
				// array
				r = [];
				for(i = 0, l = src.length; i < l; ++i){
					if(i in src){
						r[i] = lang.clone(src[i]);
					}
				}
				// we don't clone functions for performance reasons
				//		}else if(d.isFunction(src)){
				//			// function
				//			r = function(){ return src.apply(this, arguments); };
			}else{
				// generic objects
				r = src.constructor ? new src.constructor() : {};
			}
			return lang._mixin(r, src, lang.clone);
		},


		trim: String.prototype.trim ?
			function(str){ return str.trim(); } :
			function(str){ return str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); },
		/*=====
		 trim: function(str){
			 // summary:
			 //		Trims whitespace from both sides of the string
			 // str: String
			 //		String to be trimmed
			 // returns: String
			 //		Returns the trimmed string
			 // description:
			 //		This version of trim() was selected for inclusion into the base due
			 //		to its compact size and relatively good performance
			 //		(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
			 //		Uses String.prototype.trim instead, if available.
			 //		The fastest but longest version of this function is located at
			 //		lang.string.trim()
		 },
		 =====*/

		replace: function(tmpl, map, pattern){
			// summary:
			//		Performs parameterized substitutions on a string. Throws an
			//		exception if any parameter is unmatched.
			// tmpl: String
			//		String to be used as a template.
			// map: Object|Function
			//		If an object, it is used as a dictionary to look up substitutions.
			//		If a function, it is called for every substitution with following parameters:
			//		a whole match, a name, an offset, and the whole template
			//		string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
			//		for more details).
			// pattern: RegEx?
			//		Optional regular expression objects that overrides the default pattern.
			//		Must be global and match one item. The default is: /\{([^\}]+)\}/g,
			//		which matches patterns like that: "{xxx}", where "xxx" is any sequence
			//		of characters, which doesn't include "}".
			// returns: String
			//		Returns the substituted string.
			// example:
			//	|	// uses a dictionary for substitutions:
			//	|	lang.replace("Hello, {name.first} {name.last} AKA {nick}!",
			//	|		{
			//	|			nick: "Bob",
			//	|			name: {
			//	|				first:	"Robert",
			//	|				middle: "X",
			//	|				last:		"Cringely"
			//	|			}
			//	|		});
			//	|	// returns: Hello, Robert Cringely AKA Bob!
			// example:
			//	|	// uses an array for substitutions:
			//	|	lang.replace("Hello, {0} {2}!",
			//	|		["Robert", "X", "Cringely"]);
			//	|	// returns: Hello, Robert Cringely!
			// example:
			//	|	// uses a function for substitutions:
			//	|	function sum(a){
			//	|		var t = 0;
			//	|		arrayforEach(a, function(x){ t += x; });
			//	|		return t;
			//	|	}
			//	|	lang.replace(
			//	|		"{count} payments averaging {avg} USD per payment.",
			//	|		lang.hitch(
			//	|			{ payments: [11, 16, 12] },
			//	|			function(_, key){
			//	|				switch(key){
			//	|					case "count": return this.payments.length;
			//	|					case "min":		return Math.min.apply(Math, this.payments);
			//	|					case "max":		return Math.max.apply(Math, this.payments);
			//	|					case "sum":		return sum(this.payments);
			//	|					case "avg":		return sum(this.payments) / this.payments.length;
			//	|				}
			//	|			}
			//	|		)
			//	|	);
			//	|	// prints: 3 payments averaging 13 USD per payment.
			// example:
			//	|	// uses an alternative PHP-like pattern for substitutions:
			//	|	lang.replace("Hello, ${0} ${2}!",
			//	|		["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
			//	|	// returns: Hello, Robert Cringely!

			return tmpl.replace(pattern || _pattern, lang.isFunction(map) ?
				map : function(_, k){ return lang.getObject(k, false, map); });
		}
	};

	has("extend-dojo") && lang.mixin(dojo, lang);

	return lang;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/sniff.js":
/*!******************************************!*\
  !*** ./node_modules/dojo/_base/sniff.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ../sniff */ "./node_modules/dojo/sniff.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, lang, has){
	// module:
	//		dojo/_base/sniff

	/*=====
	return {
		// summary:
		//		Deprecated.   New code should use dojo/sniff.
		//		This module populates the dojo browser version sniffing properties like dojo.isIE.
	};
	=====*/

	if(!has("host-browser")){
		return has;
	}

	// no idea what this is for, or if it's used
	dojo._name = "browser";

	lang.mixin(dojo, {
		// isBrowser: Boolean
		//		True if the client is a web-browser
		isBrowser: true,

		// isFF: Number|undefined
		//		Version as a Number if client is FireFox. undefined otherwise. Corresponds to
		//		major detected FireFox version (1.5, 2, 3, etc.)
		isFF: has("ff"),

		// isIE: Number|undefined
		//		Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
		//		major detected IE version (6, 7, 8, etc.)
		isIE: has("ie"),

		// isKhtml: Number|undefined
		//		Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
		//		detected version.
		isKhtml: has("khtml"),

		// isWebKit: Number|undefined
		//		Version as a Number if client is a WebKit-derived browser (Konqueror,
		//		Safari, Chrome, etc.). undefined otherwise.
		isWebKit: has("webkit"),

		// isMozilla: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMozilla: has("mozilla"),
		// isMoz: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMoz: has("mozilla"),

		// isOpera: Number|undefined
		//		Version as a Number if client is Opera. undefined otherwise. Corresponds to
		//		major detected version.
		isOpera: has("opera"),

		// isSafari: Number|undefined
		//		Version as a Number if client is Safari or iPhone. undefined otherwise.
		isSafari: has("safari"),

		// isChrome: Number|undefined
		//		Version as a Number if client is Chrome browser. undefined otherwise.
		isChrome: has("chrome"),

		// isMac: Boolean
		//		True if the client runs on Mac
		isMac: has("mac"),

		// isIos: Number|undefined
		//		Version as a Number if client is iPhone, iPod, or iPad. undefined otherwise.
		isIos: has("ios"),

		// isAndroid: Number|undefined
		//		Version as a Number if client is android browser. undefined otherwise.
		isAndroid: has("android"),

		// isWii: Boolean
		//		True if client is Wii
		isWii: has("wii"),

		// isQuirks: Boolean
		//		Page is in quirks mode.
		isQuirks: has("quirks"),

		// isAir: Boolean
		//		True if client is Adobe Air
		isAir: has("air")
	});

	return has;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/window.js":
/*!*******************************************!*\
  !*** ./node_modules/dojo/_base/window.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ../sniff */ "./node_modules/dojo/sniff.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, lang, has){
// module:
//		dojo/_base/window

var ret = {
	// summary:
	//		API to save/set/restore the global/document scope.

	global: dojo.global,
	/*=====
	 global: {
		 // summary:
		 //		Alias for the current window. 'global' can be modified
		 //		for temporary context shifting. See also withGlobal().
		 // description:
		 //		Use this rather than referring to 'window' to ensure your code runs
		 //		correctly in managed contexts.
	 },
	 =====*/

	doc: dojo.global["document"] || null,
	/*=====
	doc: {
		// summary:
		//		Alias for the current document. 'doc' can be modified
		//		for temporary context shifting. See also withDoc().
		// description:
		//		Use this rather than referring to 'window.document' to ensure your code runs
		//		correctly in managed contexts.
		// example:
		//	|	n.appendChild(dojo.doc.createElement('div'));
	},
	=====*/

	body: function(/*Document?*/ doc){
		// summary:
		//		Return the body element of the specified document or of dojo/_base/window::doc.
		// example:
		//	|	win.body().appendChild(dojo.doc.createElement('div'));

		// Note: document.body is not defined for a strict xhtml document
		// Would like to memoize this, but dojo.doc can change vi dojo.withDoc().
		doc = doc || dojo.doc;
		return doc.body || doc.getElementsByTagName("body")[0]; // Node
	},

	setContext: function(/*Object*/ globalObject, /*DocumentElement*/ globalDocument){
		// summary:
		//		changes the behavior of many core Dojo functions that deal with
		//		namespace and DOM lookup, changing them to work in a new global
		//		context (e.g., an iframe). The varibles dojo.global and dojo.doc
		//		are modified as a result of calling this function and the result of
		//		`dojo.body()` likewise differs.
		dojo.global = ret.global = globalObject;
		dojo.doc = ret.doc = globalDocument;
	},

	withGlobal: function(	/*Object*/ globalObject,
							/*Function*/ callback,
							/*Object?*/ thisObject,
							/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc.
		// description:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc. If provided, globalObject
		//		will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo.global
		//		and dojo.doc will be restored to its previous state.

		var oldGlob = dojo.global;
		try{
			dojo.global = ret.global = globalObject;
			return ret.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);
		}finally{
			dojo.global = ret.global = oldGlob;
		}
	},

	withDoc: function(	/*DocumentElement*/ documentObject,
						/*Function*/ callback,
						/*Object?*/ thisObject,
						/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with documentObject as dojo/_base/window::doc.
		// description:
		//		Invoke callback with documentObject as dojo/_base/window::doc. If provided,
		//		callback will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo/_base/window::doc will
		//		be restored to its previous state.

		var oldDoc = ret.doc,
			oldQ = has("quirks"),
			oldIE = has("ie"), isIE, mode, pwin;

		try{
			dojo.doc = ret.doc = documentObject;
			// update dojo.isQuirks and the value of the has feature "quirks".
			// remove setting dojo.isQuirks and dojo.isIE for 2.0
			dojo.isQuirks = has.add("quirks", dojo.doc.compatMode == "BackCompat", true, true); // no need to check for QuirksMode which was Opera 7 only

			if(has("ie")){
				if((pwin = documentObject.parentWindow) && pwin.navigator){
					// re-run IE detection logic and update dojo.isIE / has("ie")
					// (the only time parentWindow/navigator wouldn't exist is if we were not
					// passed an actual legitimate document object)
					isIE = parseFloat(pwin.navigator.appVersion.split("MSIE ")[1]) || undefined;
					mode = documentObject.documentMode;
					if(mode && mode != 5 && Math.floor(isIE) != mode){
						isIE = mode;
					}
					dojo.isIE = has.add("ie", isIE, true, true);
				}
			}

			if(thisObject && typeof callback == "string"){
				callback = thisObject[callback];
			}

			return callback.apply(thisObject, cbArguments || []);
		}finally{
			dojo.doc = ret.doc = oldDoc;
			dojo.isQuirks = has.add("quirks", oldQ, true, true);
			dojo.isIE = has.add("ie", oldIE, true, true);
		}
	}
};

has("extend-dojo") && lang.mixin(dojo, ret);

return ret;

}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/xhr.js":
/*!****************************************!*\
  !*** ./node_modules/dojo/_base/xhr.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"),
	__webpack_require__(/*! ./sniff */ "./node_modules/dojo/_base/sniff.js"),
	__webpack_require__.dj.c(module.i),
	__webpack_require__(/*! ../io-query */ "./node_modules/dojo/io-query.js"),
	/*===== "./declare", =====*/
	__webpack_require__(/*! ../dom */ "./node_modules/dojo/dom.js"),
	__webpack_require__(/*! ../dom-form */ "./node_modules/dojo/dom-form.js"),
	__webpack_require__(/*! ./Deferred */ "./node_modules/dojo/_base/Deferred.js"),
	__webpack_require__(/*! ./config */ "./node_modules/dojo/_base/config.js"),
	__webpack_require__(/*! ./json */ "./node_modules/dojo/_base/json.js"),
	__webpack_require__(/*! ./lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! ./array */ "./node_modules/dojo/_base/array.js"),
	__webpack_require__(/*! ../on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! ../aspect */ "./node_modules/dojo/aspect.js"),
	__webpack_require__(/*! ../request/watch */ "./node_modules/dojo/request/watch.js"),
	__webpack_require__(/*! ../request/xhr */ "./node_modules/dojo/request/xhr.js"),
	__webpack_require__(/*! ../request/util */ "./node_modules/dojo/request/util.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has, require, ioq, /*===== declare, =====*/ dom, domForm, Deferred, config, json, lang, array, on, aspect, watch, _xhr, util){
	// module:
	//		dojo/_base/xhr

	/*=====
	dojo._xhrObj = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
	};
	=====*/
	dojo._xhrObj = _xhr._create;

	var cfg = dojo.config;

	// mix in io-query and dom-form
	dojo.objectToQuery = ioq.objectToQuery;
	dojo.queryToObject = ioq.queryToObject;
	dojo.fieldToObject = domForm.fieldToObject;
	dojo.formToObject = domForm.toObject;
	dojo.formToQuery = domForm.toQuery;
	dojo.formToJson = domForm.toJson;

	// need to block async callbacks from snatching this thread as the result
	// of an async callback might call another sync XHR, this hangs khtml forever
	// must checked by watchInFlight()

	dojo._blockAsync = false;

	// MOW: remove dojo._contentHandlers alias in 2.0
	var handlers = dojo._contentHandlers = dojo.contentHandlers = {
		// summary:
		//		A map of available XHR transport handle types. Name matches the
		//		`handleAs` attribute passed to XHR calls.
		// description:
		//		A map of available XHR transport handle types. Name matches the
		//		`handleAs` attribute passed to XHR calls. Each contentHandler is
		//		called, passing the xhr object for manipulation. The return value
		//		from the contentHandler will be passed to the `load` or `handle`
		//		functions defined in the original xhr call.
		// example:
		//		Creating a custom content-handler:
		//	|	xhr.contentHandlers.makeCaps = function(xhr){
		//	|		return xhr.responseText.toUpperCase();
		//	|	}
		//	|	// and later:
		//	|	dojo.xhrGet({
		//	|		url:"foo.txt",
		//	|		handleAs:"makeCaps",
		//	|		load: function(data){ /* data is a toUpper version of foo.txt */ }
		//	|	});

		"text": function(xhr){
			// summary:
			//		A contentHandler which simply returns the plaintext response data
			return xhr.responseText;
		},
		"json": function(xhr){
			// summary:
			//		A contentHandler which returns a JavaScript object created from the response data
			return json.fromJson(xhr.responseText || null);
		},
		"json-comment-filtered": function(xhr){
			// summary:
			//		A contentHandler which expects comment-filtered JSON.
			// description:
			//		A contentHandler which expects comment-filtered JSON.
			//		the json-comment-filtered option was implemented to prevent
			//		"JavaScript Hijacking", but it is less secure than standard JSON. Use
			//		standard JSON instead. JSON prefixing can be used to subvert hijacking.
			//
			//		Will throw a notice suggesting to use application/json mimetype, as
			//		json-commenting can introduce security issues. To decrease the chances of hijacking,
			//		use the standard `json` contentHandler, and prefix your "JSON" with: {}&&
			//
			//		use djConfig.useCommentedJson = true to turn off the notice
			if(!config.useCommentedJson){
				console.warn("Consider using the standard mimetype:application/json."
					+ " json-commenting can introduce security issues. To"
					+ " decrease the chances of hijacking, use the standard the 'json' handler and"
					+ " prefix your json with: {}&&\n"
					+ "Use djConfig.useCommentedJson=true to turn off this message.");
			}

			var value = xhr.responseText;
			var cStartIdx = value.indexOf("\/*");
			var cEndIdx = value.lastIndexOf("*\/");
			if(cStartIdx == -1 || cEndIdx == -1){
				throw new Error("JSON was not comment filtered");
			}
			return json.fromJson(value.substring(cStartIdx+2, cEndIdx));
		},
		"javascript": function(xhr){
			// summary:
			//		A contentHandler which evaluates the response data, expecting it to be valid JavaScript

			// FIXME: try Moz and IE specific eval variants?
			return dojo.eval(xhr.responseText);
		},
		"xml": function(xhr){
			// summary:
			//		A contentHandler returning an XML Document parsed from the response data
			var result = xhr.responseXML;

			if(result && has("dom-qsa2.1") && !result.querySelectorAll && has("dom-parser")){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(xhr.responseText, "application/xml");
			}

			if(has("ie")){
				if((!result || !result.documentElement)){
					//WARNING: this branch used by the xml handling in dojo.io.iframe,
					//so be sure to test dojo.io.iframe if making changes below.
					var ms = function(n){ return "MSXML" + n + ".DOMDocument"; };
					var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
					array.some(dp, function(p){
						try{
							var dom = new ActiveXObject(p);
							dom.async = false;
							dom.loadXML(xhr.responseText);
							result = dom;
						}catch(e){ return false; }
						return true;
					});
				}
			}
			return result; // DOMDocument
		},
		"json-comment-optional": function(xhr){
			// summary:
			//		A contentHandler which checks the presence of comment-filtered JSON and
			//		alternates between the `json` and `json-comment-filtered` contentHandlers.
			if(xhr.responseText && /^[^{\[]*\/\*/.test(xhr.responseText)){
				return handlers["json-comment-filtered"](xhr);
			}else{
				return handlers["json"](xhr);
			}
		}
	};

	/*=====

	// kwargs function parameter definitions.   Assigning to dojo namespace rather than making them local variables
	// because they are used by dojo/io modules too

	dojo.__IoArgs = declare(null, {
		// url: String
		//		URL to server endpoint.
		// content: Object?
		//		Contains properties with string values. These
		//		properties will be serialized as name1=value2 and
		//		passed in the request.
		// timeout: Integer?
		//		Milliseconds to wait for the response. If this time
		//		passes, the then error callbacks are called.
		// form: DOMNode?
		//		DOM node for a form. Used to extract the form values
		//		and send to the server.
		// preventCache: Boolean?
		//		Default is false. If true, then a
		//		"dojo.preventCache" parameter is sent in the request
		//		with a value that changes with each request
		//		(timestamp). Useful only with GET-type requests.
		// handleAs: String?
		//		Acceptable values depend on the type of IO
		//		transport (see specific IO calls for more information).
		// rawBody: String?
		//		Sets the raw body for an HTTP request. If this is used, then the content
		//		property is ignored. This is mostly useful for HTTP methods that have
		//		a body to their requests, like PUT or POST. This property can be used instead
		//		of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.
		// ioPublish: Boolean?
		//		Set this explicitly to false to prevent publishing of topics related to
		//		IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
		//		will be published via dojo/topic.publish() for different phases of an IO operation.
		//		See dojo/main.__IoPublish for a list of topics that are published.

		load: function(response, ioArgs){
			// summary:
			//		This function will be
			//		called on a successful HTTP response code.
	 		// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
			// response: Object
			//		The response in the format as defined with handleAs.
		},

		error: function(response, ioArgs){
			// summary:
			//		This function will
			//		be called when the request fails due to a network or server error, the url
			//		is invalid, etc. It will also be called if the load or handle callback throws an
			//		exception, unless djConfig.debugAtAllCosts is true.	 This allows deployed applications
			//		to continue to run even when a logic error happens in the callback, while making
			//		it easier to troubleshoot while in debug mode.
			// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
			// response: Object
			//		The response in the format as defined with handleAs.
		},

		handle: function(loadOrError, response, ioArgs){
			// summary:
	 		//		This function will
	 		//		be called at the end of every request, whether or not an error occurs.
			// loadOrError: String
			//		Provides a string that tells you whether this function
			//		was called because of success (load) or failure (error).
			// response: Object
			//		The response in the format as defined with handleAs.
			// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
		}
	});

	dojo.__IoCallbackArgs = declare(null, {
		// args: Object
		//		the original object argument to the IO call.
		// xhr: XMLHttpRequest
		//		For XMLHttpRequest calls only, the
		//		XMLHttpRequest object that was used for the
		//		request.
		// url: String
		//		The final URL used for the call. Many times it
		//		will be different than the original args.url
		//		value.
		// query: String
		//		For non-GET requests, the
		//		name1=value1&name2=value2 parameters sent up in
		//		the request.
		// handleAs: String
		//		The final indicator on how the response will be
		//		handled.
		// id: String
		//		For dojo/io/script calls only, the internal
		//		script ID used for the request.
		// canDelete: Boolean
		//		For dojo/io/script calls only, indicates
		//		whether the script tag that represents the
		//		request can be deleted after callbacks have
		//		been called. Used internally to know when
		//		cleanup can happen on JSONP-type requests.
		// json: Object
		//		For dojo/io/script calls only: holds the JSON
		//		response for JSONP-type requests. Used
		//		internally to hold on to the JSON responses.
		//		You should not need to access it directly --
		//		the same object should be passed to the success
		//		callbacks directly.
	});

	dojo.__IoPublish = declare(null, {
		// summary:
		//		This is a list of IO topics that can be published
		//		if djConfig.ioPublish is set to true. IO topics can be
		//		published for any Input/Output, network operation. So,
		//		dojo.xhr, dojo.io.script and dojo.io.iframe can all
		//		trigger these topics to be published.
		// start: String
		//		"/dojo/io/start" is sent when there are no outstanding IO
		//		requests, and a new IO request is started. No arguments
		//		are passed with this topic.
		// send: String
		//		"/dojo/io/send" is sent whenever a new IO request is started.
		//		It passes the dojo.Deferred for the request with the topic.
		// load: String
		//		"/dojo/io/load" is sent whenever an IO request has loaded
		//		successfully. It passes the response and the dojo.Deferred
		//		for the request with the topic.
		// error: String
		//		"/dojo/io/error" is sent whenever an IO request has errored.
		//		It passes the error and the dojo.Deferred
		//		for the request with the topic.
		// done: String
		//		"/dojo/io/done" is sent whenever an IO request has completed,
		//		either by loading or by erroring. It passes the error and
		//		the dojo.Deferred for the request with the topic.
		// stop: String
		//		"/dojo/io/stop" is sent when all outstanding IO requests have
		//		finished. No arguments are passed with this topic.
	});
	=====*/


	dojo._ioSetArgs = function(/*dojo/main.__IoArgs*/args,
			/*Function*/canceller,
			/*Function*/okHandler,
			/*Function*/errHandler){
		// summary:
		//		sets up the Deferred and ioArgs property on the Deferred so it
		//		can be used in an io call.
		// args:
		//		The args object passed into the public io call. Recognized properties on
		//		the args object are:
		// canceller:
		//		The canceller function used for the Deferred object. The function
		//		will receive one argument, the Deferred object that is related to the
		//		canceller.
		// okHandler:
		//		The first OK callback to be registered with Deferred. It has the opportunity
		//		to transform the OK response. It will receive one argument -- the Deferred
		//		object returned from this function.
		// errHandler:
		//		The first error callback to be registered with Deferred. It has the opportunity
		//		to do cleanup on an error. It will receive two arguments: error (the
		//		Error object) and dfd, the Deferred object returned from this function.

		var ioArgs = {args: args, url: args.url};

		//Get values from form if requested.
		var formObject = null;
		if(args.form){
			var form = dom.byId(args.form);
			//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
			//so use it for all. See #2844
			var actnNode = form.getAttributeNode("action");
			ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : (dojo.doc ? dojo.doc.URL : null));
			formObject = domForm.toObject(form);
		}

		// set up the query params
		var miArgs = {};

		if(formObject){
			// potentially over-ride url-provided params w/ form values
			lang.mixin(miArgs, formObject);
		}
		if(args.content){
			// stuff in content over-rides what's set by form
			lang.mixin(miArgs, args.content);
		}
		if(args.preventCache){
			miArgs["dojo.preventCache"] = new Date().valueOf();
		}
		ioArgs.query = ioq.objectToQuery(miArgs);

		// .. and the real work of getting the deferred in order, etc.
		ioArgs.handleAs = args.handleAs || "text";
		var d = new Deferred(function(dfd){
			dfd.canceled = true;
			canceller && canceller(dfd);

			var err = dfd.ioArgs.error;
			if(!err){
				err = new Error("request cancelled");
				err.dojoType="cancel";
				dfd.ioArgs.error = err;
			}
			return err;
		});
		d.addCallback(okHandler);

		//Support specifying load, error and handle callback functions from the args.
		//For those callbacks, the "this" object will be the args object.
		//The callbacks will get the deferred result value as the
		//first argument and the ioArgs object as the second argument.
		var ld = args.load;
		if(ld && lang.isFunction(ld)){
			d.addCallback(function(value){
				return ld.call(args, value, ioArgs);
			});
		}
		var err = args.error;
		if(err && lang.isFunction(err)){
			d.addErrback(function(value){
				return err.call(args, value, ioArgs);
			});
		}
		var handle = args.handle;
		if(handle && lang.isFunction(handle)){
			d.addBoth(function(value){
				return handle.call(args, value, ioArgs);
			});
		}

		// Attach error handler last (not including topic publishing)
		// to catch any errors that may have been generated from load
		// or handle functions.
		d.addErrback(function(error){
			return errHandler(error, d);
		});

		//Plug in topic publishing, if dojo.publish is loaded.
		if(cfg.ioPublish && dojo.publish && ioArgs.args.ioPublish !== false){
			d.addCallbacks(
				function(res){
					dojo.publish("/dojo/io/load", [d, res]);
					return res;
				},
				function(res){
					dojo.publish("/dojo/io/error", [d, res]);
					return res;
				}
			);
			d.addBoth(function(res){
				dojo.publish("/dojo/io/done", [d, res]);
				return res;
			});
		}

		d.ioArgs = ioArgs;

		// FIXME: need to wire up the xhr object's abort method to something
		// analogous in the Deferred
		return d;
	};

	var _deferredOk = function(/*Deferred*/dfd){
		// summary:
		//		okHandler function for dojo._ioSetArgs call.

		var ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
		return ret === undefined ? null : ret;
	};
	var _deferError = function(/*Error*/error, /*Deferred*/dfd){
		// summary:
		//		errHandler function for dojo._ioSetArgs call.

		if(!dfd.ioArgs.args.failOk){
			console.error(error);
		}
		return error;
	};

	//Use a separate count for knowing if we are starting/stopping io calls.
	var _checkPubCount = function(dfd){
		if(_pubCount <= 0){
			_pubCount = 0;
			if(cfg.ioPublish && dojo.publish && (!dfd || dfd && dfd.ioArgs.args.ioPublish !== false)){
				dojo.publish("/dojo/io/stop");
			}
		}
	};

	var _pubCount = 0;
	aspect.after(watch, "_onAction", function(){
		_pubCount -= 1;
	});
	aspect.after(watch, "_onInFlight", _checkPubCount);

	dojo._ioCancelAll = watch.cancelAll;
	/*=====
	dojo._ioCancelAll = function(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		//		(xhr, script, iframe).
	};
	=====*/

	dojo._ioNotifyStart = function(/*Deferred*/dfd){
		// summary:
		//		If dojo.publish is available, publish topics
		//		about the start of a request queue and/or the
		//		the beginning of request.
		//
		//		Used by IO transports. An IO transport should
		//		call this method before making the network connection.
		if(cfg.ioPublish && dojo.publish && dfd.ioArgs.args.ioPublish !== false){
			if(!_pubCount){
				dojo.publish("/dojo/io/start");
			}
			_pubCount += 1;
			dojo.publish("/dojo/io/send", [dfd]);
		}
	};

	dojo._ioWatch = function(dfd, validCheck, ioCheck, resHandle){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.

		var args = dfd.ioArgs.options = dfd.ioArgs.args;
		lang.mixin(dfd, {
			response: dfd.ioArgs,
			isValid: function(response){
				return validCheck(dfd);
			},
			isReady: function(response){
				return ioCheck(dfd);
			},
			handleResponse: function(response){
				return resHandle(dfd);
			}
		});
		watch(dfd);

		_checkPubCount(dfd);
	};

	var _defaultContentType = "application/x-www-form-urlencoded";

	dojo._ioAddQueryToUrl = function(/*dojo.__IoCallbackArgs*/ioArgs){
		// summary:
		//		Adds query params discovered by the io deferred construction to the URL.
		//		Only use this for operations which are fundamentally GET-type operations.
		if(ioArgs.query.length){
			ioArgs.url += (ioArgs.url.indexOf("?") == -1 ? "?" : "&") + ioArgs.query;
			ioArgs.query = null;
		}
	};

	/*=====
	dojo.__XhrArgs = declare(dojo.__IoArgs, {
		// summary:
		//		In addition to the properties listed for the dojo._IoArgs type,
		//		the following properties are allowed for dojo.xhr* methods.
		// handleAs: String?
		//		Acceptable values are: text (default), json, json-comment-optional,
		//		json-comment-filtered, javascript, xml. See `dojo/_base/xhr.contentHandlers`
	 	// sync: Boolean?
		//		false is default. Indicates whether the request should
		//		be a synchronous (blocking) request.
		// headers: Object?
		//		Additional HTTP headers to send in the request.
		// failOk: Boolean?
		//		false is default. Indicates whether a request should be
		//		allowed to fail (and therefore no console error message in
		//		the event of a failure)
		// contentType: String|Boolean
		//		"application/x-www-form-urlencoded" is default. Set to false to
		//		prevent a Content-Type header from being sent, or to a string
		//		to send a different Content-Type.
	 });
	=====*/

	dojo.xhr = function(/*String*/ method, /*dojo.__XhrArgs*/ args, /*Boolean?*/ hasBody){
		// summary:
		//		Deprecated.   Use dojo/request instead.
		// description:
		//		Sends an HTTP request with the given method.
		//		See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
		//		for those HTTP methods. There are also methods for "raw" PUT and POST methods
		//		via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.
		// method:
		//		HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.
		// hasBody:
		//		If the request has an HTTP body, then pass true for hasBody.

		var rDfd;
		//Make the Deferred object for this xhr request.
		var dfd = dojo._ioSetArgs(args, function(dfd){
			rDfd && rDfd.cancel();
		}, _deferredOk, _deferError);
		var ioArgs = dfd.ioArgs;

		//Allow for specifying the HTTP body completely.
		if("postData" in args){
			ioArgs.query = args.postData;
		}else if("putData" in args){
			ioArgs.query = args.putData;
		}else if("rawBody" in args){
			ioArgs.query = args.rawBody;
		}else if((arguments.length > 2 && !hasBody) || "POST|PUT".indexOf(method.toUpperCase()) === -1){
			//Check for hasBody being passed. If no hasBody,
			//then only append query string if not a POST or PUT request.
			dojo._ioAddQueryToUrl(ioArgs);
		}

		var options = {
			method: method,
			handleAs: "text",
			timeout: args.timeout,
			withCredentials: args.withCredentials,
			ioArgs: ioArgs
		};

		if(typeof args.headers !== 'undefined'){
			options.headers = args.headers;
		}
		if(typeof args.contentType !== 'undefined'){
			if(!options.headers){
				options.headers = {};
			}
			options.headers['Content-Type'] = args.contentType;
		}
		if(typeof ioArgs.query !== 'undefined'){
			options.data = ioArgs.query;
		}
		if(typeof args.sync !== 'undefined'){
			options.sync = args.sync;
		}

		dojo._ioNotifyStart(dfd);
		try{
			rDfd = _xhr(ioArgs.url, options, true);
		}catch(e){
			// If XHR creation fails, dojo/request/xhr throws
			// When this happens, cancel the deferred
			dfd.cancel();
			return dfd;
		}

		// sync ioArgs
		dfd.ioArgs.xhr = rDfd.response.xhr;

		rDfd.then(function(){
			dfd.resolve(dfd);
		}).otherwise(function(error){
			ioArgs.error = error;
			if(error.response){
				error.status = error.response.status;
				error.responseText = error.response.text;
				error.xhr = error.response.xhr;
			}
			dfd.reject(error);
		});
		return dfd; // dojo/_base/Deferred
	};

	dojo.xhrGet = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP GET request to the server.
		return dojo.xhr("GET", args); // dojo/_base/Deferred
	};

	dojo.rawXhrPost = dojo.xhrPost = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP POST request to the server. In addition to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		// postData:
		//		String. Send raw data in the body of the POST request.
		return dojo.xhr("POST", args, true); // dojo/_base/Deferred
	};

	dojo.rawXhrPut = dojo.xhrPut = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP PUT request to the server. In addition to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		// putData:
		//		String. Send raw data in the body of the PUT request.
		return dojo.xhr("PUT", args, true); // dojo/_base/Deferred
	};

	dojo.xhrDelete = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP DELETE request to the server.
		return dojo.xhr("DELETE", args); // dojo/_base/Deferred
	};

	/*
	dojo.wrapForm = function(formNode){
		// summary:
		//		A replacement for FormBind, but not implemented yet.

		// FIXME: need to think harder about what extensions to this we might
		// want. What should we allow folks to do w/ this? What events to
		// set/send?
		throw new Error("dojo.wrapForm not yet implemented");
	}
	*/

	dojo._isDocumentOk = function(x){
		return util.checkStatus(x.status);
	};

	dojo._getText = function(url){
		var result;
		dojo.xhrGet({url:url, sync:true, load:function(text){
			result = text;
		}});
		return result;
	};

	// Add aliases for static functions to dojo.xhr since dojo.xhr is what's returned from this module
	lang.mixin(dojo.xhr, {
		_xhrObj: dojo._xhrObj,
		fieldToObject: domForm.fieldToObject,
		formToObject: domForm.toObject,
		objectToQuery: ioq.objectToQuery,
		formToQuery: domForm.toQuery,
		formToJson: domForm.toJson,
		queryToObject: ioq.queryToObject,
		contentHandlers: handlers,
		_ioSetArgs: dojo._ioSetArgs,
		_ioCancelAll: dojo._ioCancelAll,
		_ioNotifyStart: dojo._ioNotifyStart,
		_ioWatch: dojo._ioWatch,
		_ioAddQueryToUrl: dojo._ioAddQueryToUrl,
		_isDocumentOk: dojo._isDocumentOk,
		_getText: dojo._getText,
		get: dojo.xhrGet,
		post: dojo.xhrPost,
		put: dojo.xhrPut,
		del: dojo.xhrDelete	// because "delete" is a reserved word
	});

	return dojo.xhr;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/aspect.js":
/*!*************************************!*\
  !*** ./node_modules/dojo/aspect.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){

	// module:
	//		dojo/aspect

	"use strict";
	var undefined;
	function advise(dispatcher, type, advice, receiveArguments){
		var previous = dispatcher[type];
		var around = type == "around";
		var signal;
		if(around){
			var advised = advice(function(){
				return previous.advice(this, arguments);
			});
			signal = {
				remove: function(){
					if(advised){
						advised = dispatcher = advice = null;
					}
				},
				advice: function(target, args){
					return advised ?
						advised.apply(target, args) :  // called the advised function
						previous.advice(target, args); // cancelled, skip to next one
				}
			};
		}else{
			// create the remove handler
			signal = {
				remove: function(){
					if(signal.advice){
						var previous = signal.previous;
						var next = signal.next;
						if(!next && !previous){
							delete dispatcher[type];
						}else{
							if(previous){
								previous.next = next;
							}else{
								dispatcher[type] = next;
							}
							if(next){
								next.previous = previous;
							}
						}

						// remove the advice to signal that this signal has been removed
						dispatcher = advice = signal.advice = null;
					}
				},
				id: dispatcher.nextId++,
				advice: advice,
				receiveArguments: receiveArguments
			};
		}
		if(previous && !around){
			if(type == "after"){
				// add the listener to the end of the list
				// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
				while(previous.next && (previous = previous.next)){}
				previous.next = signal;
				signal.previous = previous;
			}else if(type == "before"){
				// add to beginning
				dispatcher[type] = signal;
				signal.next = previous;
				previous.previous = signal;
			}
		}else{
			// around or first one just replaces
			dispatcher[type] = signal;
		}
		return signal;
	}
	function aspect(type){
		return function(target, methodName, advice, receiveArguments){
			var existing = target[methodName], dispatcher;
			if(!existing || existing.target != target){
				// no dispatcher in place
				target[methodName] = dispatcher = function(){
					var executionId = dispatcher.nextId;
					// before advice
					var args = arguments;
					var before = dispatcher.before;
					while(before){
						if(before.advice){
							args = before.advice.apply(this, args) || args;
						}
						before = before.next;
					}
					// around advice
					if(dispatcher.around){
						var results = dispatcher.around.advice(this, args);
					}
					// after advice
					var after = dispatcher.after;
					while(after && after.id < executionId){
						if(after.advice){
							if(after.receiveArguments){
								var newResults = after.advice.apply(this, args);
								// change the return value only if a new value was returned
								results = newResults === undefined ? results : newResults;
							}else{
								results = after.advice.call(this, results, args);
							}
						}
						after = after.next;
					}
					return results;
				};
				if(existing){
					dispatcher.around = {advice: function(target, args){
						return existing.apply(target, args);
					}};
				}
				dispatcher.target = target;
				dispatcher.nextId = dispatcher.nextId || 0;
			}
			var results = advise((dispatcher || existing), type, advice, receiveArguments);
			advice = null;
			return results;
		};
	}

	// TODOC: after/before/around return object

	var after = aspect("after");
	/*=====
	after = function(target, methodName, advice, receiveArguments){
		// summary:
		//		The "after" export of the aspect module is a function that can be used to attach
		//		"after" advice to a method. This function will be executed after the original method
		//		is executed. By default the function will be called with a single argument, the return
		//		value of the original method, or the the return value of the last executed advice (if a previous one exists).
		//		The fourth (optional) argument can be set to true to so the function receives the original
		//		arguments (from when the original method was called) rather than the return value.
		//		If there are multiple "after" advisors, they are executed in the order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called after the original method
		// receiveArguments: Boolean?
		//		If this is set to true, the advice function receives the original arguments (from when the original mehtod
		//		was called) rather than the return value of the original/previous method.
		// returns:
		//		A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
		//		stop the advice function from being executed.
	};
	=====*/

	var before = aspect("before");
	/*=====
	before = function(target, methodName, advice){
		// summary:
		//		The "before" export of the aspect module is a function that can be used to attach
		//		"before" advice to a method. This function will be executed before the original method
		//		is executed. This function will be called with the arguments used to call the method.
		//		This function may optionally return an array as the new arguments to use to call
		//		the original method (or the previous, next-to-execute before advice, if one exists).
		//		If the before method doesn't return anything (returns undefined) the original arguments
		//		will be preserved.
		//		If there are multiple "before" advisors, they are executed in the reverse order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called before the original method
	};
	=====*/

	var around = aspect("around");
	/*=====
	 around = function(target, methodName, advice){
		// summary:
		//		The "around" export of the aspect module is a function that can be used to attach
		//		"around" advice to a method. The advisor function is immediately executed when
		//		the around() is called, is passed a single argument that is a function that can be
		//		called to continue execution of the original method (or the next around advisor).
		//		The advisor function should return a function, and this function will be called whenever
		//		the method is called. It will be called with the arguments used to call the method.
		//		Whatever this function returns will be returned as the result of the method call (unless after advise changes it).
		// example:
		//		If there are multiple "around" advisors, the most recent one is executed first,
		//		which can then delegate to the next one and so on. For example:
		//		|	around(obj, "foo", function(originalFoo){
		//		|		return function(){
		//		|			var start = new Date().getTime();
		//		|			var results = originalFoo.apply(this, arguments); // call the original
		//		|			var end = new Date().getTime();
		//		|			console.log("foo execution took " + (end - start) + " ms");
		//		|			return results;
		//		|		};
		//		|	});
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called around the original method
	};
	=====*/

	return {
		// summary:
		//		provides aspect oriented programming functionality, allowing for
		//		one to add before, around, or after advice on existing methods.
		// example:
		//	|	define(["dojo/aspect"], function(aspect){
		//	|		var signal = aspect.after(targetObject, "methodName", function(someArgument){
		//	|			this will be called when targetObject.methodName() is called, after the original function is called
		//	|		});
		//
		// example:
		//	The returned signal object can be used to cancel the advice.
		//	|	signal.remove(); // this will stop the advice from being executed anymore
		//	|	aspect.before(targetObject, "methodName", function(someArgument){
		//	|		// this will be called when targetObject.methodName() is called, before the original function is called
		//	|	 });

		before: before,
		around: around,
		after: after
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/cache.js":
/*!************************************!*\
  !*** ./node_modules/dojo/cache.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./text */ "./node_modules/dojo/text.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo){
	// module:
	//		dojo/cache

	// dojo.cache is defined in dojo/text
	return dojo.cache;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/dom-attr.js":
/*!***************************************!*\
  !*** ./node_modules/dojo/dom-attr.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./sniff */ "./node_modules/dojo/sniff.js"), __webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ./dom */ "./node_modules/dojo/dom.js"), __webpack_require__(/*! ./dom-style */ "./node_modules/dojo/dom-style.js"), __webpack_require__(/*! ./dom-prop */ "./node_modules/dojo/dom-prop.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(exports, has, lang, dom, style, prop){
	// module:
	//		dojo/dom-attr
	// summary:
	//		This module defines the core dojo DOM attributes API.

	// TODOC: summary not showing up in output see https://github.com/csnover/js-doc-parse/issues/42

	// =============================
	// Element attribute Functions
	// =============================

	// This module will be obsolete soon. Use dojo/prop instead.

	// dojo/dom-attr.get() should conform to http://www.w3.org/TR/DOM-Level-2-Core/

	// attribute-related functions (to be obsolete soon)
	var forcePropNames = {
			innerHTML:	1,
			textContent:1,
			className:	1,
			htmlFor:	has("ie") ? 1 : 0,
			value:		1
		},
		attrNames = {
			// original attribute names
			classname: "class",
			htmlfor: "for",
			// for IE
			tabindex: "tabIndex",
			readonly: "readOnly"
		};

	function _hasAttr(node, name){
		var attr = node.getAttributeNode && node.getAttributeNode(name);
		return !!attr && attr.specified; // Boolean
	}
	
	// There is a difference in the presence of certain properties and their default values
	// between browsers. For example, on IE "disabled" is present on all elements,
	// but it is value is "false"; "tabIndex" of <div> returns 0 by default on IE, yet other browsers
	// can return -1.

	exports.has = function hasAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns true if the requested attribute is specified on the
		//		given element, and false otherwise.
		// node: DOMNode|String
		//		id or reference to the element to check
		// name: String
		//		the name of the attribute
		// returns: Boolean
		//		true if the requested attribute is specified on the
		//		given element, and false otherwise

		var lc = name.toLowerCase();
		return !!forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);	// Boolean
	};

	exports.get = function getAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Gets an attribute on an HTML element.
		// description:
		//		Handles normalized getting of attributes on DOM Nodes.
		// node: DOMNode|String
		//		id or reference to the element to get the attribute on
		// name: String
		//		the name of the attribute to get.
		// returns:
		//		the value of the requested attribute or null if that attribute does not have a specified or
		//		default value;
		//
		// example:
		//	|	// get the current value of the "foo" attribute on a node
		//	|	require(["dojo/dom-attr", "dojo/dom"], function(domAttr, dom){
		//	|		domAttr.get(dom.byId("nodeId"), "foo");
		//	|		// or we can just pass the id:
		//	|		domAttr.get("nodeId", "foo");
		//	|	});	
		//	|	

		node = dom.byId(node);
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName],
			value = node[propName];		// should we access this attribute via a property or via getAttribute()?

		if(forceProp && typeof value != "undefined"){
			// node's property
			return value;	// Anything
		}
		
		if(propName == "textContent"){
			return prop.get(node, propName);
		}
		
		if(propName != "href" && (typeof value == "boolean" || lang.isFunction(value))){
			// node's property
			return value;	// Anything
		}
		// node's attribute
		// we need _hasAttr() here to guard against IE returning a default value
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};

	exports.set = function setAttr(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets an attribute on an HTML element.
		// description:
		//		Handles normalized setting of attributes on DOM Nodes.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to set the attribute on
		// name: String|Object
		//		the name of the attribute to set, or a hash of key-value pairs to set.
		// value: String?
		//		the value to set for the attribute, if the name is a string.
		// returns:
		//		the DOM node
		//
		// example:
		//	|	// use attr() to set the tab index
		//	|	require(["dojo/dom-attr"], function(domAttr){
		//	|		domAttr.set("nodeId", "tabIndex", 3);
		//	|	});
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	require(["dojo/dom-attr"],
		//	|	function(domAttr){
		//	|		domAttr.set("formId", {
		//	|			"foo": "bar",
		//	|			"tabIndex": -1,
		//	|			"method": "POST"
		//	|		}
		//	|	});

		node = dom.byId(node);
		if(arguments.length == 2){ // inline'd type check
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){
				exports.set(node, x, name[x]);
			}
			return node; // DomNode
		}
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName];
		if(propName == "style" && typeof value != "string"){ // inline'd type check
			// special case: setting a style
			style.set(node, value);
			return node; // DomNode
		}
		if(forceProp || typeof value == "boolean" || lang.isFunction(value)){
			return prop.set(node, name, value);
		}
		// node's attribute
		node.setAttribute(attrNames[lc] || name, value);
		return node; // DomNode
	};

	exports.remove = function removeAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Removes an attribute from an HTML element.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute to remove

		dom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);
	};

	exports.getNodeProp = function getNodeProp(/*DomNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns an effective value of a property or an attribute.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute
		// returns:
		//		the value of the attribute

		node = dom.byId(node);
		var lc = name.toLowerCase(), propName = prop.names[lc] || name;
		if((propName in node) && propName != "href"){
			// node's property
			return node[propName];	// Anything
		}
		// node's attribute
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/dom-class.js":
/*!****************************************!*\
  !*** ./node_modules/dojo/dom-class.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ./_base/array */ "./node_modules/dojo/_base/array.js"), __webpack_require__(/*! ./dom */ "./node_modules/dojo/dom.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang, array, dom){
	// module:
	//		dojo/dom-class

	var className = "className";

	/* Part I of classList-based implementation is preserved here for posterity
	var classList = "classList";
	has.add("dom-classList", function(){
		return classList in document.createElement("p");
	});
	*/

	// =============================
	// (CSS) Class Functions
	// =============================

	var cls, // exports object
		spaces = /\s+/, a1 = [""];

	function str2array(s){
		if(typeof s == "string" || s instanceof String){
			if(s && !spaces.test(s)){
				a1[0] = s;
				return a1;
			}
			var a = s.split(spaces);
			if(a.length && !a[0]){
				a.shift();
			}
			if(a.length && !a[a.length - 1]){
				a.pop();
			}
			return a;
		}
		// assumed to be an array
		if(!s){
			return [];
		}
		return array.filter(s, function(x){ return x; });
	}

	/* Part II of classList-based implementation is preserved here for posterity
	if(has("dom-classList")){
		// new classList version
		cls = {
			contains: function containsClass(node, classStr){
				var clslst = classStr && dom.byId(node)[classList];
				return clslst && clslst.contains(classStr); // Boolean
			},

			add: function addClass(node, classStr){
				node = dom.byId(node);
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length; i < len; ++i){
					node[classList].add(classStr[i]);
				}
			},

			remove: function removeClass(node, classStr){
				node = dom.byId(node);
				if(classStr === undefined){
					node[className] = "";
				}else{
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].remove(classStr[i]);
					}
				}
			},

			replace: function replaceClass(node, addClassStr, removeClassStr){
				node = dom.byId(node);
				if(removeClassStr === undefined){
					node[className] = "";
				}else{
					removeClassStr = str2array(removeClassStr);
					for(var i = 0, len = removeClassStr.length; i < len; ++i){
						node[classList].remove(removeClassStr[i]);
					}
				}
				addClassStr = str2array(addClassStr);
				for(i = 0, len = addClassStr.length; i < len; ++i){
					node[classList].add(addClassStr[i]);
				}
			},

			toggle: function toggleClass(node, classStr, condition){
				node = dom.byId(node);
				if(condition === undefined){
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].toggle(classStr[i]);
					}
				}else{
					cls[condition ? "add" : "remove"](node, classStr);
				}
				return condition;   // Boolean
			}
		}
	}
	*/

	// regular DOM version
	var fakeNode = {};  // for effective replacement
	cls = {
		// summary:
		//		This module defines the core dojo DOM class API.

		contains: function containsClass(/*DomNode|String*/ node, /*String*/ classStr){
			// summary:
			//		Returns whether or not the specified classes are a portion of the
			//		class list currently applied to the node.
			// node: String|DOMNode
			//		String ID or DomNode reference to check the class for.
			// classStr: String
			//		A string class name to look for.
			// example:
			//		Do something if a node with id="someNode" has class="aSillyClassName" present
			//	|	if(domClass.contains("someNode","aSillyClassName")){ ... }

			return ((" " + dom.byId(node)[className] + " ").indexOf(" " + classStr + " ") >= 0); // Boolean
		},

		add: function addClass(/*DomNode|String*/ node, /*String|Array*/ classStr){
			// summary:
			//		Adds the specified classes to the end of the class list on the
			//		passed node. Will not re-apply duplicate classes.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to add a class string too
			//
			// classStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//		Add a class to some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "anewClass");
			//	|	});
			//
			// example:
			//		Add two classes at once:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Add two classes at once (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple additions
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").addClass("firstLevel");
			//	|	});

			node = dom.byId(node);
			classStr = str2array(classStr);
			var cls = node[className], oldLen;
			cls = cls ? " " + cls + " " : " ";
			oldLen = cls.length;
			for(var i = 0, len = classStr.length, c; i < len; ++i){
				c = classStr[i];
				if(c && cls.indexOf(" " + c + " ") < 0){
					cls += c + " ";
				}
			}
			if(oldLen < cls.length){
				node[className] = cls.substr(1, cls.length - 2);
			}
		},

		remove: function removeClass(/*DomNode|String*/ node, /*String|Array?*/ classStr){
			// summary:
			//		Removes the specified classes from node. No `contains()`
			//		check is required.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// classStr: String|Array
			//		An optional String class name to remove, or several space-separated
			//		class names, or an array of class names. If omitted, all class names
			//		will be deleted.
			//
			// example:
			//		Remove a class from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Remove all classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode");
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple removal
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").removeClass("foo");
			//	|	});

			node = dom.byId(node);
			var cls;
			if(classStr !== undefined){
				classStr = str2array(classStr);
				cls = " " + node[className] + " ";
				for(var i = 0, len = classStr.length; i < len; ++i){
					cls = cls.replace(" " + classStr[i] + " ", " ");
				}
				cls = lang.trim(cls);
			}else{
				cls = "";
			}
			if(node[className] != cls){ node[className] = cls; }
		},

		replace: function replaceClass(/*DomNode|String*/ node, /*String|Array*/ addClassStr, /*String|Array?*/ removeClassStr){
			// summary:
			//		Replaces one or more classes on a node if not present.
			//		Operates more quickly than calling domClass.remove and domClass.add
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// addClassStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// removeClassStr: String|Array?
			//		A String class name to remove, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "add1 add2", "remove1 remove2");
			//	|	});
			//
			// example:
			//	Replace all classes with addMe
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "addMe");
			//	|	});
			//
			// example:
			//	Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".findMe").replaceClass("addMe", "removeMe");
			//	|	});

			node = dom.byId(node);
			fakeNode[className] = node[className];
			cls.remove(fakeNode, removeClassStr);
			cls.add(fakeNode, addClassStr);
			if(node[className] !== fakeNode[className]){
				node[className] = fakeNode[className];
			}
		},

		toggle: function toggleClass(/*DomNode|String*/ node, /*String|Array*/ classStr, /*Boolean?*/ condition){
			// summary:
			//		Adds a class to node if not present, or removes if present.
			//		Pass a boolean condition if you want to explicitly add or remove.
			//		Returns the condition that was specified directly or indirectly.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to toggle a class string
			//
			// classStr: String|Array
			//		A String class name to toggle, or several space-separated class names,
			//		or an array of class names.
			//
			// condition:
			//		If passed, true means to add the class, false means to remove.
			//		Otherwise domClass.contains(node, classStr) is used to detect the class presence.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered");
			//	|	});
			//
			// example:
			//		Forcefully add a class
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered", true);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".toggleMe").toggleClass("toggleMe");
			//	|	});

			node = dom.byId(node);
			if(condition === undefined){
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length, c; i < len; ++i){
					c = classStr[i];
					cls[cls.contains(node, c) ? "remove" : "add"](node, c);
				}
			}else{
				cls[condition ? "add" : "remove"](node, classStr);
			}
			return condition;   // Boolean
		}
	};

	return cls;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/dom-construct.js":
/*!********************************************!*\
  !*** ./node_modules/dojo/dom-construct.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./sniff */ "./node_modules/dojo/sniff.js"), __webpack_require__(/*! ./_base/window */ "./node_modules/dojo/_base/window.js"), __webpack_require__(/*! ./dom */ "./node_modules/dojo/dom.js"), __webpack_require__(/*! ./dom-attr */ "./node_modules/dojo/dom-attr.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(exports, dojo, has, win, dom, attr){
	// module:
	//		dojo/dom-construct
	// summary:
	//		This module defines the core dojo DOM construction API.

	// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

	// support stuff for toDom()
	var tagWrap = {
			option: ["select"],
			tbody: ["table"],
			thead: ["table"],
			tfoot: ["table"],
			tr: ["table", "tbody"],
			td: ["table", "tbody", "tr"],
			th: ["table", "thead", "tr"],
			legend: ["fieldset"],
			caption: ["table"],
			colgroup: ["table"],
			col: ["table", "colgroup"],
			li: ["ul"]
		},
		reTag = /<\s*([\w\:]+)/,
		masterNode = {}, masterNum = 0,
		masterName = "__" + dojo._scopeName + "ToDomId";

	// generate start/end tag strings to use
	// for the injection for each special tag wrap case.
	for(var param in tagWrap){
		if(tagWrap.hasOwnProperty(param)){
			var tw = tagWrap[param];
			tw.pre = param == "option" ? '<select multiple="multiple">' : "<" + tw.join("><") + ">";
			tw.post = "</" + tw.reverse().join("></") + ">";
			// the last line is destructive: it reverses the array,
			// but we don't care at this point
		}
	}

	var html5domfix;
	if(has("ie") <= 8){
		html5domfix = function(doc){
			doc.__dojo_html5_tested = "yes";
			var div = create('div', {innerHTML: "<nav>a</nav>", style: {visibility: "hidden"}}, doc.body);
			if(div.childNodes.length !== 1){
				('abbr article aside audio canvas details figcaption figure footer header ' +
				'hgroup mark meter nav output progress section summary time video').replace(
					/\b\w+\b/g, function(n){
						doc.createElement(n);
					}
				);
			}
			destroy(div);
		}
	}

	function _insertBefore(/*DomNode*/ node, /*DomNode*/ ref){
		var parent = ref.parentNode;
		if(parent){
			parent.insertBefore(node, ref);
		}
	}

	function _insertAfter(/*DomNode*/ node, /*DomNode*/ ref){
		// summary:
		//		Try to insert node after ref
		var parent = ref.parentNode;
		if(parent){
			if(parent.lastChild == ref){
				parent.appendChild(node);
			}else{
				parent.insertBefore(node, ref.nextSibling);
			}
		}
	}

	exports.toDom = function toDom(frag, doc){
		// summary:
		//		instantiates an HTML fragment returning the corresponding DOM.
		// frag: String
		//		the HTML fragment
		// doc: DocumentNode?
		//		optional document to use when creating DOM nodes, defaults to
		//		dojo/_base/window.doc if not specified.
		// returns:
		//		Document fragment, unless it's a single node in which case it returns the node itself
		// example:
		//		Create a table row:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var tr = domConstruct.toDom("<tr><td>First!</td></tr>");
		//	|	});

		doc = doc || win.doc;
		var masterId = doc[masterName];
		if(!masterId){
			doc[masterName] = masterId = ++masterNum + "";
			masterNode[masterId] = doc.createElement("div");
		}

		if(has("ie") <= 8){
			if(!doc.__dojo_html5_tested && doc.body){
				html5domfix(doc);
			}
		}

		// make sure the frag is a string.
		frag += "";

		// find the starting tag, and get node wrapper
		var match = frag.match(reTag),
			tag = match ? match[1].toLowerCase() : "",
			master = masterNode[masterId],
			wrap, i, fc, df;
		if(match && tagWrap[tag]){
			wrap = tagWrap[tag];
			master.innerHTML = wrap.pre + frag + wrap.post;
			for(i = wrap.length; i; --i){
				master = master.firstChild;
			}
		}else{
			master.innerHTML = frag;
		}

		// one node shortcut => return the node itself
		if(master.childNodes.length == 1){
			return master.removeChild(master.firstChild); // DOMNode
		}

		// return multiple nodes as a document fragment
		df = doc.createDocumentFragment();
		while((fc = master.firstChild)){ // intentional assignment
			df.appendChild(fc);
		}
		return df; // DocumentFragment
	};

	exports.place = function place(node, refNode, position){
		// summary:
		//		Attempt to insert node into the DOM, choosing from various positioning options.
		//		Returns the first argument resolved to a DOM node.
		// node: DOMNode|DocumentFragment|String
		//		id or node reference, or HTML fragment starting with "<" to place relative to refNode
		// refNode: DOMNode|String
		//		id or node reference to use as basis for placement
		// position: String|Number?
		//		string noting the position of node relative to refNode or a
		//		number indicating the location in the childNodes collection of refNode.
		//		Accepted string values are:
		//
		//		- before
		//		- after
		//		- replace
		//		- only
		//		- first
		//		- last
		//
		//		"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,
		//		"only" replaces all children.  position defaults to "last" if not specified
		// returns: DOMNode
		//		Returned values is the first argument resolved to a DOM node.
		//
		//		.place() is also a method of `dojo/NodeList`, allowing `dojo/query` node lookups.
		// example:
		//		Place a node by string id as the last child of another node by string id:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("someNode", "anotherNode");
		//	|	});
		// example:
		//		Place a node by string id before another node by string id
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("someNode", "anotherNode", "before");
		//	|	});
		// example:
		//		Create a Node, and place it in the body element (last child):
		//	|	require(["dojo/dom-construct", "dojo/_base/window"
		//	|	], function(domConstruct, win){
		//	|		domConstruct.place("<div></div>", win.body());
		//	|	});
		// example:
		//		Put a new LI as the first child of a list by id:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("<li></li>", "someUl", "first");
		//	|	});

		refNode = dom.byId(refNode);
		if(typeof node == "string"){ // inline'd type check
			node = /^\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);
		}
		if(typeof position == "number"){ // inline'd type check
			var cn = refNode.childNodes;
			if(!cn.length || cn.length <= position){
				refNode.appendChild(node);
			}else{
				_insertBefore(node, cn[position < 0 ? 0 : position]);
			}
		}else{
			switch(position){
				case "before":
					_insertBefore(node, refNode);
					break;
				case "after":
					_insertAfter(node, refNode);
					break;
				case "replace":
					refNode.parentNode.replaceChild(node, refNode);
					break;
				case "only":
					exports.empty(refNode);
					refNode.appendChild(node);
					break;
				case "first":
					if(refNode.firstChild){
						_insertBefore(node, refNode.firstChild);
						break;
					}
					// else fallthrough...
				default: // aka: last
					refNode.appendChild(node);
			}
		}
		return node; // DomNode
	};

	var create = exports.create = function create(/*DOMNode|String*/ tag, /*Object*/ attrs, /*DOMNode|String?*/ refNode, /*String?*/ pos){
		// summary:
		//		Create an element, allowing for optional attribute decoration
		//		and placement.
		// description:
		//		A DOM Element creation function. A shorthand method for creating a node or
		//		a fragment, and allowing for a convenient optional attribute setting step,
		//		as well as an optional DOM placement reference.
		//
		//		Attributes are set by passing the optional object through `dojo/dom-attr.set`.
		//		See `dojo/dom-attr.set` for noted caveats and nuances, and API if applicable.
		//
		//		Placement is done via `dojo/dom-construct.place`, assuming the new node to be
		//		the action node, passing along the optional reference node and position.
		// tag: DOMNode|String
		//		A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),
		//		or an existing DOM node to process.
		// attrs: Object
		//		An object-hash of attributes to set on the newly created node.
		//		Can be null, if you don't want to set any attributes/styles.
		//		See: `dojo/dom-attr.set` for a description of available attributes.
		// refNode: DOMNode|String?
		//		Optional reference node. Used by `dojo/dom-construct.place` to place the newly created
		//		node somewhere in the dom relative to refNode. Can be a DomNode reference
		//		or String ID of a node.
		// pos: String?
		//		Optional positional reference. Defaults to "last" by way of `dojo/domConstruct.place`,
		//		though can be set to "first","after","before","last", "replace" or "only"
		//		to further control the placement of the new node relative to the refNode.
		//		'refNode' is required if a 'pos' is specified.
		// example:
		//		Create a DIV:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var n = domConstruct.create("div");
		//	|	});
		//
		// example:
		//		Create a DIV with content:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var n = domConstruct.create("div", { innerHTML:"<p>hi</p>" });
		//	|	});
		//
		// example:
		//		Place a new DIV in the BODY, with no attributes set
		//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
		//	|		var n = domConstruct.create("div", null, win.body());
		//	|	});
		//
		// example:
		//		Create an UL, and populate it with LI's. Place the list as the first-child of a
		//		node with id="someId":
		//	|	require(["dojo/dom-construct", "dojo/_base/array"],
		//	|	function(domConstruct, arrayUtil){
		//	|		var ul = domConstruct.create("ul", null, "someId", "first");
		//	|		var items = ["one", "two", "three", "four"];
		//	|		arrayUtil.forEach(items, function(data){
		//	|			domConstruct.create("li", { innerHTML: data }, ul);
		//	|		});
		//	|	});
		//
		// example:
		//		Create an anchor, with an href. Place in BODY:
		//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
		//	|		domConstruct.create("a", { href:"foo.html", title:"Goto FOO!" }, win.body());
		//	|	});

		var doc = win.doc;
		if(refNode){
			refNode = dom.byId(refNode);
			doc = refNode.ownerDocument;
		}
		if(typeof tag == "string"){ // inline'd type check
			tag = doc.createElement(tag);
		}
		if(attrs){ attr.set(tag, attrs); }
		if(refNode){ exports.place(tag, refNode, pos); }
		return tag; // DomNode
	};

	function _empty(/*DomNode*/ node){
		// TODO: remove this if() block in 2.0 when we no longer have to worry about IE memory leaks,
		// and then uncomment the emptyGrandchildren() test case from html.html.
		// Note that besides fixing #16957, using removeChild() is actually faster than setting node.innerHTML,
		// see http://jsperf.com/clear-dom-node.
		if("innerHTML" in node){
			try{
				// fast path
				node.innerHTML = "";
				return;
			}catch(e){
				// innerHTML is readOnly (e.g. TABLE (sub)elements in quirks mode)
				// Fall through (saves bytes)
			}
		}

		// SVG/strict elements don't support innerHTML
		for(var c; c = node.lastChild;){ // intentional assignment
			node.removeChild(c);
		}
	}

	exports.empty = function empty(/*DOMNode|String*/ node){
		// summary:
		//		safely removes all children of the node.
		// node: DOMNode|String
		//		a reference to a DOM node or an id.
		// example:
		//		Destroy node's children byId:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.empty("someId");
		//	|	});

		_empty(dom.byId(node));
	};


	function _destroy(/*DomNode*/ node, /*DomNode*/ parent){
		// in IE quirks, node.canHaveChildren can be false but firstChild can be non-null (OBJECT/APPLET)
		if(node.firstChild){
			_empty(node);
		}
		if(parent){
			// removeNode(false) doesn't leak in IE 6+, but removeChild() and removeNode(true) are known to leak under IE 8- while 9+ is TBD.
			// In IE quirks mode, PARAM nodes as children of OBJECT/APPLET nodes have a removeNode method that does nothing and
			// the parent node has canHaveChildren=false even though removeChild correctly removes the PARAM children.
			// In IE, SVG/strict nodes don't have a removeNode method nor a canHaveChildren boolean.
			has("ie") && parent.canHaveChildren && "removeNode" in node ? node.removeNode(false) : parent.removeChild(node);
		}
	}
	var destroy = exports.destroy = function destroy(/*DOMNode|String*/ node){
		// summary:
		//		Removes a node from its parent, clobbering it and all of its
		//		children.
		//
		// description:
		//		Removes a node from its parent, clobbering it and all of its
		//		children. Function only works with DomNodes, and returns nothing.
		//
		// node: DOMNode|String
		//		A String ID or DomNode reference of the element to be destroyed
		//
		// example:
		//		Destroy a node byId:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.destroy("someId");
		//	|	});

		node = dom.byId(node);
		if(!node){ return; }
		_destroy(node, node.parentNode);
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/dom-form.js":
/*!***************************************!*\
  !*** ./node_modules/dojo/dom-form.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ./dom */ "./node_modules/dojo/dom.js"), __webpack_require__(/*! ./io-query */ "./node_modules/dojo/io-query.js"), __webpack_require__(/*! ./json */ "./node_modules/dojo/json.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang, dom, ioq, json){
	// module:
	//		dojo/dom-form

    function setValue(/*Object*/ obj, /*String*/ name, /*String*/ value){
        // summary:
        //		For the named property in object, set the value. If a value
        //		already exists and it is a string, convert the value to be an
        //		array of values.

        // Skip it if there is no value
        if(value === null){
            return;
        }

        var val = obj[name];
        if(typeof val == "string"){ // inline'd type check
            obj[name] = [val, value];
        }else if(lang.isArray(val)){
            val.push(value);
        }else{
            obj[name] = value;
        }
    }

	var exclude = "file|submit|image|reset|button";

	var form = {
		// summary:
		//		This module defines form-processing functions.

		fieldToObject: function fieldToObject(/*DOMNode|String*/ inputNode){
			// summary:
			//		Serialize a form field to a JavaScript object.
			// description:
			//		Returns the value encoded in a form field as
			//		as a string or an array of strings. Disabled form elements
			//		and unchecked radio and checkboxes are skipped.	Multi-select
			//		elements are returned as an array of string values.
			// inputNode: DOMNode|String
			// returns: Object

			var ret = null;
			inputNode = dom.byId(inputNode);
			if(inputNode){
				var _in = inputNode.name, type = (inputNode.type || "").toLowerCase();
				if(_in && type && !inputNode.disabled){
					if(type == "radio" || type == "checkbox"){
						if(inputNode.checked){
							ret = inputNode.value;
						}
					}else if(inputNode.multiple){
						ret = [];
						var nodes = [inputNode.firstChild];
						while(nodes.length){
							for(var node = nodes.pop(); node; node = node.nextSibling){
								if(node.nodeType == 1 && node.tagName.toLowerCase() == "option"){
									if(node.selected){
										ret.push(node.value);
									}
								}else{
									if(node.nextSibling){
										nodes.push(node.nextSibling);
									}
									if(node.firstChild){
										nodes.push(node.firstChild);
									}
									break;
								}
							}
						}
					}else{
						ret = inputNode.value;
					}
				}
			}
			return ret; // Object
		},

		toObject: function formToObject(/*DOMNode|String*/ formNode){
			// summary:
			//		Serialize a form node to a JavaScript object.
			// description:
			//		Returns the values encoded in an HTML form as
			//		string properties in an object which it then returns. Disabled form
			//		elements, buttons, and other non-value form elements are skipped.
			//		Multi-select elements are returned as an array of string values.
			// formNode: DOMNode|String
			// example:
			//		This form:
			//		|	<form id="test_form">
			//		|		<input type="text" name="blah" value="blah">
			//		|		<input type="text" name="no_value" value="blah" disabled>
			//		|		<input type="button" name="no_value2" value="blah">
			//		|		<select type="select" multiple name="multi" size="5">
			//		|			<option value="blah">blah</option>
			//		|			<option value="thud" selected>thud</option>
			//		|			<option value="thonk" selected>thonk</option>
			//		|		</select>
			//		|	</form>
			//
			//		yields this object structure as the result of a call to
			//		formToObject():
			//
			//		|	{
			//		|		blah: "blah",
			//		|		multi: [
			//		|			"thud",
			//		|			"thonk"
			//		|		]
			//		|	};

			var ret = {}, elems = dom.byId(formNode).elements;
			for(var i = 0, l = elems.length; i < l; ++i){
				var item = elems[i], _in = item.name, type = (item.type || "").toLowerCase();
				if(_in && type && exclude.indexOf(type) < 0 && !item.disabled){
					setValue(ret, _in, form.fieldToObject(item));
					if(type == "image"){
						ret[_in + ".x"] = ret[_in + ".y"] = ret[_in].x = ret[_in].y = 0;
					}
				}
			}
			return ret; // Object
		},

		toQuery: function formToQuery(/*DOMNode|String*/ formNode){
			// summary:
			//		Returns a URL-encoded string representing the form passed as either a
			//		node or string ID identifying the form to serialize
			// formNode: DOMNode|String
			// returns: String

			return ioq.objectToQuery(form.toObject(formNode)); // String
		},

		toJson: function formToJson(/*DOMNode|String*/ formNode, /*Boolean?*/ prettyPrint){
			// summary:
			//		Create a serialized JSON string from a form node or string
			//		ID identifying the form to serialize
			// formNode: DOMNode|String
			// prettyPrint: Boolean?
			// returns: String

			return json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0); // String
		}
	};

    return form;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/dom-geometry.js":
/*!*******************************************!*\
  !*** ./node_modules/dojo/dom-geometry.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./sniff */ "./node_modules/dojo/sniff.js"), __webpack_require__(/*! ./_base/window */ "./node_modules/dojo/_base/window.js"),__webpack_require__(/*! ./dom */ "./node_modules/dojo/dom.js"), __webpack_require__(/*! ./dom-style */ "./node_modules/dojo/dom-style.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has, win, dom, style){
	// module:
	//		dojo/dom-geometry

	// the result object
	var geom = {
		// summary:
		//		This module defines the core dojo DOM geometry API.
	};

	// Box functions will assume this model.
	// On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.
	// Can be set to change behavior of box setters.

	// can be either:
	//	"border-box"
	//	"content-box" (default)
	geom.boxModel = "content-box";

	// We punt per-node box mode testing completely.
	// If anybody cares, we can provide an additional (optional) unit
	// that overrides existing code to include per-node box sensitivity.

	// Opera documentation claims that Opera 9 uses border-box in BackCompat mode.
	// but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.
	// IIRC, earlier versions of Opera did in fact use border-box.
	// Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.

	if(has("ie") /*|| has("opera")*/){
		// client code may have to adjust if compatMode varies across iframes
		geom.boxModel = document.compatMode == "BackCompat" ? "border-box" : "content-box";
	}

	geom.getPadExtents = function getPadExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		Returns object with special values specifically useful for node
		//		fitting.
		// description:
		//		Returns an object with `w`, `h`, `l`, `t` properties:
		//	|		l/t/r/b = left/top/right/bottom padding (respectively)
		//	|		w = the total of the left and right padding
		//	|		h = the total of the top and bottom padding
		//		If 'node' has position, l/t forms the origin for child nodes.
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
			l = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	var none = "none";

	geom.getBorderExtents = function getBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object with properties useful for noting the border
		//		dimensions.
		// description:
		//		- l/t/r/b = the sum of left/top/right/bottom border (respectively)
		//		- w = the sum of the left and right border
		//		- h = the sum of the top and bottom border
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node),
			l = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0,
			t = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0,
			r = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0,
			b = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	geom.getPadBorderExtents = function getPadBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		Returns object with properties useful for box fitting with
		//		regards to padding.
		// description:
		//		- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
		//		- w = the sum of the left and right padding and border
		//		- h = the sum of the top and bottom padding and border
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node),
			p = geom.getPadExtents(node, s),
			b = geom.getBorderExtents(node, s);
		return {
			l: p.l + b.l,
			t: p.t + b.t,
			r: p.r + b.r,
			b: p.b + b.b,
			w: p.w + b.w,
			h: p.h + b.h
		};
	};

	geom.getMarginExtents = function getMarginExtents(node, computedStyle){
		// summary:
		//		returns object with properties useful for box fitting with
		//		regards to box margins (i.e., the outer-box).
		//
		//		- l/t = marginLeft, marginTop, respectively
		//		- w = total width, margin inclusive
		//		- h = total height, margin inclusive
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
			l = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	// Box getters work in any box context because offsetWidth/clientWidth
	// are invariant wrt box context
	//
	// They do *not* work for display: inline objects that have padding styles
	// because the user agent ignores padding (it's bogus styling in any case)
	//
	// Be careful with IMGs because they are inline or block depending on
	// browser and browser mode.

	// Although it would be easier to read, there are not separate versions of
	// _getMarginBox for each browser because:
	// 1. the branching is not expensive
	// 2. factoring the shared code wastes cycles (function call overhead)
	// 3. duplicating the shared code wastes bytes

	geom.getMarginBox = function getMarginBox(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object that encodes the width, height, left and top
		//		positions of the node's margin box.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s),
			l = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;

		if((has("ie") == 8 && !has("quirks"))){
			// IE 8 offsetLeft/Top includes the parent's border
			if(p){
				pcs = style.getComputedStyle(p);
				l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
				t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
			}
		}
		return {l: l, t: t, w: node.offsetWidth + me.w, h: node.offsetHeight + me.h};
	};

	geom.getContentBox = function getContentBox(node, computedStyle){
		// summary:
		//		Returns an object that encodes the width, height, left and top
		//		positions of the node's content box, irrespective of the
		//		current box model.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		// clientWidth/Height are important since the automatically account for scrollbars
		// fallback to offsetWidth/Height for special cases (see #3378)
		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h,
			pe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s), l = node.offsetLeft + pe.l + be.l,
			t = node.offsetTop + pe.t + be.t;
		if(!w){
			w = node.offsetWidth - be.w;
			h = node.offsetHeight - be.h;
		}else{
			h = node.clientHeight;
		}

		if((has("ie") == 8 && !has("quirks"))){
			// IE 8 offsetLeft/Top includes the parent's border
			var p = node.parentNode, px = style.toPixelValue, pcs;
			if(p){
				pcs = style.getComputedStyle(p);
				l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
				t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
			}
		}

		return {l: l, t: t, w: w - pe.w, h: h - pe.h};
	};

	// Box setters depend on box context because interpretation of width/height styles
	// vary wrt box context.
	//
	// The value of boxModel is used to determine box context.
	// boxModel can be set directly to change behavior.
	//
	// Beware of display: inline objects that have padding styles
	// because the user agent ignores padding (it's a bogus setup anyway)
	//
	// Be careful with IMGs because they are inline or block depending on
	// browser and browser mode.
	//
	// Elements other than DIV may have special quirks, like built-in
	// margins or padding, or values not detectable via computedStyle.
	// In particular, margins on TABLE do not seems to appear
	// at all in computedStyle on Mozilla.

	function setBox(/*DomNode*/ node, /*Number?*/ l, /*Number?*/ t, /*Number?*/ w, /*Number?*/ h, /*String?*/ u){
		// summary:
		//		sets width/height/left/top in the current (native) box-model
		//		dimensions. Uses the unit passed in u.
		// node:
		//		DOM Node reference. Id string not supported for performance
		//		reasons.
		// l:
		//		left offset from parent.
		// t:
		//		top offset from parent.
		// w:
		//		width in current box model.
		// h:
		//		width in current box model.
		// u:
		//		unit measure to use for other measures. Defaults to "px".
		u = u || "px";
		var s = node.style;
		if(!isNaN(l)){
			s.left = l + u;
		}
		if(!isNaN(t)){
			s.top = t + u;
		}
		if(w >= 0){
			s.width = w + u;
		}
		if(h >= 0){
			s.height = h + u;
		}
	}

	function isButtonTag(/*DomNode*/ node){
		// summary:
		//		True if the node is BUTTON or INPUT.type="button".
		return node.tagName.toLowerCase() == "button" ||
			node.tagName.toLowerCase() == "input" && (node.getAttribute("type") || "").toLowerCase() == "button"; // boolean
	}

	function usesBorderBox(/*DomNode*/ node){
		// summary:
		//		True if the node uses border-box layout.

		// We could test the computed style of node to see if a particular box
		// has been specified, but there are details and we choose not to bother.

		// TABLE and BUTTON (and INPUT type=button) are always border-box by default.
		// If you have assigned a different box to either one via CSS then
		// box functions will break.

		return geom.boxModel == "border-box" || node.tagName.toLowerCase() == "table" || isButtonTag(node); // boolean
	}

	geom.setContentSize = function setContentSize(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
		// summary:
		//		Sets the size of the node's contents, irrespective of margins,
		//		padding, or borders.
		// node: DOMNode
		// box: Object
		//		hash with optional "w", and "h" properties for "width", and "height"
		//		respectively. All specified properties should have numeric values in whole pixels.
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var w = box.w, h = box.h;
		if(usesBorderBox(node)){
			var pb = geom.getPadBorderExtents(node, computedStyle);
			if(w >= 0){
				w += pb.w;
			}
			if(h >= 0){
				h += pb.h;
			}
		}
		setBox(node, NaN, NaN, w, h);
	};

	var nilExtents = {l: 0, t: 0, w: 0, h: 0};

	geom.setMarginBox = function setMarginBox(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
		// summary:
		//		sets the size of the node's margin box and placement
		//		(left/top), irrespective of box model. Think of it as a
		//		passthrough to setBox that handles box-model vagaries for
		//		you.
		// node: DOMNode
		// box: Object
		//		hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"
		//		respectively. All specified properties should have numeric values in whole pixels.
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,
		// Some elements have special padding, margin, and box-model settings.
		// To use box functions you may need to set padding, margin explicitly.
		// Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.
			pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),
			mb = geom.getMarginExtents(node, s);
		if(has("webkit")){
			// on Safari (3.1.2), button nodes with no explicit size have a default margin
			// setting an explicit size eliminates the margin.
			// We have to swizzle the width to get correct margin reading.
			if(isButtonTag(node)){
				var ns = node.style;
				if(w >= 0 && !ns.width){
					ns.width = "4px";
				}
				if(h >= 0 && !ns.height){
					ns.height = "4px";
				}
			}
		}
		if(w >= 0){
			w = Math.max(w - pb.w - mb.w, 0);
		}
		if(h >= 0){
			h = Math.max(h - pb.h - mb.h, 0);
		}
		setBox(node, box.l, box.t, w, h);
	};

	// =============================
	// Positioning
	// =============================

	geom.isBodyLtr = function isBodyLtr(/*Document?*/ doc){
		// summary:
		//		Returns true if the current language is left-to-right, and false otherwise.
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Boolean

		doc = doc || win.doc;
		return (win.body(doc).dir || doc.documentElement.dir || "ltr").toLowerCase() == "ltr"; // Boolean
	};

	geom.docScroll = function docScroll(/*Document?*/ doc){
		// summary:
		//		Returns an object with {node, x, y} with corresponding offsets.
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Object

		doc = doc || win.doc;
		var node = win.doc.parentWindow || win.doc.defaultView;   // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem
		return "pageXOffset" in node ? {x: node.pageXOffset, y: node.pageYOffset } :
			(node = has("quirks") ? win.body(doc) : doc.documentElement) &&
				{x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc), y: node.scrollTop || 0 };
	};

	geom.getIeDocumentElementOffset = function(/*Document?*/ doc){
		// summary:
		//		Deprecated method previously used for IE6-IE7.  Now, just returns `{x:0, y:0}`.
		return {
			x: 0,
			y: 0
		};
	};

	geom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(/*Integer*/ scrollLeft, /*Document?*/ doc){
		// summary:
		//		In RTL direction, scrollLeft should be a negative value, but IE
		//		returns a positive one. All codes using documentElement.scrollLeft
		//		must call this function to fix this error, otherwise the position
		//		will offset to right when there is a horizontal scrollbar.
		// scrollLeft: Number
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Number

		// In RTL direction, scrollLeft should be a negative value, but IE
		// returns a positive one. All codes using documentElement.scrollLeft
		// must call this function to fix this error, otherwise the position
		// will offset to right when there is a horizontal scrollbar.

		doc = doc || win.doc;
		var ie = has("ie");
		if(ie && !geom.isBodyLtr(doc)){
			var qk = has("quirks"),
				de = qk ? win.body(doc) : doc.documentElement,
				pwin = win.global;	// TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js
			if(ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight){
				scrollLeft += de.clientLeft; // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels
			}
			return (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft; // Integer
		}
		return scrollLeft; // Integer
	};

	geom.position = function(/*DomNode*/ node, /*Boolean?*/ includeScroll){
		// summary:
		//		Gets the position and size of the passed element relative to
		//		the viewport (if includeScroll==false), or relative to the
		//		document root (if includeScroll==true).
		//
		// description:
		//		Returns an object of the form:
		//		`{ x: 100, y: 300, w: 20, h: 15 }`.
		//		If includeScroll==true, the x and y values will include any
		//		document offsets that may affect the position relative to the
		//		viewport.
		//		Uses the border-box model (inclusive of border and padding but
		//		not margin).  Does not act as a setter.
		// node: DOMNode|String
		// includeScroll: Boolean?
		// returns: Object

		node = dom.byId(node);
		var	db = win.body(node.ownerDocument),
			ret = node.getBoundingClientRect();
		ret = {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};

		if(has("ie") < 9){
			// fixes the position in IE, quirks mode
			ret.x -= (has("quirks") ? db.clientLeft + db.offsetLeft : 0);
			ret.y -= (has("quirks") ? db.clientTop + db.offsetTop : 0);
		}

		// account for document scrolling
		// if offsetParent is used, ret value already includes scroll position
		// so we may have to actually remove that value if !includeScroll
		if(includeScroll){
			var scroll = geom.docScroll(node.ownerDocument);
			ret.x += scroll.x;
			ret.y += scroll.y;
		}

		return ret; // Object
	};

	// random "private" functions wildly used throughout the toolkit

	geom.getMarginSize = function getMarginSize(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object that encodes the width and height of
		//		the node's margin box
		// node: DOMNode|String
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
		var size = node.getBoundingClientRect();
		return {
			w: (size.right - size.left) + me.w,
			h: (size.bottom - size.top) + me.h
		};
	};

	geom.normalizeEvent = function(event){
		// summary:
		//		Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
		//		offsetX, offsetY, layerX, and layerX properties
		// event: Object
		if(!("layerX" in event)){
			event.layerX = event.offsetX;
			event.layerY = event.offsetY;
		}

		if(!("pageX" in event)){
			// FIXME: scroll position query is duped from dojo/_base/html to
			// avoid dependency on that entire module. Now that HTML is in
			// Base, we should convert back to something similar there.
			var se = event.target;
			var doc = (se && se.ownerDocument) || document;
			// DO NOT replace the following to use dojo/_base/window.body(), in IE, document.documentElement should be used
			// here rather than document.body
			var docBody = has("quirks") ? doc.body : doc.documentElement;
			event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc);
			event.pageY = event.clientY + (docBody.scrollTop || 0);
		}
	};

	// TODO: evaluate separate getters/setters for position and sizes?

	return geom;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/dom-prop.js":
/*!***************************************!*\
  !*** ./node_modules/dojo/dom-prop.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./sniff */ "./node_modules/dojo/sniff.js"), __webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ./dom */ "./node_modules/dojo/dom.js"), __webpack_require__(/*! ./dom-style */ "./node_modules/dojo/dom-style.js"), __webpack_require__(/*! ./dom-construct */ "./node_modules/dojo/dom-construct.js"), __webpack_require__(/*! ./_base/connect */ "./node_modules/dojo/_base/connect.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(exports, dojo, has, lang, dom, style, ctr, conn){
	// module:
	//		dojo/dom-prop
	// summary:
	//		This module defines the core dojo DOM properties API.

	// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

	// =============================
	// Element properties Functions
	// =============================

	// helper to connect events
	var _evtHdlrMap = {}, _ctr = 1, _attrId = dojo._scopeName + "attrid";
	has.add('dom-textContent', function (global, doc, element) { return 'textContent' in element; });

	exports.names = {
		// properties renamed to avoid clashes with reserved words
		"class": "className",
		"for": "htmlFor",
		// properties written as camelCase
		tabindex: "tabIndex",
		readonly: "readOnly",
		colspan: "colSpan",
		frameborder: "frameBorder",
		rowspan: "rowSpan",
		textcontent: "textContent",
		valuetype: "valueType"
	};
	
	function getText(/*DOMNode*/node){
		// summary:
		//		recursion method for get('textContent') to use. Gets text value for a node.
		// description:
		//		Juse uses nodedValue so things like <br/> tags do not end up in
		//		the text as any sort of line return.
		var text = "", ch = node.childNodes;
		for(var i = 0, n; n = ch[i]; i++){
			//Skip comments.
			if(n.nodeType != 8){
				if(n.nodeType == 1){
					text += getText(n);
				}else{
					text += n.nodeValue;
				}
			}
		}
		return text;
	}

	exports.get = function getProp(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Gets a property on an HTML element.
		// description:
		//		Handles normalized getting of properties on DOM nodes.
		//
		// node: DOMNode|String
		//		id or reference to the element to get the property on
		// name: String
		//		the name of the property to get.
		// returns:
		//		the value of the requested property or its default value
		//
		// example:
		//	|	// get the current value of the "foo" property on a node
		//	|	require(["dojo/dom-prop", "dojo/dom"], function(domProp, dom){
		//	|		domProp.get(dom.byId("nodeId"), "foo");
		//	|		// or we can just pass the id:
		//	|		domProp.get("nodeId", "foo");
		//	|	});

		node = dom.byId(node);
		var lc = name.toLowerCase(), propName = exports.names[lc] || name;
		
		if(propName == "textContent" && !has("dom-textContent")){
			return getText(node);
		}
		
		return node[propName];	// Anything
	};

	exports.set = function setProp(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets a property on an HTML element.
		// description:
		//		Handles normalized setting of properties on DOM nodes.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to set the property on
		// name: String|Object
		//		the name of the property to set, or a hash object to set
		//		multiple properties at once.
		// value: String?
		//		The value to set for the property
		// returns:
		//		the DOM node
		//
		// example:
		//	|	// use prop() to set the tab index
		//	|	require(["dojo/dom-prop"], function(domProp){
		//	|		domProp.set("nodeId", "tabIndex", 3);
		//	|	});
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	require(["dojo/dom-prop"], function(domProp){
		//	|		domProp.set("formId", {
		//	|			"foo": "bar",
		//	|			"tabIndex": -1,
		//	|			"method": "POST",
		//	|		});
		//	|	});

		node = dom.byId(node);
		var l = arguments.length;
		if(l == 2 && typeof name != "string"){ // inline'd type check
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){
				exports.set(node, x, name[x]);
			}
			return node; // DomNode
		}
		var lc = name.toLowerCase(), propName = exports.names[lc] || name;
		if(propName == "style" && typeof value != "string"){ // inline'd type check
			// special case: setting a style
			style.set(node, value);
			return node; // DomNode
		}
		if(propName == "innerHTML"){
			// special case: assigning HTML
			// the hash lists elements with read-only innerHTML on IE
			if(has("ie") && node.tagName.toLowerCase() in {col: 1, colgroup: 1,
						table: 1, tbody: 1, tfoot: 1, thead: 1, tr: 1, title: 1}){
				ctr.empty(node);
				node.appendChild(ctr.toDom(value, node.ownerDocument));
			}else{
				node[propName] = value;
			}
			return node; // DomNode
		}
		if(propName == "textContent" && !has("dom-textContent")) {
			ctr.empty(node);
			node.appendChild(node.ownerDocument.createTextNode(value));
			return node;
		}
		if(lang.isFunction(value)){
			// special case: assigning an event handler
			// clobber if we can
			var attrId = node[_attrId];
			if(!attrId){
				attrId = _ctr++;
				node[_attrId] = attrId;
			}
			if(!_evtHdlrMap[attrId]){
				_evtHdlrMap[attrId] = {};
			}
			var h = _evtHdlrMap[attrId][propName];
			if(h){
				//h.remove();
				conn.disconnect(h);
			}else{
				try{
					delete node[propName];
				}catch(e){}
			}
			// ensure that event objects are normalized, etc.
			if(value){
				//_evtHdlrMap[attrId][propName] = on(node, propName, value);
				_evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);
			}else{
				node[propName] = null;
			}
			return node; // DomNode
		}
		node[propName] = value;
		return node;	// DomNode
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/dom-style.js":
/*!****************************************!*\
  !*** ./node_modules/dojo/dom-style.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./sniff */ "./node_modules/dojo/sniff.js"), __webpack_require__(/*! ./dom */ "./node_modules/dojo/dom.js"), __webpack_require__(/*! ./_base/window */ "./node_modules/dojo/_base/window.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has, dom, win){
	// module:
	//		dojo/dom-style

	// =============================
	// Style Functions
	// =============================

	// getComputedStyle drives most of the style code.
	// Wherever possible, reuse the returned object.
	//
	// API functions below that need to access computed styles accept an
	// optional computedStyle parameter.
	// If this parameter is omitted, the functions will call getComputedStyle themselves.
	// This way, calling code can access computedStyle once, and then pass the reference to
	// multiple API functions.

	// Although we normally eschew argument validation at this
	// level, here we test argument 'node' for (duck)type,
	// by testing nodeType, ecause 'document' is the 'parentNode' of 'body'
	// it is frequently sent to this function even
	// though it is not Element.
	var getComputedStyle, style = {
		// summary:
		//		This module defines the core dojo DOM style API.
	};
	if(has("webkit")){
		getComputedStyle = function(/*DomNode*/ node){
			var s;
			if(node.nodeType == 1){
				var dv = node.ownerDocument.defaultView;
				s = dv.getComputedStyle(node, null);
				if(!s && node.style){
					node.style.display = "";
					s = dv.getComputedStyle(node, null);
				}
			}
			return s || {};
		};
	}else if(has("ie") && (has("ie") < 9 || has("quirks"))){
		getComputedStyle = function(node){
			// IE (as of 7) doesn't expose Element like sane browsers
			// currentStyle can be null on IE8!
			return node.nodeType == 1 /* ELEMENT_NODE*/ && node.currentStyle ? node.currentStyle : {};
		};
	}else{
		getComputedStyle = function(node){
			if(node.nodeType === 1 /* ELEMENT_NODE*/){
				var dv = node.ownerDocument.defaultView,
					w = dv.opener ? dv : win.global.window;
				return w.getComputedStyle(node, null);
			}
			return {};
		};
	}
	style.getComputedStyle = getComputedStyle;
	/*=====
	style.getComputedStyle = function(node){
		// summary:
		//		Returns a "computed style" object.
		//
		// description:
		//		Gets a "computed style" object which can be used to gather
		//		information about the current state of the rendered node.
		//
		//		Note that this may behave differently on different browsers.
		//		Values may have different formats and value encodings across
		//		browsers.
		//
		//		Note also that this method is expensive.  Wherever possible,
		//		reuse the returned object.
		//
		//		Use the dojo/dom-style.get() method for more consistent (pixelized)
		//		return values.
		//
		// node: DOMNode
		//		A reference to a DOM node. Does NOT support taking an
		//		ID string for speed reasons.
		// example:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.getComputedStyle(dom.byId('foo')).borderWidth;
		//	|	});
		//
		// example:
		//		Reusing the returned object, avoiding multiple lookups:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		var cs = domStyle.getComputedStyle(dom.byId("someNode"));
		//	|		var w = cs.width, h = cs.height;
		//	|	});
		return; // CSS2Properties
	};
	=====*/

	var toPixel;
	if(!has("ie")){
		toPixel = function(element, value){
			// style values can be floats, client code may want
			// to round for integer pixels.
			return parseFloat(value) || 0;
		};
	}else{
		toPixel = function(element, avalue){
			if(!avalue){ return 0; }
			// on IE7, medium is usually 4 pixels
			if(avalue == "medium"){ return 4; }
			// style values can be floats, client code may
			// want to round this value for integer pixels.
			if(avalue.slice && avalue.slice(-2) == 'px'){ return parseFloat(avalue); }
			var s = element.style, rs = element.runtimeStyle, cs = element.currentStyle,
				sLeft = s.left, rsLeft = rs.left;
			rs.left = cs.left;
			try{
				// 'avalue' may be incompatible with style.left, which can cause IE to throw
				// this has been observed for border widths using "thin", "medium", "thick" constants
				// those particular constants could be trapped by a lookup
				// but perhaps there are more
				s.left = avalue;
				avalue = s.pixelLeft;
			}catch(e){
				avalue = 0;
			}
			s.left = sLeft;
			rs.left = rsLeft;
			return avalue;
		};
	}
	style.toPixelValue = toPixel;
	/*=====
	style.toPixelValue = function(node, value){
		// summary:
		//		converts style value to pixels on IE or return a numeric value.
		// node: DOMNode
		// value: String
		// returns: Number
	};
	=====*/

	// FIXME: there opacity quirks on FF that we haven't ported over. Hrm.

	var astr = "DXImageTransform.Microsoft.Alpha";
	var af = function(n, f){
		try{
			return n.filters.item(astr);
		}catch(e){
			return f ? {} : null;
		}
	};

	var _getOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(node){
			try{
				return af(node).Opacity / 100; // Number
			}catch(e){
				return 1; // Number
			}
		} :
		function(node){
			return getComputedStyle(node).opacity;
		};

	var _setOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(/*DomNode*/ node, /*Number*/ opacity){
			if(opacity === ""){ opacity = 1; }
			var ov = opacity * 100, fullyOpaque = opacity === 1;

			// on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),
			// but still update the opacity value so we can get a correct reading if it is read later:
			// af(node, 1).Enabled = !fullyOpaque;

			if(fullyOpaque){
				node.style.zoom = "";
				if(af(node)){
					node.style.filter = node.style.filter.replace(
						new RegExp("\\s*progid:" + astr + "\\([^\\)]+?\\)", "i"), "");
				}
			}else{
				node.style.zoom = 1;
				if(af(node)){
					af(node, 1).Opacity = ov;
				}else{
					node.style.filter += " progid:" + astr + "(Opacity=" + ov + ")";
				}
				af(node, 1).Enabled = true;
			}

			if(node.tagName.toLowerCase() == "tr"){
				for(var td = node.firstChild; td; td = td.nextSibling){
					if(td.tagName.toLowerCase() == "td"){
						_setOpacity(td, opacity);
					}
				}
			}
			return opacity;
		} :
		function(node, opacity){
			return node.style.opacity = opacity;
		};

	var _pixelNamesCache = {
		left: true, top: true
	};
	var _pixelRegExp = /margin|padding|width|height|max|min|offset/; // |border
	function _toStyleValue(node, type, value){
		//TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!
		type = type.toLowerCase();

		// Adjustments for IE and Edge
		if(value == "auto"){
			if(type == "height"){ return node.offsetHeight; }
			if(type == "width"){ return node.offsetWidth; }
		}
		if(type == "fontweight"){
			switch(value){
				case 700: return "bold";
				case 400:
				default: return "normal";
			}
		}

		if(!(type in _pixelNamesCache)){
			_pixelNamesCache[type] = _pixelRegExp.test(type);
		}
		return _pixelNamesCache[type] ? toPixel(node, value) : value;
	}

	var _floatAliases = {cssFloat: 1, styleFloat: 1, "float": 1};

	// public API

	style.get = function getStyle(/*DOMNode|String*/ node, /*String?*/ name){
		// summary:
		//		Accesses styles on a node.
		// description:
		//		Getting the style value uses the computed style for the node, so the value
		//		will be a calculated value, not just the immediate node.style value.
		//		Also when getting values, use specific style names,
		//		like "borderBottomWidth" instead of "border" since compound values like
		//		"border" are not necessarily reflected as expected.
		//		If you want to get node dimensions, use `dojo/dom-geometry.getMarginBox()`,
		//		`dojo/dom-geometry.getContentBox()` or `dojo/dom-geometry.getPosition()`.
		// node: DOMNode|String
		//		id or reference to node to get style for
		// name: String?
		//		the style property to get
		// example:
		//		Passing only an ID or node returns the computed style object of
		//		the node:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger");
		//	|	});
		// example:
		//		Passing a node and a style property returns the current
		//		normalized, computed value for that property:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger", "opacity"); // 1 by default
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		if(l == 2 && op){
			return _getOpacity(n);
		}
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		var s = style.getComputedStyle(n);
		return (l == 1) ? s : _toStyleValue(n, name, s[name] || n.style[name]); /* CSS2Properties||String||Number */
	};

	style.set = function setStyle(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets styles on a node.
		// node: DOMNode|String
		//		id or reference to node to set style for
		// name: String|Object
		//		the style property to set in DOM-accessor format
		//		("borderWidth", not "border-width") or an object with key/value
		//		pairs suitable for setting each property.
		// value: String?
		//		If passed, sets value on the node for style, handling
		//		cross-browser concerns.  When setting a pixel value,
		//		be sure to include "px" in the value. For instance, top: "200px".
		//		Otherwise, in some cases, some browsers will not apply the style.
		//
		// example:
		//		Passing a node, a style property, and a value changes the
		//		current display of the node and returns the new computed value
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", "opacity", 0.5); // == 0.5
		//	|	});
		//
		// example:
		//		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", {
		//	|			"opacity": 0.5,
		//	|			"border": "3px solid black",
		//	|			"height": "300px"
		//	|		});
		//	|	});
		//
		// example:
		//		When the CSS style property is hyphenated, the JavaScript property is camelCased.
		//		font-size becomes fontSize, and so on.
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.set("thinger",{
		//	|			fontSize:"14pt",
		//	|			letterSpacing:"1.2em"
		//	|		});
		//	|	});
		//
		// example:
		//		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
		//		dojo/dom-style.get() on every element of the list. See: `dojo/query` and `dojo/NodeList`
		//	|	require(["dojo/dom-style", "dojo/query", "dojo/NodeList-dom"],
		//	|	function(domStyle, query){
		//	|		query(".someClassName").style("visibility","hidden");
		//	|		// or
		//	|		query("#baz > div").style({
		//	|			opacity:0.75,
		//	|			fontSize:"13pt"
		//	|		});
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		if(l == 3){
			return op ? _setOpacity(n, value) : n.style[name] = value; // Number
		}
		for(var x in name){
			style.set(node, x, name[x]);
		}
		return style.getComputedStyle(n);
	};

	return style;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/dom.js":
/*!**********************************!*\
  !*** ./node_modules/dojo/dom.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./sniff */ "./node_modules/dojo/sniff.js"), __webpack_require__(/*! ./_base/window */ "./node_modules/dojo/_base/window.js"), __webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has, win, kernel){
	// module:
	//		dojo/dom

	// FIXME: need to add unit tests for all the semi-public methods

	if(has("ie") <= 7){
		try{
			document.execCommand("BackgroundImageCache", false, true);
		}catch(e){
			// sane browsers don't have cache "issues"
		}
	}

	// =============================
	// DOM Functions
	// =============================

	// the result object
	var dom = {
		// summary:
		//		This module defines the core dojo DOM API.
	};

	if(has("ie")){
		dom.byId = function(id, doc){
			if(typeof id != "string"){
				return id || null;
			}
			var _d = doc || win.doc, te = id && _d.getElementById(id);
			// attributes.id.value is better than just id in case the
			// user has a name=id inside a form
			if(te && (te.attributes.id.value == id || te.id == id)){
				return te;
			}else{
				var eles = _d.all[id];
				if(!eles || eles.nodeName){
					eles = [eles];
				}
				// if more than 1, choose first with the correct id
				var i = 0;
				while((te = eles[i++])){
					if((te.attributes && te.attributes.id && te.attributes.id.value == id) || te.id == id){
						return te;
					}
				}
			}
			return null;
		};
	}else{
		dom.byId = function(id, doc){
			// inline'd type check.
			// be sure to return null per documentation, to match IE branch.
			return ((typeof id == "string") ? (doc || win.doc).getElementById(id) : id) || null; // DOMNode
		};
	}
	/*=====
	 dom.byId = function(id, doc){
		// summary:
		//		Returns DOM node with matching `id` attribute or falsy value (ex: null or undefined)
		//		if not found.  If `id` is a DomNode, this function is a no-op.
		//
		// id: String|DOMNode
		//		A string to match an HTML id attribute or a reference to a DOM Node
		//
		// doc: Document?
		//		Document to work in. Defaults to the current value of
		//		dojo/_base/window.doc.  Can be used to retrieve
		//		node references from other documents.
		//
		// example:
		//		Look up a node by ID:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("foo");
		//	|	});
		//
		// example:
		//		Check if a node exists, and use it.
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("bar");
		//	|		if(n){ doStuff() ... }
		//	|	});
		//
		// example:
		//		Allow string or DomNode references to be passed to a custom function:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var foo = function(nodeOrId){
		//	|			nodeOrId = dom.byId(nodeOrId);
		//	|			// ... more stuff
		//	|		}
		//	|	});
	 };
	 =====*/

	// Test for DOMNode.contains() method, available everywhere except FF8-
	// and IE8-, where it's available in general, but not on document itself,
	// and also problems when either ancestor or node are text nodes.

	var doc = kernel.global["document"] || null;
	has.add("dom-contains", !!(doc && doc.contains));
	dom.isDescendant = has("dom-contains") ?
		// FF9+, IE9+, webkit, opera, iOS, Android, Edge, etc.
		function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
			return !!( (ancestor = dom.byId(ancestor)) && ancestor.contains(dom.byId(node)) );
		} :
		function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
			// summary:
			//		Returns true if node is a descendant of ancestor
			// node: DOMNode|String
			//		string id or node reference to test
			// ancestor: DOMNode|String
			//		string id or node reference of potential parent to test against
			//
			// example:
			//		Test is node id="bar" is a descendant of node id="foo"
			//	|	require(["dojo/dom"], function(dom){
			//	|		if(dom.isDescendant("bar", "foo")){ ... }
			//	|	});

			try{
				node = dom.byId(node);
				ancestor = dom.byId(ancestor);
				while(node){
					if(node == ancestor){
						return true; // Boolean
					}
					node = node.parentNode;
				}
			}catch(e){ /* squelch, return false */ }
			return false; // Boolean
		};

	// TODO: do we need setSelectable in the base?

	// Add feature test for user-select CSS property
	// (currently known to work in all but IE < 10 and Opera)
	// TODO: The user-select CSS property as of May 2014 is no longer part of
	// any CSS specification. In IE, -ms-user-select does not do the same thing
	// as the unselectable attribute on elements; namely, dijit Editor buttons
	// do not properly prevent the content of the editable content frame from
	// unblurring. As a result, the -ms- prefixed version is omitted here.
	has.add("css-user-select", function(global, doc, element){
		// Avoid exception when dom.js is loaded in non-browser environments
		if(!element){ return false; }

		var style = element.style;
		var prefixes = ["Khtml", "O", "Moz", "Webkit"],
			i = prefixes.length,
			name = "userSelect",
			prefix;

		// Iterate prefixes from most to least likely
		do{
			if(typeof style[name] !== "undefined"){
				// Supported; return property name
				return name;
			}
		}while(i-- && (name = prefixes[i] + "UserSelect"));

		// Not supported if we didn't return before now
		return false;
	});

	/*=====
	dom.setSelectable = function(node, selectable){
		// summary:
		//		Enable or disable selection on a node
		// node: DOMNode|String
		//		id or reference to node
		// selectable: Boolean
		//		state to put the node in. false indicates unselectable, true
		//		allows selection.
		// example:
		//		Make the node id="bar" unselectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar");
		//	|	});
		// example:
		//		Make the node id="bar" selectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar", true);
		//	|	});
	};
	=====*/

	var cssUserSelect = has("css-user-select");
	dom.setSelectable = cssUserSelect ? function(node, selectable){
		// css-user-select returns a (possibly vendor-prefixed) CSS property name
		dom.byId(node).style[cssUserSelect] = selectable ? "" : "none";
	} : function(node, selectable){
		node = dom.byId(node);

		// (IE < 10 / Opera) Fall back to setting/removing the
		// unselectable attribute on the element and all its children
		var nodes = node.getElementsByTagName("*"),
			i = nodes.length;

		if(selectable){
			node.removeAttribute("unselectable");
			while(i--){
				nodes[i].removeAttribute("unselectable");
			}
		}else{
			node.setAttribute("unselectable", "on");
			while(i--){
				nodes[i].setAttribute("unselectable", "on");
			}
		}
	};

	return dom;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/domReady.js":
/*!***************************************!*\
  !*** ./node_modules/dojo/domReady.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./global */ "./node_modules/dojo/global.js"), __webpack_require__(/*! ./has */ "./node_modules/dojo/has.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(global, has){
	var doc = document,
		readyStates = { 'loaded': 1, 'complete': 1 },
		fixReadyState = typeof doc.readyState != "string",
		ready = !!readyStates[doc.readyState],
		readyQ = [],
		recursiveGuard;

	function domReady(callback){
		// summary:
		//		Plugin to delay require()/define() callback from firing until the DOM has finished loading.
		readyQ.push(callback);
		if(ready){ processQ(); }
	}
	domReady.load = function(id, req, load){
		domReady(load);
	};

	// Export queue so that ready() can check if it's empty or not.
	domReady._Q = readyQ;
	domReady._onQEmpty = function(){
		// summary:
		//		Private method overridden by dojo/ready, to notify when everything in the
		//		domReady queue has been processed.  Do not use directly.
		//		Will be removed in 2.0, along with domReady._Q.
	};

	// For FF <= 3.5
	if(fixReadyState){ doc.readyState = "loading"; }

	function processQ(){
		// Calls all functions in the queue in order, unless processQ() is already running, in which case just return

		if(recursiveGuard){ return; }
		recursiveGuard = true;

		while(readyQ.length){
			try{
				(readyQ.shift())(doc);
			}catch(err){
				console.error(err, "in domReady callback", err.stack);
			}
		}

		recursiveGuard = false;

		// Notification for dojo/ready.  Remove for 2.0.
		// Note that this could add more tasks to the ready queue.
		domReady._onQEmpty();
	}

	if(!ready){
		var tests = [],
			detectReady = function(evt){
				evt = evt || global.event;
				if(ready || (evt.type == "readystatechange" && !readyStates[doc.readyState])){ return; }

				// For FF <= 3.5
				if(fixReadyState){ doc.readyState = "complete"; }

				ready = 1;
				processQ();
			},
			on = function(node, event){
				node.addEventListener(event, detectReady, false);
				readyQ.push(function(){ node.removeEventListener(event, detectReady, false); });
			};

		if(!has("dom-addeventlistener")){
			on = function(node, event){
				event = "on" + event;
				node.attachEvent(event, detectReady);
				readyQ.push(function(){ node.detachEvent(event, detectReady); });
			};

			var div = doc.createElement("div");
			try{
				if(div.doScroll && global.frameElement === null){
					// the doScroll test is only useful if we're in the top-most frame
					tests.push(function(){
						// Derived with permission from Diego Perini's IEContentLoaded
						// http://javascript.nwbox.com/IEContentLoaded/
						try{
							div.doScroll("left");
							return 1;
						}catch(e){}
					});
				}
			}catch(e){}
		}

		on(doc, "DOMContentLoaded");
		on(global, "load");

		if("onreadystatechange" in doc){
			on(doc, "readystatechange");
		}else if(!fixReadyState){
			// if the ready state property exists and there's
			// no readystatechange event, poll for the state
			// to change
			tests.push(function(){
				return readyStates[doc.readyState];
			});
		}

		if(tests.length){
			var poller = function(){
				if(ready){ return; }
				var i = tests.length;
				while(i--){
					if(tests[i]()){
						detectReady("poller");
						return;
					}
				}
				setTimeout(poller, 30);
			};
			poller();
		}
	}

	return domReady;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/errors/CancelError.js":
/*!*************************************************!*\
  !*** ./node_modules/dojo/errors/CancelError.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./create */ "./node_modules/dojo/errors/create.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(create){
	// module:
	//		dojo/errors/CancelError

	/*=====
	return function(){
		// summary:
		//		Default error if a promise is canceled without a reason.
	};
	=====*/

	return create("CancelError", null, null, { dojoType: "cancel", log: false });
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/errors/RequestError.js":
/*!**************************************************!*\
  !*** ./node_modules/dojo/errors/RequestError.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./create */ "./node_modules/dojo/errors/create.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(create){
	// module:
	//		dojo/errors/RequestError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestError", function(message, response){
		this.response = response;
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/errors/RequestTimeoutError.js":
/*!*********************************************************!*\
  !*** ./node_modules/dojo/errors/RequestTimeoutError.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./create */ "./node_modules/dojo/errors/create.js"), __webpack_require__(/*! ./RequestError */ "./node_modules/dojo/errors/RequestError.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(create, RequestError){
	// module:
	//		dojo/errors/RequestTimeoutError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestTimeoutError", null, RequestError, {
		dojoType: "timeout"
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/errors/create.js":
/*!********************************************!*\
  !*** ./node_modules/dojo/errors/create.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../_base/lang */ "./node_modules/dojo/_base/lang.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang){
	return function(name, ctor, base, props){
		base = base || Error;

		var ErrorCtor = function(message){
			if(base === Error){
				if(Error.captureStackTrace){
					Error.captureStackTrace(this, ErrorCtor);
				}

				// Error.call() operates on the returned error
				// object rather than operating on |this|
				var err = Error.call(this, message),
					prop;

				// Copy own properties from err to |this|
				for(prop in err){
					if(err.hasOwnProperty(prop)){
						this[prop] = err[prop];
					}
				}

				// messsage is non-enumerable in ES5
				this.message = message;
				// stack is non-enumerable in at least Firefox
				this.stack = err.stack;
			}else{
				base.apply(this, arguments);
			}
			if(ctor){
				ctor.apply(this, arguments);
			}
		};

		ErrorCtor.prototype = lang.delegate(base.prototype, props);
		ErrorCtor.prototype.name = name;
		ErrorCtor.prototype.constructor = ErrorCtor;

		return ErrorCtor;
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/global.js":
/*!*************************************!*\
  !*** ./node_modules/dojo/global.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){
    if (typeof global !== 'undefined' && typeof global !== 'function') {
        // global spec defines a reference to the global object called 'global'
        // https://github.com/tc39/proposal-global
        // `global` is also defined in NodeJS
        return global;
    }
    else if (typeof window !== 'undefined') {
        // window is defined in browsers
        return window;
    }
    else if (typeof self !== 'undefined') {
        // self is defined in WebWorkers
        return self;
    }
    return this;
}).call(null, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/has.js":
/*!**********************************!*\
  !*** ./node_modules/dojo/has.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./global */ "./node_modules/dojo/global.js"), __webpack_require__.dj.c(module.i), __webpack_require__.dj.m(module)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(global, require, module){
	// module:
	//		dojo/has
	// summary:
	//		Defines the has.js API and several feature tests used by dojo.
	// description:
	//		This module defines the has API as described by the project has.js with the following additional features:
	//
	//		- the has test cache is exposed at has.cache.
	//		- the method has.add includes a forth parameter that controls whether or not existing tests are replaced
	//		- the loader's has cache may be optionally copied into this module's has cahce.
	//
	//		This module adopted from https://github.com/phiggins42/has.js; thanks has.js team!

	// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one
	// if using a foreign loader, then the has cache may be initialized via the config object for this module
	// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail
	var has = require.has || function(){};
	if(!has("dojo-has-api")){
		var
			isBrowser =
				// the most fundamental decision: are we in the browser?
				typeof window != "undefined" &&
				typeof location != "undefined" &&
				typeof document != "undefined" &&
				window.location == location && window.document == document,

			// has API variables
			doc = isBrowser && document,
			element = doc && doc.createElement("DiV"),
			cache = (module.config && module.config()) || {};

		has = function(name){
			// summary:
			//		Return the current value of the named feature.
			//
			// name: String|Integer
			//		The name (if a string) or identifier (if an integer) of the feature to test.
			//
			// description:
			//		Returns the value of the feature named by name. The feature must have been
			//		previously added to the cache by has.add.

			return typeof cache[name] == "function" ? (cache[name] = cache[name](global, doc, element)) : cache[name]; // Boolean
		};

		has.cache = cache;

		has.add = function(name, test, now, force){
			// summary:
			//	 	Register a new feature test for some named feature.
			// name: String|Integer
			//	 	The name (if a string) or identifier (if an integer) of the feature to test.
			// test: Function
			//		 A test function to register. If a function, queued for testing until actually
			//		 needed. The test function should return a boolean indicating
			//	 	the presence of a feature or bug.
			// now: Boolean?
			//		 Optional. Omit if `test` is not a function. Provides a way to immediately
			//		 run the test and cache the result.
			// force: Boolean?
			//	 	Optional. If the test already exists and force is truthy, then the existing
			//	 	test will be replaced; otherwise, add does not replace an existing test (that
			//	 	is, by default, the first test advice wins).
			// example:
			//		A redundant test, testFn with immediate execution:
			//	|	has.add("javascript", function(){ return true; }, true);
			//
			// example:
			//		Again with the redundantness. You can do this in your tests, but we should
			//		not be doing this in any internal has.js tests
			//	|	has.add("javascript", true);
			//
			// example:
			//		Three things are passed to the testFunction. `global`, `document`, and a generic element
			//		from which to work your test should the need arise.
			//	|	has.add("bug-byid", function(g, d, el){
			//	|		// g	== global, typically window, yadda yadda
			//	|		// d	== document object
			//	|		// el == the generic element. a `has` element.
			//	|		return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
			//	|	});

			(typeof cache[name]=="undefined" || force) && (cache[name]= test);
			return now && has(name);
		};

		// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize
		// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder
		// can optimize these away iff desired
		has.add("host-browser", isBrowser);
		has.add("host-node", (typeof process == "object" && process.versions && process.versions.node && process.versions.v8));
		has.add("host-rhino", (typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object")));
		has.add("dom", isBrowser);
		has.add("dojo-dom-ready-api", 1);
		has.add("dojo-sniff", 1);
	}

	if(has("host-browser")){
		// Common application level tests
		has.add("dom-addeventlistener", !!document.addEventListener);

		// Do the device and browser have touch capability?
		has.add("touch", "ontouchstart" in document
			|| ("onpointerdown" in document && navigator.maxTouchPoints > 0)
			|| window.navigator.msMaxTouchPoints);

		// Touch events support
		has.add("touch-events", "ontouchstart" in document);

		// Test if pointer events are supported and enabled, with either standard names ("pointerdown" etc.) or
		// IE specific names ("MSPointerDown" etc.).  Tests are designed to work on embedded C# WebBrowser Controls
		// in addition to IE, Edge, and future versions of Firefox and Chrome.
		// Note that on IE11, has("pointer-events") and has("MSPointer") are both true.
		has.add("pointer-events", "pointerEnabled" in window.navigator ?
				window.navigator.pointerEnabled : "PointerEvent" in window);
		has.add("MSPointer", window.navigator.msPointerEnabled);
		// The "pointermove"" event is only continuously emitted in a touch environment if
		// the target node's "touch-action"" CSS property is set to "none"
		// https://www.w3.org/TR/pointerevents/#the-touch-action-css-property
		has.add("touch-action", has("touch") && has("pointer-events"));

		// I don't know if any of these tests are really correct, just a rough guess
		has.add("device-width", screen.availWidth || innerWidth);

		// Tests for DOMNode.attributes[] behavior:
		//	 - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes
		//	 - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify
		//	 - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.
		var form = document.createElement("form");
		has.add("dom-attributes-explicit", form.attributes.length == 0); // W3C
		has.add("dom-attributes-specified-flag", form.attributes.length > 0 && form.attributes.length < 40);	// IE8
	}

	has.clearElement = function(element){
		// summary:
		//	 Deletes the contents of the element passed to test functions.
		element.innerHTML= "";
		return element;
	};

	has.normalize = function(id, toAbsMid){
		// summary:
		//	 Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
		//
		// toAbsMid: Function
		//	 Resolves a relative module id into an absolute module id
		var
			tokens = id.match(/[\?:]|[^:\?]*/g), i = 0,
			get = function(skip){
				var term = tokens[i++];
				if(term == ":"){
					// empty string module name, resolves to 0
					return 0;
				}else{
					// postfixed with a ? means it is a feature to branch on, the term is the name of the feature
					if(tokens[i++] == "?"){
						if(!skip && has(term)){
							// matched the feature, get the first value from the options
							return get();
						}else{
							// did not match, get the second value, passing over the first
							get(true);
							return get(skip);
						}
					}
					// a module
					return term || 0;
				}
			};
		id = get();
		return id && toAbsMid(id);
	};

	has.load = function(id, parentRequire, loaded){
		// summary:
		//		Conditional loading of AMD modules based on a has feature test value.
		// id: String
		//		Gives the resolved module id to load.
		// parentRequire: Function
		//		The loader require function with respect to the module that contained the plugin resource in it's
		//		dependency list.
		// loaded: Function
		//	 Callback to loader that consumes result of plugin demand.

		if(id){
			parentRequire([id], loaded);
		}else{
			loaded();
		}
	};

	return has;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/hccss.js":
/*!************************************!*\
  !*** ./node_modules/dojo/hccss.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__.dj.c(module.i),			// require, require.toUrl
	__webpack_require__(/*! ./_base/config */ "./node_modules/dojo/_base/config.js"), // config.blankGif
	__webpack_require__(/*! ./dom-class */ "./node_modules/dojo/dom-class.js"), // domClass.add
	__webpack_require__(/*! ./dom-style */ "./node_modules/dojo/dom-style.js"), // domStyle.getComputedStyle
	__webpack_require__(/*! ./has */ "./node_modules/dojo/has.js"),
	__webpack_require__(/*! ./domReady */ "./node_modules/dojo/domReady.js"),
	__webpack_require__(/*! ./_base/window */ "./node_modules/dojo/_base/window.js") // win.body
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(require, config, domClass, domStyle, has, domReady, win){

	// module:
	//		dojo/hccss

	/*=====
	return function(){
		// summary:
		//		Test if computer is in high contrast mode (i.e. if browser is not displaying background images).
		//		Defines `has("highcontrast")` and sets `dj_a11y` CSS class on `<body>` if machine is in high contrast mode.
		//		Returns `has()` method;
	};
	=====*/

	// Has() test for when background images aren't displayed.  Don't call has("highcontrast") before dojo/domReady!.
	has.add("highcontrast", function(){
		// note: if multiple documents, doesn't matter which one we use
		var div = win.doc.createElement("div");
		try{
			div.style.cssText = "border: 1px solid; border-color:red green; position: absolute; height: 5px; top: -999px;" +
				"background-image: url(\"" + (config.blankGif || require.toUrl("./resources/blank.gif")) + "\");";
			win.body().appendChild(div);

			var cs = domStyle.getComputedStyle(div),
				bkImg = cs.backgroundImage;
			return cs.borderTopColor == cs.borderRightColor ||
				(bkImg && (bkImg == "none" || bkImg == "url(invalid-url:)" ));
		}catch(e){
			console.warn("hccss: exception detecting high-contrast mode, document is likely hidden: " + e.toString());
			return false;
		}finally{
			if(has("ie") <= 8){
				div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
			}else{
				win.body().removeChild(div);
			}
		}
	});

	domReady(function(){
		if(has("highcontrast")){
			domClass.add(win.body(), "dj_a11y");
		}
	});

	return has;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/i18n.js":
/*!***********************************!*\
  !*** ./node_modules/dojo/i18n.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__.dj.c(module.i), __webpack_require__(/*! ./has */ "./node_modules/dojo/has.js"), __webpack_require__(/*! ./_base/array */ "./node_modules/dojo/_base/array.js"), __webpack_require__(/*! ./_base/config */ "./node_modules/dojo/_base/config.js"), __webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ./_base/xhr */ "./node_modules/dojo/_base/xhr.js"), __webpack_require__(/*! ./json */ "./node_modules/dojo/json.js"), __webpack_require__.dj.m(module)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, require, has, array, config, lang, xhr, json, module){

	// module:
	//		dojo/i18n

	has.add("dojo-preload-i18n-Api",
		// if true, define the preload localizations machinery
		1
	);

	has.add("dojo-v1x-i18n-Api",
		// if true, define the v1.x i18n functions
		1
	);

	var
		thisModule = dojo.i18n =
			{
				// summary:
				//		This module implements the dojo/i18n! plugin and the v1.6- i18n API
				// description:
				//		We choose to include our own plugin to leverage functionality already contained in dojo
				//		and thereby reduce the size of the plugin compared to various loader implementations. Also, this
				//		allows foreign AMD loaders to be used without their plugins.
			},

		nlsRe =
			// regexp for reconstructing the master bundle name from parts of the regexp match
			// nlsRe.exec("foo/bar/baz/nls/en-ca/foo") gives:
			// ["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]
			// nlsRe.exec("foo/bar/baz/nls/foo") gives:
			// ["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]
			// so, if match[5] is blank, it means this is the top bundle definition.
			// courtesy of http://requirejs.org
			/(^.*(^|\/)nls)(\/|$)([^\/]*)\/?([^\/]*)/,

		getAvailableLocales = function(
			root,
			locale,
			bundlePath,
			bundleName
		){
			// summary:
			//		return a vector of module ids containing all available locales with respect to the target locale
			//		For example, assuming:
			//
			//		- the root bundle indicates specific bundles for "fr" and "fr-ca",
			//		-  bundlePath is "myPackage/nls"
			//		- bundleName is "myBundle"
			//
			//		Then a locale argument of "fr-ca" would return
			//
			//			["myPackage/nls/myBundle", "myPackage/nls/fr/myBundle", "myPackage/nls/fr-ca/myBundle"]
			//
			//		Notice that bundles are returned least-specific to most-specific, starting with the root.
			//
			//		If root===false indicates we're working with a pre-AMD i18n bundle that doesn't tell about the available locales;
			//		therefore, assume everything is available and get 404 errors that indicate a particular localization is not available

			for(var result = [bundlePath + bundleName], localeParts = locale.split("-"), current = "", i = 0; i<localeParts.length; i++){
				current += (current ? "-" : "") + localeParts[i];
				if(!root || root[current]){
					result.push(bundlePath + current + "/" + bundleName);
					result.specificity = current;
				}
			}
			return result;
		},

		cache = {},

		getBundleName = function(moduleName, bundleName, locale){
			locale = locale ? locale.toLowerCase() : dojo.locale;
			moduleName = moduleName.replace(/\./g, "/");
			bundleName = bundleName.replace(/\./g, "/");
			return (/root/i.test(locale)) ?
				(moduleName + "/nls/" + bundleName) :
				(moduleName + "/nls/" + locale + "/" + bundleName);
		},

		getL10nName = dojo.getL10nName = function(moduleName, bundleName, locale){
			return moduleName = module.id + "!" + getBundleName(moduleName, bundleName, locale);
		},

		doLoad = function(require, bundlePathAndName, bundlePath, bundleName, locale, load){
			// summary:
			//		get the root bundle which instructs which other bundles are required to construct the localized bundle
			require([bundlePathAndName], function(root){
				var current = lang.clone(root.root || root.ROOT),// 1.6 built bundle defined ROOT
					availableLocales = getAvailableLocales(!root._v1x && root, locale, bundlePath, bundleName);
				require(availableLocales, function(){
					for (var i = 1; i<availableLocales.length; i++){
						current = lang.mixin(lang.clone(current), arguments[i]);
					}
					// target may not have been resolve (e.g., maybe only "fr" exists when "fr-ca" was requested)
					var target = bundlePathAndName + "/" + locale;
					cache[target] = current;
					current.$locale = availableLocales.specificity;
					load();
				});
			});
		},

		normalize = function(id, toAbsMid){
			// summary:
			//		id may be relative.
			//		preload has form `*preload*<path>/nls/<module>*<flattened locales>` and
			//		therefore never looks like a relative
			return /^\./.test(id) ? toAbsMid(id) : id;
		},

		getLocalesToLoad = function(targetLocale){
			var list = config.extraLocale || [];
			list = lang.isArray(list) ? list : [list];
			list.push(targetLocale);
			return list;
		},

		load = function(id, require, load){
			// summary:
			//		id is in one of the following formats
			//
			//		1. <path>/nls/<bundle>
			//			=> load the bundle, localized to config.locale; load all bundles localized to
			//			config.extraLocale (if any); return the loaded bundle localized to config.locale.
			//
			//		2. <path>/nls/<locale>/<bundle>
			//			=> load then return the bundle localized to <locale>
			//
			//		3. *preload*<path>/nls/<module>*<JSON array of available locales>
			//			=> for config.locale and all config.extraLocale, load all bundles found
			//			in the best-matching bundle rollup. A value of 1 is returned, which
			//			is meaningless other than to say the plugin is executing the requested
			//			preloads
			//
			//		In cases 1 and 2, <path> is always normalized to an absolute module id upon entry; see
			//		normalize. In case 3, it <path> is assumed to be absolute; this is arranged by the builder.
			//
			//		To load a bundle means to insert the bundle into the plugin's cache and publish the bundle
			//		value to the loader. Given <path>, <bundle>, and a particular <locale>, the cache key
			//
			//			<path>/nls/<bundle>/<locale>
			//
			//		will hold the value. Similarly, then plugin will publish this value to the loader by
			//
			//			define("<path>/nls/<bundle>/<locale>", <bundle-value>);
			//
			//		Given this algorithm, other machinery can provide fast load paths be preplacing
			//		values in the plugin's cache, which is public. When a load is demanded the
			//		cache is inspected before starting any loading. Explicitly placing values in the plugin
			//		cache is an advanced/experimental feature that should not be needed; use at your own risk.
			//
			//		For the normal AMD algorithm, the root bundle is loaded first, which instructs the
			//		plugin what additional localized bundles are required for a particular locale. These
			//		additional locales are loaded and a mix of the root and each progressively-specific
			//		locale is returned. For example:
			//
			//		1. The client demands "dojo/i18n!some/path/nls/someBundle
			//
			//		2. The loader demands load(some/path/nls/someBundle)
			//
			//		3. This plugin require's "some/path/nls/someBundle", which is the root bundle.
			//
			//		4. Assuming config.locale is "ab-cd-ef" and the root bundle indicates that localizations
			//		are available for "ab" and "ab-cd-ef" (note the missing "ab-cd", then the plugin
			//		requires "some/path/nls/ab/someBundle" and "some/path/nls/ab-cd-ef/someBundle"
			//
			//		5. Upon receiving all required bundles, the plugin constructs the value of the bundle
			//		ab-cd-ef as...
			//
			//				mixin(mixin(mixin({}, require("some/path/nls/someBundle"),
			//		  			require("some/path/nls/ab/someBundle")),
			//					require("some/path/nls/ab-cd-ef/someBundle"));
			//
			//		This value is inserted into the cache and published to the loader at the
			//		key/module-id some/path/nls/someBundle/ab-cd-ef.
			//
			//		The special preload signature (case 3) instructs the plugin to stop servicing all normal requests
			//		(further preload requests will be serviced) until all ongoing preloading has completed.
			//
			//		The preload signature instructs the plugin that a special rollup module is available that contains
			//		one or more flattened, localized bundles. The JSON array of available locales indicates which locales
			//		are available. Here is an example:
			//
			//			*preload*some/path/nls/someModule*["root", "ab", "ab-cd-ef"]
			//
			//		This indicates the following rollup modules are available:
			//
			//			some/path/nls/someModule_ROOT
			//			some/path/nls/someModule_ab
			//			some/path/nls/someModule_ab-cd-ef
			//
			//		Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.
			//		For example, assume someModule contained the bundles some/bundle/path/someBundle and
			//		some/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:
			//
			//			define({
			//				some/bundle/path/someBundle:<value of someBundle, flattened with respect to locale ab>,
			//				some/bundle/path/someOtherBundle:<value of someOtherBundle, flattened with respect to locale ab>,
			//			});
			//
			//		E.g., given this design, preloading for locale=="ab" can execute the following algorithm:
			//
			//			require(["some/path/nls/someModule_ab"], function(rollup){
			//				for(var p in rollup){
			//					var id = p + "/ab",
			//					cache[id] = rollup[p];
			//					define(id, rollup[p]);
			//				}
			//			});
			//
			//		Similarly, if "ab-cd" is requested, the algorithm can determine that "ab" is the best available and
			//		load accordingly.
			//
			//		The builder will write such rollups for every layer if a non-empty localeList  profile property is
			//		provided. Further, the builder will include the following cache entry in the cache associated with
			//		any layer.
			//
			//			"*now":function(r){r(['dojo/i18n!*preload*<path>/nls/<module>*<JSON array of available locales>']);}
			//
			//		The *now special cache module instructs the loader to apply the provided function to context-require
			//		with respect to the particular layer being defined. This causes the plugin to hold all normal service
			//		requests until all preloading is complete.
			//
			//		Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case
			//		where the target locale has a single segment and a layer depends on a single bundle:
			//
			//		Without Preloads:
			//
			//		1. Layer loads root bundle.
			//		2. bundle is demanded; plugin loads single localized bundle.
			//
			//		With Preloads:
			//
			//		1. Layer causes preloading of target bundle.
			//		2. bundle is demanded; service is delayed until preloading complete; bundle is returned.
			//
			//		In each case a single transaction is required to load the target bundle. In cases where multiple bundles
			//		are required and/or the locale has multiple segments, preloads still requires a single transaction whereas
			//		the normal path requires an additional transaction for each additional bundle/locale-segment. However all
			//		of these additional transactions can be done concurrently. Owing to this analysis, the entire preloading
			//		algorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.

			var match = nlsRe.exec(id),
				bundlePath = match[1] + "/",
				bundleName = match[5] || match[4],
				bundlePathAndName = bundlePath + bundleName,
				localeSpecified = (match[5] && match[4]),
				targetLocale =	localeSpecified || dojo.locale || "",
				loadTarget = bundlePathAndName + "/" + targetLocale,
				loadList = localeSpecified ? [targetLocale] : getLocalesToLoad(targetLocale),
				remaining = loadList.length,
				finish = function(){
					if(!--remaining){
						load(lang.delegate(cache[loadTarget]));
					}
				},
				split = id.split("*"),
				preloadDemand = split[1] == "preload";

			if(has("dojo-preload-i18n-Api")){
				if(preloadDemand){
					if(!cache[id]){
						// use cache[id] to prevent multiple preloads of the same preload; this shouldn't happen, but
						// who knows what over-aggressive human optimizers may attempt
						cache[id] = 1;
						preloadL10n(split[2], json.parse(split[3]), 1, require);
					}
					// don't stall the loader!
					load(1);
				}
				if(preloadDemand || (waitForPreloads(id, require, load) && !cache[loadTarget])){
					return;
				}
			}
			else if (preloadDemand) {
				// If a build is created with nls resources and 'dojo-preload-i18n-Api' has not been set to false,
				// the built file will include a preload in the cache (which looks about like so:)
				// '*now':function(r){r(['dojo/i18n!*preload*dojo/nls/dojo*["ar","ca","cs","da","de","el","en-gb","en-us","es-es","fi-fi","fr-fr","he-il","hu","it-it","ja-jp","ko-kr","nl-nl","nb","pl","pt-br","pt-pt","ru","sk","sl","sv","th","tr","zh-tw","zh-cn","ROOT"]']);}
				// If the consumer of the build sets 'dojo-preload-i18n-Api' to false in the Dojo config, the cached
				// preload will not be parsed and will result in an attempt to call 'require' passing it the unparsed
				// preload, which is not a valid module id.
				// In this case we should skip this request.
				load(1);

				return;
			}

			array.forEach(loadList, function(locale){
				var target = bundlePathAndName + "/" + locale;
				if(has("dojo-preload-i18n-Api")){
					checkForLegacyModules(target);
				}
				if(!cache[target]){
					doLoad(require, bundlePathAndName, bundlePath, bundleName, locale, finish);
				}else{
					finish();
				}
			});
		};

	if(has("dojo-preload-i18n-Api") || has("dojo-v1x-i18n-Api")){
		var normalizeLocale = thisModule.normalizeLocale = function(locale){
				var result = locale ? locale.toLowerCase() : dojo.locale;
				return result == "root" ? "ROOT" : result;
			},

			isXd = function(mid, contextRequire){
				return (has("dojo-sync-loader") && has("dojo-v1x-i18n-Api")) ?
					contextRequire.isXdUrl(require.toUrl(mid + ".js")) :
					true;
			},

			preloading = 0,

			preloadWaitQueue = [],

			preloadL10n = thisModule._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated, /*boolean?*/ guaranteedAmdFormat, /*function?*/ contextRequire){
				// summary:
				//		Load available flattened resource bundles associated with a particular module for dojo/locale and all dojo/config.extraLocale (if any)
				// description:
				//		Only called by built layer files. The entire locale hierarchy is loaded. For example,
				//		if locale=="ab-cd", then ROOT, "ab", and "ab-cd" are loaded. This is different than v1.6-
				//		in that the v1.6- would only load ab-cd...which was *always* flattened.
				//
				//		If guaranteedAmdFormat is true, then the module can be loaded with require thereby circumventing the detection algorithm
				//		and the extra possible extra transaction.

				// If this function is called from legacy code, then guaranteedAmdFormat and contextRequire will be undefined. Since the function
				// needs a require in order to resolve module ids, fall back to the context-require associated with this dojo/i18n module, which
				// itself may have been mapped.
				contextRequire = contextRequire || require;

				function doRequire(mid, callback){
					if(isXd(mid, contextRequire) || guaranteedAmdFormat){
						contextRequire([mid], callback);
					}else{
						syncRequire([mid], callback, contextRequire);
					}
				}

				function forEachLocale(locale, func){
					// given locale= "ab-cd-ef", calls func on "ab-cd-ef", "ab-cd", "ab", "ROOT"; stops calling the first time func returns truthy
					var parts = locale.split("-");
					while(parts.length){
						if(func(parts.join("-"))){
							return;
						}
						parts.pop();
					}
					func("ROOT");
				}

					function preloadingAddLock(){
						preloading++;
					}

					function preloadingRelLock(){
						--preloading;
						while(!preloading && preloadWaitQueue.length){
							load.apply(null, preloadWaitQueue.shift());
						}
					}

					function cacheId(path, name, loc, require){
						// path is assumed to have a trailing "/"
						return require.toAbsMid(path + name + "/" + loc)
					}

					function preload(locale){
						locale = normalizeLocale(locale);
						forEachLocale(locale, function(loc){
							if(array.indexOf(localesGenerated, loc) >= 0){
								var mid = bundlePrefix.replace(/\./g, "/") + "_" + loc;
								preloadingAddLock();
								doRequire(mid, function(rollup){
									for(var p in rollup){
										var bundle = rollup[p],
											match = p.match(/(.+)\/([^\/]+)$/),
											bundleName, bundlePath;
											
											// If there is no match, the bundle is not a regular bundle from an AMD layer.
											if (!match){continue;}

											bundleName = match[2];
											bundlePath = match[1] + "/";

										// backcompat
										if(!bundle._localized){continue;}

										var localized;
										if(loc === "ROOT"){
											var root = localized = bundle._localized;
											delete bundle._localized;
											root.root = bundle;
											cache[require.toAbsMid(p)] = root;
										}else{
											localized = bundle._localized;
											cache[cacheId(bundlePath, bundleName, loc, require)] = bundle;
										}

										if(loc !== locale){
											// capture some locale variables
											function improveBundle(bundlePath, bundleName, bundle, localized){
												// locale was not flattened and we've fallen back to a less-specific locale that was flattened
												// for example, we had a flattened 'fr', a 'fr-ca' is available for at least this bundle, and
												// locale==='fr-ca'; therefore, we must improve the bundle as retrieved from the rollup by
												// manually loading the fr-ca version of the bundle and mixing this into the already-retrieved 'fr'
												// version of the bundle.
												//
												// Remember, different bundles may have different sets of locales available.
												//
												// we are really falling back on the regular algorithm here, but--hopefully--starting with most
												// of the required bundles already on board as given by the rollup and we need to "manually" load
												// only one locale from a few bundles...or even better...we won't find anything better to load.
												// This algorithm ensures there is nothing better to load even when we can only load a less-specific rollup.
												//
												// note: this feature is only available in async mode

												// inspect the loaded bundle that came from the rollup to see if something better is available
												// for any bundle in a rollup, more-specific available locales are given at localized.
												var requiredBundles = [],
													cacheIds = [];
												forEachLocale(locale, function(loc){
													if(localized[loc]){
														requiredBundles.push(require.toAbsMid(bundlePath + loc + "/" + bundleName));
														cacheIds.push(cacheId(bundlePath, bundleName, loc, require));
													}
												});

												if(requiredBundles.length){
													preloadingAddLock();
													contextRequire(requiredBundles, function(){
														// requiredBundles was constructed by forEachLocale so it contains locales from 
														// less specific to most specific. 
														// the loop starts with the most specific locale, the last one.
														for(var i = requiredBundles.length - 1; i >= 0 ; i--){
															bundle = lang.mixin(lang.clone(bundle), arguments[i]);
															cache[cacheIds[i]] = bundle;
														}
														// this is the best possible (maybe a perfect match, maybe not), accept it
														cache[cacheId(bundlePath, bundleName, locale, require)] = lang.clone(bundle);
														preloadingRelLock();
													});
												}else{
													// this is the best possible (definitely not a perfect match), accept it
													cache[cacheId(bundlePath, bundleName, locale, require)] = bundle;
												}
											}
											improveBundle(bundlePath, bundleName, bundle, localized);
										}
									}
									preloadingRelLock();
								});
								return true;
							}
							return false;
						});
					}

				preload();
				array.forEach(dojo.config.extraLocale, preload);
			},

			waitForPreloads = function(id, require, load){
				if(preloading){
					preloadWaitQueue.push([id, require, load]);
				}
				return preloading;
			},

			checkForLegacyModules = function()
				{};
	}

	if(has("dojo-v1x-i18n-Api")){
		// this code path assumes the dojo loader and won't work with a standard AMD loader
		var amdValue = {},
			l10nCache = {},
			evalBundle,

			syncRequire = function(deps, callback, require){
				var results = [];
				array.forEach(deps, function(mid){
					var url = require.toUrl(mid + ".js");

					function load(text){
						if (!evalBundle) {
							// use the function ctor to keep the minifiers away (also come close to global scope, but this is secondary)
							evalBundle = new Function(
								"__bundle",				   // the bundle to evalutate
								"__checkForLegacyModules", // a function that checks if __bundle defined __mid in the global space
								"__mid",				   // the mid that __bundle is intended to define
								"__amdValue",

								// returns one of:
								//		1 => the bundle was an AMD bundle
								//		a legacy bundle object that is the value of __mid
								//		instance of Error => could not figure out how to evaluate bundle

								// used to detect when __bundle calls define
								"var define = function(mid, factory){define.called = 1; __amdValue.result = factory || mid;},"
								+ "	   require = function(){define.called = 1;};"

								+ "try{"
								+		"define.called = 0;"
								+		"eval(__bundle);"
								+		"if(define.called==1)"
											// bundle called define; therefore signal it's an AMD bundle
								+			"return __amdValue;"

								+		"if((__checkForLegacyModules = __checkForLegacyModules(__mid)))"
											// bundle was probably a v1.6- built NLS flattened NLS bundle that defined __mid in the global space
								+			"return __checkForLegacyModules;"

								+ "}catch(e){}"
								// evaulating the bundle was *neither* an AMD *nor* a legacy flattened bundle
								// either way, re-eval *after* surrounding with parentheses

								+ "try{"
								+		"return eval('('+__bundle+')');"
								+ "}catch(e){"
								+		"return e;"
								+ "}"
							);
						}
						var result = evalBundle(text, checkForLegacyModules, mid, amdValue);
						if(result===amdValue){
							// the bundle was an AMD module; re-inject it through the normal AMD path
							// we gotta do this since it could be an anonymous module and simply evaluating
							// the text here won't provide the loader with the context to know what
							// module is being defined()'d. With browser caching, this should be free; further
							// this entire code path can be circumvented by using the AMD format to begin with
							results.push(cache[url] = amdValue.result);
						}else{
							if(result instanceof Error){
								console.error("failed to evaluate i18n bundle; url=" + url, result);
								result = {};
							}
							// nls/<locale>/<bundle-name> indicates not the root.
							results.push(cache[url] = (/nls\/[^\/]+\/[^\/]+$/.test(url) ? result : {root:result, _v1x:1}));
						}
					}

					if(cache[url]){
						results.push(cache[url]);
					}else{
						var bundle = require.syncLoadNls(mid);
						// need to check for legacy module here because there might be a legacy module for a
						// less specific locale (which was not looked up during the first checkForLegacyModules
						// call in load()).
						// Also need to reverse the locale and the module name in the mid because syncRequire
						// deps parameters uses the AMD style package/nls/locale/module while legacy code uses
						// package/nls/module/locale.
						if(!bundle){
							bundle = checkForLegacyModules(mid.replace(/nls\/([^\/]*)\/([^\/]*)$/, "nls/$2/$1"));
						}
						if(bundle){
							results.push(bundle);
						}else{
							if(!xhr){
								try{
									require.getText(url, true, load);
								}catch(e){
									results.push(cache[url] = {});
								}
							}else{
								xhr.get({
									url:url,
									sync:true,
									load:load,
									error:function(){
										results.push(cache[url] = {});
									}
								});
							}
						}
					}
				});
				callback && callback.apply(null, results);
			};

		checkForLegacyModules = function(target){
			// legacy code may have already loaded [e.g] the raw bundle x/y/z at x.y.z; when true, push into the cache
			for(var result, names = target.split("/"), object = dojo.global[names[0]], i = 1; object && i<names.length-1; object = object[names[i++]]){}
			if(object){
				result = object[names[i]];
				if(!result){
					// fallback for incorrect bundle build of 1.6
					result = object[names[i].replace(/-/g,"_")];
				}
				if(result){
					cache[target] = result;
				}
			}
			return result;
		};

		thisModule.getLocalization = function(moduleName, bundleName, locale){
			var result,
				l10nName = getBundleName(moduleName, bundleName, locale);

			if (l10nCache[l10nName]) {
				return l10nCache[l10nName];
			}

			load(
				l10nName,

				// isXd() and syncRequire() need a context-require in order to resolve the mid with respect to a reference module.
				// Since this legacy function does not have the concept of a reference module, resolve with respect to this
				// dojo/i18n module, which, itself may have been mapped.
				(!isXd(l10nName, require) ? function(deps, callback){ syncRequire(deps, callback, require); } : require),

				function(result_){
					l10nCache[l10nName] = result_;
					result = result_;
				}
			);
			return result;
		};
	}

	return lang.mixin(thisModule, {
		dynamic:true,
		normalize:normalize,
		load:load,
		cache:cache,
		getL10nName: getL10nName
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/io-query.js":
/*!***************************************!*\
  !*** ./node_modules/dojo/io-query.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang){

	// module:
	//		dojo/io-query

	var backstop = {};

	return {
		// summary:
		//		This module defines query string processing functions.

		objectToQuery: function objectToQuery(/*Object*/ map){
			// summary:
			//		takes a name/value mapping object and returns a string representing
			//		a URL-encoded version of that object.
			// example:
			//		this object:
			//
			//	|	{
			//	|		blah: "blah",
			//	|		multi: [
			//	|			"thud",
			//	|			"thonk"
			//	|		]
			//	|	};
			//
			//		yields the following query string:
			//
			//	|	"blah=blah&multi=thud&multi=thonk"

			// FIXME: need to implement encodeAscii!!
			var enc = encodeURIComponent, pairs = [];
			for(var name in map){
				var value = map[name];
				if(value != backstop[name]){
					var assign = enc(name) + "=";
					if(lang.isArray(value)){
						for(var i = 0, l = value.length; i < l; ++i){
							pairs.push(assign + enc(value[i]));
						}
					}else{
						pairs.push(assign + enc(value));
					}
				}
			}
			return pairs.join("&"); // String
		},

		queryToObject: function queryToObject(/*String*/ str){
			// summary:
			//		Create an object representing a de-serialized query section of a
			//		URL. Query keys with multiple values are returned in an array.
			//
			// example:
			//		This string:
			//
			//	|		"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&"
			//
			//		results in this object structure:
			//
			//	|		{
			//	|			foo: [ "bar", "baz" ],
			//	|			thinger: " spaces =blah",
			//	|			zonk: "blarg"
			//	|		}
			//
			//		Note that spaces and other urlencoded entities are correctly
			//		handled.

        	var dec = decodeURIComponent, qp = str.split("&"), ret = {}, name, val;
			for(var i = 0, l = qp.length, item; i < l; ++i){
				item = qp[i];
				if(item.length){
					var s = item.indexOf("=");
					if(s < 0){
						name = dec(item);
						val = "";
					}else{
						name = dec(item.slice(0, s));
						val = dec(item.slice(s + 1));
					}
					if(typeof ret[name] == "string"){ // inline'd type check
						ret[name] = [ret[name]];
					}

					if(lang.isArray(ret[name])){
						ret[name].push(val);
					}else{
						ret[name] = val;
					}
				}
			}
			return ret; // Object
		}
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/dojo/json.js":
/*!***********************************!*\
  !*** ./node_modules/dojo/json.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./has */ "./node_modules/dojo/has.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has){
	"use strict";
	var hasJSON = typeof JSON != "undefined";
	has.add("json-parse", hasJSON); // all the parsers work fine
		// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184
	has.add("json-stringify", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{"a":1}');

	/*=====
	return {
		// summary:
		//		Functions to parse and serialize JSON

		parse: function(str, strict){
			// summary:
			//		Parses a [JSON](http://json.org) string to return a JavaScript object.
			// description:
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Throws for invalid JSON strings. This delegates to eval() if native JSON
			//		support is not available. By default this will evaluate any valid JS expression.
			//		With the strict parameter set to true, the parser will ensure that only
			//		valid JSON strings are parsed (otherwise throwing an error). Without the strict
			//		parameter, the content passed to this method must come
			//		from a trusted source.
			// str:
			//		a string literal of a JSON item, for instance:
			//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
			// strict:
			//		When set to true, this will ensure that only valid, secure JSON is ever parsed.
			//		Make sure this is set to true for untrusted content. Note that on browsers/engines
			//		without native JSON support, setting this to true will run slower.
		},
		stringify: function(value, replacer, spacer){
			// summary:
			//		Returns a [JSON](http://json.org) serialization of an object.
			// description:
			//		Returns a [JSON](http://json.org) serialization of an object.
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Note that this doesn't check for infinite recursion, so don't do that!
			// value:
			//		A value to be serialized.
			// replacer:
			//		A replacer function that is called for each value and can return a replacement
			// spacer:
			//		A spacer string to be used for pretty printing of JSON
			// example:
			//		simple serialization of a trivial object
			//	|	define(["dojo/json"], function(JSON){
			// 	|		var jsonStr = JSON.stringify({ howdy: "stranger!", isStrange: true });
			//	|		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
		}
	};
	=====*/

	if(has("json-stringify")){
		return JSON;
	}else{
		var escapeString = function(/*String*/str){
			// summary:
			//		Adds escape sequences for non-visual characters, double quote and
			//		backslash and surrounds with double quotes to form a valid string
			//		literal.
			return ('"' + str.replace(/(["\\])/g, '\\$1') + '"').
				replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").
				replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r"); // string
		};
		return {
			parse: has("json-parse") ? JSON.parse : function(str, strict){
				if(strict && !/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(str)){
					throw new SyntaxError("Invalid characters in JSON");
				}
				return eval('(' + str + ')');
			},
			stringify: function(value, replacer, spacer){
				var undef;
				if(typeof replacer == "string"){
					spacer = replacer;
					replacer = null;
				}
				function stringify(it, indent, key){
					if(replacer){
						it = replacer(key, it);
					}
					var val, objtype = typeof it;
					if(objtype == "number"){
						return isFinite(it) ? it + "" : "null";
					}
					if(objtype == "boolean"){
						return it + "";
					}
					if(it === null){
						return "null";
					}
					if(typeof it == "string"){
						return escapeString(it);
					}
					if(objtype == "function" || objtype == "undefined"){
						return undef; // undefined
					}
					// short-circuit for objects that support "json" serialization
					// if they return "self" then just pass-through...
					if(typeof it.toJSON == "function"){
						return stringify(it.toJSON(key), indent, key);
					}
					if(it instanceof Date){
						return '"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'.replace(/\{(\w+)(\+)?\}/g, function(t, prop, plus){
							var num = it["getUTC" + prop]() + (plus ? 1 : 0);
							return num < 10 ? "0" + num : num;
						});
					}
					if(it.valueOf() !== it){
						// primitive wrapper, try again unwrapped:
						return stringify(it.valueOf(), indent, key);
					}
					var nextIndent= spacer ? (indent + spacer) : "";
					/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ 
				
					var sep = spacer ? " " : "";
					var newLine = spacer ? "\n" : "";
				
					// array
					if(it instanceof Array){
						var itl = it.length, res = [];
						for(key = 0; key < itl; key++){
							var obj = it[key];
							val = stringify(obj, nextIndent, key);
							if(typeof val != "string"){
								val = "null";
							}
							res.push(newLine + nextIndent + val);
						}
						return "[" + res.join(",") + newLine + indent + "]";
					}
					// generic object code path
					var output = [];
					for(key in it){
						var keyStr;
						if(it.hasOwnProperty(key)){
							if(typeof key == "number"){
								keyStr = '"' + key + '"';
							}else if(typeof key == "string"){
								keyStr = escapeString(key);
							}else{
								// skip non-string or number keys
								continue;
							}
							val = stringify(it[key], nextIndent, key);
							if(typeof val != "string"){
								// skip non-serializable values
								continue;
							}
							// At this point, the most non-IE browsers don't get in this branch 
							// (they have native JSON), so push is definitely the way to
							output.push(newLine + nextIndent + keyStr + ":" + sep + val);
						}
					}
					return "{" + output.join(",") + newLine + indent + "}"; // String
				}
				return stringify(value, "", "");
			}
		};
	}
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/keys.js":
/*!***********************************!*\
  !*** ./node_modules/dojo/keys.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./sniff */ "./node_modules/dojo/sniff.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has){

	// module:
	//		dojo/keys

	return dojo.keys = {
		// summary:
		//		Definitions for common key values.  Client code should test keyCode against these named constants,
		//		as the actual codes can vary by browser.

		BACKSPACE: 8,
		TAB: 9,
		CLEAR: 12,
		ENTER: 13,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		META: has("webkit") ? 91 : 224,		// the apple key on macs
		PAUSE: 19,
		CAPS_LOCK: 20,
		ESCAPE: 27,
		SPACE: 32,
		PAGE_UP: 33,
		PAGE_DOWN: 34,
		END: 35,
		HOME: 36,
		LEFT_ARROW: 37,
		UP_ARROW: 38,
		RIGHT_ARROW: 39,
		DOWN_ARROW: 40,
		INSERT: 45,
		DELETE: 46,
		HELP: 47,
		LEFT_WINDOW: 91,
		RIGHT_WINDOW: 92,
		SELECT: 93,
		NUMPAD_0: 96,
		NUMPAD_1: 97,
		NUMPAD_2: 98,
		NUMPAD_3: 99,
		NUMPAD_4: 100,
		NUMPAD_5: 101,
		NUMPAD_6: 102,
		NUMPAD_7: 103,
		NUMPAD_8: 104,
		NUMPAD_9: 105,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_PLUS: 107,
		NUMPAD_ENTER: 108,
		NUMPAD_MINUS: 109,
		NUMPAD_PERIOD: 110,
		NUMPAD_DIVIDE: 111,
		F1: 112,
		F2: 113,
		F3: 114,
		F4: 115,
		F5: 116,
		F6: 117,
		F7: 118,
		F8: 119,
		F9: 120,
		F10: 121,
		F11: 122,
		F12: 123,
		F13: 124,
		F14: 125,
		F15: 126,
		NUM_LOCK: 144,
		SCROLL_LOCK: 145,
		UP_DPAD: 175,
		DOWN_DPAD: 176,
		LEFT_DPAD: 177,
		RIGHT_DPAD: 178,
		// virtual key mapping
		copyKey: has("mac") && !has("air") ? (has("safari") ? 91 : 224 ) : 17
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/mouse.js":
/*!************************************!*\
  !*** ./node_modules/dojo/mouse.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./on */ "./node_modules/dojo/on.js"), __webpack_require__(/*! ./has */ "./node_modules/dojo/has.js"), __webpack_require__(/*! ./dom */ "./node_modules/dojo/dom.js"), __webpack_require__(/*! ./_base/window */ "./node_modules/dojo/_base/window.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, on, has, dom, win){

	// module:
	//		dojo/mouse

    has.add("dom-quirks", win.doc && win.doc.compatMode == "BackCompat");
	has.add("events-mouseenter", win.doc && "onmouseenter" in win.doc.createElement("div"));
	has.add("events-mousewheel", win.doc && 'onmousewheel' in win.doc);

	var mouseButtons;
	if((has("dom-quirks") && has("ie")) || !has("dom-addeventlistener")){
		mouseButtons = {
			LEFT:   1,
			MIDDLE: 4,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button & button; },
			isLeft:   function(e){ return e.button & 1; },
			isMiddle: function(e){ return e.button & 4; },
			isRight:  function(e){ return e.button & 2; }
		};
	}else{
		mouseButtons = {
			LEFT:   0,
			MIDDLE: 1,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button == button; },
			isLeft:   function(e){ return e.button == 0; },
			isMiddle: function(e){ return e.button == 1; },
			isRight:  function(e){ return e.button == 2; }
		};
	}
	dojo.mouseButtons = mouseButtons;

/*=====
	dojo.mouseButtons = {
		// LEFT: Number
		//		Numeric value of the left mouse button for the platform.
		LEFT:   0,
		// MIDDLE: Number
		//		Numeric value of the middle mouse button for the platform.
		MIDDLE: 1,
		// RIGHT: Number
		//		Numeric value of the right mouse button for the platform.
		RIGHT:  2,

		isButton: function(e, button){
			// summary:
			//		Checks an event object for a pressed button
			// e: Event
			//		Event object to examine
			// button: Number
			//		The button value (example: dojo.mouseButton.LEFT)
			return e.button == button; // Boolean
		},
		isLeft: function(e){
			// summary:
			//		Checks an event object for the pressed left button
			// e: Event
			//		Event object to examine
			return e.button == 0; // Boolean
		},
		isMiddle: function(e){
			// summary:
			//		Checks an event object for the pressed middle button
			// e: Event
			//		Event object to examine
			return e.button == 1; // Boolean
		},
		isRight: function(e){
			// summary:
			//		Checks an event object for the pressed right button
			// e: Event
			//		Event object to examine
			return e.button == 2; // Boolean
		}
	};
=====*/

	function eventHandler(type, selectHandler){
		// emulation of mouseenter/leave with mouseover/out using descendant checking
		var handler = function(node, listener){
			return on(node, type, function(evt){
				if(selectHandler){
					return selectHandler(evt, listener);
				}
				if(!dom.isDescendant(evt.relatedTarget, node)){
					return listener.call(this, evt);
				}
			});
		};
		handler.bubble = function(select){
			return eventHandler(type, function(evt, listener){
				// using a selector, use the select function to determine if the mouse moved inside the selector and was previously outside the selector
				var target = select(evt.target);
				var relatedTarget = evt.relatedTarget;
				if(target && (target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget)))){
					return listener.call(target, evt);
				} 
			});
		};
		return handler;
	}
	var wheel;
	if(has("events-mousewheel")){
		wheel = 'mousewheel';
	}else{ //firefox
		wheel = function(node, listener){
			return on(node, 'DOMMouseScroll', function(evt){
				evt.wheelDelta = -evt.detail;
				listener.call(this, evt);
			});
		};
	}
	return {
		// summary:
		//		This module provide mouse event handling utility functions and exports
		//		mouseenter and mouseleave event emulation.
		// example:
		//		To use these events, you register a mouseenter like this:
		//		|	define(["dojo/on", "dojo/mouse"], function(on, mouse){
		//		|		on(targetNode, mouse.enter, function(event){
		//		|			dojo.addClass(targetNode, "highlighted");
		//		|		});
		//		|		on(targetNode, mouse.leave, function(event){
		//		|			dojo.removeClass(targetNode, "highlighted");
		//		|		});

		_eventHandler: eventHandler,		// for dojo/touch

		// enter: Synthetic Event
		//		This is an extension event for the mouseenter that IE provides, emulating the
		//		behavior on other browsers.
		enter: eventHandler("mouseover"),

		// leave: Synthetic Event
		//		This is an extension event for the mouseleave that IE provides, emulating the
		//		behavior on other browsers.
		leave: eventHandler("mouseout"),

		// wheel: Normalized Mouse Wheel Event
		//		This is an extension event for the mousewheel that non-Mozilla browsers provide,
		//		emulating the behavior on Mozilla based browsers.
		wheel: wheel,

		isLeft: mouseButtons.isLeft,
		/*=====
		isLeft: function(){
			// summary:
			//		Test an event object (from a mousedown event) to see if the left button was pressed.
		},
		=====*/

		isMiddle: mouseButtons.isMiddle,
		/*=====
		 isMiddle: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the middle button was pressed.
		 },
		 =====*/

		isRight: mouseButtons.isRight
		/*=====
		 , isRight: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the right button was pressed.
		 }
		 =====*/
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/on.js":
/*!*********************************!*\
  !*** ./node_modules/dojo/on.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__.dj.h("dom-addeventlistener?:./node_modules/dojo/aspect.js"), __webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./sniff */ "./node_modules/dojo/sniff.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(aspect, dojo, has){

	"use strict";
	if(has("dom")){ // check to make sure we are in a browser, this module should work anywhere
		var major = window.ScriptEngineMajorVersion;
		has.add("jscript", major && (major() + ScriptEngineMinorVersion() / 10));
		has.add("event-orientationchange", has("touch") && !has("android")); // TODO: how do we detect this?
		has.add("event-stopimmediatepropagation", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);
		has.add("event-focusin", function(global, doc, element){
			return 'onfocusin' in element;
		});

		if(has("touch")){
			has.add("touch-can-modify-event-delegate", function(){
				// This feature test checks whether deleting a property of an event delegate works
				// for a touch-enabled device. If it works, event delegation can be used as fallback
				// for browsers such as Safari in older iOS where deleting properties of the original
				// event does not work.
				var EventDelegate = function(){};
				EventDelegate.prototype =
					document.createEvent("MouseEvents"); // original event
				// Attempt to modify a property of an event delegate and check if
				// it succeeds. Depending on browsers and on whether dojo/on's
				// strict mode is stripped in a Dojo build, there are 3 known behaviors:
				// it may either succeed, or raise an error, or fail to set the property
				// without raising an error.
				try{
					var eventDelegate = new EventDelegate;
					eventDelegate.target = null;
					return eventDelegate.target === null;
				}catch(e){
					return false; // cannot use event delegation
				}
			});
		}
	}
	var on = function(target, type, listener, dontFix){
		// summary:
		//		A function that provides core event listening functionality. With this function
		//		you can provide a target, event type, and listener to be notified of
		//		future matching events that are fired.
		// target: Element|Object
		//		This is the target object or DOM element that to receive events from
		// type: String|Function
		//		This is the name of the event to listen for or an extension event type.
		// listener: Function
		//		This is the function that should be called when the event fires.
		// returns: Object
		//		An object with a remove() method that can be used to stop listening for this
		//		event.
		// description:
		//		To listen for "click" events on a button node, we can do:
		//		|	define(["dojo/on"], function(on){
		//		|		on(button, "click", clickHandler);
		//		|		...
		//		Evented JavaScript objects can also have their own events.
		//		|	var obj = new Evented;
		//		|	on(obj, "foo", fooHandler);
		//		And then we could publish a "foo" event:
		//		|	on.emit(obj, "foo", {key: "value"});
		//		We can use extension events as well. For example, you could listen for a tap gesture:
		//		|	define(["dojo/on", "dojo/gesture/tap", function(on, tap){
		//		|		on(button, tap, tapHandler);
		//		|		...
		//		which would trigger fooHandler. Note that for a simple object this is equivalent to calling:
		//		|	obj.onfoo({key:"value"});
		//		If you use on.emit on a DOM node, it will use native event dispatching when possible.

		if(typeof target.on == "function" && typeof type != "function" && !target.nodeType){
			// delegate to the target's on() method, so it can handle it's own listening if it wants (unless it
			// is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the
			// Element prototype
			return target.on(type, listener);
		}
		// delegate to main listener code
		return on.parse(target, type, listener, addListener, dontFix, this);
	};
	on.pausable =  function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but with pausable functionality. The
		//		returned signal object has pause() and resume() functions. Calling the
		//		pause() method will cause the listener to not be called for future events. Calling the
		//		resume() method will cause the listener to again be called for future events.
		var paused;
		var signal = on(target, type, function(){
			if(!paused){
				return listener.apply(this, arguments);
			}
		}, dontFix);
		signal.pause = function(){
			paused = true;
		};
		signal.resume = function(){
			paused = false;
		};
		return signal;
	};
	on.once = function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but will only call the listener once. The
		//		listener will be called for the first
		//		event that takes place and then listener will automatically be removed.
		var signal = on(target, type, function(){
			// remove this listener
			signal.remove();
			// proceed to call the listener
			return listener.apply(this, arguments);
		});
		return signal;
	};
	on.parse = function(target, type, listener, addListener, dontFix, matchesTarget){
		var events;
		if(type.call){
			// event handler function
			// on(node, touch.press, touchListener);
			return type.call(matchesTarget, target, listener);
		}

		if(type instanceof Array){
			// allow an array of event names (or event handler functions)
			events = type;
		}else if(type.indexOf(",") > -1){
			// we allow comma delimited event names, so you can register for multiple events at once
			events = type.split(/\s*,\s*/);
		}
		if(events){
			var handles = [];
			var i = 0;
			var eventName;
			while(eventName = events[i++]){ // intentional assignment
				handles.push(on.parse(target, eventName, listener, addListener, dontFix, matchesTarget));
			}
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		}
		return addListener(target, type, listener, dontFix, matchesTarget);
	};
	var touchEvents = /^touch/;
	function addListener(target, type, listener, dontFix, matchesTarget){
		// event delegation:
		var selector = type.match(/(.*):(.*)/);
		// if we have a selector:event, the last one is interpreted as an event, and we use event delegation
		if(selector){
			type = selector[2];
			selector = selector[1];
			// create the extension event for selectors and directly call it
			return on.selector(selector, type).call(matchesTarget, target, listener);
		}
		// test to see if it a touch event right now, so we don't have to do it every time it fires
		if(has("touch")){
			if(touchEvents.test(type)){
				// touch event, fix it
				listener = fixTouchListener(listener);
			}
			if(!has("event-orientationchange") && (type == "orientationchange")){
				//"orientationchange" not supported <= Android 2.1,
				//but works through "resize" on window
				type = "resize";
				target = window;
				listener = fixTouchListener(listener);
			}
		}
		if(addStopImmediate){
			// add stopImmediatePropagation if it doesn't exist
			listener = addStopImmediate(listener);
		}
		// normal path, the target is |this|
		if(target.addEventListener){
			// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)
			// check for capture conversions
			var capture = type in captures,
				adjustedType = capture ? captures[type] : type;
			target.addEventListener(adjustedType, listener, capture);
			// create and return the signal
			return {
				remove: function(){
					target.removeEventListener(adjustedType, listener, capture);
				}
			};
		}
		type = "on" + type;
		if(fixAttach && target.attachEvent){
			return fixAttach(target, type, listener);
		}
		throw new Error("Target must be an event emitter");
	}
	on.matches = function(node, selector, context, children, matchesTarget) {
		// summary:
		//		Check if a node match the current selector within the constraint of a context
		// node: DOMNode
		//		The node that originate the event
		// selector: String
		//		The selector to check against
		// context: DOMNode
		//		The context to search in.
		// children: Boolean
		//		Indicates if children elements of the selector should be allowed. This defaults to
		//		true
		// matchesTarget: Object|dojo/query?
		//		An object with a property "matches" as a function. Default is dojo/query.
		//		Matching DOMNodes will be done against this function
		//		The function must return a Boolean.
		//		It will have 3 arguments: "node", "selector" and "context"
		//		True is expected if "node" is matching the current "selector" in the passed "context"
		// returns: DOMNode?
		//		The matching node, if any. Else you get false

		// see if we have a valid matchesTarget or default to dojo/query
		matchesTarget = matchesTarget && (typeof matchesTarget.matches == "function") ? matchesTarget : dojo.query;
		children = children !== false;
		// there is a selector, so make sure it matches
		if(node.nodeType != 1){
			// text node will fail in native match selector
			node = node.parentNode;
		}
		while(!matchesTarget.matches(node, selector, context)){
			if(node == context || children === false || !(node = node.parentNode) || node.nodeType != 1){ // intentional assignment
				return false;
			}
		}
		return node;
	};
	on.selector = function(selector, eventType, children){
		// summary:
		//		Creates a new extension event with event delegation. This is based on
		//		the provided event type (can be extension event) that
		//		only calls the listener when the CSS selector matches the target of the event.
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		// selector:
		//		The CSS selector to use for filter events and determine the |this| of the event listener.
		// eventType:
		//		The event to listen for
		// children:
		//		Indicates if children elements of the selector should be allowed. This defaults to
		//		true
		// example:
		// |	require(["dojo/on", "dojo/mouse", "dojo/query!css2"], function(on, mouse){
		// |		on(node, on.selector(".my-class", mouse.enter), handlerForMyHover);
		return function(target, listener){
			// if the selector is function, use it to select the node, otherwise use the matches method
			var matchesTarget = typeof selector == "function" ? {matches: selector} : this,
				bubble = eventType.bubble;
			function select(eventTarget){
				return on.matches(eventTarget, selector, target, children, matchesTarget);
			}
			if(bubble){
				// the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself
				return on(target, bubble(select), listener);
			}
			// standard event delegation
			return on(target, eventType, function(event){
				// call select to see if we match
				var eventTarget = select(event.target);
				// if it matches we call the listener
				if (eventTarget) {
					// We save the matching target into the event, so it can be accessed even when hitching (see #18355)
					event.selectorTarget = eventTarget;
					return listener.call(eventTarget, event);
				}
			});
		};
	};

	function syntheticPreventDefault(){
		this.cancelable = false;
		this.defaultPrevented = true;
	}
	function syntheticStopPropagation(){
		this.bubbles = false;
	}
	var slice = [].slice,
		syntheticDispatch = on.emit = function(target, type, event){
		// summary:
		//		Fires an event on the target object.
		// target:
		//		The target object to fire the event on. This can be a DOM element or a plain
		//		JS object. If the target is a DOM element, native event emitting mechanisms
		//		are used when possible.
		// type:
		//		The event type name. You can emulate standard native events like "click" and
		//		"mouseover" or create custom events like "open" or "finish".
		// event:
		//		An object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent
		//		for some of the properties. These properties are copied to the event object.
		//		Of particular importance are the cancelable and bubbles properties. The
		//		cancelable property indicates whether or not the event has a default action
		//		that can be cancelled. The event is cancelled by calling preventDefault() on
		//		the event object. The bubbles property indicates whether or not the
		//		event will bubble up the DOM tree. If bubbles is true, the event will be called
		//		on the target and then each parent successively until the top of the tree
		//		is reached or stopPropagation() is called. Both bubbles and cancelable
		//		default to false.
		// returns:
		//		If the event is cancelable and the event is not cancelled,
		//		emit will return true. If the event is cancelable and the event is cancelled,
		//		emit will return false.
		// details:
		//		Note that this is designed to emit events for listeners registered through
		//		dojo/on. It should actually work with any event listener except those
		//		added through IE's attachEvent (IE8 and below's non-W3C event emitting
		//		doesn't support custom event types). It should work with all events registered
		//		through dojo/on. Also note that the emit method does do any default
		//		action, it only returns a value to indicate if the default action should take
		//		place. For example, emitting a keypress event would not cause a character
		//		to appear in a textbox.
		// example:
		//		To fire our own click event
		//	|	require(["dojo/on", "dojo/dom"
		//	|	], function(on, dom){
		//	|		on.emit(dom.byId("button"), "click", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			screenX: 33,
		//	|			screenY: 44
		//	|		});
		//		We can also fire our own custom events:
		//	|		on.emit(dom.byId("slider"), "slide", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			direction: "left-to-right"
		//	|		});
		//	|	});
		var args = slice.call(arguments, 2);
		var method = "on" + type;
		if("parentNode" in target){
			// node (or node-like), create event controller methods
			var newEvent = args[0] = {};
			for(var i in event){
				newEvent[i] = event[i];
			}
			newEvent.preventDefault = syntheticPreventDefault;
			newEvent.stopPropagation = syntheticStopPropagation;
			newEvent.target = target;
			newEvent.type = type;
			event = newEvent;
		}
		do{
			// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)
			target[method] && target[method].apply(target, args);
			// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)
		}while(event && event.bubbles && (target = target.parentNode));
		return event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen
	};
	var captures = has("event-focusin") ? {} : {focusin: "focus", focusout: "blur"};
	if(!has("event-stopimmediatepropagation")){
		var stopImmediatePropagation =function(){
			this.immediatelyStopped = true;
			this.modified = true; // mark it as modified so the event will be cached in IE
		};
		var addStopImmediate = function(listener){
			return function(event){
				if(!event.immediatelyStopped){// check to make sure it hasn't been stopped immediately
					event.stopImmediatePropagation = stopImmediatePropagation;
					return listener.apply(this, arguments);
				}
			};
		};
	}
	if(has("dom-addeventlistener")){
		// emitter that works with native event handling
		on.emit = function(target, type, event){
			if(target.dispatchEvent && document.createEvent){
				// use the native event emitting mechanism if it is available on the target object
				// create a generic event
				// we could create branch into the different types of event constructors, but
				// that would be a lot of extra code, with little benefit that I can see, seems
				// best to use the generic constructor and copy properties over, making it
				// easy to have events look like the ones created with specific initializers
				var ownerDocument = target.ownerDocument || document;
				var nativeEvent = ownerDocument.createEvent("HTMLEvents");
				nativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);
				// and copy all our properties over
				for(var i in event){
					if(!(i in nativeEvent)){
						nativeEvent[i] = event[i];
					}
				}
				return target.dispatchEvent(nativeEvent) && nativeEvent;
			}
			return syntheticDispatch.apply(on, arguments); // emit for a non-node
		};
	}else{
		// no addEventListener, basically old IE event normalization
		on._fixEvent = function(evt, sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt:
			//		native event object
			// sender:
			//		node to treat as "currentTarget"
			if(!evt){
				var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
				evt = w.event;
			}
			if(!evt){return evt;}
			try{
				if(lastEvent && evt.type == lastEvent.type  && evt.srcElement == lastEvent.target){
					// should be same event, reuse event object (so it can be augmented);
					// accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below
					evt = lastEvent;
				}
			}catch(e){
				// will occur on IE on lastEvent.type reference if lastEvent points to a previous event that already
				// finished bubbling, but the setTimeout() to clear lastEvent hasn't fired yet
			}
			if(!evt.target){ // check to see if it has been fixed yet
				evt.target = evt.srcElement;
				evt.currentTarget = (sender || evt.srcElement);
				if(evt.type == "mouseover"){
					evt.relatedTarget = evt.fromElement;
				}
				if(evt.type == "mouseout"){
					evt.relatedTarget = evt.toElement;
				}
				if(!evt.stopPropagation){
					evt.stopPropagation = stopPropagation;
					evt.preventDefault = preventDefault;
				}
				switch(evt.type){
					case "keypress":
						var c = ("charCode" in evt ? evt.charCode : evt.keyCode);
						if (c==10){
							// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla
							c=0;
							evt.keyCode = 13;
						}else if(c==13||c==27){
							c=0; // Mozilla considers ENTER and ESC non-printable
						}else if(c==3){
							c=99; // Mozilla maps CTRL-BREAK to CTRL-c
						}
						// Mozilla sets keyCode to 0 when there is a charCode
						// but that stops the event on IE.
						evt.charCode = c;
						_setKeyChar(evt);
						break;
				}
			}
			return evt;
		};
		var lastEvent, IESignal = function(handle){
			this.handle = handle;
		};
		IESignal.prototype.remove = function(){
			delete _dojoIEListeners_[this.handle];
		};
		var fixListener = function(listener){
			// this is a minimal function for closing on the previous listener with as few as variables as possible
			return function(evt){
				evt = on._fixEvent(evt, this);
				var result = listener.call(this, evt);
				if(evt.modified){
					// cache the last event and reuse it if we can
					if(!lastEvent){
						setTimeout(function(){
							lastEvent = null;
						});
					}
					lastEvent = evt;
				}
				return result;
			};
		};
		var fixAttach = function(target, type, listener){
			listener = fixListener(listener);
			if(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top ||
						has("jscript") < 5.8) &&
					!has("config-_allow_leaks")){
				// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.
				// Here we use global redirection to solve the memory leaks
				if(typeof _dojoIEListeners_ == "undefined"){
					_dojoIEListeners_ = [];
				}
				var emitter = target[type];
				if(!emitter || !emitter.listeners){
					var oldListener = emitter;
					emitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');
					emitter.listeners = [];
					target[type] = emitter;
					emitter.global = this;
					if(oldListener){
						emitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);
					}
				}
				var handle;
				emitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));
				return new IESignal(handle);
			}
			return aspect.after(target, type, listener, true);
		};

		var _setKeyChar = function(evt){
			evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
			evt.charOrCode = evt.keyChar || evt.keyCode;	// TODO: remove for 2.0
		};
		// Called in Event scope
		var stopPropagation = function(){
			this.cancelBubble = true;
		};
		var preventDefault = on._preventDefault = function(){
			// Setting keyCode to 0 is the only way to prevent certain keypresses (namely
			// ctrl-combinations that correspond to menu accelerator keys).
			// Otoh, it prevents upstream listeners from getting this information
			// Try to split the difference here by clobbering keyCode only for ctrl
			// combinations. If you still need to access the key upstream, bubbledKeyCode is
			// provided as a workaround.
			this.bubbledKeyCode = this.keyCode;
			if(this.ctrlKey){
				try{
					// squelch errors when keyCode is read-only
					// (e.g. if keyCode is ctrl or shift)
					this.keyCode = 0;
				}catch(e){
				}
			}
			this.defaultPrevented = true;
			this.returnValue = false;
			this.modified = true; // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE
		};
	}
	if(has("touch")){
		var EventDelegate = function(){};
		var windowOrientation = window.orientation;
		var fixTouchListener = function(listener){
			return function(originalEvent){
				//Event normalization(for ontouchxxx and resize):
				//1.incorrect e.pageX|pageY in iOS
				//2.there are no "e.rotation", "e.scale" and "onorientationchange" in Android
				//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY

				// see if it has already been corrected
				var event = originalEvent.corrected;
				if(!event){
					var type = originalEvent.type;
					try{
						delete originalEvent.type; // on some JS engines (android), deleting properties makes them mutable
					}catch(e){}
					if(originalEvent.type){
						// Deleting the property of the original event did not work (this is the case of
						// browsers such as older Safari iOS), hence fallback:
						if(has("touch-can-modify-event-delegate")){
							// If deleting properties of delegated event works, use event delegation:
							EventDelegate.prototype = originalEvent;
							event = new EventDelegate;
						}else{
							// Otherwise last fallback: other browsers, such as mobile Firefox, do not like
							// delegated properties, so we have to copy
							event = {};
							for(var name in originalEvent){
								event[name] = originalEvent[name];
							}
						}
						// have to delegate methods to make them work
						event.preventDefault = function(){
							originalEvent.preventDefault();
						};
						event.stopPropagation = function(){
							originalEvent.stopPropagation();
						};
					}else{
						// deletion worked, use property as is
						event = originalEvent;
						event.type = type;
					}
					originalEvent.corrected = event;
					if(type == 'resize'){
						if(windowOrientation == window.orientation){
							return null;//double tap causes an unexpected 'resize' in Android
						}
						windowOrientation = window.orientation;
						event.type = "orientationchange";
						return listener.call(this, event);
					}
					// We use the original event and augment, rather than doing an expensive mixin operation
					if(!("rotation" in event)){ // test to see if it has rotation
						event.rotation = 0;
						event.scale = 1;
					}
					if (window.TouchEvent && originalEvent instanceof TouchEvent) {
						// use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target
						var firstChangeTouch = event.changedTouches[0];
						for(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here
							delete event[i]; // delete it first to make it mutable
							event[i] = firstChangeTouch[i];
						}
					}
				}
				return listener.call(this, event);
			};
		};
	}
	return on;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/promise/Promise.js":
/*!**********************************************!*\
  !*** ./node_modules/dojo/promise/Promise.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ../_base/lang */ "./node_modules/dojo/_base/lang.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang){
	"use strict";

	// module:
	//		dojo/promise/Promise

	function throwAbstract(){
		throw new TypeError("abstract");
	}

	return lang.extend(function Promise(){
		// summary:
		//		The public interface to a deferred.
		// description:
		//		The public interface to a deferred. All promises in Dojo are
		//		instances of this class.
	}, {
		then: function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the promise.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			throwAbstract();
		},

		cancel: function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			throwAbstract();
		},

		isResolved: function(){
			// summary:
			//		Checks whether the promise has been resolved.
			// returns: Boolean

			throwAbstract();
		},

		isRejected: function(){
			// summary:
			//		Checks whether the promise has been rejected.
			// returns: Boolean

			throwAbstract();
		},

		isFulfilled: function(){
			// summary:
			//		Checks whether the promise has been resolved or rejected.
			// returns: Boolean

			throwAbstract();
		},

		isCanceled: function(){
			// summary:
			//		Checks whether the promise has been canceled.
			// returns: Boolean

			throwAbstract();
		},

		always: function(callbackOrErrback){
			// summary:
			//		Add a callback to be invoked when the promise is resolved
			//		or rejected.
			// callbackOrErrback: Function?
			//		A function that is used both as a callback and errback.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback/errback.

			return this.then(callbackOrErrback, callbackOrErrback);
		},

		"catch": function(errback){
		    // summary:
		    //		Add new errbacks to the promise. Follows ECMA specification naming.
		    // errback: Function?
		    //		Callback to be invoked when the promise is rejected.
		    // returns: dojo/promise/Promise
		    //		Returns a new promise for the result of the errback.

		    return this.then(null, errback);
		},

		otherwise: function(errback){
			// summary:
			//		Add new errbacks to the promise.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the errback.

			return this.then(null, errback);
		},

		trace: function(){
			return this;
		},

		traceRejected: function(){
			return this;
		},

		toString: function(){
			// returns: string
			//		Returns `[object Promise]`.

			return "[object Promise]";
		}
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/promise/instrumentation.js":
/*!******************************************************!*\
  !*** ./node_modules/dojo/promise/instrumentation.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./tracer */ "./node_modules/dojo/promise/tracer.js"),
	__webpack_require__(/*! ../has */ "./node_modules/dojo/has.js"),
	__webpack_require__(/*! ../_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! ../_base/array */ "./node_modules/dojo/_base/array.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(tracer, has, lang, arrayUtil){
	has.add("config-useDeferredInstrumentation", "report-unhandled-rejections");

	function logError(error, rejection, deferred){
		if(error && error.log === false){
			return;
		}
		var stack = "";
		if(error && error.stack){
			stack += error.stack;
		}
		if(rejection && rejection.stack){
			stack += "\n    ----------------------------------------\n    rejected" + rejection.stack.split("\n").slice(1).join("\n").replace(/^\s+/, " ");
		}
		if(deferred && deferred.stack){
			stack += "\n    ----------------------------------------\n" + deferred.stack;
		}
		console.error(error, stack);
	}

	function reportRejections(error, handled, rejection, deferred){
		if(!handled){
			logError(error, rejection, deferred);
		}
	}

	var errors = [];
	var activeTimeout = false;
	var unhandledWait = 1000;
	function trackUnhandledRejections(error, handled, rejection, deferred){
		// try to find the existing tracking object
		if(!arrayUtil.some(errors, function(obj){
			if(obj.error === error){
				// found the tracking object for this error
				if(handled){
					// if handled, update the state
					obj.handled = true;
				}
				return true;
			}
		})){
			// no tracking object has been setup, create one
			errors.push({
				error: error,
				rejection: rejection,
				handled: handled,
				deferred: deferred,
				timestamp: new Date().getTime()
			});
		}

		if(!activeTimeout){
			activeTimeout = setTimeout(logRejected, unhandledWait);
		}
	}

	function logRejected(){
		var now = new Date().getTime();
		var reportBefore = now - unhandledWait;
		errors = arrayUtil.filter(errors, function(obj){
			// only report the error if we have waited long enough and
			// it hasn't been handled
			if(obj.timestamp < reportBefore){
				if(!obj.handled){
					logError(obj.error, obj.rejection, obj.deferred);
				}
				return false;
			}
			return true;
		});

		if(errors.length){
			activeTimeout = setTimeout(logRejected, errors[0].timestamp + unhandledWait - now);
		}else{
			activeTimeout = false;
		}
	}

	return function(Deferred){
		// summary:
		//		Initialize instrumentation for the Deferred class.
		// description:
		//		Initialize instrumentation for the Deferred class.
		//		Done automatically by `dojo/Deferred` if the
		//		`deferredInstrumentation` and `useDeferredInstrumentation`
		//		config options are set.
		//
		//		Sets up `dojo/promise/tracer` to log to the console.
		//
		//		Sets up instrumentation of rejected deferreds so unhandled
		//		errors are logged to the console.

		var usage = has("config-useDeferredInstrumentation");
		if(usage){
			tracer.on("resolved", lang.hitch(console, "log", "resolved"));
			tracer.on("rejected", lang.hitch(console, "log", "rejected"));
			tracer.on("progress", lang.hitch(console, "log", "progress"));

			var args = [];
			if(typeof usage === "string"){
				args = usage.split(",");
				usage = args.shift();
			}
			if(usage === "report-rejections"){
				Deferred.instrumentRejected = reportRejections;
			}else if(usage === "report-unhandled-rejections" || usage === true || usage === 1){
				Deferred.instrumentRejected = trackUnhandledRejections;
				unhandledWait = parseInt(args[0], 10) || unhandledWait;
			}else{
				throw new Error("Unsupported instrumentation usage <" + usage + ">");
			}
		}
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/promise/tracer.js":
/*!*********************************************!*\
  !*** ./node_modules/dojo/promise/tracer.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ../_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! ./Promise */ "./node_modules/dojo/promise/Promise.js"),
	__webpack_require__(/*! ../Evented */ "./node_modules/dojo/Evented.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang, Promise, Evented){
	"use strict";

	// module:
	//		dojo/promise/tracer

	/*=====
	return {
		// summary:
		//		Trace promise fulfillment.
		// description:
		//		Trace promise fulfillment. Calling `.trace()` or `.traceError()` on a
		//		promise enables tracing. Will emit `resolved`, `rejected` or `progress`
		//		events.

		on: function(type, listener){
			// summary:
			//		Subscribe to traces.
			// description:
			//		See `dojo/Evented#on()`.
			// type: String
			//		`resolved`, `rejected`, or `progress`
			// listener: Function
			//		The listener is passed the traced value and any arguments
			//		that were used with the `.trace()` call.
		}
	};
	=====*/

	var evented = new Evented;
	var emit = evented.emit;
	evented.emit = null;
	// Emit events asynchronously since they should not change the promise state.
	function emitAsync(args){
		setTimeout(function(){
			emit.apply(evented, args);
		}, 0);
	}

	Promise.prototype.trace = function(){
		// summary:
		//		Trace the promise.
		// description:
		//		Tracing allows you to transparently log progress,
		//		resolution and rejection of promises, without affecting the
		//		promise itself. Any arguments passed to `trace()` are
		//		emitted in trace events. See `dojo/promise/tracer` on how
		//		to handle traces.
		// returns: dojo/promise/Promise
		//		The promise instance `trace()` is called on.

		var args = lang._toArray(arguments);
		this.then(
			function(value){ emitAsync(["resolved", value].concat(args)); },
			function(error){ emitAsync(["rejected", error].concat(args)); },
			function(update){ emitAsync(["progress", update].concat(args)); }
		);
		return this;
	};

	Promise.prototype.traceRejected = function(){
		// summary:
		//		Trace rejection of the promise.
		// description:
		//		Tracing allows you to transparently log progress,
		//		resolution and rejection of promises, without affecting the
		//		promise itself. Any arguments passed to `trace()` are
		//		emitted in trace events. See `dojo/promise/tracer` on how
		//		to handle traces.
		// returns: dojo/promise/Promise
		//		The promise instance `traceRejected()` is called on.

		var args = lang._toArray(arguments);
		this.otherwise(function(error){
			emitAsync(["rejected", error].concat(args));
		});
		return this;
	};

	return evented;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/query.js":
/*!************************************!*\
  !*** ./node_modules/dojo/query.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./has */ "./node_modules/dojo/has.js"), __webpack_require__(/*! ./dom */ "./node_modules/dojo/dom.js"), __webpack_require__(/*! ./on */ "./node_modules/dojo/on.js"), __webpack_require__(/*! ./_base/array */ "./node_modules/dojo/_base/array.js"), __webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ./selector/_loader */ "./node_modules/dojo/selector/_loader.js"), __webpack_require__(/*! ./selector/_loader!default */ "./node_modules/dojo/selector/lite.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has, dom, on, array, lang, loader, defaultEngine){

	"use strict";

	has.add("array-extensible", function(){
		// test to see if we can extend an array (not supported in old IE)
		return lang.delegate([], {length: 1}).length == 1 && !has("bug-for-in-skips-shadowed");
	});
	
	var ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;

	var tnl = function(/*Array*/ a, /*dojo/NodeList?*/ parent, /*Function?*/ NodeListCtor){
		// summary:
		//		decorate an array to make it look like a `dojo/NodeList`.
		// a:
		//		Array of nodes to decorate.
		// parent:
		//		An optional parent NodeList that generated the current
		//		list of nodes. Used to call _stash() so the parent NodeList
		//		can be accessed via end() later.
		// NodeListCtor:
		//		An optional constructor function to use for any
		//		new NodeList calls. This allows a certain chain of
		//		NodeList calls to use a different object than dojo/NodeList.
		var nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);
		return parent ? nodeList._stash(parent) : nodeList;
	};

	var loopBody = function(f, a, o){
		a = [0].concat(aps.call(a, 0));
		o = o || dojo.global;
		return function(node){
			a[0] = node;
			return f.apply(o, a);
		};
	};

	// adapters

	var adaptAsForEach = function(f, o){
		// summary:
		//		adapts a single node function to be used in the forEach-type
		//		actions. The initial object is returned from the specialized
		//		function.
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			this.forEach(loopBody(f, arguments, o));
			return this;	// Object
		};
	};

	var adaptAsMap = function(f, o){
		// summary:
		//		adapts a single node function to be used in the map-type
		//		actions. The return is a new array of values, as via `dojo/_base/array.map`
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			return this.map(loopBody(f, arguments, o));
		};
	};

	var adaptAsFilter = function(f, o){
		// summary:
		//		adapts a single node function to be used in the filter-type actions
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			return this.filter(loopBody(f, arguments, o));
		};
	};

	var adaptWithCondition = function(f, g, o){
		// summary:
		//		adapts a single node function to be used in the map-type
		//		actions, behaves like forEach() or map() depending on arguments
		// f: Function
		//		a function to adapt
		// g: Function
		//		a condition function, if true runs as map(), otherwise runs as forEach()
		// o: Object?
		//		an optional context for f and g
		return function(){
			var a = arguments, body = loopBody(f, a, o);
			if(g.call(o || dojo.global, a)){
				return this.map(body);	// self
			}
			this.forEach(body);
			return this;	// self
		};
	};

	var NodeList = function(array){
		// summary:
		//		Array-like object which adds syntactic
		//		sugar for chaining, common iteration operations, animation, and
		//		node manipulation. NodeLists are most often returned as the
		//		result of dojo/query() calls.
		// description:
		//		NodeList instances provide many utilities that reflect
		//		core Dojo APIs for Array iteration and manipulation, DOM
		//		manipulation, and event handling. Instead of needing to dig up
		//		functions in the dojo package, NodeLists generally make the
		//		full power of Dojo available for DOM manipulation tasks in a
		//		simple, chainable way.
		// example:
		//		create a node list from a node
		//		|	require(["dojo/query", "dojo/dom"
		//		|	], function(query, dom){
		//		|		query.NodeList(dom.byId("foo"));
		//		|	});
		// example:
		//		get a NodeList from a CSS query and iterate on it
		//		|	require(["dojo/on", "dojo/dom"
		//		|	], function(on, dom){
		//		|		var l = query(".thinger");
		//		|		l.forEach(function(node, index, nodeList){
		//		|			console.log(index, node.innerHTML);
		//		|		});
		//		|	});
		// example:
		//		use native and Dojo-provided array methods to manipulate a
		//		NodeList without needing to use dojo.* functions explicitly:
		//		|	require(["dojo/query", "dojo/dom-construct", "dojo/dom"
		//		|	], function(query, domConstruct, dom){
		//		|		var l = query(".thinger");
		//		|		// since NodeLists are real arrays, they have a length
		//		|		// property that is both readable and writable and
		//		|		// push/pop/shift/unshift methods
		//		|		console.log(l.length);
		//		|		l.push(domConstruct.create("span"));
		//		|
		//		|		// dojo's normalized array methods work too:
		//		|		console.log( l.indexOf(dom.byId("foo")) );
		//		|		// ...including the special "function as string" shorthand
		//		|		console.log( l.every("item.nodeType == 1") );
		//		|
		//		|		// NodeLists can be [..] indexed, or you can use the at()
		//		|		// function to get specific items wrapped in a new NodeList:
		//		|		var node = l[3]; // the 4th element
		//		|		var newList = l.at(1, 3); // the 2nd and 4th elements
		//		|	});
		// example:
		//		chainability is a key advantage of NodeLists:
		//		|	require(["dojo/query", "dojo/NodeList-dom"
		//		|	], function(query){
		//		|		query(".thinger")
		//		|			.onclick(function(e){ /* ... */ })
		//		|			.at(1, 3, 8) // get a subset
		//		|				.style("padding", "5px")
		//		|				.forEach(console.log);
		//		|	});

		var isNew = this instanceof nl && has("array-extensible");
		if(typeof array == "number"){
			array = Array(array);
		}
		var nodeArray = (array && "length" in array) ? array : arguments;
		if(isNew || !nodeArray.sort){
			// make sure it's a real array before we pass it on to be wrapped 
			var target = isNew ? this : [],
				l = target.length = nodeArray.length;
			for(var i = 0; i < l; i++){
				target[i] = nodeArray[i];
			}
			if(isNew){
				// called with new operator, this means we are going to use this instance and push
				// the nodes on to it. This is usually much faster since the NodeList properties
				//	don't need to be copied (unless the list of nodes is extremely large).
				return target;
			}
			nodeArray = target;
		}
		// called without new operator, use a real array and copy prototype properties,
		// this is slower and exists for back-compat. Should be removed in 2.0.
		lang._mixin(nodeArray, nlp);
		nodeArray._NodeListCtor = function(array){
			// call without new operator to preserve back-compat behavior
			return nl(array);
		};
		return nodeArray;
	};
	
	var nl = NodeList, nlp = nl.prototype = 
		has("array-extensible") ? [] : {};// extend an array if it is extensible

	// expose adapters and the wrapper as private functions

	nl._wrap = nlp._wrap = tnl;
	nl._adaptAsMap = adaptAsMap;
	nl._adaptAsForEach = adaptAsForEach;
	nl._adaptAsFilter  = adaptAsFilter;
	nl._adaptWithCondition = adaptWithCondition;

	// mass assignment

	// add array redirectors
	forEach(["slice", "splice"], function(name){
		var f = ap[name];
		//Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.
		// CANNOT apply ._stash()/end() to splice since it currently modifies
		// the existing this array -- it would break backward compatibility if we copy the array before
		// the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.
		nlp[name] = function(){ return this._wrap(f.apply(this, arguments), name == "slice" ? this : null); };
	});
	// concat should be here but some browsers with native NodeList have problems with it

	// add array.js redirectors
	forEach(["indexOf", "lastIndexOf", "every", "some"], function(name){
		var f = array[name];
		nlp[name] = function(){ return f.apply(dojo, [this].concat(aps.call(arguments, 0))); };
	});

	lang.extend(NodeList, {
		// copy the constructors
		constructor: nl,
		_NodeListCtor: nl,
		toString: function(){
			// Array.prototype.toString can't be applied to objects, so we use join
			return this.join(",");
		},
		_stash: function(parent){
			// summary:
			//		private function to hold to a parent NodeList. end() to return the parent NodeList.
			//
			// example:
			//		How to make a `dojo/NodeList` method that only returns the third node in
			//		the dojo/NodeList but allows access to the original NodeList by using this._stash:
			//	|	require(["dojo/query", "dojo/_base/lang", "dojo/NodeList", "dojo/NodeList-dom"
			//	|	], function(query, lang){
			//	|		lang.extend(NodeList, {
			//	|			third: function(){
			//	|				var newNodeList = NodeList(this[2]);
			//	|				return newNodeList._stash(this);
			//	|			}
			//	|		});
			//	|		// then see how _stash applies a sub-list, to be .end()'ed out of
			//	|		query(".foo")
			//	|			.third()
			//	|				.addClass("thirdFoo")
			//	|			.end()
			//	|			// access to the orig .foo list
			//	|			.removeClass("foo")
			//	|	});
			//
			this._parent = parent;
			return this; // dojo/NodeList
		},

		on: function(eventName, listener){
			// summary:
			//		Listen for events on the nodes in the NodeList. Basic usage is:
			//
			// example:
			//		|	require(["dojo/query"
			//		|	], function(query){
			//		|		query(".my-class").on("click", listener);
			//			This supports event delegation by using selectors as the first argument with the event names as
			//			pseudo selectors. For example:
			//		| 		query("#my-list").on("li:click", listener);
			//			This will listen for click events within `<li>` elements that are inside the `#my-list` element.
			//			Because on supports CSS selector syntax, we can use comma-delimited events as well:
			//		| 		query("#my-list").on("li button:mouseover, li:click", listener);
			//		|	});
			var handles = this.map(function(node){
				return on(node, eventName, listener); // TODO: apply to the NodeList so the same selector engine is used for matches
			});
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		},

		end: function(){
			// summary:
			//		Ends use of the current `NodeList` by returning the previous NodeList
			//		that generated the current NodeList.
			// description:
			//		Returns the `NodeList` that generated the current `NodeList`. If there
			//		is no parent NodeList, an empty NodeList is returned.
			// example:
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("a")
			//	|			.filter(".disabled")
			//	|				// operate on the anchors that only have a disabled class
			//	|				.style("color", "grey")
			//	|			.end()
			//	|			// jump back to the list of anchors
			//	|			.style(...)
			//	|	});
			//
			if(this._parent){
				return this._parent;
			}else{
				//Just return empty list.
				return new this._NodeListCtor(0);
			}
		},

		// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods

		// FIXME: handle return values for #3244
		//		http://trac.dojotoolkit.org/ticket/3244

		// FIXME:
		//		need to wrap or implement:
		//			join (perhaps w/ innerHTML/outerHTML overload for toString() of items?)
		//			reduce
		//			reduceRight

		/*=====
		slice: function(begin, end){
			// summary:
			//		Returns a new NodeList, maintaining this one in place
			// description:
			//		This method behaves exactly like the Array.slice method
			//		with the caveat that it returns a `dojo/NodeList` and not a
			//		raw Array. For more details, see Mozilla's [slice
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)
			// begin: Integer
			//		Can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// end: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			return this._wrap(a.slice.apply(this, arguments));
		},

		splice: function(index, howmany, item){
			// summary:
			//		Returns a new NodeList, manipulating this NodeList based on
			//		the arguments passed, potentially splicing in new elements
			//		at an offset, optionally deleting elements
			// description:
			//		This method behaves exactly like the Array.splice method
			//		with the caveat that it returns a `dojo/NodeList` and not a
			//		raw Array. For more details, see Mozilla's [splice
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)
			//		For backwards compatibility, calling .end() on the spliced NodeList
			//		does not return the original NodeList -- splice alters the NodeList in place.
			// index: Integer
			//		begin can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// howmany: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			// item: Object...?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList
			return this._wrap(a.splice.apply(this, arguments));	// dojo/NodeList
		},

		indexOf: function(value, fromIndex){
			// summary:
			//		see `dojo/_base/array.indexOf()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The location to start searching from. Optional. Defaults to 0.
			// description:
			//		For more details on the behavior of indexOf, see Mozilla's
			//		[indexOf
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf)
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.indexOf(this, value, fromIndex); // Integer
		},

		lastIndexOf: function(value, fromIndex){
			// summary:
			//		see `dojo/_base/array.lastIndexOf()`. The primary difference is that the
			//		acted-on array is implicitly this NodeList
			// description:
			//		For more details on the behavior of lastIndexOf, see
			//		Mozilla's [lastIndexOf
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf)
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The location to start searching from. Optional. Defaults to 0.
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.lastIndexOf(this, value, fromIndex); // Integer
		},

		every: function(callback, thisObject){
			// summary:
			//		see `dojo/_base/array.every()` and the [Array.every
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every).
			//		Takes the same structure of arguments and returns as
			//		dojo/_base/array.every() with the caveat that the passed array is
			//		implicitly this NodeList
			// callback: Function
			//		the callback
			// thisObject: Object?
			//		the context
			return d.every(this, callback, thisObject); // Boolean
		},

		some: function(callback, thisObject){
			// summary:
			//		Takes the same structure of arguments and returns as
			//		`dojo/_base/array.some()` with the caveat that the passed array is
			//		implicitly this NodeList.  See `dojo/_base/array.some()` and Mozilla's
			//		[Array.some
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some).
			// callback: Function
			//		the callback
			// thisObject: Object?
			//		the context
			return d.some(this, callback, thisObject); // Boolean
		},
		=====*/

		concat: function(item){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		as well as items passed in as parameters
			// description:
			//		This method behaves exactly like the Array.concat method
			//		with the caveat that it returns a `NodeList` and not a
			//		raw Array. For more details, see the [Array.concat
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat)
			// item: Object?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList

			//return this._wrap(apc.apply(this, arguments));
			// the line above won't work for the native NodeList, or for Dojo NodeLists either :-(

			// implementation notes:
			// Array.concat() doesn't recognize native NodeLists or Dojo NodeLists
			// as arrays, and so does not inline them into a unioned array, but
			// appends them as single entities. Both the original NodeList and the
			// items passed in as parameters must be converted to raw Arrays
			// and then the concatenation result may be re-_wrap()ed as a Dojo NodeList.

			var t = aps.call(this, 0),
				m = array.map(arguments, function(a){
					return aps.call(a, 0);
				});
			return this._wrap(apc.apply(t, m), this);	// dojo/NodeList
		},

		map: function(/*Function*/ func, /*Function?*/ obj){
			// summary:
			//		see `dojo/_base/array.map()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList and the return is a
			//		NodeList (a subclass of Array)
			return this._wrap(array.map(this, func, obj), this); // dojo/NodeList
		},

		forEach: function(callback, thisObj){
			// summary:
			//		see `dojo/_base/array.forEach()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList. If you want the option to break out
			//		of the forEach loop, use every() or some() instead.
			forEach(this, callback, thisObj);
			// non-standard return to allow easier chaining
			return this; // dojo/NodeList
		},
		filter: function(/*String|Function*/ filter){
			// summary:
			//		"masks" the built-in javascript filter() method (supported
			//		in Dojo via `dojo/_base/array.filter`) to support passing a simple
			//		string filter in addition to supporting filtering function
			//		objects.
			// filter:
			//		If a string, a CSS rule like ".thinger" or "div > span".
			// example:
			//		"regular" JS filter syntax as exposed in `dojo/_base/array.filter`:
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query("*").filter(function(item){
			//		|			// highlight every paragraph
			//		|			return (item.nodeName == "p");
			//		|		}).style("backgroundColor", "yellow");
			//		|	});
			// example:
			//		the same filtering using a CSS selector
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query("*").filter("p").styles("backgroundColor", "yellow");
			//		|	});

			var a = arguments, items = this, start = 0;
			if(typeof filter == "string"){ // inline'd type check
				items = query._filterResult(this, a[0]);
				if(a.length == 1){
					// if we only got a string query, pass back the filtered results
					return items._stash(this); // dojo/NodeList
				}
				// if we got a callback, run it over the filtered items
				start = 1;
			}
			return this._wrap(array.filter(items, a[start], a[start + 1]), this);	// dojo/NodeList
		},
		instantiate: function(/*String|Object*/ declaredClass, /*Object?*/ properties){
			// summary:
			//		Create a new instance of a specified class, using the
			//		specified properties and each node in the NodeList as a
			//		srcNodeRef.
			// example:
			//		Grabs all buttons in the page and converts them to dijit/form/Button's.
			//	|	var buttons = query("button").instantiate(Button, {showLabel: true});
			var c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);
			properties = properties || {};
			return this.forEach(function(node){
				new c(properties, node);
			});	// dojo/NodeList
		},
		at: function(/*===== index =====*/){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		at the given index or indices.
			//
			// index: Integer...
			//		One or more 0-based indices of items in the current
			//		NodeList. A negative index will start at the end of the
			//		list and go backwards.
			//
			// example:
			//	Shorten the list to the first, second, and third elements
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("a").at(0, 1, 2).forEach(fn);
			//	|	});
			//
			// example:
			//	Retrieve the first and last elements of a unordered list:
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("ul > li").at(0, -1).forEach(cb);
			//	|	});
			//
			// example:
			//	Do something for the first element only, but end() out back to
			//	the original list and continue chaining:
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("a").at(0).onclick(fn).end().forEach(function(n){
			//	|			console.log(n); // all anchors on the page.
			//	|	})
			//	|	});

			var t = new this._NodeListCtor(0);
			forEach(arguments, function(i){
				if(i < 0){ i = this.length + i; }
				if(this[i]){ t.push(this[i]); }
			}, this);
			return t._stash(this); // dojo/NodeList
		}
	});

	function queryForEngine(engine, NodeList){
		var query = function(/*String*/ query, /*String|DOMNode?*/ root){
			// summary:
			//		Returns nodes which match the given CSS selector, searching the
			//		entire document by default but optionally taking a node to scope
			//		the search by. Returns an instance of NodeList.
			if(typeof root == "string"){
				root = dom.byId(root);
				if(!root){
					return new NodeList([]);
				}
			}
			var results = typeof query == "string" ? engine(query, root) : query ? (query.end && query.on) ? query : [query] : [];
			if(results.end && results.on){
				// already wrapped
				return results;
			}
			return new NodeList(results);
		};
		query.matches = engine.match || function(node, selector, root){
			// summary:
			//		Test to see if a node matches a selector
			return query.filter([node], selector, root).length > 0;
		};
		// the engine provides a filtering function, use it to for matching
		query.filter = engine.filter || function(nodes, selector, root){
			// summary:
			//		Filters an array of nodes. Note that this does not guarantee to return a NodeList, just an array.
			return query(selector, root).filter(function(node){
				return array.indexOf(nodes, node) > -1;
			});
		};
		if(typeof engine != "function"){
			var search = engine.search;
			engine = function(selector, root){
				// Slick does it backwards (or everyone else does it backwards, probably the latter)
				return search(root || document, selector);
			};
		}
		return query;
	}
	var query = queryForEngine(defaultEngine, NodeList);
	/*=====
	query = function(selector, context){
		// summary:
		//		This modules provides DOM querying functionality. The module export is a function
		//		that can be used to query for DOM nodes by CSS selector and returns a NodeList
		//		representing the matching nodes.
		// selector: String
		//		A CSS selector to search for.
		// context: String|DomNode?
		//		An optional context to limit the searching scope. Only nodes under `context` will be
		//		scanned.
		// example:
		//		add an onclick handler to every submit button in the document
		//		which causes the form to be sent via Ajax instead:
		//	|	require(["dojo/query", "dojo/request", "dojo/dom-form", "dojo/dom-construct", "dojo/dom-style"
		//	|	], function(query, request, domForm, domConstruct, domStyle){
		//	|		query("input[type='submit']").on("click", function(e){
		//	|			e.preventDefault(); // prevent sending the form
		//	|			var btn = e.target;
		//	|			request.post("http://example.com/", {
		//	|				data: domForm.toObject(btn.form)
		//	|			}).then(function(response){
		//	|				// replace the form with the response
		//	|				domConstruct.create(div, {innerHTML: response}, btn.form, "after");
		//	|				domStyle.set(btn.form, "display", "none");
		//	|			});
		//	|		});
		//	|	});
		//
		// description:
		//		dojo/query is responsible for loading the appropriate query engine and wrapping
		//		its results with a `NodeList`. You can use dojo/query with a specific selector engine
		//		by using it as a plugin. For example, if you installed the sizzle package, you could
		//		use it as the selector engine with:
		//		|	require(["dojo/query!sizzle"], function(query){
		//		|		query("div")...
		//
		//		The id after the ! can be a module id of the selector engine or one of the following values:
		//
		//		- acme: This is the default engine used by Dojo base, and will ensure that the full
		//		Acme engine is always loaded.
		//
		//		- css2: If the browser has a native selector engine, this will be used, otherwise a
		//		very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
		//		(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (>)
		//		operators) and nothing more.
		//
		//		- css2.1: If the browser has a native selector engine, this will be used, otherwise the
		//		full Acme engine will be loaded.
		//
		//		- css3: If the browser has a native selector engine with support for CSS3 pseudo
		//		selectors (most modern browsers except IE8), this will be used, otherwise the
		//		full Acme engine will be loaded.
		//
		//		- Or the module id of a selector engine can be used to explicitly choose the selector engine
		//
		//		For example, if you are using CSS3 pseudo selectors in module, you can specify that
		//		you will need support them with:
		//		|	require(["dojo/query!css3"], function(query){
		//		|		query('#t > h3:nth-child(odd)')...
		//
		//		You can also choose the selector engine/load configuration by setting the query-selector:
		//		For example:
		//		|	<script data-dojo-config="query-selector:'css3'" src="dojo.js"></script>
		//
		return new NodeList(); // dojo/NodeList
	 };
	 =====*/

	// the query that is returned from this module is slightly different than dojo.query,
	// because dojo.query has to maintain backwards compatibility with returning a
	// true array which has performance problems. The query returned from the module
	// does not use true arrays, but rather inherits from Array, making it much faster to
	// instantiate.
	dojo.query = queryForEngine(defaultEngine, function(array){
		// call it without the new operator to invoke the back-compat behavior that returns a true array
		return NodeList(array);	// dojo/NodeList
	});

	query.load = function(id, parentRequire, loaded){
		// summary:
		//		can be used as AMD plugin to conditionally load new query engine
		// example:
		//	|	require(["dojo/query!custom"], function(qsa){
		//	|		// loaded selector/custom.js as engine
		//	|		qsa("#foobar").forEach(...);
		//	|	});
		loader.load(id, parentRequire, function(engine){
			loaded(queryForEngine(engine, NodeList));
		});
	};

	dojo._filterQueryResult = query._filterResult = function(nodes, selector, root){
		return new NodeList(query.filter(nodes, selector, root));
	};
	dojo.NodeList = query.NodeList = NodeList;
	return query;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/ready.js":
/*!************************************!*\
  !*** ./node_modules/dojo/ready.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./has */ "./node_modules/dojo/has.js"), __webpack_require__.dj.c(module.i), __webpack_require__(/*! ./domReady */ "./node_modules/dojo/domReady.js"), __webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has, require, domReady, lang){
	// module:
	//		dojo/ready
	// note:
	//		This module should be unnecessary in dojo 2.0

	var
		// truthy if DOMContentLoaded or better (e.g., window.onload fired) has been achieved
		isDomReady = 0,

		// The queue of functions waiting to execute as soon as dojo.ready conditions satisfied
		loadQ = [],

		// prevent recursion in onLoad
		onLoadRecursiveGuard = 0,

		handleDomReady = function(){
			isDomReady = 1;
			dojo._postLoad = dojo.config.afterOnLoad = true;
			onEvent();
		},

		onEvent = function(){
			// Called when some state changes:
			//		- dom ready
			//		- dojo/domReady has finished processing everything in its queue
			//		- task added to loadQ
			//		- require() has finished loading all currently requested modules
			//
			// Run the functions queued with dojo.ready if appropriate.


			//guard against recursions into this function
			if(onLoadRecursiveGuard){
				return;
			}
			onLoadRecursiveGuard = 1;

			// Run tasks in queue if require() is finished loading modules, the dom is ready, and there are no
			// pending tasks registered via domReady().
			// The last step is necessary so that a user defined dojo.ready() callback is delayed until after the
			// domReady() calls inside of dojo.	  Failure can be seen on dijit/tests/robot/Dialog_ally.html on IE8
			// because the dijit/focus.js domReady() callback doesn't execute until after the test starts running.
			while(isDomReady && (!domReady || domReady._Q.length == 0) && (require.idle ? require.idle() : true) && loadQ.length){
				var f = loadQ.shift();
				try{
					f();
				}catch(e){
					// force the dojo.js on("error") handler do display the message
					e.info = e.message;
					if(require.signal){
						require.signal("error", e);
					}else{
						throw e;
					}
				}
			}

			onLoadRecursiveGuard = 0;
		};

	// Check if we should run the next queue operation whenever require() finishes loading modules or domReady
	// finishes processing it's queue.
	require.on && require.on("idle", onEvent);
	if(domReady){
		domReady._onQEmpty = onEvent;
	}

	var ready = dojo.ready = dojo.addOnLoad = function(priority, context, callback){
		// summary:
		//		Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
		//		In most cases, the `domReady` plug-in should suffice and this method should not be needed.
		//
		//		When called in a non-browser environment, just checks that all requested modules have arrived and been
		//		evaluated.
		// priority: Integer?
		//		The order in which to exec this callback relative to other callbacks, defaults to 1000
		// context: Object?|Function
		//		The context in which to run execute callback, or a callback if not using context
		// callback: Function?
		//		The function to execute.
		//
		// example:
		//	Simple DOM and Modules ready syntax
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(function(){ alert("Dom ready!"); });
		//	|	});
		//
		// example:
		//	Using a priority
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(2, function(){ alert("low priority ready!"); })
		//	|	});
		//
		// example:
		//	Using context
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(foo, function(){
		//	|			// in here, this == foo
		//	|		});
		//	|	});
		//
		// example:
		//	Using dojo/hitch style args:
		//	|	require(["dojo/ready"], function(ready){
		//	|		var foo = { dojoReady: function(){ console.warn(this, "dojo dom and modules ready."); } };
		//	|		ready(foo, "dojoReady");
		//	|	});

		var hitchArgs = lang._toArray(arguments);
		if(typeof priority != "number"){
			callback = context;
			context = priority;
			priority = 1000;
		}else{
			hitchArgs.shift();
		}
		callback = callback ?
			lang.hitch.apply(dojo, hitchArgs) :
			function(){
				context();
			};
		callback.priority = priority;
		for(var i = 0; i < loadQ.length && priority >= loadQ[i].priority; i++){}
		loadQ.splice(i, 0, callback);
		onEvent();
	};

	has.add("dojo-config-addOnLoad", 1);
	if(has("dojo-config-addOnLoad")){
		var dca = dojo.config.addOnLoad;
		if(dca){
			ready[(lang.isArray(dca) ? "apply" : "call")](dojo, dca);
		}
	}

	if(has("dojo-sync-loader") && dojo.config.parseOnLoad && !dojo.isAsync){
		ready(99, function(){
			if(!dojo.parser){
				dojo.deprecated("Add explicit require(['dojo/parser']);", "", "2.0");
				__webpack_require__.e(/*! AMD require */ 1).then(function() {[__webpack_require__(/*! dojo/parser */ "./node_modules/dojo/parser.js")];}).catch(__webpack_require__.oe);
			}
		});
	}

	if(domReady){
		domReady(handleDomReady);
	}else{
		handleDomReady();
	}

	return ready;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/request.js":
/*!**************************************!*\
  !*** ./node_modules/dojo/request.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./request/default */ "./node_modules/dojo/request/xhr.js")/*=====,
	'./_base/declare',
	'./promise/Promise' =====*/
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(request/*=====, declare, Promise =====*/){
	/*=====
	request = function(url, options){
		// summary:
		//		Send a request using the default transport for the current platform.
		// url: String
		//		The URL to request.
		// options: dojo/request.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.__Promise = declare(Promise, {
		// response: dojo/promise/Promise
		//		A promise resolving to an object representing
		//		the response from the server.
	});
	request.__BaseOptions = declare(null, {
		// query: String|Object?
		//		Query parameters to append to the URL.
		// data: String|Object?
		//		Data to transfer.  This is ignored for GET and DELETE
		//		requests.
		// preventCache: Boolean?
		//		Whether to append a cache-busting parameter to the URL.
		// timeout: Integer?
		//		Milliseconds to wait for the response.  If this time
		//		passes, the then the promise is rejected.
		// handleAs: String?
		//		How to handle the response from the server.  Default is
		//		'text'.  Other values are 'json', 'javascript', and 'xml'.
	});
	request.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request.  Must be
		//		uppercase.
	});
	request.__Options = declare([request.__BaseOptions, request.__MethodOptions]);

	request.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.put = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	return request;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/request/handlers.js":
/*!***********************************************!*\
  !*** ./node_modules/dojo/request/handlers.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ../json */ "./node_modules/dojo/json.js"),
	__webpack_require__(/*! ../_base/kernel */ "./node_modules/dojo/_base/kernel.js"),
	__webpack_require__(/*! ../_base/array */ "./node_modules/dojo/_base/array.js"),
	__webpack_require__(/*! ../has */ "./node_modules/dojo/has.js"),
	__webpack_require__(/*! ./node_modules/dojo-webpack-plugin/lib/NoModule.js */ "./node_modules/dojo-webpack-plugin/lib/NoModule.js") // only included for has() qsa tests
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(JSON, kernel, array, has){
	has.add('activex', typeof ActiveXObject !== 'undefined');
	has.add('dom-parser', function(global){
		return 'DOMParser' in global;
	});

	var handleXML;
	if(has('activex')){
		// GUIDs obtained from http://msdn.microsoft.com/en-us/library/ms757837(VS.85).aspx
		var dp = [
			'Msxml2.DOMDocument.6.0',
			'Msxml2.DOMDocument.4.0',
			'MSXML2.DOMDocument.3.0',
			'MSXML.DOMDocument' // 2.0
		];
		var lastParser;

		handleXML = function(response){
			var result = response.data;
			var text = response.text;

			if(result && has('dom-qsa2.1') && !result.querySelectorAll && has('dom-parser')){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(text, 'application/xml');
			}

			function createDocument(p) {
					try{
						var dom = new ActiveXObject(p);
						dom.async = false;
						dom.loadXML(text);
						result = dom;
						lastParser = p;
					}catch(e){ return false; }
					return true;
			}

			if(!result || !result.documentElement){
				// The creation of an ActiveX object is expensive, so we cache the
				// parser type to avoid trying all parser types each time we handle a
				// document. There is some concern that some parser types might fail
				// depending on the document being parsed. If parsing using the cached
				// parser type fails, we do the more expensive operation of finding one
				// that works for the given document.
				// https://bugs.dojotoolkit.org/ticket/15246
				if(!lastParser || !createDocument(lastParser)) {
					array.some(dp, createDocument);
				}
			}

			return result;
		};
	}

	var handleNativeResponse = function(response) {
		if(!has('native-xhr2-blob') && response.options.handleAs === 'blob' && typeof Blob !== 'undefined'){
			return new Blob([ response.xhr.response ], { type: response.xhr.getResponseHeader('Content-Type') });
		}

		return response.xhr.response;
	}

	var handlers = {
		'javascript': function(response){
			return kernel.eval(response.text || '');
		},
		'json': function(response){
			return JSON.parse(response.text || null);
		},
		'xml': handleXML,
		'blob': handleNativeResponse,
		'arraybuffer': handleNativeResponse,
		'document': handleNativeResponse
	};

	function handle(response){
		var handler = handlers[response.options.handleAs];

		response.data = handler ? handler(response) : (response.data || response.text);

		return response;
	}

	handle.register = function(name, handler){
		handlers[name] = handler;
	};

	return handle;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/request/util.js":
/*!*******************************************!*\
  !*** ./node_modules/dojo/request/util.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	exports,
	__webpack_require__(/*! ../errors/RequestError */ "./node_modules/dojo/errors/RequestError.js"),
	__webpack_require__(/*! ../errors/CancelError */ "./node_modules/dojo/errors/CancelError.js"),
	__webpack_require__(/*! ../Deferred */ "./node_modules/dojo/Deferred.js"),
	__webpack_require__(/*! ../io-query */ "./node_modules/dojo/io-query.js"),
	__webpack_require__(/*! ../_base/array */ "./node_modules/dojo/_base/array.js"),
	__webpack_require__(/*! ../_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! ../promise/Promise */ "./node_modules/dojo/promise/Promise.js"),
	__webpack_require__(/*! ../has */ "./node_modules/dojo/has.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(exports, RequestError, CancelError, Deferred, ioQuery, array, lang, Promise, has){

	function isArrayBuffer(value) {
		return has('native-arraybuffer') && value instanceof ArrayBuffer
	}

	function isBlob(value) {
		return has('native-blob') && value instanceof Blob
	}
	
	function isFormElement(value) {
		if(typeof HTMLFormElement !== 'undefined') { //all other
			return value instanceof HTMLFormElement;
		} else { //IE<=7
			value.tagName === "FORM"
		}
	}

	function isFormData(value) {
		return has('native-formdata') && value instanceof FormData;
	}

	function shouldDeepCopy(value) {
		return value &&
			typeof value === 'object' &&
			!isFormData(value) &&
			!isFormElement(value) &&
			!isBlob(value) &&
			!isArrayBuffer(value)
	}

	exports.deepCopy = function(target, source) {
		for (var name in source) {
			var tval = target[name],
  			    sval = source[name];
			if (tval !== sval) {
				if (shouldDeepCopy(sval)) {
					if (Object.prototype.toString.call(sval) === '[object Date]') { // use this date test to handle crossing frame boundaries
						target[name] = new Date(sval);
					} else if (lang.isArray(sval)) {
 						  target[name] = exports.deepCopyArray(sval);
					} else {
						if (tval && typeof tval === 'object') {
							exports.deepCopy(tval, sval);
						} else {
							target[name] = exports.deepCopy({}, sval);
						}
					}
				} else {
					target[name] = sval;
				}
			}
		}
		return target;
	};

	exports.deepCopyArray = function(source) {
		var clonedArray = [];
		for (var i = 0, l = source.length; i < l; i++) {
			var svalItem = source[i];
			if (typeof svalItem === 'object') {
				clonedArray.push(exports.deepCopy({}, svalItem));
			} else {
				clonedArray.push(svalItem);
			}
		}

		return clonedArray;
	};

	exports.deepCreate = function deepCreate(source, properties){
		properties = properties || {};
		var target = lang.delegate(source),
			name, value;

		for(name in source){
			value = source[name];

			if(value && typeof value === 'object'){
				target[name] = exports.deepCreate(value, properties[name]);
			}
		}
		return exports.deepCopy(target, properties);
	};

	var freeze = Object.freeze || function(obj){ return obj; };
	function okHandler(response){
		return freeze(response);
	}
	function dataHandler (response) {
		return response.data !== undefined ? response.data : response.text;
	}

	exports.deferred = function deferred(response, cancel, isValid, isReady, handleResponse, last){
		var def = new Deferred(function(reason){
			cancel && cancel(def, response);

			if(!reason || !(reason instanceof RequestError) && !(reason instanceof CancelError)){
				return new CancelError('Request canceled', response);
			}
			return reason;
		});

		def.response = response;
		def.isValid = isValid;
		def.isReady = isReady;
		def.handleResponse = handleResponse;

		function errHandler(error){
			error.response = response;
			throw error;
		}
		var responsePromise = def.then(okHandler).otherwise(errHandler);

		if(exports.notify){
			responsePromise.then(
				lang.hitch(exports.notify, 'emit', 'load'),
				lang.hitch(exports.notify, 'emit', 'error')
			);
		}

		var dataPromise = responsePromise.then(dataHandler);

		// http://bugs.dojotoolkit.org/ticket/16794
		// The following works around a leak in IE9 through the
		// prototype using lang.delegate on dataPromise and
		// assigning the result a property with a reference to
		// responsePromise.
		var promise = new Promise();
		for (var prop in dataPromise) {
			if (dataPromise.hasOwnProperty(prop)) {
				promise[prop] = dataPromise[prop];
			}
		}
		promise.response = responsePromise;
		freeze(promise);
		// End leak fix


		if(last){
			def.then(function(response){
				last.call(def, response);
			}, function(error){
				last.call(def, response, error);
			});
		}

		def.promise = promise;
		def.then = promise.then;

		return def;
	};

	exports.addCommonMethods = function addCommonMethods(provider, methods){
		array.forEach(methods||['GET', 'POST', 'PUT', 'DELETE'], function(method){
			provider[(method === 'DELETE' ? 'DEL' : method).toLowerCase()] = function(url, options){
				options = lang.delegate(options||{});
				options.method = method;
				return provider(url, options);
			};
		});
	};

	exports.parseArgs = function parseArgs(url, options, skipData){
		var data = options.data,
			query = options.query;

		if(data && !skipData){
			if(typeof data === 'object' && (!(has('native-xhr2')) || !(isArrayBuffer(data) || isBlob(data) ))){
				options.data = ioQuery.objectToQuery(data);
			}
		}

		if(query){
			if(typeof query === 'object'){
				query = ioQuery.objectToQuery(query);
			}
			if(options.preventCache){
				query += (query ? '&' : '') + 'request.preventCache=' + (+(new Date));
			}
		}else if(options.preventCache){
			query = 'request.preventCache=' + (+(new Date));
		}

		if(url && query){
			url += (~url.indexOf('?') ? '&' : '?') + query;
		}

		return {
			url: url,
			options: options,
			getHeader: function(headerName){ return null; }
		};
	};

	exports.checkStatus = function(stat){
		stat = stat || 0;
		return (stat >= 200 && stat < 300) || // allow any 2XX response code
			stat === 304 ||                 // or, get it out of the cache
			stat === 1223 ||                // or, Internet Explorer mangled the status code
			!stat;                         // or, we're Titanium/browser chrome/chrome extension requesting a local file
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/request/watch.js":
/*!********************************************!*\
  !*** ./node_modules/dojo/request/watch.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./util */ "./node_modules/dojo/request/util.js"),
	__webpack_require__(/*! ../errors/RequestTimeoutError */ "./node_modules/dojo/errors/RequestTimeoutError.js"),
	__webpack_require__(/*! ../errors/CancelError */ "./node_modules/dojo/errors/CancelError.js"),
	__webpack_require__(/*! ../_base/array */ "./node_modules/dojo/_base/array.js"),
	__webpack_require__(/*! ../_base/window */ "./node_modules/dojo/_base/window.js"),
	__webpack_require__.dj.h("dom-addeventlistener?:./node_modules/dojo/on.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(util, RequestTimeoutError, CancelError, array, win, on){
	// avoid setting a timer per request. It degrades performance on IE
	// something fierece if we don't use unified loops.
	var _inFlightIntvl = null,
		_inFlight = [];

	function watchInFlight(){
		// summary:
		//		internal method that checks each inflight XMLHttpRequest to see
		//		if it has completed or if the timeout situation applies.

		var now = +(new Date);

		// we need manual loop because we often modify _inFlight (and therefore 'i') while iterating
		for(var i = 0, dfd; i < _inFlight.length && (dfd = _inFlight[i]); i++){
			var response = dfd.response,
				options = response.options;
			if((dfd.isCanceled && dfd.isCanceled()) || (dfd.isValid && !dfd.isValid(response))){
				_inFlight.splice(i--, 1);
				watch._onAction && watch._onAction();
			}else if(dfd.isReady && dfd.isReady(response)){
				_inFlight.splice(i--, 1);
				dfd.handleResponse(response);
				watch._onAction && watch._onAction();
			}else if(dfd.startTime){
				// did we timeout?
				if(dfd.startTime + (options.timeout || 0) < now){
					_inFlight.splice(i--, 1);
					// Cancel the request so the io module can do appropriate cleanup.
					dfd.cancel(new RequestTimeoutError('Timeout exceeded', response));
					watch._onAction && watch._onAction();
				}
			}
		}

		watch._onInFlight && watch._onInFlight(dfd);

		if(!_inFlight.length){
			clearInterval(_inFlightIntvl);
			_inFlightIntvl = null;
		}
	}

	function watch(dfd){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// response: Object
		//		The object used as the value of the request promise.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.
		if(dfd.response.options.timeout){
			dfd.startTime = +(new Date);
		}

		if(dfd.isFulfilled()){
			// bail out if the deferred is already fulfilled
			return;
		}

		_inFlight.push(dfd);
		if(!_inFlightIntvl){
			_inFlightIntvl = setInterval(watchInFlight, 50);
		}

		// handle sync requests separately from async:
		// http://bugs.dojotoolkit.org/ticket/8467
		if(dfd.response.options.sync){
			watchInFlight();
		}
	}

	watch.cancelAll = function cancelAll(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		try{
			array.forEach(_inFlight, function(dfd){
				try{
					dfd.cancel(new CancelError('All requests canceled.'));
				}catch(e){}
			});
		}catch(e){}
	};

	if(win && on && win.doc.attachEvent){
		// Automatically call cancel all io calls on unload in IE
		// http://bugs.dojotoolkit.org/ticket/2357
		on(win.global, 'unload', function(){
			watch.cancelAll();
		});
	}

	return watch;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/request/xhr.js":
/*!******************************************!*\
  !*** ./node_modules/dojo/request/xhr.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ../errors/RequestError */ "./node_modules/dojo/errors/RequestError.js"),
	__webpack_require__(/*! ./watch */ "./node_modules/dojo/request/watch.js"),
	__webpack_require__(/*! ./handlers */ "./node_modules/dojo/request/handlers.js"),
	__webpack_require__(/*! ./util */ "./node_modules/dojo/request/util.js"),
	__webpack_require__(/*! ../has */ "./node_modules/dojo/has.js")/*=====,
	'../request',
	'../_base/declare' =====*/
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(RequestError, watch, handlers, util, has/*=====, request, declare =====*/){
	has.add('native-xhr', function(){
		// if true, the environment has a native XHR implementation
		return typeof XMLHttpRequest !== 'undefined';
	});
	has.add('dojo-force-activex-xhr', function(){
		return has('activex') && window.location.protocol === 'file:';
	});

	has.add('native-xhr2', function(){
		if(!has('native-xhr') || has('dojo-force-activex-xhr')){ return; }
		var x = new XMLHttpRequest();
		return typeof x['addEventListener'] !== 'undefined' &&
			(typeof opera === 'undefined' || typeof x['upload'] !== 'undefined');
	});

	has.add('native-formdata', function(){
		// if true, the environment has a native FormData implementation
		return typeof FormData !== 'undefined';
	});

	has.add('native-blob', function(){
		// if true, the environment has a native Blob implementation
		return typeof Blob !== 'undefined';
	});

	has.add('native-arraybuffer', function(){
		// if true, the environment has a native ArrayBuffer implementation
		return typeof ArrayBuffer !== 'undefined';
	});

	has.add('native-response-type', function(){
		return has('native-xhr') && typeof new XMLHttpRequest().responseType !== 'undefined';
	});

	has.add('native-xhr2-blob', function(){
		if(!has('native-response-type')){ return; }
		var x = new XMLHttpRequest();
		// The URL used here does not have to be reachable as the XHR's `send` method is never called.
		// It does need to be parsable/resolvable in all cases, so it should be an absolute URL.
		// XMLHttpRequest within a Worker created from a Blob does not support relative URL paths.
		x.open('GET', 'https://dojotoolkit.org/', true);
		x.responseType = 'blob';
		// will not be set if unsupported
		var responseType = x.responseType;
		x.abort();
		return responseType === 'blob';
	});

	// Google Chrome doesn't support "json" response type
	// up to version 30, so it's intentionally not included here
	var nativeResponseTypes = {
		'blob': has('native-xhr2-blob') ? 'blob' : 'arraybuffer',
		'document': 'document',
		'arraybuffer': 'arraybuffer'
	};

	function handleResponse(response, error){
		var _xhr = response.xhr;
		response.status = response.xhr.status;

		try {
			// Firefox throws an error when trying to access
			// xhr.responseText if response isn't text
			response.text = _xhr.responseText;
		} catch (e) {}

		if(response.options.handleAs === 'xml'){
			response.data = _xhr.responseXML;
		}

		var handleError;
		if(error){
			this.reject(error);
		}else{
			try{
				handlers(response);
			}catch(e){
				handleError = e;
			}
			if(util.checkStatus(_xhr.status)){
				if(!handleError){
					this.resolve(response);
				}else{
					this.reject(handleError);
				}
			}else{
				if(!handleError){
					error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
					this.reject(error);
				}else{
					error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status +
						' and an error in handleAs: transformation of response', response);
					this.reject(error);
				}
			}
		}
	}

	var isValid, isReady, addListeners, cancel;
	if(has('native-xhr2')){
		// Any platform with XHR2 will only use the watch mechanism for timeout.

		isValid = function(response){
			// summary:
			//		Check to see if the request should be taken out of the watch queue
			return !this.isFulfilled();
		};
		cancel = function(dfd, response){
			// summary:
			//		Canceler for deferred
			response.xhr.abort();
		};
		addListeners = function(_xhr, dfd, response, uploadProgress){
			// summary:
			//		Adds event listeners to the XMLHttpRequest object
			function onLoad(evt){
				dfd.handleResponse(response);
			}
			function onError(evt){
				var _xhr = evt.target;
				var error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
				dfd.handleResponse(response, error);
			}

			function onProgress(transferType, evt){
				response.transferType = transferType;
				if(evt.lengthComputable){
					response.loaded = evt.loaded;
					response.total = evt.total;
					dfd.progress(response);
				} else if(response.xhr.readyState === 3){
					response.loaded = ('loaded' in evt) ? evt.loaded : evt.position;
					dfd.progress(response);
				}
			}

			function onDownloadProgress(evt) {
				return onProgress('download', evt);
			}

			function onUploadProgress(evt) {
				return onProgress('upload', evt);
			}

			_xhr.addEventListener('load', onLoad, false);
			_xhr.addEventListener('error', onError, false);
			_xhr.addEventListener('progress', onDownloadProgress, false);

			if (uploadProgress && _xhr.upload) {
				_xhr.upload.addEventListener('progress', onUploadProgress, false);
			}

			return function(){
				_xhr.removeEventListener('load', onLoad, false);
				_xhr.removeEventListener('error', onError, false);
				_xhr.removeEventListener('progress', onDownloadProgress, false);
				_xhr.upload.removeEventListener('progress', onUploadProgress, false);
				_xhr = null;
			};
		};
	}else{
		isValid = function(response){
			return response.xhr.readyState; //boolean
		};
		isReady = function(response){
			return 4 === response.xhr.readyState; //boolean
		};
		cancel = function(dfd, response){
			// summary:
			//		canceller function for util.deferred call.
			var xhr = response.xhr;
			var _at = typeof xhr.abort;
			if(_at === 'function' || _at === 'object' || _at === 'unknown'){
				xhr.abort();
			}
		};
	}

	function getHeader(headerName){
		return this.xhr.getResponseHeader(headerName);
	}

	var undefined,
		defaultOptions = {
			data: null,
			query: null,
			sync: false,
			method: 'GET'
		};
	function xhr(url, options, returnDeferred){
		var isFormData = has('native-formdata') && options && options.data && options.data instanceof FormData;
		var response = util.parseArgs(
			url,
			util.deepCreate(defaultOptions, options),
			isFormData
		);
		url = response.url;
		options = response.options;
		var hasNoData = !options.data && options.method !== 'POST' && options.method !== 'PUT';

		if(has('ie') <= 10){
			// older IE breaks point 9 in http://www.w3.org/TR/XMLHttpRequest/#the-open()-method and sends fragment, so strip it
			url = url.split('#')[0];
		}

		var remover,
			last = function(){
				remover && remover();
			};

		//Make the Deferred object for this xhr request.
		var dfd = util.deferred(
			response,
			cancel,
			isValid,
			isReady,
			handleResponse,
			last
		);
		var _xhr = response.xhr = xhr._create();

		if(!_xhr){
			// If XHR factory somehow returns nothings,
			// cancel the deferred.
			dfd.cancel(new RequestError('XHR was not created'));
			return returnDeferred ? dfd : dfd.promise;
		}

		response.getHeader = getHeader;

		if(addListeners){
			remover = addListeners(_xhr, dfd, response, options.uploadProgress);
		}

		// IE11 treats data: undefined different than other browsers
		var data = typeof(options.data) === 'undefined' ? null : options.data,
			async = !options.sync,
			method = options.method;

		try{
			// IE6 won't let you call apply() on the native function.
			_xhr.open(method, url, async, options.user || undefined, options.password || undefined);

			if(options.withCredentials){
				_xhr.withCredentials = options.withCredentials;
			}

			if(has('native-response-type') && options.handleAs in nativeResponseTypes) {
				_xhr.responseType = nativeResponseTypes[options.handleAs];
			}

			var headers = options.headers,
				contentType = (isFormData || hasNoData) ? false : 'application/x-www-form-urlencoded';
			if(headers){
				for(var hdr in headers){
					if(hdr.toLowerCase() === 'content-type'){
						contentType = headers[hdr];
					}else if(headers[hdr]){
						//Only add header if it has a value. This allows for instance, skipping
						//insertion of X-Requested-With by specifying empty value.
						_xhr.setRequestHeader(hdr, headers[hdr]);
					}
				}
			}

			if(contentType && contentType !== false){
				_xhr.setRequestHeader('Content-Type', contentType);
			}
			if(!headers || !('X-Requested-With' in headers)){
				_xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
			}

			if(util.notify){
				util.notify.emit('send', response, dfd.promise.cancel);
			}
			_xhr.send(data);
		}catch(e){
			dfd.reject(e);
		}

		watch(dfd);
		_xhr = null;

		return returnDeferred ? dfd : dfd.promise;
	}

	/*=====
	xhr = function(url, options){
		// summary:
		//		Sends a request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.__BaseOptions = declare(request.__BaseOptions, {
		// sync: Boolean?
		//		Whether to make a synchronous request or not. Default
		//		is `false` (asynchronous).
		// data: String|Object|FormData?
		//		Data to transfer. This is ignored for GET and DELETE
		//		requests.
		// headers: Object?
		//		Headers to use for the request.
		// user: String?
		//		Username to use during the request.
		// password: String?
		//		Password to use during the request.
		// withCredentials: Boolean?
		//		For cross-site requests, whether to send credentials
		//		or not.
		// uploadProgress: Boolean?
		//		Upload progress events cause preflighted requests. This
		//		option enables upload progress event support but also
		//		causes all requests to be preflighted.
	});
	xhr.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request. Must be
		//		uppercase. Default is `"GET"`.
	});
	xhr.__Options = declare([xhr.__BaseOptions, xhr.__MethodOptions]);

	xhr.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.put = function(url, options){
		// summary:
		//		Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	xhr._create = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
		throw new Error('XMLHTTP not available');
	};
	if(has('native-xhr') && !has('dojo-force-activex-xhr')){
		xhr._create = function(){
			return new XMLHttpRequest();
		};
	}else if(has('activex')){
		try{
			new ActiveXObject('Msxml2.XMLHTTP');
			xhr._create = function(){
				return new ActiveXObject('Msxml2.XMLHTTP');
			};
		}catch(e){
			try{
				new ActiveXObject('Microsoft.XMLHTTP');
				xhr._create = function(){
					return new ActiveXObject('Microsoft.XMLHTTP');
				};
			}catch(e){}
		}
	}

	util.addCommonMethods(xhr);

	return xhr;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/selector/_loader.js":
/*!***********************************************!*\
  !*** ./node_modules/dojo/selector/_loader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../has */ "./node_modules/dojo/has.js"), __webpack_require__.dj.c(module.i)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has, require){

"use strict";
if (typeof document !== "undefined") {
	var testDiv = document.createElement("div");
	has.add("dom-qsa2.1", !!testDiv.querySelectorAll);
	has.add("dom-qsa3", function(){
		// test to see if we have a reasonable native selector engine available
		try{
			testDiv.innerHTML = "<p class='TEST'></p>"; // test kind of from sizzle
			// Safari can't handle uppercase or unicode characters when
			// in quirks mode, IE8 can't handle pseudos like :empty
			return testDiv.querySelectorAll(".TEST:empty").length == 1;
		}catch(e){}
	});
}

var fullEngine;
var acme = "./acme", lite = "./lite";
return {
	// summary:
	//		This module handles loading the appropriate selector engine for the given browser

	load: function(id, parentRequire, loaded, config){
		if (config && config.isBuild) {
			//Indicate that the optimizer should not wait
			//for this resource any more and complete optimization.
			//This resource will be resolved dynamically during
			//run time in the web browser.
			loaded();
			return;
		}

		var req = require;
		// here we implement the default logic for choosing a selector engine
		id = id == "default" ? has("config-selectorEngine") || "css3" : id;
		id = id == "css2" || id == "lite" ? lite :
				id == "css2.1" ? has("dom-qsa2.1") ? lite : acme :
				id == "css3" ? has("dom-qsa3") ? lite : acme :
				id == "acme" ? acme : (req = parentRequire) && id;
		if(id.charAt(id.length-1) == '?'){
			id = id.substring(0,id.length - 1);
			var optionalLoad = true;
		}
		// the query engine is optional, only load it if a native one is not available or existing one has not been loaded
		if(optionalLoad && (has("dom-compliant-qsa") || fullEngine)){
			return loaded(fullEngine);
		}
		// load the referenced selector engine
		req([id], function(engine){
			if(id != "./lite"){
				fullEngine = engine;
			}
			loaded(engine);
		});
	}
};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/selector/lite.js":
/*!********************************************!*\
  !*** ./node_modules/dojo/selector/lite.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../has */ "./node_modules/dojo/has.js"), __webpack_require__(/*! ../_base/kernel */ "./node_modules/dojo/_base/kernel.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has, dojo){
"use strict";

var testDiv = document.createElement("div");
var matchesSelector = testDiv.matches || testDiv.webkitMatchesSelector || testDiv.mozMatchesSelector || testDiv.msMatchesSelector || testDiv.oMatchesSelector;
var querySelectorAll = testDiv.querySelectorAll;
var unionSplit = /([^\s,](?:"(?:\\.|[^"])+"|'(?:\\.|[^'])+'|[^,])*)/g;
has.add("dom-matches-selector", !!matchesSelector);
has.add("dom-qsa", !!querySelectorAll); 

// this is a simple query engine. It has handles basic selectors, and for simple
// common selectors is extremely fast
var liteEngine = function(selector, root){
	// summary:
	//		A small lightweight query selector engine that implements CSS2.1 selectors
	//		minus pseudo-classes and the sibling combinator, plus CSS3 attribute selectors

	if(combine && selector.indexOf(',') > -1){
		return combine(selector, root);
	}
	// use the root's ownerDocument if provided, otherwise try to use dojo.doc. Note 
	// that we don't use dojo/_base/window's doc to reduce dependencies, and 
	// fallback to plain document if dojo.doc hasn't been defined (by dojo/_base/window).
	// presumably we will have a better way to do this in 2.0 
	var doc = root ? root.ownerDocument || root : dojo.doc || document, 
		match = (querySelectorAll ? 
			/^([\w]*)#([\w\-]+$)|^(\.)([\w\-\*]+$)|^(\w+$)/ : // this one only matches on simple queries where we can beat qSA with specific methods
			/^([\w]*)#([\w\-]+)(?:\s+(.*))?$|(?:^|(>|.+\s+))([\w\-\*]+)(\S*$)/) // this one matches parts of the query that we can use to speed up manual filtering
			.exec(selector);
	root = root || doc;
	if(match){
		var isInsideDomTree = has('ie') === 8 && has('quirks')?
			root.nodeType === doc.nodeType:
			root.parentNode !== null && root.nodeType !== 9 && root.parentNode === doc;

		// fast path regardless of whether or not querySelectorAll exists
		if(match[2] && isInsideDomTree){
			// an #id
			// use dojo.byId if available as it fixes the id retrieval in IE, note that we can't use the dojo namespace in 2.0, but if there is a conditional module use, we will use that
			var found = dojo.byId ? dojo.byId(match[2], doc) : doc.getElementById(match[2]);
			if(!found || (match[1] && match[1] != found.tagName.toLowerCase())){
				// if there is a tag qualifer and it doesn't match, no matches
				return [];
			}
			if(root != doc){
				// there is a root element, make sure we are a child of it
				var parent = found;
				while(parent != root){
					parent = parent.parentNode;
					if(!parent){
						return [];
					}
				}
			}
			return match[3] ?
					liteEngine(match[3], found) 
					: [found];
		}
		if(match[3] && root.getElementsByClassName){
			// a .class
			return root.getElementsByClassName(match[4]);
		}
		var found;
		if(match[5]){
			// a tag
			found = root.getElementsByTagName(match[5]);
			if(match[4] || match[6]){
				selector = (match[4] || "") + match[6];
			}else{
				// that was the entirety of the query, return results
				return found;
			}
		}
	}
	if(querySelectorAll){
		// qSA works strangely on Element-rooted queries
		// We can work around this by specifying an extra ID on the root
		// and working up from there (Thanks to Andrew Dupont for the technique)
		// IE 8 doesn't work on object elements
		if (root.nodeType === 1 && root.nodeName.toLowerCase() !== "object"){				
			return useRoot(root, selector, root.querySelectorAll);
		}else{
			// we can use the native qSA
			return root.querySelectorAll(selector);
		}
	}else if(!found){
		// search all children and then filter
		found = root.getElementsByTagName("*");
	}
	// now we filter the nodes that were found using the matchesSelector
	var results = [];
	for(var i = 0, l = found.length; i < l; i++){
		var node = found[i];
		if(node.nodeType == 1 && jsMatchesSelector(node, selector, root)){
			// keep the nodes that match the selector
			results.push(node);
		}
	}
	return results;
};
var useRoot = function(context, query, method){
	// this function creates a temporary id so we can do rooted qSA queries, this is taken from sizzle
	var oldContext = context,
		old = context.getAttribute("id"),
		nid = old || "__dojo__",
		hasParent = context.parentNode,
		relativeHierarchySelector = /^\s*[+~]/.test(query);

	if(relativeHierarchySelector && !hasParent){
		return [];
	}
	if(!old){
		context.setAttribute("id", nid);
	}else{
		nid = nid.replace(/'/g, "\\$&");
	}
	if(relativeHierarchySelector && hasParent){
		context = context.parentNode;
	}
	var selectors = query.match(unionSplit);
	for(var i = 0; i < selectors.length; i++){
		selectors[i] = "[id='" + nid + "'] " + selectors[i];
	}
	query = selectors.join(",");

	try{
		return method.call(context, query);
	}finally{
		if(!old){
			oldContext.removeAttribute("id");
		}
	}
};

if(!has("dom-matches-selector")){
	var jsMatchesSelector = (function(){
		// a JS implementation of CSS selector matching, first we start with the various handlers
		var caseFix = testDiv.tagName == "div" ? "toLowerCase" : "toUpperCase";
		var selectorTypes = {
			"": function(tagName){
				tagName = tagName[caseFix]();
				return function(node){
					return node.tagName == tagName;
				};
			},
			".": function(className){
				var classNameSpaced = ' ' + className + ' ';
				return function(node){
					return node.className.indexOf(className) > -1 && (' ' + node.className + ' ').indexOf(classNameSpaced) > -1;
				};
			},
			"#": function(id){
				return function(node){
					return node.id == id;
				};
			}
		};
		var attrComparators = {
			"^=": function(attrValue, value){
				return attrValue.indexOf(value) == 0;
			},
			"*=": function(attrValue, value){
				return attrValue.indexOf(value) > -1;
			},
			"$=": function(attrValue, value){
				return attrValue.substring(attrValue.length - value.length, attrValue.length) == value;
			},
			"~=": function(attrValue, value){
				return (' ' + attrValue + ' ').indexOf(' ' + value + ' ') > -1;
			},
			"|=": function(attrValue, value){
				return (attrValue + '-').indexOf(value + '-') == 0;
			},
			"=": function(attrValue, value){
				return attrValue == value;
			},
			"": function(attrValue, value){
				return true;
			}
		};
		function attr(name, value, type){
			var firstChar = value.charAt(0);
			if(firstChar == '"' || firstChar == "'"){
				// it is quoted, remove the quotes
				value = value.slice(1, -1);
			}
			value = value.replace(/\\/g,'');
			var comparator = attrComparators[type || ""];
			return function(node){
				var attrValue = node.getAttribute(name);
				return attrValue && comparator(attrValue, value);
			};
		}
		function ancestor(matcher){
			return function(node, root){
				while((node = node.parentNode) != root){
					if(matcher(node, root)){
						return true;
					}
				}
			};
		}
		function parent(matcher){
			return function(node, root){
				node = node.parentNode;
				return matcher ? 
					node != root && matcher(node, root)
					: node == root;
			};
		}
		var cache = {};
		function and(matcher, next){
			return matcher ?
				function(node, root){
					return next(node) && matcher(node, root);
				}
				: next;
		}
		return function(node, selector, root){
			// this returns true or false based on if the node matches the selector (optionally within the given root)
			var matcher = cache[selector]; // check to see if we have created a matcher function for the given selector
			if(!matcher){
				// create a matcher function for the given selector
				// parse the selectors
				if(selector.replace(/(?:\s*([> ])\s*)|(#|\.)?((?:\\.|[\w-])+)|\[\s*([\w-]+)\s*(.?=)?\s*("(?:\\.|[^"])+"|'(?:\\.|[^'])+'|(?:\\.|[^\]])*)\s*\]/g, function(t, combinator, type, value, attrName, attrType, attrValue){
					if(value){
						matcher = and(matcher, selectorTypes[type || ""](value.replace(/\\/g, '')));
					}
					else if(combinator){
						matcher = (combinator == " " ? ancestor : parent)(matcher);
					}
					else if(attrName){
						matcher = and(matcher, attr(attrName, attrValue, attrType));
					}
					return "";
				})){
					throw new Error("Syntax error in query");
				}
				if(!matcher){
					return true;
				}
				cache[selector] = matcher;
			}
			// now run the matcher function on the node
			return matcher(node, root);
		};
	})();
}
if(!has("dom-qsa")){
	var combine = function(selector, root){
		// combined queries
		var selectors = selector.match(unionSplit);
		var indexed = [];
		// add all results and keep unique ones, this only runs in IE, so we take advantage 
		// of known IE features, particularly sourceIndex which is unique and allows us to 
		// order the results 
		for(var i = 0; i < selectors.length; i++){
			selector = new String(selectors[i].replace(/\s*$/,''));
			selector.indexOf = escape; // keep it from recursively entering combine
			var results = liteEngine(selector, root);
			for(var j = 0, l = results.length; j < l; j++){
				var node = results[j];
				indexed[node.sourceIndex] = node;
			}
		}
		// now convert from a sparse array to a dense array
		var totalResults = [];
		for(i in indexed){
			totalResults.push(indexed[i]);
		}
		return totalResults;
	};
}

liteEngine.match = matchesSelector ? function(node, selector, root){
	if(root && root.nodeType != 9){
		// doesn't support three args, use rooted id trick
		return useRoot(root, selector, function(query){
			return matchesSelector.call(node, query);
		});
	}
	// we have a native matchesSelector, use that
	return matchesSelector.call(node, selector);
} : jsMatchesSelector; // otherwise use the JS matches impl

return liteEngine;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/sniff.js":
/*!************************************!*\
  !*** ./node_modules/dojo/sniff.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./has */ "./node_modules/dojo/has.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has){
	// module:
	//		dojo/sniff

	/*=====
	return function(){
		// summary:
		//		This module sets has() flags based on the current browser.
		//		It returns the has() function.
	};
	=====*/

	if(has("host-browser")){
		var n = navigator,
			dua = n.userAgent,
			dav = n.appVersion,
			tv = parseFloat(dav);
		has.add("air", dua.indexOf("AdobeAIR") >= 0);
		has.add("wp", parseFloat(dua.split("Windows Phone")[1]) || undefined);
		has.add("msapp", parseFloat(dua.split("MSAppHost/")[1]) || undefined);
		has.add("khtml", dav.indexOf("Konqueror") >= 0 ? tv : undefined);
		has.add("edge", parseFloat(dua.split("Edge/")[1]) || undefined);
		has.add("opr", parseFloat(dua.split("OPR/")[1]) || undefined);
		// NOTE: https://dev.opera.com/blog/opera-user-agent-strings-opera-15-and-beyond/
		has.add("webkit", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
			&& !has("edge") && parseFloat(dua.split("WebKit/")[1]) || undefined);
		has.add("chrome", !has("edge") && !has("opr")
				&& parseFloat(dua.split("Chrome/")[1]) || undefined);
		has.add("android", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
				&& parseFloat(dua.split("Android ")[1]) || undefined);
		has.add("safari", dav.indexOf("Safari") >= 0
				&& !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
				&& !has("chrome") && !has("android") && !has("edge") && !has("opr") ?
			parseFloat(dav.split("Version/")[1]) : undefined);
		has.add("mac", dav.indexOf("Macintosh") >= 0);
		has.add("quirks", document.compatMode == "BackCompat");
		if(!has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
				&& dua.match(/(iPhone|iPod|iPad)/)){
			var p = RegExp.$1.replace(/P/, "p");
			var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
			var os = parseFloat(v.replace(/_/, ".").replace(/_/g, ""));
			has.add(p, os);		// "iphone", "ipad" or "ipod"
			has.add("ios", os);
		}
		has.add("bb", (dua.indexOf("BlackBerry") >= 0 || dua.indexOf("BB10") >= 0) && parseFloat(dua.split("Version/")[1]) || undefined);
		has.add("trident", parseFloat(dav.split("Trident/")[1]) || undefined);

		has.add("svg", typeof SVGAngle !== "undefined");

		if(!has("webkit")){
			// Opera
			if(dua.indexOf("Opera") >= 0){
				// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/
				// 9.8 has both styles; <9.8, 9.9 only old style
				has.add("opera", tv >= 9.8 ? parseFloat(dua.split("Version/")[1]) || tv : tv);
			}

			// Mozilla and firefox
			if(dua.indexOf("Gecko") >= 0 && !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1
					&& !has("khtml") && !has("trident") && !has("edge")){
				has.add("mozilla", tv);
			}
			if(has("mozilla")){
				//We really need to get away from this. Consider a sane isGecko approach for the future.
				has.add("ff", parseFloat(dua.split("Firefox/")[1] || dua.split("Minefield/")[1]) || undefined);
			}

			// IE
			if(document.all && !has("opera")){
				var isIE = parseFloat(dav.split("MSIE ")[1]) || undefined;

				//In cases where the page has an HTTP header or META tag with
				//X-UA-Compatible, then it is in emulation mode.
				//Make sure isIE reflects the desired version.
				//document.documentMode of 5 means quirks mode.
				//Only switch the value if documentMode's major version
				//is different from isIE's major version.
				var mode = document.documentMode;
				if(mode && mode != 5 && Math.floor(isIE) != mode){
					isIE = mode;
				}

				has.add("ie", isIE);
			}

			// Wii
			has.add("wii", typeof opera != "undefined" && opera.wiiremote);
		}
	}

	return has;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/string.js":
/*!*************************************!*\
  !*** ./node_modules/dojo/string.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"),	// kernel.global
	__webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(kernel, lang){

// module:
//		dojo/string
var ESCAPE_REGEXP = /[&<>'"\/]/g;
var ESCAPE_MAP = {
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;',
	'"': '&quot;',
	"'": '&#x27;',
	'/': '&#x2F;'
};
var string = {
	// summary:
	//		String utilities for Dojo
};
lang.setObject("dojo.string", string);

string.escape = function(/*String*/str){
	// summary:
	//		Efficiently escape a string for insertion into HTML (innerHTML or attributes), replacing &, <, >, ", ', and / characters.
	// str:
	//		the string to escape
	if(!str){ return ""; }
	return str.replace(ESCAPE_REGEXP, function(c) {
		return ESCAPE_MAP[c];
	});
};

string.rep = function(/*String*/str, /*Integer*/num){
	// summary:
	//		Efficiently replicate a string `n` times.
	// str:
	//		the string to replicate
	// num:
	//		number of times to replicate the string

	if(num <= 0 || !str){ return ""; }

	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	// summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	// text:
	//		the string to pad
	// size:
	//		length to provide padding
	// ch:
	//		character to pad, defaults to '0'
	// end:
	//		adds padding at the end if true, otherwise pads at start
	// example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	// summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	// template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	//		The special sequence `${}` can be used escape `$`.
	// map:
	//		hash to search for substitutions
	// transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	// thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	// example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	// example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	// example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || kernel.global;
	transform = transform ?
		lang.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]*)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			if (key == ''){
				return '$';
			}
			var value = lang.getObject(key, false, map);
			if(format){
				value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			var result = transform(value, key);

			if (typeof result === 'undefined') {
				throw new Error('string.substitute could not find key "' + key + '" in template');
			}

			return result.toString();
		}); // String
};

string.trim = String.prototype.trim ?
	lang.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

/*=====
 string.trim = function(str){
	 // summary:
	 //		Trims whitespace from both sides of the string
	 // str: String
	 //		String to be trimmed
	 // returns: String
	 //		Returns the trimmed string
	 // description:
	 //		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	 //		The short yet performant version of this function is dojo/_base/lang.trim(),
	 //		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	 return "";	// String
 };
 =====*/

	return string;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/text.js":
/*!***********************************!*\
  !*** ./node_modules/dojo/text.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__.dj.c(module.i), __webpack_require__(/*! ./has */ "./node_modules/dojo/has.js"), __webpack_require__(/*! ./request */ "./node_modules/dojo/request.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, require, has, request){
	// module:
	//		dojo/text

	var getText;
	if(has("host-browser")){
		getText= function(url, sync, load){
			request(url, {sync:!!sync, headers: { 'X-Requested-With': null } }).then(load);
		};
	}else{
		// Path for node.js and rhino, to load from local file system.
		// TODO: use node.js native methods rather than depending on a require.getText() method to exist.
		if(require.getText){
			getText= require.getText;
		}else{
			console.error("dojo/text plugin failed to load because loader does not support getText");
		}
	}

	var
		theCache = {},

		strip= function(text){
			//Strips <?xml ...?> declarations so that external SVG and XML
			//documents can be added to a document without worry. Also, if the string
			//is an HTML document, only the part inside the body tag is returned.
			if(text){
				text= text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
				var matches= text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
				if(matches){
					text= matches[1];
				}
			}else{
				text = "";
			}
			return text;
		},

		notFound = {},

		pending = {};

	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		//		A getter and setter for storing the string content associated with the
		//		module and url arguments.
		// description:
		//		If module is a string that contains slashes, then it is interpretted as a fully
		//		resolved path (typically a result returned by require.toUrl), and url should not be
		//		provided. This is the preferred signature. If module is a string that does not
		//		contain slashes, then url must also be provided and module and url are used to
		//		call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
		//		If value is specified, the cache value for the moduleUrl will be set to
		//		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		//		in its internal cache and return that cached value for the URL. To clear
		//		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		//		the URL contents, only modules on the same domain of the page can use this capability.
		//		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		//		If a String with slashes, a fully resolved path; if a String without slashes, the
		//		module name to use for the base part of the URL, similar to module argument
		//		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		//		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		//		The rest of the path to append to the path derived from the module argument. If
		//		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		//		If a String, the value to use in the cache for the module/url combination.
		//		If an Object, it can have two properties: value and sanitize. The value property
		//		should be the value to use in the cache, and sanitize can be set to true or false,
		//		to indicate if XML declarations should be removed from the value and if the HTML
		//		inside a body tag in the value should be extracted as the real value. The value argument
		//		or the value property on the value argument are usually only used by the build system
		//		as it inlines cache content.
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		//		of call is used to avoid an issue with the build system erroneously trying to intern
		//		this example. To get the build system to intern your dojo.cache calls, use the
		//		"dojo.cache" style of call):
		//		| //If template.html contains "<h1>Hello</h1>" that will be
		//		| //the value for the text variable.
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html");
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		//		 (the dojo["cache"] style of call is used to avoid an issue with the build system
		//		erroneously trying to intern this example. To get the build system to intern your
		//		dojo.cache calls, use the "dojo.cache" style of call):
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		// example:
		//		Same example as previous, but demonstrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//	 * (string string [value]) => (module, url, value)
		//	 * (object [value])        => (module, value), url defaults to ""
		//
		//	 * if module is an object, then it must be convertable to a string
		//	 * (module, url) module + (url ? ("/" + url) : "") must be a legal argument to require.toUrl
		//	 * value may be a string or an object; if an object then may have the properties "value" and/or "sanitize"
		var key;
		if(typeof module=="string"){
			if(/\//.test(module)){
				// module is a version 1.7+ resolved path
				key = module;
				value = url;
			}else{
				// module is a version 1.6- argument to dojo.moduleUrl
				key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
			}
		}else{
			key = module + "";
			value = url;
		}
		var
			val = (value != undefined && typeof value != "string") ? value.value : value,
			sanitize = value && value.sanitize;

		if(typeof val == "string"){
			//We have a string, set cache value
			theCache[key] = val;
			return sanitize ? strip(val) : val;
		}else if(val === null){
			//Remove cached value
			delete theCache[key];
			return null;
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in theCache)){
				getText(key, true, function(text){
					theCache[key]= text;
				});
			}
			return sanitize ? strip(theCache[key]) : theCache[key];
		}
	};

	return {
		// summary:
		//		This module implements the dojo/text! plugin and the dojo.cache API.
		// description:
		//		We choose to include our own plugin to leverage functionality already contained in dojo
		//		and thereby reduce the size of the plugin compared to various foreign loader implementations.
		//		Also, this allows foreign AMD loaders to be used without their plugins.
		//
		//		CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
		//		loader. This feature is outside the scope of the CommonJS plugins specification.

		// the dojo/text caches it's own resources because of dojo.cache
		dynamic: true,

		normalize: function(id, toAbsMid){
			// id is something like (path may be relative):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var parts= id.split("!"),
				url= parts[0];
			return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
		},

		load: function(id, require, load){
			// id: String
			//		Path to the resource.
			// require: Function
			//		Object that include the function toUrl with given id returns a valid URL from which to load the text.
			// load: Function
			//		Callback function which will be called, when the loading finished.

			// id is something like (path is always absolute):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var
				parts= id.split("!"),
				stripFlag= parts.length>1,
				absMid= parts[0],
				url = require.toUrl(parts[0]),
				requireCacheUrl = "url:" + url,
				text = notFound,
				finish = function(text){
					load(stripFlag ? strip(text) : text);
				};
			if(absMid in theCache){
				text = theCache[absMid];
			}else if(require.cache && requireCacheUrl in require.cache){
				text = require.cache[requireCacheUrl];
			}else if(url in theCache){
				text = theCache[url];
			}
			if(text===notFound){
				if(pending[url]){
					pending[url].push(finish);
				}else{
					var pendingList = pending[url] = [finish];
					getText(url, !require.async, function(text){
						theCache[absMid]= theCache[url]= text;
						for(var i = 0; i<pendingList.length;){
							pendingList[i++](text);
						}
						delete pending[url];
					});
				}
			}else{
				finish(text);
			}
		}
	};

}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));



/***/ }),

/***/ "./node_modules/dojo/topic.js":
/*!************************************!*\
  !*** ./node_modules/dojo/topic.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./Evented */ "./node_modules/dojo/Evented.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Evented){

	// module:
	//		dojo/topic

	var hub = new Evented;
	return {
		// summary:
		//		Pubsub hub.
		// example:
		//		| 	topic.subscribe("some/topic", function(event){
		//		|	... do something with event
		//		|	});
		//		|	topic.publish("some/topic", {name:"some event", ...});

		publish: function(topic, event){
			// summary:
			//		Publishes a message to a topic on the pub/sub hub. All arguments after
			//		the first will be passed to the subscribers, so any number of arguments
			//		can be provided (not just event).
			// topic: String
			//		The name of the topic to publish to
			// event: Object
			//		An event to distribute to the topic listeners
			return hub.emit.apply(hub, arguments);
		},

		subscribe: function(topic, listener){
			// summary:
			//		Subscribes to a topic on the pub/sub hub
			// topic: String
			//		The topic to subscribe to
			// listener: Function
			//		A function to call when a message is published to the given topic
			return hub.on.apply(hub, arguments);
		}
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/touch.js":
/*!************************************!*\
  !*** ./node_modules/dojo/touch.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./aspect */ "./node_modules/dojo/aspect.js"), __webpack_require__(/*! ./dom */ "./node_modules/dojo/dom.js"), __webpack_require__(/*! ./dom-class */ "./node_modules/dojo/dom-class.js"), __webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ./on */ "./node_modules/dojo/on.js"), __webpack_require__(/*! ./has */ "./node_modules/dojo/has.js"), __webpack_require__(/*! ./mouse */ "./node_modules/dojo/mouse.js"), __webpack_require__(/*! ./domReady */ "./node_modules/dojo/domReady.js"), __webpack_require__(/*! ./_base/window */ "./node_modules/dojo/_base/window.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, aspect, dom, domClass, lang, on, has, mouse, domReady, win){

	// module:
	//		dojo/touch

	var ios4 = has("ios") < 5;

	// Detect if platform supports Pointer Events, and if so, the names of the events (pointerdown vs. MSPointerDown).
	var hasPointer = has("pointer-events") || has("MSPointer"),
		pointer = (function () {
			var pointer = {};
			for (var type in { down: 1, move: 1, up: 1, cancel: 1, over: 1, out: 1 }) {
				pointer[type] = has("MSPointer") ?
					"MSPointer" + type.charAt(0).toUpperCase() + type.slice(1) :
					"pointer" + type;
			}
			return pointer;
		})();

	// Detect if platform supports the webkit touchstart/touchend/... events
	var hasTouch = has("touch-events");

	// Click generation variables
	var clicksInited, clickTracker, useTarget = false, clickTarget, clickX, clickY, clickDx, clickDy, clickTime;

	// Time of most recent touchstart, touchmove, or touchend event
	var lastTouch;

	function dualEvent(mouseType, touchType, pointerType){
		// Returns synthetic event that listens for both the specified mouse event and specified touch event.
		// But ignore fake mouse events that were generated due to the user touching the screen.
		if(hasPointer && pointerType){
			// IE10+: MSPointer* events are designed to handle both mouse and touch in a uniform way,
			// so just use that regardless of hasTouch.
			return function(node, listener){
				return on(node, pointerType, listener);
			};
		}else if(hasTouch){
			return function(node, listener){
				var handle1 = on(node, touchType, function(evt){
						listener.call(this, evt);

						// On slow mobile browsers (see https://bugs.dojotoolkit.org/ticket/17634),
						// a handler for a touch event may take >1s to run.  That time shouldn't
						// be included in the calculation for lastTouch.
						lastTouch = (new Date()).getTime();
					}),
					handle2 = on(node, mouseType, function(evt){
						if(!lastTouch || (new Date()).getTime() > lastTouch + 1000){
							listener.call(this, evt);
						}
					});
				return {
					remove: function(){
						handle1.remove();
						handle2.remove();
					}
				};
			};
		}else{
			// Avoid creating listeners for touch events on performance sensitive older browsers like IE6
			return function(node, listener){
				return on(node, mouseType, listener);
			};
		}
	}

	function marked(/*DOMNode*/ node){
		// Search for node ancestor has been marked with the dojoClick property to indicate special processing.
		// Returns marked ancestor.
		do{
			if(node.dojoClick !== undefined){ return node; }
		}while(node = node.parentNode);
	}

	function doClicks(e, moveType, endType){
		// summary:
		//		Setup touch listeners to generate synthetic clicks immediately (rather than waiting for the browser
		//		to generate clicks after the double-tap delay) and consistently (regardless of whether event.preventDefault()
		//		was called in an event listener. Synthetic clicks are generated only if a node or one of its ancestors has
		//		its dojoClick property set to truthy. If a node receives synthetic clicks because one of its ancestors has its
		//      dojoClick property set to truthy, you can disable synthetic clicks on this node by setting its own dojoClick property
		//      to falsy.

		if(mouse.isRight(e)){
			return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
		}

		var markedNode = marked(e.target);
		clickTracker  = !e.target.disabled && markedNode && markedNode.dojoClick; // click threshold = true, number, x/y object, or "useTarget"
		if(clickTracker){
			useTarget = (clickTracker == "useTarget");
			clickTarget = (useTarget?markedNode:e.target);
			if(useTarget){
				// We expect a click, so prevent any other
				// default action on "touchpress"
				e.preventDefault();
			}
			clickX = e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX;
			clickY = e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY;
			clickDx = (typeof clickTracker == "object" ? clickTracker.x : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
			clickDy = (typeof clickTracker == "object" ? clickTracker.y : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;

			// add move/end handlers only the first time a node with dojoClick is seen,
			// so we don't add too much overhead when dojoClick is never set.
			if(!clicksInited){
				clicksInited = true;

				function updateClickTracker(e){
					if(useTarget){
						clickTracker = dom.isDescendant(
							win.doc.elementFromPoint(
								(e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX),
								(e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY)),
							clickTarget);
					}else{
						clickTracker = clickTracker &&
							(e.changedTouches ? e.changedTouches[0].target : e.target) == clickTarget &&
							Math.abs((e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX) - clickX) <= clickDx &&
							Math.abs((e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY) - clickY) <= clickDy;
					}
				}

				win.doc.addEventListener(moveType, function(e){
					if(mouse.isRight(e)){
						return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
					}
					updateClickTracker(e);
					if(useTarget){
						// prevent native scroll event and ensure touchend is
						// fire after touch moves between press and release.
						e.preventDefault();
					}
				}, true);

				win.doc.addEventListener(endType, function(e){
					if(mouse.isRight(e)){
						return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
					}
					updateClickTracker(e);
					if(clickTracker){
						clickTime = (new Date()).getTime();
						var target = (useTarget?clickTarget:e.target);
						if(target.tagName === "LABEL"){
							// when clicking on a label, forward click to its associated input if any
							target = dom.byId(target.getAttribute("for")) || target;
						}
						//some attributes can be on the Touch object, not on the Event:
						//http://www.w3.org/TR/touch-events/#touch-interface
						var src = (e.changedTouches) ? e.changedTouches[0] : e;
						function createMouseEvent(type){
							//create the synthetic event.
							//http://www.w3.org/TR/DOM-Level-3-Events/#widl-MouseEvent-initMouseEvent
							var evt = document.createEvent("MouseEvents");
							evt._dojo_click = true;
							evt.initMouseEvent(type,
								true, //bubbles
								true, //cancelable
								e.view,
								e.detail,
								src.screenX,
								src.screenY,
								src.clientX,
								src.clientY,
								e.ctrlKey,
								e.altKey,
								e.shiftKey,
								e.metaKey,
								0, //button
								null //related target
							);
							return evt;
						}
						var mouseDownEvt = createMouseEvent("mousedown");
						var mouseUpEvt = createMouseEvent("mouseup");
						var clickEvt = createMouseEvent("click");

						setTimeout(function(){
							on.emit(target, "mousedown", mouseDownEvt);
							on.emit(target, "mouseup", mouseUpEvt);
							on.emit(target, "click", clickEvt);

							// refresh clickTime in case app-defined click handler took a long time to run
							clickTime = (new Date()).getTime();
						}, 0);
					}
				}, true);

				function stopNativeEvents(type){
					win.doc.addEventListener(type, function(e){
						// Stop native events when we emitted our own click event.  Note that the native click may occur
						// on a different node than the synthetic click event was generated on.  For example,
						// click on a menu item, causing the menu to disappear, and then (~300ms later) the browser
						// sends a click event to the node that was *underneath* the menu.  So stop all native events
						// sent shortly after ours, similar to what is done in dualEvent.
						// The INPUT.dijitOffScreen test is for offscreen inputs used in dijit/form/Button, on which
						// we call click() explicitly, we don't want to stop this event.
						var target = e.target;
						if(clickTracker && !e._dojo_click &&
								(new Date()).getTime() <= clickTime + 1000 &&
								!(target.tagName == "INPUT" && domClass.contains(target, "dijitOffScreen"))){
							e.stopPropagation();
							e.stopImmediatePropagation && e.stopImmediatePropagation();
							if(type == "click" &&
								(target.tagName != "INPUT" ||
								(target.type == "radio" &&
									// #18352 Do not preventDefault for radios that are not dijit or
									// dojox/mobile widgets.
									// (The CSS class dijitCheckBoxInput holds for both checkboxes and radio buttons.)
									(domClass.contains(target, "dijitCheckBoxInput") ||
										domClass.contains(target, "mblRadioButton"))) ||
								(target.type == "checkbox" &&
									// #18352 Do not preventDefault for checkboxes that are not dijit or
									// dojox/mobile widgets.
									(domClass.contains(target, "dijitCheckBoxInput") ||
										domClass.contains(target, "mblCheckBox")))) &&
								target.tagName != "TEXTAREA" && target.tagName != "AUDIO" && target.tagName != "VIDEO"){
								// preventDefault() breaks textual <input>s on android, keyboard doesn't popup,
								// but it is still needed for checkboxes and radio buttons, otherwise in some cases
								// the checked state becomes inconsistent with the widget's state
								e.preventDefault();
							}
						}
					}, true);
				}

				stopNativeEvents("click");

				// We also stop mousedown/up since these would be sent well after with our "fast" click (300ms),
				// which can confuse some dijit widgets.
				stopNativeEvents("mousedown");
				stopNativeEvents("mouseup");
			}
		}
	}

	var hoveredNode;

	if(has("touch")){
		if(hasPointer){
			// MSPointer (IE10+) already has support for over and out, so we just need to init click support
			domReady(function(){
				win.doc.addEventListener(pointer.down, function(evt){
					doClicks(evt, pointer.move, pointer.up);
				}, true);
			});
		}else{
			domReady(function(){
				// Keep track of currently hovered node
				hoveredNode = win.body();	// currently hovered node

				win.doc.addEventListener("touchstart", function(evt){
						lastTouch = (new Date()).getTime();

					// Precede touchstart event with touch.over event.  DnD depends on this.
					// Use addEventListener(cb, true) to run cb before any touchstart handlers on node run,
					// and to ensure this code runs even if the listener on the node does event.stop().
					var oldNode = hoveredNode;
					hoveredNode = evt.target;
					on.emit(oldNode, "dojotouchout", {
						relatedTarget: hoveredNode,
						bubbles: true
					});
					on.emit(hoveredNode, "dojotouchover", {
						relatedTarget: oldNode,
						bubbles: true
					});

					doClicks(evt, "touchmove", "touchend"); // init click generation
				}, true);

				function copyEventProps(evt){
					// Make copy of event object and also set bubbles:true.  Used when calling on.emit().
					var props = lang.delegate(evt, {
						bubbles: true
					});

					if(has("ios") >= 6){
						// On iOS6 "touches" became a non-enumerable property, which
						// is not hit by for...in.  Ditto for the other properties below.
						props.touches = evt.touches;
						props.altKey = evt.altKey;
						props.changedTouches = evt.changedTouches;
						props.ctrlKey = evt.ctrlKey;
						props.metaKey = evt.metaKey;
						props.shiftKey = evt.shiftKey;
						props.targetTouches = evt.targetTouches;
					}

					return props;
				}

				on(win.doc, "touchmove", function(evt){
					lastTouch = (new Date()).getTime();

					var newNode = win.doc.elementFromPoint(
						evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
						evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
					);

					if(newNode){
						// Fire synthetic touchover and touchout events on nodes since the browser won't do it natively.
						if(hoveredNode !== newNode){
							// touch out on the old node
							on.emit(hoveredNode, "dojotouchout", {
								relatedTarget: newNode,
								bubbles: true
							});

							// touchover on the new node
							on.emit(newNode, "dojotouchover", {
								relatedTarget: hoveredNode,
								bubbles: true
							});

							hoveredNode = newNode;
						}

						// Unlike a listener on "touchmove", on(node, "dojotouchmove", listener) fires when the finger
						// drags over the specified node, regardless of which node the touch started on.
						if(!on.emit(newNode, "dojotouchmove", copyEventProps(evt))){
							// emit returns false when synthetic event "dojotouchmove" is cancelled, so we prevent the
							// default behavior of the underlying native event "touchmove".
							evt.preventDefault();
						}
					}
				});

				// Fire a dojotouchend event on the node where the finger was before it was removed from the screen.
				// This is different than the native touchend, which fires on the node where the drag started.
				on(win.doc, "touchend", function(evt){
						lastTouch = (new Date()).getTime();
					var node = win.doc.elementFromPoint(
						evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
						evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
					) || win.body(); // if out of the screen

					on.emit(node, "dojotouchend", copyEventProps(evt));
				});
			});
		}
	}

	//device neutral events - touch.press|move|release|cancel/over/out
	var touch = {
		press: dualEvent("mousedown", "touchstart", pointer.down),
		move: dualEvent("mousemove", "dojotouchmove", pointer.move),
		release: dualEvent("mouseup", "dojotouchend", pointer.up),
		cancel: dualEvent(mouse.leave, "touchcancel", hasPointer ? pointer.cancel : null),
		over: dualEvent("mouseover", "dojotouchover", pointer.over),
		out: dualEvent("mouseout", "dojotouchout", pointer.out),
		enter: mouse._eventHandler(dualEvent("mouseover","dojotouchover", pointer.over)),
		leave: mouse._eventHandler(dualEvent("mouseout", "dojotouchout", pointer.out))
	};

	/*=====
	touch = {
		// summary:
		//		This module provides unified touch event handlers by exporting
		//		press, move, release and cancel which can also run well on desktop.
		//		Based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
		//      Also, if the dojoClick property is set to truthy on a DOM node, dojo/touch generates
		//      click events immediately for this node and its descendants (except for descendants that
		//      have a dojoClick property set to falsy), to avoid the delay before native browser click events,
		//      and regardless of whether evt.preventDefault() was called in a touch.press event listener.
		//
		// example:
		//		Used with dojo/on
		//		|	define(["dojo/on", "dojo/touch"], function(on, touch){
		//		|		on(node, touch.press, function(e){});
		//		|		on(node, touch.move, function(e){});
		//		|		on(node, touch.release, function(e){});
		//		|		on(node, touch.cancel, function(e){});
		// example:
		//		Used with touch.* directly
		//		|	touch.press(node, function(e){});
		//		|	touch.move(node, function(e){});
		//		|	touch.release(node, function(e){});
		//		|	touch.cancel(node, function(e){});
		// example:
		//		Have dojo/touch generate clicks without delay, with a default move threshold of 4 pixels
		//		|	node.dojoClick = true;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically
		//		|	node.dojoClick = 10;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically
		//		|	node.dojoClick = {x:50, y:5};
		// example:
		//		Disable clicks without delay generated by dojo/touch on a node that has an ancestor with property dojoClick set to truthy
		//		|  node.dojoClick = false;

		press: function(node, listener){
			// summary:
			//		Register a listener to 'touchstart'|'mousedown' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		move: function(node, listener){
			// summary:
			//		Register a listener that fires when the mouse cursor or a finger is dragged over the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		release: function(node, listener){
			// summary:
			//		Register a listener to releasing the mouse button while the cursor is over the given node
			//		(i.e. "mouseup") or for removing the finger from the screen while touching the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		cancel: function(node, listener){
			// summary:
			//		Register a listener to 'touchcancel'|'mouseleave' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		over: function(node, listener){
			// summary:
			//		Register a listener to 'mouseover' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		out: function(node, listener){
			// summary:
			//		Register a listener to 'mouseout' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		enter: function(node, listener){
			// summary:
			//		Register a listener to mouse.enter or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		leave: function(node, listener){
			// summary:
			//		Register a listener to mouse.leave or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		}
	};
	=====*/

	has("extend-dojo") && (dojo.touch = touch);

	return touch;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/uacss.js":
/*!************************************!*\
  !*** ./node_modules/dojo/uacss.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./dom-geometry */ "./node_modules/dojo/dom-geometry.js"), __webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ./domReady */ "./node_modules/dojo/domReady.js"), __webpack_require__(/*! ./sniff */ "./node_modules/dojo/sniff.js"), __webpack_require__(/*! ./_base/window */ "./node_modules/dojo/_base/window.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(geometry, lang, domReady, has, baseWindow){

	// module:
	//		dojo/uacss

	/*=====
	return {
		// summary:
		//		Applies pre-set CSS classes to the top-level HTML node, based on:
		//
		//		- browser (ex: dj_ie)
		//		- browser version (ex: dj_ie6)
		//		- box model (ex: dj_contentBox)
		//		- text direction (ex: dijitRtl)
		//
		//		In addition, browser, browser version, and box model are
		//		combined with an RTL flag when browser text is RTL. ex: dj_ie-rtl.
		//
		//		Returns the has() method.
	};
	=====*/

	var
		html = baseWindow.doc.documentElement,
		ie = has("ie"),
		trident = has("trident"),
		opera = has("opera"),
		maj = Math.floor,
		ff = has("ff"),
		boxModel = geometry.boxModel.replace(/-/,''),

		classes = {
			"dj_quirks": has("quirks"),

			// NOTE: Opera not supported by dijit
			"dj_opera": opera,

			"dj_khtml": has("khtml"),

			"dj_webkit": has("webkit"),
			"dj_safari": has("safari"),
			"dj_chrome": has("chrome"),
			"dj_edge": has("edge"),

			"dj_gecko": has("mozilla"),

			"dj_ios": has("ios"),
			"dj_android": has("android")
		}; // no dojo unsupported browsers

	if(ie){
		classes["dj_ie"] = true;
		classes["dj_ie" + maj(ie)] = true;
		classes["dj_iequirks"] = has("quirks");
	}
	if(trident){
		classes["dj_trident"] = true;
		classes["dj_trident" + maj(trident)] = true;
	}
	if(ff){
		classes["dj_ff" + maj(ff)] = true;
	}

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	var classStr = "";
	for(var clz in classes){
		if(classes[clz]){
			classStr += clz + " ";
		}
	}
	html.className = lang.trim(html.className + " " + classStr);

	// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.
	// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).
	domReady(function(){
		if(!geometry.isBodyLtr()){
			var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ");
			html.className = lang.trim(html.className + " " + rtlClassStr + "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl "));
		}
	});
	return has;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/when.js":
/*!***********************************!*\
  !*** ./node_modules/dojo/when.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./Deferred */ "./node_modules/dojo/Deferred.js"),
	__webpack_require__(/*! ./promise/Promise */ "./node_modules/dojo/promise/Promise.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Deferred, Promise){
	"use strict";

	// module:
	//		dojo/when

	return function when(valueOrPromise, callback, errback, progback){
		// summary:
		//		Transparently applies callbacks to values and/or promises.
		// description:
		//		Accepts promises but also transparently handles non-promises. If no
		//		callbacks are provided returns a promise, regardless of the initial
		//		value. Foreign promises are converted.
		//
		//		If callbacks are provided and the initial value is not a promise,
		//		the callback is executed immediately with no error handling. Returns
		//		a promise if the initial value is a promise, or the result of the
		//		callback otherwise.
		// valueOrPromise:
		//		Either a regular value or an object with a `then()` method that
		//		follows the Promises/A specification.
		// callback: Function?
		//		Callback to be invoked when the promise is resolved, or a non-promise
		//		is received.
		// errback: Function?
		//		Callback to be invoked when the promise is rejected.
		// progback: Function?
		//		Callback to be invoked when the promise emits a progress update.
		// returns: dojo/promise/Promise
		//		Promise, or if a callback is provided, the result of the callback.

		var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
		var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

		if(!receivedPromise){
			if(arguments.length > 1){
				return callback ? callback(valueOrPromise) : valueOrPromise;
			}else{
				return new Deferred().resolve(valueOrPromise);
			}
		}else if(!nativePromise){
			var deferred = new Deferred(valueOrPromise.cancel);
			valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
			valueOrPromise = deferred.promise;
		}

		if(callback || errback || progback){
			return valueOrPromise.then(callback, errback, progback);
		}
		return valueOrPromise;
	};
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/window.js":
/*!*************************************!*\
  !*** ./node_modules/dojo/window.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ./sniff */ "./node_modules/dojo/sniff.js"), __webpack_require__(/*! ./_base/window */ "./node_modules/dojo/_base/window.js"), __webpack_require__(/*! ./dom */ "./node_modules/dojo/dom.js"), __webpack_require__(/*! ./dom-geometry */ "./node_modules/dojo/dom-geometry.js"), __webpack_require__(/*! ./dom-style */ "./node_modules/dojo/dom-style.js"), __webpack_require__(/*! ./dom-construct */ "./node_modules/dojo/dom-construct.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang, has, baseWindow, dom, geom, style, domConstruct){

	// feature detection
	/* not needed but included here for future reference
	has.add("rtl-innerVerticalScrollBar-on-left", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'hidden', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', width:'64px', height:'64px'}
			}, body, "last"),
			center = domConstruct.create('center', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			inner = domConstruct.create('div', {
				style: {overflow:'visible', display:'inline' }
			}, center, "last");
		inner.innerHTML="&nbsp;";
		var midPoint = Math.max(inner.offsetLeft, geom.position(inner).x);
		var ret = midPoint >= 32;
		center.removeChild(inner);
		scrollable.removeChild(center);
		body.removeChild(scrollable);
		return ret;
	});
	*/
	has.add("rtl-adjust-position-for-verticalScrollBar", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'visible', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', top:'0', width:'64px', height:'64px'}
			}, body, "last"),
			div = domConstruct.create('div', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			ret = geom.position(div).x != 0;
		scrollable.removeChild(div);
		body.removeChild(scrollable);
		return ret;
	});

	has.add("position-fixed-support", function(win, doc){
		// IE6, IE7+quirks, and some older mobile browsers don't support position:fixed
		var	body = baseWindow.body(doc),
			outer = domConstruct.create('span', {
				style: {visibility:'hidden', position:'fixed', left:'1px', top:'1px'}
			}, body, "last"),
			inner = domConstruct.create('span', {
				style: {position:'fixed', left:'0', top:'0'}
			}, outer, "last"),
			ret = geom.position(inner).x != geom.position(outer).x;
		outer.removeChild(inner);
		body.removeChild(outer);
		return ret;
	});

	// module:
	//		dojo/window

	var window = {
		// summary:
		//		TODOC

		getBox: function(/*Document?*/ doc){
			// summary:
			//		Returns the dimensions and scroll position of the viewable area of a browser window

			doc = doc || baseWindow.doc;

			var
				scrollRoot = (doc.compatMode == 'BackCompat') ? baseWindow.body(doc) : doc.documentElement,
				// get scroll position
				scroll = geom.docScroll(doc), // scrollRoot.scrollTop/Left should work
				w, h;

			if(has("touch")){ // if(scrollbars not supported)
				var uiWindow = window.get(doc);   // use UI window, not dojo.global window
				// on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight
				w = uiWindow.innerWidth || scrollRoot.clientWidth; // || scrollRoot.clientXXX probably never evaluated
				h = uiWindow.innerHeight || scrollRoot.clientHeight;
			}else{
				// on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight
				// uiWindow.innerWidth/Height includes the scrollbar and cannot be used
				w = scrollRoot.clientWidth;
				h = scrollRoot.clientHeight;
			}
			return {
				l: scroll.x,
				t: scroll.y,
				w: w,
				h: h
			};
		},

		get: function(/*Document*/ doc){
			// summary:
			//		Get window object associated with document doc.
			// doc:
			//		The document to get the associated window for.

			// In some IE versions (at least 6.0), document.parentWindow does not return a
			// reference to the real window object (maybe a copy), so we must fix it as well
			// We use IE specific execScript to attach the real window reference to
			// document._parentWindow for later use
			if(has("ie") && window !== document.parentWindow){
				/*
				In IE 6, only the variable "window" can be used to connect events (others
				may be only copies).
				*/
				doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
				//to prevent memory leak, unset it after use
				//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
				var win = doc._parentWindow;
				doc._parentWindow = null;
				return win;	//	Window
			}

			return doc.parentWindow || doc.defaultView;	//	Window
		},

		scrollIntoView: function(/*DomNode*/ node, /*Object?*/ pos){
			// summary:
			//		Scroll the passed node into view using minimal movement, if it is not already.

			// Don't rely on node.scrollIntoView working just because the function is there since
			// it forces the node to the page's bottom or top (and left or right in IE) without consideration for the minimal movement.
			// WebKit's node.scrollIntoViewIfNeeded doesn't work either for inner scrollbars in right-to-left mode
			// and when there's a fixed position scrollable element

			try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
				node = dom.byId(node);
				var	doc = node.ownerDocument || baseWindow.doc,	// TODO: why baseWindow.doc?  Isn't node.ownerDocument always defined?
					body = baseWindow.body(doc),
					html = doc.documentElement || body.parentNode,
					isIE = has("ie") || has("trident"),
					isWK = has("webkit");
				// if an untested browser, then use the native method
				if(node == body || node == html){ return; }
				if(!(has("mozilla") || isIE || isWK || has("opera") || has("trident") || has("edge"))
						&& ("scrollIntoView" in node)){
					node.scrollIntoView(false); // short-circuit to native if possible
					return;
				}
				var	backCompat = doc.compatMode == 'BackCompat',
					rootWidth = Math.min(body.clientWidth || html.clientWidth, html.clientWidth || body.clientWidth),
					rootHeight = Math.min(body.clientHeight || html.clientHeight, html.clientHeight || body.clientHeight),
					scrollRoot = (isWK || backCompat) ? body : html,
					nodePos = pos || geom.position(node),
					el = node.parentNode,
					isFixed = function(el){
						return (isIE <= 6 || (isIE == 7 && backCompat))
							? false
							: (has("position-fixed-support") && (style.get(el, 'position').toLowerCase() == "fixed"));
					},
					self = this,
					scrollElementBy = function(el, x, y){
						if(el.tagName == "BODY" || el.tagName == "HTML"){
							self.get(el.ownerDocument).scrollBy(x, y);
						}else{
							x && (el.scrollLeft += x);
							y && (el.scrollTop += y);
						}
					};
				if(isFixed(node)){ return; } // nothing to do
				while(el){
					if(el == body){ el = scrollRoot; }
					var	elPos = geom.position(el),
						fixedPos = isFixed(el),
						rtl = style.getComputedStyle(el).direction.toLowerCase() == "rtl";

					if(el == scrollRoot){
						elPos.w = rootWidth; elPos.h = rootHeight;
						if(scrollRoot == html && (isIE || has("trident")) && rtl){
							elPos.x += scrollRoot.offsetWidth-elPos.w;// IE workaround where scrollbar causes negative x
						}
						elPos.x = 0;
						elPos.y = 0;
					}else{
						var pb = geom.getPadBorderExtents(el);
						elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
						var clientSize = el.clientWidth,
							scrollBarSize = elPos.w - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							if(rtl && has("rtl-adjust-position-for-verticalScrollBar")){
								elPos.x += scrollBarSize;
							}
							elPos.w = clientSize;
						}
						clientSize = el.clientHeight;
						scrollBarSize = elPos.h - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							elPos.h = clientSize;
						}
					}
					if(fixedPos){ // bounded by viewport, not parents
						if(elPos.y < 0){
							elPos.h += elPos.y; elPos.y = 0;
						}
						if(elPos.x < 0){
							elPos.w += elPos.x; elPos.x = 0;
						}
						if(elPos.y + elPos.h > rootHeight){
							elPos.h = rootHeight - elPos.y;
						}
						if(elPos.x + elPos.w > rootWidth){
							elPos.w = rootWidth - elPos.x;
						}
					}
					// calculate overflow in all 4 directions
					var	l = nodePos.x - elPos.x, // beyond left: < 0
//						t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
						t = nodePos.y - elPos.y, // beyond top: < 0
						r = l + nodePos.w - elPos.w, // beyond right: > 0
						bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
					var s, old;
					if(r * l > 0 && (!!el.scrollLeft || el == scrollRoot || el.scrollWidth > el.offsetHeight)){
						s = Math[l < 0? "max" : "min"](l, r);
						if(rtl && ((isIE == 8 && !backCompat) || has("trident") >= 5)){ s = -s; }
						old = el.scrollLeft;
						scrollElementBy(el, s, 0);
						s = el.scrollLeft - old;
						nodePos.x -= s;
					}
					if(bot * t > 0 && (!!el.scrollTop || el == scrollRoot || el.scrollHeight > el.offsetHeight)){
						s = Math.ceil(Math[t < 0? "max" : "min"](t, bot));
						old = el.scrollTop;
						scrollElementBy(el, 0, s);
						s = el.scrollTop - old;
						nodePos.y -= s;
					}
					el = (el != scrollRoot) && !fixedPos && el.parentNode;
				}
			}catch(error){
				console.error('scrollIntoView: ' + error);
				node.scrollIntoView(false);
			}
		}
	};

	has("extend-dojo") && lang.setObject("dojo.window", window);

	return window;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlqaXQvQmFja2dyb3VuZElmcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlqaXQvRGVzdHJveWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rpaml0L1Rvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rpaml0L1ZpZXdwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9fQXR0YWNoTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rpaml0L19CaWRpTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rpaml0L19Dc3NTdGF0ZU1peGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9fRm9jdXNNaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlqaXQvX09uRGlqaXRDbGlja01peGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9fVGVtcGxhdGVkTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rpaml0L19XaWRnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rpaml0L19XaWRnZXRCYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9fYmFzZS9tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9hMTF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9hMTF5Y2xpY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rpaml0L2ZvY3VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9mb3JtL0Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rpaml0L2Zvcm0vVGV4dEJveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlqaXQvZm9ybS9WYWxpZGF0aW9uVGV4dEJveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlqaXQvZm9ybS9fRm9ybU1peGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9mb3JtL19Gb3JtVmFsdWVNaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlqaXQvZm9ybS9fRm9ybVZhbHVlV2lkZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9mb3JtL19Gb3JtV2lkZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9mb3JtL19Gb3JtV2lkZ2V0TWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rpaml0L2Zvcm0vX1RleHRCb3hNaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlqaXQvZm9ybS9ubHMvZXMvdmFsaWRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rpaml0L2Zvcm0vbmxzL2ZyL3ZhbGlkYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9mb3JtL25scy92YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlqaXQvaGNjc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rpaml0L2xheW91dC9fQ29udGVudFBhbmVSZXNpemVNaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlqaXQvbGF5b3V0L3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9tYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9wbGFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlqaXQvcmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8td2VicGFjay1wbHVnaW4vbGliL05vTW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWppdC9mb3JtL25scy92YWxpZGF0ZS5qcz80YTVlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvLXdlYnBhY2stcGx1Z2luL2xvYWRlcnMvZG9qby9ydW5uZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rpaml0L2Zvcm0vdGVtcGxhdGVzL1RleHRCb3guaHRtbCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlqaXQvZm9ybS90ZW1wbGF0ZXMvVmFsaWRhdGlvblRleHRCb3guaHRtbCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlqaXQvdGVtcGxhdGVzL1Rvb2x0aXAuaHRtbCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9EZWZlcnJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9FdmVudGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL1N0YXRlZnVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL19iYXNlL0NvbG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL19iYXNlL0RlZmVycmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL19iYXNlL2FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL19iYXNlL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9fYmFzZS9jb25uZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL19iYXNlL2RlY2xhcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vX2Jhc2UvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vX2Jhc2UvZnguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vX2Jhc2UvanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9fYmFzZS9rZXJuZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vX2Jhc2UvbGFuZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9fYmFzZS9zbmlmZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9fYmFzZS93aW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vX2Jhc2UveGhyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL2FzcGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9jYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9kb20tYXR0ci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9kb20tY2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vZG9tLWNvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9kb20tZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9kb20tZ2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vZG9tLXByb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vZG9tLXN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL2RvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9kb21SZWFkeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9lcnJvcnMvQ2FuY2VsRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vZXJyb3JzL1JlcXVlc3RFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9lcnJvcnMvUmVxdWVzdFRpbWVvdXRFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9lcnJvcnMvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vaGNjc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vaTE4bi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9pby1xdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vbW91c2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vcHJvbWlzZS9Qcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL3Byb21pc2UvaW5zdHJ1bWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL3Byb21pc2UvdHJhY2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL3F1ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL3JlYWR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL3JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vcmVxdWVzdC9oYW5kbGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9yZXF1ZXN0L3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vcmVxdWVzdC93YXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9yZXF1ZXN0L3hoci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby9zZWxlY3Rvci9fbG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL3NlbGVjdG9yL2xpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vc25pZmYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vdG9waWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vdG91Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vdWFjc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8vd2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9qby93aW5kb3cuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlHQUFPO0FBQ1AsQ0FBQyxrQ0FBUztBQUNWLENBQUMsaUVBQVE7QUFDVCxDQUFDLG1GQUFtQjtBQUNwQixDQUFDLHFGQUFvQjtBQUNyQixDQUFDLDZFQUFnQjtBQUNqQixDQUFDLCtFQUFpQjtBQUNsQixDQUFDLCtEQUFTO0FBQ1YsQ0FBQyxxRUFBWTtBQUNiLENBQUMsbUNBQUU7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJ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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFH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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0NBQWdDO0FBQ2hDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDZEQUE2RDtBQUM3RCwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHNGQUFzRixNQUFNO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixNQUFNO0FBQ3BHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2RUFBNkU7QUFDN0UsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxpRUFBaUU7QUFDakUsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkcsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0EsdUNBQXVDLHNCQUFzQixFQUFFO0FBQy9EO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFBQSxvR0FBQzs7Ozs7Ozs7Ozs7O0FDenNDRixpR0FBTztBQUNQLENBQUMsaUZBQWtCO0FBQ25CLENBQUMsbUZBQW1CO0FBQ3BCLENBQUMsK0VBQWlCO0FBQ2xCLENBQUMsMEVBQWE7QUFDZCxDQUFDLGtFQUFTO0FBQ1YsQ0FBQyxtQ0FBRTs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBLHdCQUF3QjtBQUN4QixjQUFjO0FBQ2QsQ0FBQztBQUFBLG9HQUFDOzs7Ozs7Ozs7Ozs7QUNsQ0YsaUdBQU87QUFDUCxDQUFDLGlGQUFrQjtBQUNuQixDQUFDLGlFQUFVO0FBQ1gsQ0FBQywyRUFBZTtBQUNoQixDQUFDLDZFQUFnQjtBQUNqQixDQUFDLCtFQUFpQjtBQUNsQixDQUFDLHFFQUFZO0FBQ2IsQ0FBQyxpRUFBUTtBQUNULENBQUMsbUNBQUU7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsMENBQTBDO0FBQzFDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7QUFBQSxvR0FBQzs7Ozs7Ozs7Ozs7O0FDOUxGLGlHQUFPO0FBQ1AsQ0FBQyxtRUFBVztBQUNaLENBQUMscUVBQVk7QUFDYixDQUFDLCtEQUFTO0FBQ1YsQ0FBQyxxRUFBWTtBQUNiLENBQUMsbUNBQUU7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQyx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0EsQ0FBQztBQUFBLG9HQUFDOzs7Ozs7Ozs7Ozs7QUMxSUYsaUdBQU87QUFDUCxDQUFDLHVFQUFhO0FBQ2QsQ0FBQyxxRkFBb0I7QUFDckIsQ0FBQyxpRUFBVTtBQUNYLENBQUMsMkVBQWU7QUFDaEIsQ0FBQyw2RUFBZ0I7QUFDakIsQ0FBQyxxRkFBb0I7QUFDckIsQ0FBQyx5RUFBYztBQUNmLENBQUMsK0VBQWlCO0FBQ2xCLENBQUMsK0RBQVM7QUFDVixDQUFDLDJFQUFlO0FBQ2hCLENBQUMscUVBQVk7QUFDYixDQUFDLDJFQUFlO0FBQ2hCLENBQUMsbUZBQW1CO0FBQ3BCLENBQUMsdUVBQWE7QUFDZCxDQUFDLGlFQUFRO0FBQ1QsQ0FBQyx5RUFBWTtBQUNiLENBQUMsaUVBQVE7QUFDVCxDQUFDLG1DQUFFO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE1BQU07QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7O0FBRXJEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSiwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxTQUFTOztBQUViO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixzQ0FBc0M7QUFDNUQ7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGNBQWMsRUFBRSxTQUFTO0FBQ2pDO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxDQUFDO0FBQUEsb0dBQUM7Ozs7Ozs7Ozs7OztBQ2xYRixpR0FBTztBQUNQLENBQUMscUZBQW9CO0FBQ3JCLENBQUMsMkVBQWU7QUFDaEIsQ0FBQyxtRkFBbUI7QUFDcEIsQ0FBQyxxRUFBWTtBQUNiLENBQUMsd0VBQVk7QUFDYixDQUFDLHdGQUFvQjtBQUNyQixDQUFDLGtGQUFjO0FBQ2YsQ0FBQyxzSEFBbUM7QUFDcEMsQ0FBQyxtQ0FBRTs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrSEFBK0gsaUJBQWlCOztBQUVoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7QUFBQSxvR0FBQzs7Ozs7Ozs7Ozs7O0FDdktGLGlHQUFPO0FBQ1AsQ0FBQyxxRkFBb0I7QUFDckIsQ0FBQyxxRkFBb0I7QUFDckIsQ0FBQyw2RUFBZ0I7QUFDakIsQ0FBQyxtRkFBbUI7QUFDcEIsQ0FBQywrRUFBaUI7QUFDbEIsQ0FBQywrREFBUztBQUNWLENBQUMscUVBQVk7QUFDYixDQUFDLDhGQUFvQjtBQUNyQixDQUFDLHdGQUFpQjtBQUNsQixDQUFDLCtLQUFvQztBQUNyQyxDQUFDLGtFQUFTO0FBQ1YsQ0FBQyxtQ0FBRTtBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0pBQXdKLEtBQUssSUFBSSxpQkFBaUI7O0FBRWxMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVM7QUFDZjtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaURBQWlELHNCQUFzQixFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsQ0FBQztBQUFBLG9HQUFDOzs7Ozs7Ozs7Ozs7QUM5S0YsaUdBQU87QUFDUCxDQUFDLHFGQUFvQjtBQUNyQixDQUFDLG1GQUFtQjtBQUNwQixDQUFDLCtFQUFpQjtBQUNsQixDQUFDLG1FQUFXO0FBQ1osQ0FBQyw0RUFBVztBQUNaLENBQUMsd0VBQVk7QUFDYixDQUFDLG1NQUE4QztBQUMvQyxDQUFDLDhKQUEwQjtBQUMzQixDQUFDLG1DQUFFOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsSUFBSTtBQUNKLCtDQUErQztBQUMvQyxvRUFBb0U7QUFDcEUsSUFBSTtBQUNKLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxFQUFFLEtBQUssS0FBSztBQUNoRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSyxTQUFTO0FBQ2Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxHQUFHOztBQUVIO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFBQSxvR0FBQzs7Ozs7Ozs7Ozs7O0FDbFZGLGlHQUFPO0FBQ1AsQ0FBQyxpRkFBa0I7QUFDbkIsQ0FBQyxxRkFBb0I7QUFDckIsQ0FBQyxtRkFBbUI7QUFDcEIsQ0FBQywrRUFBaUI7QUFDbEIsQ0FBQywrREFBUztBQUNWLENBQUMsdUVBQWE7QUFDZCxDQUFDLG1DQUFFOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQkFBbUI7OztBQUdoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0JBQWtCLGFBQWEsRUFBRTtBQUNyQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2QkFBNkIsRUFBRTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw0QkFBNEIsRUFBRTtBQUM3RixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlDQUFpQyxRQUFROztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLE1BQU07QUFDTix5QkFBeUI7QUFDekIsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLEVBQUU7QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNELHVDQUF1QyxFQUFFO0FBQy9GLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRixDQUFDO0FBQUEsb0dBQUM7Ozs7Ozs7Ozs7OztBQ3JjRixpR0FBTztBQUNQLENBQUMscUZBQW9CO0FBQ3JCLENBQUMsMkVBQWU7QUFDaEIsQ0FBQyxtRUFBVztBQUNaLENBQUMsK0VBQWlCO0FBQ2xCLENBQUMsK0RBQVM7QUFDVixDQUFDLHFFQUFZO0FBQ2IsQ0FBQyw4RkFBb0I7QUFDckIsQ0FBQyxtQ0FBRTs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQztBQUFBLG9HQUFDOzs7Ozs7Ozs7Ozs7QUNoRkYsaUdBQU87QUFDUCxDQUFDLHFGQUFvQjtBQUNyQixDQUFDLHFFQUFZO0FBQ2IsQ0FBQyxvRkFBZTtBQUNoQixDQUFDLDRGQUFtQjtBQUNwQixDQUFDLG1DQUFFOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELDJDQUEyQztBQUMzQztBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQSxTQUFTLEVBQUU7QUFDWDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7QUFBQSxvR0FBQzs7Ozs7Ozs7Ozs7O0FDbERGLGlHQUFPO0FBQ1AsQ0FBQyxxRkFBb0I7QUFDckIsQ0FBQyxxRUFBWTtBQUNiLENBQUMsbUZBQW1CO0FBQ3BCLENBQUMscUVBQVk7QUFDYixDQUFDLHdFQUFZO0FBQ2IsQ0FBQyxzRkFBbUI7QUFDcEIsQ0FBQyx3RkFBb0I7QUFDckIsQ0FBQyw4RkFBb0I7QUFDckIsQ0FBQyxtQ0FBRTs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQztBQUFBLG9HQUFDOzs7Ozs7Ozs7Ozs7QUNsRUYsaUdBQU87QUFDUCxDQUFDLGlGQUFrQjtBQUNuQixDQUFDLHFGQUFvQjtBQUNyQixDQUFDLDJFQUFlO0FBQ2hCLENBQUMsNkVBQWdCO0FBQ2pCLENBQUMsK0VBQWlCO0FBQ2xCLENBQUMscUVBQVk7QUFDYixDQUFDLCtEQUFTO0FBQ1YsQ0FBQyxxRUFBWTtBQUNiLENBQUMsdUVBQWE7QUFDZCxDQUFDLGtFQUFTO0FBQ1YsQ0FBQyxtQ0FBRTs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsT0FBTztBQUNQLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7QUFDVDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDO0FBQUEsb0dBQUM7Ozs7Ozs7Ozs7OztBQzdQRixpR0FBTztBQUNQLENBQUMsaUZBQWtCO0FBQ25CLENBQUMscUZBQW9CO0FBQ3JCLENBQUMsaUVBQVU7QUFDWCxDQUFDLHFFQUFZO0FBQ2IsQ0FBQyxtRUFBVztBQUNaLENBQUMsK0VBQWlCO0FBQ2xCLENBQUMsK0RBQVM7QUFDVixDQUFDLGtFQUFTO0FBQ1YsQ0FBQyxtQ0FBRTs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsR0FBRzs7QUFFSDtBQUNBO0FB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CLGNBQWMsRUFBRSxFQUFFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsR0FBRztBQUNIO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBLENBQUM7QUFBQSxvR0FBQzs7Ozs7Ozs7Ozs7O0FDOVhGLGlHQUFPLENBQUMsMEVBQVUsRUFBRSwrREFBUSxFQUFFLHNFQUFRLENBQUMsbUNBQUU7QUFDekM7QUFDQTs7QUFFQTtBQUNBLGVBQWU7O0FBRWY7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxVQUFVO0FBQ2xCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZSxFQUFFO0FBQ25FO0FBQ0E7QUFDQSxrREFBa0QsZUFBZSxFQUFFO0FBQ25FLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlLEVBQUU7QUFDakU7QUFDQTtBQUNBLGdEQUFnRCxlQUFlLEVBQUU7QUFDakUsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQSxJQUFJO0FBQ0osU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0EsSUFBSTtBQUNKLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxlQUFlLEVBQUU7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsQ0FBQztBQUFBLG9HQUFDOzs7Ozs7Ozs7Ozs7QUM3VkYsaUdBQU8sQ0FBQyxxRUFBVyxFQUFFLCtEQUFRLEVBQUUsa0NBQVMsQ0FBQyxtQ0FBRTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQsNkRBQTZEO0FBQzdEO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxzREFBc0Q7QUFDdEQ7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFBQSxvR0FBQzs7Ozs7Ozs7Ozs7OztBQ3RMRixpR0FBTyxDQUFDLDBFQUFVLEVBQUUsNkRBQU8sRUFBRSxtRUFBVSxFQUFFLHFFQUFXLEVBQUUsd0VBQVMsRUFBRSxtRUFBVSxFQUFFLHdFQUFTLEVBQUUsc0VBQVEsRUFBRSxpRUFBUyxDQUFDLG1DQUFFO0FBQzlHO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCO0FBQ3hELG1DQUFtQyx1QkFBdUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsTUFBTTtBQUNOLGNBQWM7QUFDZCxNQUFNO0FBQ04sY0FBYztBQUNkLE1BQU07QUFDTiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBDQUEwQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGNBQWM7QUFDcEUsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUssTUFBTSxpQkFBaUI7QUFDakQ7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsaUNBQWlDLEVBQUU7QUFDcEc7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGlDQUFpQztBQUNsRztBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQsNEVBQTRFO0FBQzVFLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsaUNBQWlDO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUFBLG9HQUFDOzs7Ozs7Ozs7Ozs7OztBQ25YRixpR0FBTyxDQUFDLDBFQUFVLEVBQUUsK0RBQVEsRUFBRSxzRUFBUSxDQUFDLG1DQUFFO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSx3QkFBd0Isa0VBQWtFOztBQUUxRjtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQixlQUFlO0FBQzdEOztBQUVBO0FBQ0EsT0FBTyxPQUFPO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyQkFBMkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyQkFBMkI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxHQUFHO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELEdBQUc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxjQUFjLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsY0FBYyxZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsR0FBRyxNQUFNO0FBQzlCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGFBQWE7QUFDYixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsQ0FBQztBQUFBLG9HQUFDOzs7Ozs7Ozs7Ozs7QUM3c0JGLGlHQUFPLEVBQUUsbUNBQUU7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4Rzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUdBQXFHO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw0Q0FBNEM7QUFDNUM7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFdBQVc7QUFDWCxPQUFPO0FBQ1AsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsZUFBZSwyQkFBMkIsTUFBTSxzREFBc0QsY0FBYyw0QkFBNEI7QUFDaE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQSxvR0FBQzs7Ozs7Ozs7Ozs7O0FDcmxCRixpR0FBTztBQUNQLENBQUMsNkVBQWU7QUFDaEIsQ0FBQyxtQ0FBRTtBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7QUFBQSxvR0FBQzs7Ozs7Ozs7Ozs7O0FDL0lGLGlHQUFPO0FBQ1AsQ0FBQyw0RUFBVTtBQUNYLENBQUMsK0RBQVE7QUFDVCxDQUFDLDZFQUFlO0FBQ2hCLENBQUMsK0VBQWdCO0FBQ2pCLENBQUMsbUNBQUU7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQSxvR0FBQzs7Ozs7Ozs7Ozs7O0FDdEhGLGlHQUFPO0FBQ1AsQ0FBQyw2RUFBZTtBQUNoQixDQUFDLDhFQUFXO0FBQ1osQ0FBQyx1RUFBWTtBQUNiLENBQUMsbUNBQUU7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDZDQUE2QyxFQUFFO0FBQ2xFLG1CQUFtQiw2Q0FBNkMsRUFBRTtBQUNsRSxvQkFBb0IsOENBQThDO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUFBLG9HQUFDOzs7Ozs7Ozs7Ozs7QUNwRkYsaUdBQU8sQ0FBQyxnRkFBZ0IsRUFBRSw4REFBTyxFQUFFLDhEQUFPLEVBQUUsNERBQU0sRUFBRSw4RUFBZSxFQUFFLDRFQUFjLEVBQUUsd0ZBQW9CLEVBQUUsNkZBQTRCLENBQUMsbUNBQ3ZJOztBQUVEOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QyxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGtDQUFrQztBQUNsQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEVBQTRFO0FBQ3JHLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkRBQTZEO0FBQ3RGLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZTtBQUNmLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHlDQUF5QztBQUN6QyxJQUFJO0FBQ0o7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDO0FBQUEsb0dBQUM7Ozs7Ozs7Ozs7OztBQzlZRiw2R0FBTyxDQUFDLCtEQUFRLEVBQUUsa0NBQVMsQ0FBQyxtQ0FDMUI7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFBQSxvR0FBQzs7Ozs7Ozs7Ozs7O0FDMURGLGlHQUFPLENBQUMsK0RBQVEsRUFBRSxpRkFBaUIsQ0FBQyxtQ0FBRTtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ3ZEOztBQUVBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QyIsImZpbGUiOiIwLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXG5cdFwicmVxdWlyZVwiLFx0XHRcdC8vIHJlcXVpcmUudG9Vcmxcblx0XCIuL21haW5cIixcdC8vIHRvIGV4cG9ydCBkaWppdC5CYWNrZ3JvdW5kSWZyYW1lXG5cdFwiZG9qby9fYmFzZS9jb25maWdcIixcblx0XCJkb2pvL2RvbS1jb25zdHJ1Y3RcIiwgLy8gZG9tQ29uc3RydWN0LmNyZWF0ZVxuXHRcImRvam8vZG9tLXN0eWxlXCIsIC8vIGRvbVN0eWxlLnNldFxuXHRcImRvam8vX2Jhc2UvbGFuZ1wiLCAvLyBsYW5nLmV4dGVuZCBsYW5nLmhpdGNoXG5cdFwiZG9qby9vblwiLFxuXHRcImRvam8vc25pZmZcIiAvLyBoYXMoXCJpZVwiKSwgaGFzKFwidHJpZGVudFwiKSwgaGFzKFwicXVpcmtzXCIpXG5dLCBmdW5jdGlvbihyZXF1aXJlLCBkaWppdCwgY29uZmlnLCBkb21Db25zdHJ1Y3QsIGRvbVN0eWxlLCBsYW5nLCBvbiwgaGFzKXtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRpaml0L0JhY2tncm91bmRJRnJhbWVcblxuXHQvLyBGbGFnIGZvciB3aGV0aGVyIHRvIGNyZWF0ZSBiYWNrZ3JvdW5kIGlmcmFtZSBiZWhpbmQgcG9wdXBzIGxpa2UgTWVudXMgYW5kIERpYWxvZy5cblx0Ly8gQSBiYWNrZ3JvdW5kIGlmcmFtZSBpcyB1c2VmdWwgdG8gcHJldmVudCBwcm9ibGVtcyB3aXRoIHBvcHVwcyBhcHBlYXJpbmcgYmVoaW5kIGFwcGxldHMvcGRmIGZpbGVzLFxuXHQvLyBhbmQgaXMgYWxzbyB1c2VmdWwgb24gb2xkZXIgdmVyc2lvbnMgb2YgSUUgKElFNiBhbmQgSUU3KSB0byBwcmV2ZW50IHRoZSBcImJsZWVkIHRocm91Z2ggc2VsZWN0XCIgcHJvYmxlbS5cblx0Ly8gQnkgZGVmYXVsdCwgaXQncyBlbmFibGVkIGZvciBJRTYtMTEsIGV4Y2x1ZGluZyBXaW5kb3dzIFBob25lIDguXG5cdC8vIFRPRE86IEZvciAyLjAsIG1ha2UgdGhpcyBmYWxzZSBieSBkZWZhdWx0LiAgQWxzbywgcG9zc2libHkgbW92ZSBkZWZpbml0aW9uIHRvIGhhcy5qcyBzbyB0aGF0IHRoaXMgbW9kdWxlIGNhbiBiZVxuXHQvLyBjb25kaXRpb25hbGx5IHJlcXVpcmVkIHZpYSAgZG9qby9oYXMhYmdJZmFtZT9kaWppdC9CYWNrZ3JvdW5kSWZyYW1lXG5cdGhhcy5hZGQoXCJjb25maWctYmdJZnJhbWVcIixcbiAgICBcdChoYXMoXCJpZVwiKSB8fCBoYXMoXCJ0cmlkZW50XCIpKSAmJiAhL0lFTW9iaWxlXFwvMTBcXC4wLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKTsgLy8gTm8gaWZyYW1lIG9uIFdQOCwgdG8gbWF0Y2ggMS45IGJlaGF2aW9yXG5cblx0dmFyIF9mcmFtZXMgPSBuZXcgZnVuY3Rpb24oKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdGNhY2hlIG9mIGlmcmFtZXNcblxuXHRcdHZhciBxdWV1ZSA9IFtdO1xuXG5cdFx0dGhpcy5wb3AgPSBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGlmcmFtZTtcblx0XHRcdGlmKHF1ZXVlLmxlbmd0aCl7XG5cdFx0XHRcdGlmcmFtZSA9IHF1ZXVlLnBvcCgpO1xuXHRcdFx0XHRpZnJhbWUuc3R5bGUuZGlzcGxheT1cIlwiO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIHRyYW5zcGFyZW5jeSBuZWVkZWQgZm9yIERpYWxvZ1VuZGVybGF5IGFuZCBmb3IgdG9vbHRpcHMgb24gSUUgKHRvIHNlZSBzY3JlZW4gbmVhciBjb25uZWN0b3IpXG5cdFx0XHRcdGlmKGhhcyhcImllXCIpIDwgOSl7XG5cdFx0XHRcdFx0dmFyIGJ1cmwgPSBjb25maWdbXCJkb2pvQmxhbmtIdG1sVXJsXCJdIHx8IHJlcXVpcmUudG9VcmwoXCJkb2pvL3Jlc291cmNlcy9ibGFuay5odG1sXCIpIHx8IFwiamF2YXNjcmlwdDpcXFwiXFxcIlwiO1xuXHRcdFx0XHRcdHZhciBodG1sPVwiPGlmcmFtZSBzcmM9J1wiICsgYnVybCArIFwiJyByb2xlPSdwcmVzZW50YXRpb24nXCJcblx0XHRcdFx0XHRcdCsgXCIgc3R5bGU9J3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMHB4OyB0b3A6IDBweDtcIlxuXHRcdFx0XHRcdFx0KyBcInotaW5kZXg6IC0xOyBmaWx0ZXI6QWxwaGEoT3BhY2l0eT1cXFwiMFxcXCIpOyc+XCI7XG5cdFx0XHRcdFx0aWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0aWZyYW1lID0gZG9tQ29uc3RydWN0LmNyZWF0ZShcImlmcmFtZVwiKTtcblx0XHRcdFx0XHRpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6XCJcIic7XG5cdFx0XHRcdFx0aWZyYW1lLmNsYXNzTmFtZSA9IFwiZGlqaXRCYWNrZ3JvdW5kSWZyYW1lXCI7XG5cdFx0XHRcdFx0aWZyYW1lLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG5cdFx0XHRcdFx0ZG9tU3R5bGUuc2V0KGlmcmFtZSwgXCJvcGFjaXR5XCIsIDAuMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWZyYW1lLnRhYkluZGV4ID0gLTE7IC8vIE1hZ2ljIHRvIHByZXZlbnQgaWZyYW1lIGZyb20gZ2V0dGluZyBmb2N1cyBvbiB0YWIga2V5cHJlc3MgLSBhcyBzdHlsZSBkaWRuJ3Qgd29yay5cblx0XHRcdH1cblx0XHRcdHJldHVybiBpZnJhbWU7XG5cdFx0fTtcblxuXHRcdHRoaXMucHVzaCA9IGZ1bmN0aW9uKGlmcmFtZSl7XG5cdFx0XHRpZnJhbWUuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtcblx0XHRcdHF1ZXVlLnB1c2goaWZyYW1lKTtcblx0XHR9XG5cdH0oKTtcblxuXG5cdGRpaml0LkJhY2tncm91bmRJZnJhbWUgPSBmdW5jdGlvbigvKkRvbU5vZGUqLyBub2RlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEZvciBJRS9GRiB6LWluZGV4IHNoZW5hbmlnYW5zLiBpZCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQuXG5cdFx0Ly9cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRuZXcgZGlqaXQuQmFja2dyb3VuZElmcmFtZShub2RlKS5cblx0XHQvL1xuXHRcdC8vXHRcdE1ha2VzIGEgYmFja2dyb3VuZCBpZnJhbWUgYXMgYSBjaGlsZCBvZiBub2RlLCB0aGF0IGZpbGxzXG5cdFx0Ly9cdFx0YXJlYSAoYW5kIHBvc2l0aW9uKSBvZiBub2RlXG5cblx0XHRpZighbm9kZS5pZCl7IHRocm93IG5ldyBFcnJvcihcIm5vIGlkXCIpOyB9XG5cdFx0aWYoaGFzKFwiY29uZmlnLWJnSWZyYW1lXCIpKXtcblx0XHRcdHZhciBpZnJhbWUgPSAodGhpcy5pZnJhbWUgPSBfZnJhbWVzLnBvcCgpKTtcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0XHRcdGlmKGhhcyhcImllXCIpPDcgfHwgaGFzKFwicXVpcmtzXCIpKXtcblx0XHRcdFx0dGhpcy5yZXNpemUobm9kZSk7XG5cdFx0XHRcdHRoaXMuX2Nvbm4gPSBvbihub2RlLCAncmVzaXplJywgbGFuZy5oaXRjaCh0aGlzLCBcInJlc2l6ZVwiLCBub2RlKSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0ZG9tU3R5bGUuc2V0KGlmcmFtZSwge1xuXHRcdFx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdFx0aGVpZ2h0OiAnMTAwJSdcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGxhbmcuZXh0ZW5kKGRpaml0LkJhY2tncm91bmRJZnJhbWUsIHtcblx0XHRyZXNpemU6IGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlc2l6ZSB0aGUgaWZyYW1lIHNvIGl0J3MgdGhlIHNhbWUgc2l6ZSBhcyBub2RlLlxuXHRcdFx0Ly9cdFx0TmVlZGVkIG9uIElFNiBhbmQgSUUvcXVpcmtzIGJlY2F1c2UgaGVpZ2h0OjEwMCUgZG9lc24ndCB3b3JrIHJpZ2h0LlxuXHRcdFx0aWYodGhpcy5pZnJhbWUpe1xuXHRcdFx0XHRkb21TdHlsZS5zZXQodGhpcy5pZnJhbWUsIHtcblx0XHRcdFx0XHR3aWR0aDogbm9kZS5vZmZzZXRXaWR0aCArICdweCcsXG5cdFx0XHRcdFx0aGVpZ2h0OiBub2RlLm9mZnNldEhlaWdodCArICdweCdcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdGRlc3Ryb3kgdGhlIGlmcmFtZVxuXHRcdFx0aWYodGhpcy5fY29ubil7XG5cdFx0XHRcdHRoaXMuX2Nvbm4ucmVtb3ZlKCk7XG5cdFx0XHRcdHRoaXMuX2Nvbm4gPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5pZnJhbWUpe1xuXHRcdFx0XHR0aGlzLmlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuaWZyYW1lKTtcblx0XHRcdFx0X2ZyYW1lcy5wdXNoKHRoaXMuaWZyYW1lKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuaWZyYW1lO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGRpaml0LkJhY2tncm91bmRJZnJhbWU7XG59KTtcbiIsImRlZmluZShbXG5cdFwiZG9qby9fYmFzZS9hcnJheVwiLCAvLyBhcnJheS5mb3JFYWNoIGFycmF5Lm1hcFxuXHRcImRvam8vYXNwZWN0XCIsXG5cdFwiZG9qby9fYmFzZS9kZWNsYXJlXCJcbl0sIGZ1bmN0aW9uKGFycmF5LCBhc3BlY3QsIGRlY2xhcmUpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvRGVzdHJveWFibGVcblxuXHRyZXR1cm4gZGVjbGFyZShcImRpaml0LkRlc3Ryb3lhYmxlXCIsIG51bGwsIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdE1peGluIHRvIHRyYWNrIGhhbmRsZXMgYW5kIHJlbGVhc2UgdGhlbSB3aGVuIGluc3RhbmNlIGlzIGRlc3Ryb3llZC5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRDYWxsIHRoaXMub3duKC4uLikgb24gbGlzdCBvZiBoYW5kbGVzIChyZXR1cm5lZCBmcm9tIGRvam8vYXNwZWN0LCBkb2pvL29uLFxuXHRcdC8vXHRcdGRvam8vU3RhdGVmdWw6OndhdGNoLCBvciBhbnkgY2xhc3MgKGluY2x1ZGluZyB3aWRnZXRzKSB3aXRoIGEgZGVzdHJveVJlY3Vyc2l2ZSgpIG9yIGRlc3Ryb3koKSBtZXRob2QuXG5cdFx0Ly9cdFx0VGhlbiBjYWxsIGRlc3Ryb3koKSBsYXRlciB0byBkZXN0cm95IHRoaXMgaW5zdGFuY2UgYW5kIHJlbGVhc2UgdGhlIHJlc291cmNlcy5cblxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKC8qQm9vbGVhbiovIHByZXNlcnZlRG9tKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXN0cm95IHRoaXMgY2xhc3MsIHJlbGVhc2luZyBhbnkgcmVzb3VyY2VzIHJlZ2lzdGVyZWQgdmlhIG93bigpLlxuXHRcdFx0dGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0b3duOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRyYWNrIHNwZWNpZmllZCBoYW5kbGVzIGFuZCByZW1vdmUvZGVzdHJveSB0aGVtIHdoZW4gdGhpcyBpbnN0YW5jZSBpcyBkZXN0cm95ZWQsIHVubGVzcyB0aGV5IHdlcmVcblx0XHRcdC8vXHRcdGFscmVhZHkgcmVtb3ZlZC9kZXN0cm95ZWQgbWFudWFsbHkuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cdFx0XHQvLyByZXR1cm5zOlxuXHRcdFx0Ly9cdFx0VGhlIGFycmF5IG9mIHNwZWNpZmllZCBoYW5kbGVzLCBzbyB5b3UgY2FuIGRvIGZvciBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdFx0dmFyIGhhbmRsZSA9IHRoaXMub3duKG9uKC4uLikpWzBdO1xuXG5cdFx0XHR2YXIgY2xlYW51cE1ldGhvZHMgPSBbXG5cdFx0XHRcdFwiZGVzdHJveVJlY3Vyc2l2ZVwiLFxuXHRcdFx0XHRcImRlc3Ryb3lcIixcblx0XHRcdFx0XCJyZW1vdmVcIlxuXHRcdFx0XTtcblxuXHRcdFx0YXJyYXkuZm9yRWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKGhhbmRsZSl7XG5cdFx0XHRcdC8vIFdoZW4gdGhpcy5kZXN0cm95KCkgaXMgY2FsbGVkLCBkZXN0cm95IGhhbmRsZS4gIFNpbmNlIEknbSB1c2luZyBhc3BlY3QuYmVmb3JlKCksXG5cdFx0XHRcdC8vIHRoZSBoYW5kbGUgd2lsbCBiZSBkZXN0cm95ZWQgYmVmb3JlIGEgc3ViY2xhc3MncyBkZXN0cm95KCkgbWV0aG9kIHN0YXJ0cyBydW5uaW5nLCBiZWZvcmUgaXQgY2FsbHNcblx0XHRcdFx0Ly8gdGhpcy5pbmhlcml0ZWQoKSBvciBldmVuIGlmIGl0IGRvZXNuJ3QgY2FsbCB0aGlzLmluaGVyaXRlZCgpIGF0IGFsbC4gIElmIHRoYXQncyBhbiBpc3N1ZSwgbWFrZSBhblxuXHRcdFx0XHQvLyBvbkRlc3Ryb3koKSBtZXRob2QgYW5kIGNvbm5lY3QgdG8gdGhhdCBpbnN0ZWFkLlxuXHRcdFx0XHR2YXIgZGVzdHJveU1ldGhvZE5hbWU7XG5cdFx0XHRcdHZhciBvZGggPSBhc3BlY3QuYmVmb3JlKHRoaXMsIFwiZGVzdHJveVwiLCBmdW5jdGlvbiAocHJlc2VydmVEb20pe1xuXHRcdFx0XHRcdGhhbmRsZVtkZXN0cm95TWV0aG9kTmFtZV0ocHJlc2VydmVEb20pO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBoYW5kbGUgaXMgbWFudWFsbHkgZGVzdHJveWVkLlxuXHRcdFx0XHR2YXIgaGRocyA9IFtdO1xuXHRcdFx0XHRmdW5jdGlvbiBvbk1hbnVhbERlc3Ryb3koKXtcblx0XHRcdFx0XHRvZGgucmVtb3ZlKCk7XG5cdFx0XHRcdFx0YXJyYXkuZm9yRWFjaChoZGhzLCBmdW5jdGlvbihoZGgpe1xuXHRcdFx0XHRcdFx0aGRoLnJlbW92ZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0dXAgbGlzdGVuZXJzIGZvciBtYW51YWwgZGVzdHJveSBvZiBoYW5kbGUuXG5cdFx0XHRcdC8vIEFsc28gY29tcHV0ZXMgZGVzdHJveU1ldGhvZE5hbWUsIHVzZWQgaW4gbGlzdGVuZXIgYWJvdmUuXG5cdFx0XHRcdGlmKGhhbmRsZS50aGVuKXtcblx0XHRcdFx0XHQvLyBTcGVjaWFsIHBhdGggZm9yIFByb21pc2VzLiAgRGV0ZWN0IHdoZW4gUHJvbWlzZSBpcyByZXNvbHZlZCwgcmVqZWN0ZWQsIG9yXG5cdFx0XHRcdFx0Ly8gY2FuY2VsZWQgKG5iOiBjYW5jZWxsaW5nIGEgUHJvbWlzZSBjYXVzZXMgaXQgdG8gYmUgcmVqZWN0ZWQpLlxuXHRcdFx0XHRcdGRlc3Ryb3lNZXRob2ROYW1lID0gXCJjYW5jZWxcIjtcblx0XHRcdFx0XHRoYW5kbGUudGhlbihvbk1hbnVhbERlc3Ryb3ksIG9uTWFudWFsRGVzdHJveSk7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdC8vIFBhdGggZm9yIG90aGVyIGhhbmRsZXMuICBKdXN0IHVzZSBBT1AgdG8gZGV0ZWN0IHdoZW4gaGFuZGxlIGlzIG1hbnVhbGx5IGRlc3Ryb3llZC5cblx0XHRcdFx0XHRhcnJheS5mb3JFYWNoKGNsZWFudXBNZXRob2RzLCBmdW5jdGlvbihjbGVhbnVwTWV0aG9kKXtcblx0XHRcdFx0XHRcdGlmKHR5cGVvZiBoYW5kbGVbY2xlYW51cE1ldGhvZF0gPT09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRcdFx0XHRcdGlmKCFkZXN0cm95TWV0aG9kTmFtZSl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIGZpcnN0IG1hdGNoaW5nIG1ldGhvZCBuYW1lIGluIGFib3ZlIGxpc3RlbmVyIChwcmVmZXIgZGVzdHJveVJlY3Vyc2l2ZSgpIHRvIGRlc3Ryb3koKSlcblx0XHRcdFx0XHRcdFx0XHRkZXN0cm95TWV0aG9kTmFtZSA9IGNsZWFudXBNZXRob2Q7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aGRocy5wdXNoKGFzcGVjdC5hZnRlcihoYW5kbGUsIGNsZWFudXBNZXRob2QsIG9uTWFudWFsRGVzdHJveSwgdHJ1ZSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cztcdFx0Ly8gaGFuZGxlXG5cdFx0fVxuXHR9KTtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCJkb2pvL19iYXNlL2FycmF5XCIsIC8vIGFycmF5LmZvckVhY2ggYXJyYXkuaW5kZXhPZiBhcnJheS5tYXBcblx0XCJkb2pvL19iYXNlL2RlY2xhcmVcIiwgLy8gZGVjbGFyZVxuXHRcImRvam8vX2Jhc2UvZnhcIiwgLy8gZnguZmFkZUluIGZ4LmZhZGVPdXRcblx0XCJkb2pvL2RvbVwiLCAvLyBkb20uYnlJZFxuXHRcImRvam8vZG9tLWNsYXNzXCIsIC8vIGRvbUNsYXNzLmFkZFxuXHRcImRvam8vZG9tLWdlb21ldHJ5XCIsIC8vIGRvbUdlb21ldHJ5LnBvc2l0aW9uXG5cdFwiZG9qby9kb20tc3R5bGVcIiwgLy8gZG9tU3R5bGUuc2V0LCBkb21TdHlsZS5nZXRcblx0XCJkb2pvL19iYXNlL2xhbmdcIiwgLy8gbGFuZy5oaXRjaCBsYW5nLmlzQXJyYXlMaWtlXG5cdFwiZG9qby9tb3VzZVwiLFxuXHRcImRvam8vb25cIixcblx0XCJkb2pvL3NuaWZmXCIsIC8vIGhhcyhcImllXCIpLCBoYXMoXCJ0cmlkZW50XCIpXG5cdFwiLi9fYmFzZS9tYW5hZ2VyXCIsXHQvLyBtYW5hZ2VyLmRlZmF1bHREdXJhdGlvblxuXHRcIi4vcGxhY2VcIixcblx0XCIuL19XaWRnZXRcIixcblx0XCIuL19UZW1wbGF0ZWRNaXhpblwiLFxuXHRcIi4vQmFja2dyb3VuZElmcmFtZVwiLFxuXHRcImRvam8vdGV4dCEuL3RlbXBsYXRlcy9Ub29sdGlwLmh0bWxcIixcblx0XCIuL21haW5cIlx0XHQvLyBzZXRzIGRpaml0LnNob3dUb29sdGlwIGV0Yy4gZm9yIGJhY2stY29tcGF0XG5dLCBmdW5jdGlvbihhcnJheSwgZGVjbGFyZSwgZngsIGRvbSwgZG9tQ2xhc3MsIGRvbUdlb21ldHJ5LCBkb21TdHlsZSwgbGFuZywgbW91c2UsIG9uLCBoYXMsXG5cdFx0XHRtYW5hZ2VyLCBwbGFjZSwgX1dpZGdldCwgX1RlbXBsYXRlZE1peGluLCBCYWNrZ3JvdW5kSWZyYW1lLCB0ZW1wbGF0ZSwgZGlqaXQpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvVG9vbHRpcFxuXG5cblx0Ly8gVE9ETzogVG9vbHRpcCBzaG91bGQgcmVhbGx5IHNoYXJlIG1vcmUgcG9zaXRpb25pbmcgY29kZSB3aXRoIFRvb2x0aXBEaWFsb2csIGxpa2U6XG5cdC8vXHRcdC0gdGhlIG9yaWVudCgpIG1ldGhvZFxuXHQvL1x0XHQtIHRoZSBjb25uZWN0b3IgcG9zaXRpb25pbmcgY29kZSBpbiBzaG93KClcblx0Ly9cdFx0LSB0aGUgZGlqaXRUb29sdGlwW0RpYWxvZ10gY2xhc3Ncblx0Ly9cblx0Ly8gVGhlIHByb2JsZW0gaXMgdGhhdCBUb29sdGlwJ3MgaW1wbGVtZW50YXRpb24gc3VwcGxpZXMgaXQncyBvd24gPGlmcmFtZT4gYW5kIGludGVyYWN0cyBkaXJlY3RseVxuXHQvLyB3aXRoIGRpaml0L3BsYWNlLCByYXRoZXIgdGhhbiBnb2luZyB0aHJvdWdoIGRpaml0L3BvcHVwIGxpa2UgVG9vbHRpcERpYWxvZyBhbmQgb3RoZXIgcG9wdXBzIChleDogTWVudSkuXG5cblx0dmFyIE1hc3RlclRvb2x0aXAgPSBkZWNsYXJlKFwiZGlqaXQuX01hc3RlclRvb2x0aXBcIiwgW19XaWRnZXQsIF9UZW1wbGF0ZWRNaXhpbl0sIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEludGVybmFsIHdpZGdldCB0aGF0IGhvbGRzIHRoZSBhY3R1YWwgdG9vbHRpcCBtYXJrdXAsXG5cdFx0Ly9cdFx0d2hpY2ggb2NjdXJzIG9uY2UgcGVyIHBhZ2UuXG5cdFx0Ly9cdFx0Q2FsbGVkIGJ5IFRvb2x0aXAgd2lkZ2V0cyB3aGljaCBhcmUganVzdCBjb250YWluZXJzIHRvIGhvbGRcblx0XHQvL1x0XHR0aGUgbWFya3VwXG5cdFx0Ly8gdGFnczpcblx0XHQvL1x0XHRwcm90ZWN0ZWRcblxuXHRcdC8vIGR1cmF0aW9uOiBJbnRlZ2VyXG5cdFx0Ly9cdFx0TWlsbGlzZWNvbmRzIHRvIGZhZGUgaW4vZmFkZSBvdXRcblx0XHRkdXJhdGlvbjogbWFuYWdlci5kZWZhdWx0RHVyYXRpb24sXG5cblx0XHR0ZW1wbGF0ZVN0cmluZzogdGVtcGxhdGUsXG5cblx0XHRwb3N0Q3JlYXRlOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5vd25lckRvY3VtZW50Qm9keS5hcHBlbmRDaGlsZCh0aGlzLmRvbU5vZGUpO1xuXG5cdFx0XHR0aGlzLmJnSWZyYW1lID0gbmV3IEJhY2tncm91bmRJZnJhbWUodGhpcy5kb21Ob2RlKTtcblxuXHRcdFx0Ly8gU2V0dXAgZmFkZS1pbiBhbmQgZmFkZS1vdXQgZnVuY3Rpb25zLlxuXHRcdFx0dGhpcy5mYWRlSW4gPSBmeC5mYWRlSW4oeyBub2RlOiB0aGlzLmRvbU5vZGUsIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLCBvbkVuZDogbGFuZy5oaXRjaCh0aGlzLCBcIl9vblNob3dcIikgfSk7XG5cdFx0XHR0aGlzLmZhZGVPdXQgPSBmeC5mYWRlT3V0KHsgbm9kZTogdGhpcy5kb21Ob2RlLCBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbiwgb25FbmQ6IGxhbmcuaGl0Y2godGhpcywgXCJfb25IaWRlXCIpIH0pO1xuXHRcdH0sXG5cblx0XHRzaG93OiBmdW5jdGlvbihpbm5lckhUTUwsIGFyb3VuZE5vZGUsIHBvc2l0aW9uLCBydGwsIHRleHREaXIsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREaXNwbGF5IHRvb2x0aXAgdy9zcGVjaWZpZWQgY29udGVudHMgdG8gcmlnaHQgb2Ygc3BlY2lmaWVkIG5vZGVcblx0XHRcdC8vXHRcdChUbyBsZWZ0IGlmIHRoZXJlJ3Mgbm8gc3BhY2Ugb24gdGhlIHJpZ2h0LCBvciBpZiBydGwgPT0gdHJ1ZSlcblx0XHRcdC8vIGlubmVySFRNTDogU3RyaW5nXG5cdFx0XHQvL1x0XHRDb250ZW50cyBvZiB0aGUgdG9vbHRpcFxuXHRcdFx0Ly8gYXJvdW5kTm9kZTogRG9tTm9kZXxkaWppdC9wbGFjZS5fX1JlY3RhbmdsZVxuXHRcdFx0Ly9cdFx0U3BlY2lmaWVzIHRoYXQgdG9vbHRpcCBzaG91bGQgYmUgbmV4dCB0byB0aGlzIG5vZGUgLyBhcmVhXG5cdFx0XHQvLyBwb3NpdGlvbjogU3RyaW5nW10/XG5cdFx0XHQvL1x0XHRMaXN0IG9mIHBvc2l0aW9ucyB0byB0cnkgdG8gcG9zaXRpb24gdG9vbHRpcCAoZXg6IFtcInJpZ2h0XCIsIFwiYWJvdmVcIl0pXG5cdFx0XHQvLyBydGw6IEJvb2xlYW4/XG5cdFx0XHQvL1x0XHRDb3JyZXNwb25kcyB0byBgV2lkZ2V0QmFzZS5kaXJgIGF0dHJpYnV0ZSwgd2hlcmUgZmFsc2UgbWVhbnMgXCJsdHJcIiBhbmQgdHJ1ZVxuXHRcdFx0Ly9cdFx0bWVhbnMgXCJydGxcIjsgc3BlY2lmaWVzIEdVSSBkaXJlY3Rpb24sIG5vdCB0ZXh0IGRpcmVjdGlvbi5cblx0XHRcdC8vIHRleHREaXI6IFN0cmluZz9cblx0XHRcdC8vXHRcdENvcnJlc3BvbmRzIHRvIGBXaWRnZXRCYXNlLnRleHRkaXJgIGF0dHJpYnV0ZTsgc3BlY2lmaWVzIGRpcmVjdGlvbiBvZiB0ZXh0LlxuXHRcdFx0Ly8gb25Nb3VzZUVudGVyOiBGdW5jdGlvbj9cblx0XHRcdC8vXHRcdENhbGxiYWNrIGZ1bmN0aW9uIGZvciBtb3VzZSBlbnRlciBvbiB0b29sdGlwXG5cdFx0XHQvLyBvbk1vdXNlTGVhdmU6IEZ1bmN0aW9uP1xuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgZnVuY3Rpb24gZm9yIG1vdXNlIGxlYXZlIG9uIHRvb2x0aXBcblxuXHRcdFx0aWYodGhpcy5hcm91bmROb2RlICYmIHRoaXMuYXJvdW5kTm9kZSA9PT0gYXJvdW5kTm9kZSAmJiB0aGlzLmNvbnRhaW5lck5vZGUuaW5uZXJIVE1MID09IGlubmVySFRNTCl7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYodGhpcy5mYWRlT3V0LnN0YXR1cygpID09IFwicGxheWluZ1wiKXtcblx0XHRcdFx0Ly8gcHJldmlvdXMgdG9vbHRpcCBpcyBiZWluZyBoaWRkZW47IHdhaXQgdW50aWwgdGhlIGhpZGUgY29tcGxldGVzIHRoZW4gc2hvdyBuZXcgb25lXG5cdFx0XHRcdHRoaXMuX29uRGVjaz1hcmd1bWVudHM7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuY29udGFpbmVyTm9kZS5pbm5lckhUTUw9aW5uZXJIVE1MO1xuXG5cdFx0XHRpZih0ZXh0RGlyKXtcblx0XHRcdFx0dGhpcy5zZXQoXCJ0ZXh0RGlyXCIsIHRleHREaXIpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNvbnRhaW5lck5vZGUuYWxpZ24gPSBydGw/IFwicmlnaHRcIiA6IFwibGVmdFwiOyAvL2ZpeCB0aGUgdGV4dCBhbGlnbm1lbnRcblxuXHRcdFx0dmFyIHBvcyA9IHBsYWNlLmFyb3VuZCh0aGlzLmRvbU5vZGUsIGFyb3VuZE5vZGUsXG5cdFx0XHRcdHBvc2l0aW9uICYmIHBvc2l0aW9uLmxlbmd0aCA/IHBvc2l0aW9uIDogVG9vbHRpcC5kZWZhdWx0UG9zaXRpb24sICFydGwsIGxhbmcuaGl0Y2godGhpcywgXCJvcmllbnRcIikpO1xuXG5cdFx0XHQvLyBQb3NpdGlvbiB0aGUgdG9vbHRpcCBjb25uZWN0b3IgZm9yIG1pZGRsZSBhbGlnbm1lbnQuXG5cdFx0XHQvLyBUaGlzIGNvdWxkIG5vdCBoYXZlIGJlZW4gZG9uZSBpbiBvcmllbnQoKSBzaW5jZSB0aGUgdG9vbHRpcCB3YXNuJ3QgcG9zaXRpb25lZCBhdCB0aGF0IHRpbWUuXG5cdFx0XHR2YXIgYXJvdW5kTm9kZUNvb3JkcyA9IHBvcy5hcm91bmROb2RlUG9zO1xuXHRcdFx0aWYocG9zLmNvcm5lci5jaGFyQXQoMCkgPT0gJ00nICYmIHBvcy5hcm91bmRDb3JuZXIuY2hhckF0KDApID09ICdNJyl7XG5cdFx0XHRcdHRoaXMuY29ubmVjdG9yTm9kZS5zdHlsZS50b3AgPSBhcm91bmROb2RlQ29vcmRzLnkgKyAoKGFyb3VuZE5vZGVDb29yZHMuaCAtIHRoaXMuY29ubmVjdG9yTm9kZS5vZmZzZXRIZWlnaHQpID4+IDEpIC0gcG9zLnkgKyBcInB4XCI7XG5cdFx0XHRcdHRoaXMuY29ubmVjdG9yTm9kZS5zdHlsZS5sZWZ0ID0gXCJcIjtcblx0XHRcdH1lbHNlIGlmKHBvcy5jb3JuZXIuY2hhckF0KDEpID09ICdNJyAmJiBwb3MuYXJvdW5kQ29ybmVyLmNoYXJBdCgxKSA9PSAnTScpe1xuXHRcdFx0XHR0aGlzLmNvbm5lY3Rvck5vZGUuc3R5bGUubGVmdCA9IGFyb3VuZE5vZGVDb29yZHMueCArICgoYXJvdW5kTm9kZUNvb3Jkcy53IC0gdGhpcy5jb25uZWN0b3JOb2RlLm9mZnNldFdpZHRoKSA+PiAxKSAtIHBvcy54ICsgXCJweFwiO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIE5vdCAqLWNlbnRlcmVkLCBidXQganVzdCBhYm92ZS9iZWxvdy9hZnRlci9iZWZvcmVcblx0XHRcdFx0dGhpcy5jb25uZWN0b3JOb2RlLnN0eWxlLmxlZnQgPSBcIlwiO1xuXHRcdFx0XHR0aGlzLmNvbm5lY3Rvck5vZGUuc3R5bGUudG9wID0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2hvdyBpdFxuXHRcdFx0ZG9tU3R5bGUuc2V0KHRoaXMuZG9tTm9kZSwgXCJvcGFjaXR5XCIsIDApO1xuXHRcdFx0dGhpcy5mYWRlSW4ucGxheSgpO1xuXHRcdFx0dGhpcy5pc1Nob3dpbmdOb3cgPSB0cnVlO1xuXHRcdFx0dGhpcy5hcm91bmROb2RlID0gYXJvdW5kTm9kZTtcblxuXHRcdFx0dGhpcy5vbk1vdXNlRW50ZXIgPSBvbk1vdXNlRW50ZXIgfHwgbm9vcDtcblx0XHRcdHRoaXMub25Nb3VzZUxlYXZlID0gb25Nb3VzZUxlYXZlIHx8IG5vb3A7XG5cdFx0fSxcblxuXHRcdG9yaWVudDogZnVuY3Rpb24oLypEb21Ob2RlKi8gbm9kZSwgLypTdHJpbmcqLyBhcm91bmRDb3JuZXIsIC8qU3RyaW5nKi8gdG9vbHRpcENvcm5lciwgLypPYmplY3QqLyBzcGFjZUF2YWlsYWJsZSwgLypPYmplY3QqLyBhcm91bmROb2RlQ29vcmRzKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRQcml2YXRlIGZ1bmN0aW9uIHRvIHNldCBDU1MgZm9yIHRvb2x0aXAgbm9kZSBiYXNlZCBvbiB3aGljaCBwb3NpdGlvbiBpdCdzIGluLlxuXHRcdFx0Ly9cdFx0VGhpcyBpcyBjYWxsZWQgYnkgdGhlIGRpaml0IHBvcHVwIGNvZGUuICAgSXQgd2lsbCBhbHNvIHJlZHVjZSB0aGUgdG9vbHRpcCdzXG5cdFx0XHQvL1x0XHR3aWR0aCB0byB3aGF0ZXZlciB3aWR0aCBpcyBhdmFpbGFibGVcblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblxuXHRcdFx0dGhpcy5jb25uZWN0b3JOb2RlLnN0eWxlLnRvcCA9IFwiXCI7IC8vcmVzZXQgdG8gZGVmYXVsdFxuXG5cdFx0XHR2YXIgaGVpZ2h0QXZhaWxhYmxlID0gc3BhY2VBdmFpbGFibGUuaCxcblx0XHRcdFx0d2lkdGhBdmFpbGFibGUgPSBzcGFjZUF2YWlsYWJsZS53O1xuXG5cdFx0XHRub2RlLmNsYXNzTmFtZSA9IFwiZGlqaXRUb29sdGlwIFwiICtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdFwiTVItTUxcIjogXCJkaWppdFRvb2x0aXBSaWdodFwiLFxuXHRcdFx0XHRcdFwiTUwtTVJcIjogXCJkaWppdFRvb2x0aXBMZWZ0XCIsXG5cdFx0XHRcdFx0XCJUTS1CTVwiOiBcImRpaml0VG9vbHRpcEFib3ZlXCIsXG5cdFx0XHRcdFx0XCJCTS1UTVwiOiBcImRpaml0VG9vbHRpcEJlbG93XCIsXG5cdFx0XHRcdFx0XCJCTC1UTFwiOiBcImRpaml0VG9vbHRpcEJlbG93IGRpaml0VG9vbHRpcEFCTGVmdFwiLFxuXHRcdFx0XHRcdFwiVEwtQkxcIjogXCJkaWppdFRvb2x0aXBBYm92ZSBkaWppdFRvb2x0aXBBQkxlZnRcIixcblx0XHRcdFx0XHRcIkJSLVRSXCI6IFwiZGlqaXRUb29sdGlwQmVsb3cgZGlqaXRUb29sdGlwQUJSaWdodFwiLFxuXHRcdFx0XHRcdFwiVFItQlJcIjogXCJkaWppdFRvb2x0aXBBYm92ZSBkaWppdFRvb2x0aXBBQlJpZ2h0XCIsXG5cdFx0XHRcdFx0XCJCUi1CTFwiOiBcImRpaml0VG9vbHRpcFJpZ2h0XCIsXG5cdFx0XHRcdFx0XCJCTC1CUlwiOiBcImRpaml0VG9vbHRpcExlZnRcIlxuXHRcdFx0XHR9W2Fyb3VuZENvcm5lciArIFwiLVwiICsgdG9vbHRpcENvcm5lcl07XG5cblx0XHRcdC8vIHJlc2V0IHdpZHRoOyBpdCBtYXkgaGF2ZSBiZWVuIHNldCBieSBvcmllbnQoKSBvbiBhIHByZXZpb3VzIHRvb2x0aXAgc2hvdygpXG5cdFx0XHR0aGlzLmRvbU5vZGUuc3R5bGUud2lkdGggPSBcImF1dG9cIjtcblxuXHRcdFx0Ly8gUmVkdWNlIHRvb2x0aXAncyB3aWR0aCB0byB0aGUgYW1vdW50IG9mIHdpZHRoIGF2YWlsYWJsZSwgc28gdGhhdCBpdCBkb2Vzbid0IG92ZXJmbG93IHNjcmVlbi5cblx0XHRcdC8vIE5vdGUgdGhhdCBzb21ldGltZXMgd2lkdGhBdmFpbGFibGUgaXMgbmVnYXRpdmUsIGJ1dCB3ZSBndWFyZCBhZ2FpbnN0IHNldHRpbmcgc3R5bGUud2lkdGggdG8gYVxuXHRcdFx0Ly8gbmVnYXRpdmUgbnVtYmVyIHNpbmNlIHRoYXQgY2F1c2VzIGFuIGV4Y2VwdGlvbiBvbiBJRS5cblx0XHRcdHZhciBzaXplID0gZG9tR2VvbWV0cnkucG9zaXRpb24odGhpcy5kb21Ob2RlKTtcblx0XHRcdGlmKGhhcyhcImllXCIpIHx8IGhhcyhcInRyaWRlbnRcIikpe1xuXHRcdFx0XHQvLyB3b3JrYXJvdW5kIHN0cmFuZ2UgSUUgYnVnIHdoZXJlIHNldHRpbmcgd2lkdGggdG8gb2Zmc2V0V2lkdGggY2F1c2VzIHdvcmRzIHRvIHdyYXBcblx0XHRcdFx0c2l6ZS53ICs9IDI7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB3aWR0aCA9IE1hdGgubWluKChNYXRoLm1heCh3aWR0aEF2YWlsYWJsZSwxKSksIHNpemUudyk7XG5cblx0XHRcdGRvbUdlb21ldHJ5LnNldE1hcmdpbkJveCh0aGlzLmRvbU5vZGUsIHt3OiB3aWR0aH0pO1xuXG5cdFx0XHQvLyBSZXBvc2l0aW9uIHRoZSB0b29sdGlwIGNvbm5lY3Rvci5cblx0XHRcdGlmKHRvb2x0aXBDb3JuZXIuY2hhckF0KDApID09ICdCJyAmJiBhcm91bmRDb3JuZXIuY2hhckF0KDApID09ICdCJyl7XG5cdFx0XHRcdHZhciBiYiA9IGRvbUdlb21ldHJ5LnBvc2l0aW9uKG5vZGUpO1xuXHRcdFx0XHR2YXIgdG9vbHRpcENvbm5lY3RvckhlaWdodCA9IHRoaXMuY29ubmVjdG9yTm9kZS5vZmZzZXRIZWlnaHQ7XG5cdFx0XHRcdGlmKGJiLmggPiBoZWlnaHRBdmFpbGFibGUpe1xuXHRcdFx0XHRcdC8vIFRoZSB0b29sdGlwIHN0YXJ0cyBhdCB0aGUgdG9wIG9mIHRoZSBwYWdlIGFuZCB3aWxsIGV4dGVuZCBwYXN0IHRoZSBhcm91bmROb2RlXG5cdFx0XHRcdFx0dmFyIGFyb3VuZE5vZGVQbGFjZW1lbnQgPSBoZWlnaHRBdmFpbGFibGUgLSAoKGFyb3VuZE5vZGVDb29yZHMuaCArIHRvb2x0aXBDb25uZWN0b3JIZWlnaHQpID4+IDEpO1xuXHRcdFx0XHRcdHRoaXMuY29ubmVjdG9yTm9kZS5zdHlsZS50b3AgPSBhcm91bmROb2RlUGxhY2VtZW50ICsgXCJweFwiO1xuXHRcdFx0XHRcdHRoaXMuY29ubmVjdG9yTm9kZS5zdHlsZS5ib3R0b20gPSBcIlwiO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHQvLyBBbGlnbiBjZW50ZXIgb2YgY29ubmVjdG9yIHdpdGggY2VudGVyIG9mIGFyb3VuZE5vZGUsIGV4Y2VwdCBkb24ndCBsZXQgYm90dG9tXG5cdFx0XHRcdFx0Ly8gb2YgY29ubmVjdG9yIGV4dGVuZCBiZWxvdyBib3R0b20gb2YgdG9vbHRpcCBjb250ZW50LCBvciB0b3Agb2YgY29ubmVjdG9yXG5cdFx0XHRcdFx0Ly8gZXh0ZW5kIHBhc3QgdG9wIG9mIHRvb2x0aXAgY29udGVudFxuXHRcdFx0XHRcdHRoaXMuY29ubmVjdG9yTm9kZS5zdHlsZS5ib3R0b20gPSBNYXRoLm1pbihcblx0XHRcdFx0XHRcdE1hdGgubWF4KGFyb3VuZE5vZGVDb29yZHMuaC8yIC0gdG9vbHRpcENvbm5lY3RvckhlaWdodC8yLCAwKSxcblx0XHRcdFx0XHRcdGJiLmggLSB0b29sdGlwQ29ubmVjdG9ySGVpZ2h0KSArIFwicHhcIjtcblx0XHRcdFx0XHR0aGlzLmNvbm5lY3Rvck5vZGUuc3R5bGUudG9wID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIHJlc2V0IHRoZSB0b29sdGlwIGJhY2sgdG8gdGhlIGRlZmF1bHRzXG5cdFx0XHRcdHRoaXMuY29ubmVjdG9yTm9kZS5zdHlsZS50b3AgPSBcIlwiO1xuXHRcdFx0XHR0aGlzLmNvbm5lY3Rvck5vZGUuc3R5bGUuYm90dG9tID0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KDAsIHNpemUudyAtIHdpZHRoQXZhaWxhYmxlKTtcblx0XHR9LFxuXG5cdFx0X29uU2hvdzogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYWxsZWQgYXQgZW5kIG9mIGZhZGUtaW4gb3BlcmF0aW9uXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cdFx0XHRpZihoYXMoXCJpZVwiKSl7XG5cdFx0XHRcdC8vIHRoZSBhcnJvdyB3b24ndCBzaG93IHVwIG9uIGEgbm9kZSB3L2FuIG9wYWNpdHkgZmlsdGVyXG5cdFx0XHRcdHRoaXMuZG9tTm9kZS5zdHlsZS5maWx0ZXI9XCJcIjtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0aGlkZTogZnVuY3Rpb24oYXJvdW5kTm9kZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0SGlkZSB0aGUgdG9vbHRpcFxuXG5cdFx0XHRpZih0aGlzLl9vbkRlY2sgJiYgdGhpcy5fb25EZWNrWzFdID09IGFyb3VuZE5vZGUpe1xuXHRcdFx0XHQvLyB0aGlzIGhpZGUgcmVxdWVzdCBpcyBmb3IgYSBzaG93KCkgdGhhdCBoYXNuJ3QgZXZlbiBzdGFydGVkIHlldDtcblx0XHRcdFx0Ly8ganVzdCBjYW5jZWwgdGhlIHBlbmRpbmcgc2hvdygpXG5cdFx0XHRcdHRoaXMuX29uRGVjaz1udWxsO1xuXHRcdFx0fWVsc2UgaWYodGhpcy5hcm91bmROb2RlID09PSBhcm91bmROb2RlKXtcblx0XHRcdFx0Ly8gdGhpcyBoaWRlIHJlcXVlc3QgaXMgZm9yIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHRvb2x0aXBcblx0XHRcdFx0dGhpcy5mYWRlSW4uc3RvcCgpO1xuXHRcdFx0XHR0aGlzLmlzU2hvd2luZ05vdyA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLmFyb3VuZE5vZGUgPSBudWxsO1xuXHRcdFx0XHR0aGlzLmZhZGVPdXQucGxheSgpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIGp1c3QgaWdub3JlIHRoZSBjYWxsLCBpdCdzIGZvciBhIHRvb2x0aXAgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGVyYXNlZFxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9uTW91c2VFbnRlciA9IHRoaXMub25Nb3VzZUxlYXZlID0gbm9vcDtcblx0XHR9LFxuXG5cdFx0X29uSGlkZTogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYWxsZWQgYXQgZW5kIG9mIGZhZGUtb3V0IG9wZXJhdGlvblxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXG5cdFx0XHR0aGlzLmRvbU5vZGUuc3R5bGUuY3NzVGV4dD1cIlwiO1x0Ly8gdG8gcG9zaXRpb24gb2Zmc2NyZWVuIGFnYWluXG5cdFx0XHR0aGlzLmNvbnRhaW5lck5vZGUuaW5uZXJIVE1MPVwiXCI7XG5cdFx0XHRpZih0aGlzLl9vbkRlY2spe1xuXHRcdFx0XHQvLyBhIHNob3cgcmVxdWVzdCBoYXMgYmVlbiBxdWV1ZWQgdXA7IGRvIGl0IG5vd1xuXHRcdFx0XHR0aGlzLnNob3cuYXBwbHkodGhpcywgdGhpcy5fb25EZWNrKTtcblx0XHRcdFx0dGhpcy5fb25EZWNrPW51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRpZihoYXMoXCJkb2pvLWJpZGlcIikpe1xuXHRcdE1hc3RlclRvb2x0aXAuZXh0ZW5kKHtcblx0XHRcdF9zZXRBdXRvVGV4dERpcjogZnVuY3Rpb24oLypPYmplY3QqL25vZGUpe1xuXHRcdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0XHQvL1x0XHRSZXNvbHZlIFwiYXV0b1wiIHRleHQgZGlyZWN0aW9uIGZvciBjaGlsZHJlbiBub2Rlc1xuXHRcdFx0XHQvLyB0YWdzOlxuXHRcdFx0XHQvL1x0XHRwcml2YXRlXG5cblx0XHRcdFx0dGhpcy5hcHBseVRleHREaXIobm9kZSk7XG5cdFx0XHRcdGFycmF5LmZvckVhY2gobm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpeyB0aGlzLl9zZXRBdXRvVGV4dERpcihjaGlsZCk7IH0sIHRoaXMpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3NldFRleHREaXJBdHRyOiBmdW5jdGlvbigvKlN0cmluZyovIHRleHREaXIpe1xuXHRcdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0XHQvL1x0XHRTZXR0ZXIgZm9yIHRleHREaXIuXG5cdFx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0XHQvL1x0XHRVc2VycyBzaG91bGRuJ3QgY2FsbCB0aGlzIGZ1bmN0aW9uOyB0aGV5IHNob3VsZCBiZSBjYWxsaW5nXG5cdFx0XHRcdC8vXHRcdHNldCgndGV4dERpcicsIHZhbHVlKVxuXHRcdFx0XHQvLyB0YWdzOlxuXHRcdFx0XHQvL1x0XHRwcml2YXRlXG5cblx0XHRcdFx0dGhpcy5fc2V0KFwidGV4dERpclwiLCB0ZXh0RGlyKTtcblxuXHRcdFx0XHRpZiAodGV4dERpciA9PSBcImF1dG9cIil7XG5cdFx0XHRcdFx0dGhpcy5fc2V0QXV0b1RleHREaXIodGhpcy5jb250YWluZXJOb2RlKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0dGhpcy5jb250YWluZXJOb2RlLmRpciA9IHRoaXMudGV4dERpcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0ZGlqaXQuc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihpbm5lckhUTUwsIGFyb3VuZE5vZGUsIHBvc2l0aW9uLCBydGwsIHRleHREaXIsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFN0YXRpYyBtZXRob2QgdG8gZGlzcGxheSB0b29sdGlwIHcvc3BlY2lmaWVkIGNvbnRlbnRzIGluIHNwZWNpZmllZCBwb3NpdGlvbi5cblx0XHQvL1x0XHRTZWUgZGVzY3JpcHRpb24gb2YgZGlqaXQvVG9vbHRpcC5kZWZhdWx0UG9zaXRpb24gZm9yIGRldGFpbHMgb24gcG9zaXRpb24gcGFyYW1ldGVyLlxuXHRcdC8vXHRcdElmIHBvc2l0aW9uIGlzIG5vdCBzcGVjaWZpZWQgdGhlbiBkaWppdC9Ub29sdGlwLmRlZmF1bHRQb3NpdGlvbiBpcyB1c2VkLlxuXHRcdC8vIGlubmVySFRNTDogU3RyaW5nXG5cdFx0Ly9cdFx0Q29udGVudHMgb2YgdGhlIHRvb2x0aXBcblx0XHQvLyBhcm91bmROb2RlOiBwbGFjZS5fX1JlY3RhbmdsZVxuXHRcdC8vXHRcdFNwZWNpZmllcyB0aGF0IHRvb2x0aXAgc2hvdWxkIGJlIG5leHQgdG8gdGhpcyBub2RlIC8gYXJlYVxuXHRcdC8vIHBvc2l0aW9uOiBTdHJpbmdbXT9cblx0XHQvL1x0XHRMaXN0IG9mIHBvc2l0aW9ucyB0byB0cnkgdG8gcG9zaXRpb24gdG9vbHRpcCAoZXg6IFtcInJpZ2h0XCIsIFwiYWJvdmVcIl0pXG5cdFx0Ly8gcnRsOiBCb29sZWFuP1xuXHRcdC8vXHRcdENvcnJlc3BvbmRzIHRvIGBXaWRnZXRCYXNlLmRpcmAgYXR0cmlidXRlLCB3aGVyZSBmYWxzZSBtZWFucyBcImx0clwiIGFuZCB0cnVlXG5cdFx0Ly9cdFx0bWVhbnMgXCJydGxcIjsgc3BlY2lmaWVzIEdVSSBkaXJlY3Rpb24sIG5vdCB0ZXh0IGRpcmVjdGlvbi5cblx0XHQvLyB0ZXh0RGlyOiBTdHJpbmc/XG5cdFx0Ly9cdFx0Q29ycmVzcG9uZHMgdG8gYFdpZGdldEJhc2UudGV4dGRpcmAgYXR0cmlidXRlOyBzcGVjaWZpZXMgZGlyZWN0aW9uIG9mIHRleHQuXG5cdFx0Ly8gb25Nb3VzZUVudGVyOiBGdW5jdGlvbj9cblx0XHQvL1x0XHRDYWxsYmFjayBmdW5jdGlvbiBmb3IgbW91c2Ugb3ZlciBvbiB0b29sdGlwXG5cdFx0Ly8gb25Nb3VzZUxlYXZlOiBGdW5jdGlvbj9cblx0XHQvL1x0XHRDYWxsYmFjayBmdW5jdGlvbiBmb3IgbW91c2UgbGVhdmUgb24gdG9vbHRpcFxuXG5cdFx0Ly8gQWZ0ZXIvYmVmb3JlIGRvbid0IHdvcmssIGJ1dCBmb3IgYmFjay1jb21wYXQgY29udmVydCB0aGVtIHRvIHRoZSB3b3JraW5nIGFmdGVyLWNlbnRlcmVkLCBiZWZvcmUtY2VudGVyZWQuXG5cdFx0Ly8gUG9zc2libHkgcmVtb3ZlIHRoaXMgaW4gMi4wLiAgIEFsdGVybmF0ZWx5LCBnZXQgYmVmb3JlL2FmdGVyIHRvIHdvcmsuXG5cdFx0aWYocG9zaXRpb24pe1xuXHRcdFx0cG9zaXRpb24gPSBhcnJheS5tYXAocG9zaXRpb24sIGZ1bmN0aW9uKHZhbCl7XG5cdFx0XHRcdHJldHVybiB7YWZ0ZXI6IFwiYWZ0ZXItY2VudGVyZWRcIiwgYmVmb3JlOiBcImJlZm9yZS1jZW50ZXJlZFwifVt2YWxdIHx8IHZhbDtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmKCFUb29sdGlwLl9tYXN0ZXJUVCl7IGRpaml0Ll9tYXN0ZXJUVCA9IFRvb2x0aXAuX21hc3RlclRUID0gbmV3IE1hc3RlclRvb2x0aXAoKTsgfVxuXHRcdHJldHVybiBUb29sdGlwLl9tYXN0ZXJUVC5zaG93KGlubmVySFRNTCwgYXJvdW5kTm9kZSwgcG9zaXRpb24sIHJ0bCwgdGV4dERpciwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUpO1xuXHR9O1xuXG5cdGRpaml0LmhpZGVUb29sdGlwID0gZnVuY3Rpb24oYXJvdW5kTm9kZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTdGF0aWMgbWV0aG9kIHRvIGhpZGUgdGhlIHRvb2x0aXAgZGlzcGxheWVkIHZpYSBzaG93VG9vbHRpcCgpXG5cdFx0cmV0dXJuIFRvb2x0aXAuX21hc3RlclRUICYmIFRvb2x0aXAuX21hc3RlclRULmhpZGUoYXJvdW5kTm9kZSk7XG5cdH07XG5cblx0Ly8gUG9zc2libGUgc3RhdGVzIGZvciBhIHRvb2x0aXAsIHNlZSBUb29sdGlwLnN0YXRlIHByb3BlcnR5IGZvciBkZWZpbml0aW9uc1xuXHR2YXIgRE9STUFOVCA9IFwiRE9STUFOVFwiLFxuXHRcdFNIT1dfVElNRVIgPSBcIlNIT1cgVElNRVJcIixcblx0XHRTSE9XSU5HID0gXCJTSE9XSU5HXCIsXG5cdFx0SElERV9USU1FUiA9IFwiSElERSBUSU1FUlwiO1xuXG5cdGZ1bmN0aW9uIG5vb3AoKXt9XG5cblx0dmFyIFRvb2x0aXAgPSBkZWNsYXJlKFwiZGlqaXQuVG9vbHRpcFwiLCBfV2lkZ2V0LCB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRQb3BzIHVwIGEgdG9vbHRpcCAoYSBoZWxwIG1lc3NhZ2UpIHdoZW4geW91IGhvdmVyIG92ZXIgYSBub2RlLlxuXHRcdC8vXHRcdEFsc28gcHJvdmlkZXMgc3RhdGljIHNob3coKSBhbmQgaGlkZSgpIG1ldGhvZHMgdGhhdCBjYW4gYmUgdXNlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgYSBkaWppdC9Ub29sdGlwLlxuXG5cdFx0Ly8gbGFiZWw6IFN0cmluZ1xuXHRcdC8vXHRcdEhUTUwgdG8gZGlzcGxheSBpbiB0aGUgdG9vbHRpcC5cblx0XHQvL1x0XHRTcGVjaWZpZWQgYXMgaW5uZXJIVE1MIHdoZW4gY3JlYXRpbmcgdGhlIHdpZGdldCBmcm9tIG1hcmt1cC5cblx0XHRsYWJlbDogXCJcIixcblxuXHRcdC8vIHNob3dEZWxheTogSW50ZWdlclxuXHRcdC8vXHRcdE51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBhZnRlciBob3ZlcmluZyBvdmVyL2ZvY3VzaW5nIG9uIHRoZSBvYmplY3QsIGJlZm9yZVxuXHRcdC8vXHRcdHRoZSB0b29sdGlwIGlzIGRpc3BsYXllZC5cblx0XHRzaG93RGVsYXk6IDQwMCxcblxuXHRcdC8vIGhpZGVEZWxheTogSW50ZWdlclxuXHRcdC8vXHRcdE51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBhZnRlciB1bmhvdmVyaW5nIHRoZSBvYmplY3QsIGJlZm9yZVxuXHRcdC8vXHRcdHRoZSB0b29sdGlwIGlzIGhpZGRlbi4gIE5vdGUgdGhhdCBibHVycmluZyBhbiBvYmplY3QgaGlkZXMgdGhlIHRvb2x0aXAgaW1tZWRpYXRlbHkuXG5cdFx0aGlkZURlbGF5OiA0MDAsXG5cblx0XHQvLyBjb25uZWN0SWQ6IFN0cmluZ3xTdHJpbmdbXXxEb21Ob2RlfERvbU5vZGVbXVxuXHRcdC8vXHRcdElkIG9mIGRvbU5vZGUocykgdG8gYXR0YWNoIHRoZSB0b29sdGlwIHRvLlxuXHRcdC8vXHRcdFdoZW4gdXNlciBob3ZlcnMgb3ZlciBzcGVjaWZpZWQgZG9tIG5vZGUocyksIHRoZSB0b29sdGlwIHdpbGwgYXBwZWFyLlxuXHRcdGNvbm5lY3RJZDogW10sXG5cblx0XHQvLyBwb3NpdGlvbjogU3RyaW5nW11cblx0XHQvL1x0XHRTZWUgZGVzY3JpcHRpb24gb2YgYGRpaml0L1Rvb2x0aXAuZGVmYXVsdFBvc2l0aW9uYCBmb3IgZGV0YWlscyBvbiBwb3NpdGlvbiBwYXJhbWV0ZXIuXG5cdFx0cG9zaXRpb246IFtdLFxuXG5cdFx0Ly8gc2VsZWN0b3I6IFN0cmluZz9cblx0XHQvL1x0XHRDU1MgZXhwcmVzc2lvbiB0byBhcHBseSB0aGlzIFRvb2x0aXAgdG8gZGVzY2VuZGFudHMgb2YgY29ubmVjdElkcywgcmF0aGVyIHRoYW4gdG9cblx0XHQvL1x0XHR0aGUgbm9kZXMgc3BlY2lmaWVkIGJ5IGNvbm5lY3RJZHMgdGhlbXNlbHZlcy4gICAgVXNlZnVsIGZvciBhcHBseWluZyBhIFRvb2x0aXAgdG9cblx0XHQvL1x0XHRhIHJhbmdlIG9mIHJvd3MgaW4gYSB0YWJsZSwgdHJlZSwgZXRjLiAgIFVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIGdldENvbnRlbnQoKSBwYXJhbWV0ZXIuXG5cdFx0Ly9cdFx0RXg6IGNvbm5lY3RJZDogbXlUYWJsZSwgc2VsZWN0b3I6IFwidHJcIiwgZ2V0Q29udGVudDogZnVuY3Rpb24obm9kZSl7IHJldHVybiAuLi47IH1cblx0XHQvL1xuXHRcdC8vXHRcdFRoZSBhcHBsaWNhdGlvbiBtdXN0IHJlcXVpcmUoKSBhbiBhcHByb3ByaWF0ZSBsZXZlbCBvZiBkb2pvL3F1ZXJ5IHRvIGhhbmRsZSB0aGUgc2VsZWN0b3IuXG5cdFx0c2VsZWN0b3I6IFwiXCIsXG5cblx0XHQvLyBUT0RPOiBpbiAyLjAgcmVtb3ZlIHN1cHBvcnQgZm9yIG11bHRpcGxlIGNvbm5lY3RJZHMuICAgc2VsZWN0b3IgZ2l2ZXMgdGhlIHNhbWUgZWZmZWN0LlxuXHRcdC8vIFNvLCBjaGFuZ2UgY29ubmVjdElkIHRvIGEgXCJcIiwgcmVtb3ZlIGFkZFRhcmdldCgpL3JlbW92ZVRhcmdldCgpLCBldGMuXG5cblx0XHRfc2V0Q29ubmVjdElkQXR0cjogZnVuY3Rpb24oLypTdHJpbmd8U3RyaW5nW118RG9tTm9kZXxEb21Ob2RlW10qLyBuZXdJZCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q29ubmVjdCB0byBzcGVjaWZpZWQgbm9kZShzKVxuXG5cdFx0XHQvLyBSZW1vdmUgY29ubmVjdGlvbnMgdG8gb2xkIG5vZGVzIChpZiB0aGVyZSBhcmUgYW55KVxuXHRcdFx0YXJyYXkuZm9yRWFjaCh0aGlzLl9jb25uZWN0aW9ucyB8fCBbXSwgZnVuY3Rpb24obmVzdGVkKXtcblx0XHRcdFx0YXJyYXkuZm9yRWFjaChuZXN0ZWQsIGZ1bmN0aW9uKGhhbmRsZSl7IGhhbmRsZS5yZW1vdmUoKTsgfSk7XG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0Ly8gTWFrZSBhcnJheSBvZiBpZCdzIHRvIGNvbm5lY3QgdG8sIGV4Y2x1ZGluZyBlbnRyaWVzIGZvciBub2RlcyB0aGF0IGRvbid0IGV4aXN0IHlldCwgc2VlIHN0YXJ0dXAoKVxuXHRcdFx0dGhpcy5fY29ubmVjdElkcyA9IGFycmF5LmZpbHRlcihsYW5nLmlzQXJyYXlMaWtlKG5ld0lkKSA/IG5ld0lkIDogKG5ld0lkID8gW25ld0lkXSA6IFtdKSxcblx0XHRcdFx0XHRmdW5jdGlvbihpZCl7IHJldHVybiBkb20uYnlJZChpZCwgdGhpcy5vd25lckRvY3VtZW50KTsgfSwgdGhpcyk7XG5cblx0XHRcdC8vIE1ha2UgY29ubmVjdGlvbnNcblx0XHRcdHRoaXMuX2Nvbm5lY3Rpb25zID0gYXJyYXkubWFwKHRoaXMuX2Nvbm5lY3RJZHMsIGZ1bmN0aW9uKGlkKXtcblx0XHRcdFx0dmFyIG5vZGUgPSBkb20uYnlJZChpZCwgdGhpcy5vd25lckRvY3VtZW50KSxcblx0XHRcdFx0XHRzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IsXG5cdFx0XHRcdFx0ZGVsZWdhdGVkRXZlbnQgPSBzZWxlY3RvciA/XG5cdFx0XHRcdFx0XHRmdW5jdGlvbihldmVudFR5cGUpeyByZXR1cm4gb24uc2VsZWN0b3Ioc2VsZWN0b3IsIGV2ZW50VHlwZSk7IH0gOlxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24oZXZlbnRUeXBlKXsgcmV0dXJuIGV2ZW50VHlwZTsgfSxcblx0XHRcdFx0XHRzZWxmID0gdGhpcztcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRvbihub2RlLCBkZWxlZ2F0ZWRFdmVudChtb3VzZS5lbnRlciksIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRzZWxmLl9vbkhvdmVyKHRoaXMpO1xuXHRcdFx0XHRcdH0pLFxuXHRcdFx0XHRcdG9uKG5vZGUsIGRlbGVnYXRlZEV2ZW50KFwiZm9jdXNpblwiKSwgZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdHNlbGYuX29uSG92ZXIodGhpcyk7XG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0b24obm9kZSwgZGVsZWdhdGVkRXZlbnQobW91c2UubGVhdmUpLCBsYW5nLmhpdGNoKHNlbGYsIFwiX29uVW5Ib3ZlclwiKSksXG5cdFx0XHRcdFx0b24obm9kZSwgZGVsZWdhdGVkRXZlbnQoXCJmb2N1c291dFwiKSwgbGFuZy5oaXRjaChzZWxmLCBcInNldFwiLCBcInN0YXRlXCIsIERPUk1BTlQpKVxuXHRcdFx0XHRdO1xuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX3NldChcImNvbm5lY3RJZFwiLCBuZXdJZCk7XG5cdFx0fSxcblxuXHRcdGFkZFRhcmdldDogZnVuY3Rpb24oLypEb21Ob2RlfFN0cmluZyovIG5vZGUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEF0dGFjaCB0b29sdGlwIHRvIHNwZWNpZmllZCBub2RlIGlmIGl0J3Mgbm90IGFscmVhZHkgY29ubmVjdGVkXG5cblx0XHRcdC8vIFRPRE86IHJlbW92ZSBpbiAyLjAgYW5kIGp1c3QgdXNlIHNldChcImNvbm5lY3RJZFwiLCAuLi4pIGludGVyZmFjZVxuXG5cdFx0XHR2YXIgaWQgPSBub2RlLmlkIHx8IG5vZGU7XG5cdFx0XHRpZihhcnJheS5pbmRleE9mKHRoaXMuX2Nvbm5lY3RJZHMsIGlkKSA9PSAtMSl7XG5cdFx0XHRcdHRoaXMuc2V0KFwiY29ubmVjdElkXCIsIHRoaXMuX2Nvbm5lY3RJZHMuY29uY2F0KGlkKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHJlbW92ZVRhcmdldDogZnVuY3Rpb24oLypEb21Ob2RlfFN0cmluZyovIG5vZGUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERldGFjaCB0b29sdGlwIGZyb20gc3BlY2lmaWVkIG5vZGVcblxuXHRcdFx0Ly8gVE9ETzogcmVtb3ZlIGluIDIuMCBhbmQganVzdCB1c2Ugc2V0KFwiY29ubmVjdElkXCIsIC4uLikgaW50ZXJmYWNlXG5cblx0XHRcdHZhciBpZCA9IG5vZGUuaWQgfHwgbm9kZSxcdC8vIG1hcCBmcm9tIERPTU5vZGUgYmFjayB0byBwbGFpbiBpZCBzdHJpbmdcblx0XHRcdFx0aWR4ID0gYXJyYXkuaW5kZXhPZih0aGlzLl9jb25uZWN0SWRzLCBpZCk7XG5cdFx0XHRpZihpZHggPj0gMCl7XG5cdFx0XHRcdC8vIHJlbW92ZSBpZCAobW9kaWZpZXMgb3JpZ2luYWwgdGhpcy5fY29ubmVjdElkcyBidXQgdGhhdCdzIE9LIGluIHRoaXMgY2FzZSlcblx0XHRcdFx0dGhpcy5fY29ubmVjdElkcy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0dGhpcy5zZXQoXCJjb25uZWN0SWRcIiwgdGhpcy5fY29ubmVjdElkcyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJ1aWxkUmVuZGVyaW5nOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHRcdGRvbUNsYXNzLmFkZCh0aGlzLmRvbU5vZGUsXCJkaWppdFRvb2x0aXBEYXRhXCIpO1xuXHRcdH0sXG5cblx0XHRzdGFydHVwOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblxuXHRcdFx0Ly8gSWYgdGhpcyB0b29sdGlwIHdhcyBjcmVhdGVkIGluIGEgdGVtcGxhdGUsIG9yIGZvciBzb21lIG90aGVyIHJlYXNvbiB0aGUgc3BlY2lmaWVkIGNvbm5lY3RJZFtzXVxuXHRcdFx0Ly8gZGlkbid0IGV4aXN0IGR1cmluZyB0aGUgd2lkZ2V0J3MgaW5pdGlhbGl6YXRpb24sIHRoZW4gY29ubmVjdCBub3cuXG5cdFx0XHR2YXIgaWRzID0gdGhpcy5jb25uZWN0SWQ7XG5cdFx0XHRhcnJheS5mb3JFYWNoKGxhbmcuaXNBcnJheUxpa2UoaWRzKSA/IGlkcyA6IFtpZHNdLCB0aGlzLmFkZFRhcmdldCwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdGdldENvbnRlbnQ6IGZ1bmN0aW9uKC8qRG9tTm9kZSovIG5vZGUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFVzZXIgb3ZlcnJpZGFibGUgZnVuY3Rpb24gdGhhdCByZXR1cm4gdGhlIHRleHQgdG8gZGlzcGxheSBpbiB0aGUgdG9vbHRpcC5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRleHRlbnNpb25cblx0XHRcdHJldHVybiB0aGlzLmxhYmVsIHx8IHRoaXMuZG9tTm9kZS5pbm5lckhUTUw7XG5cdFx0fSxcblxuXHRcdC8vIHN0YXRlOiBbcHJpdmF0ZSByZWFkb25seV0gU3RyaW5nXG5cdFx0Ly9cdFx0T25lIG9mOlxuXHRcdC8vXG5cdFx0Ly9cdFx0LSBET1JNQU5UOiB0b29sdGlwIG5vdCBTSE9XSU5HXG5cdFx0Ly9cdFx0LSBTSE9XIFRJTUVSOiB0b29sdGlwIG5vdCBTSE9XSU5HIGJ1dCB0aW1lciBzZXQgdG8gc2hvdyBpdFxuXHRcdC8vXHRcdC0gU0hPV0lORzogdG9vbHRpcCBkaXNwbGF5ZWRcblx0XHQvL1x0XHQtIEhJREUgVElNRVI6IHRvb2x0aXAgZGlzcGxheWVkLCBidXQgdGltZXIgc2V0IHRvIGhpZGUgaXRcblx0XHRzdGF0ZTogRE9STUFOVCxcblx0XHRfc2V0U3RhdGVBdHRyOiBmdW5jdGlvbih2YWwpe1xuXHRcdFx0aWYodGhpcy5zdGF0ZSA9PSB2YWwgfHxcblx0XHRcdFx0KHZhbCA9PSBTSE9XX1RJTUVSICYmIHRoaXMuc3RhdGUgPT0gU0hPV0lORykgfHxcblx0XHRcdFx0KHZhbCA9PSBISURFX1RJTUVSICYmIHRoaXMuc3RhdGUgPT0gRE9STUFOVCkpe1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuX2hpZGVUaW1lcil7XG5cdFx0XHRcdHRoaXMuX2hpZGVUaW1lci5yZW1vdmUoKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2hpZGVUaW1lcjtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuX3Nob3dUaW1lcil7XG5cdFx0XHRcdHRoaXMuX3Nob3dUaW1lci5yZW1vdmUoKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX3Nob3dUaW1lcjtcblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoKHZhbCl7XG5cdFx0XHRcdGNhc2UgRE9STUFOVDpcblx0XHRcdFx0XHRpZih0aGlzLl9jb25uZWN0Tm9kZSl7XG5cdFx0XHRcdFx0XHRUb29sdGlwLmhpZGUodGhpcy5fY29ubmVjdE5vZGUpO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX2Nvbm5lY3ROb2RlO1xuXHRcdFx0XHRcdFx0dGhpcy5vbkhpZGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgU0hPV19USU1FUjpcdCAvLyBzZXQgdGltZXIgdG8gc2hvdyB0b29sdGlwXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIG9ubHkgZ2V0IGhlcmUgZnJvbSBhIERPUk1BTlQgc3RhdGUsIGkuZS4gdG9vbHRpcCBjYW4ndCBiZSBhbHJlYWR5IFNIT1dJTkdcblx0XHRcdFx0XHRpZih0aGlzLnN0YXRlICE9IFNIT1dJTkcpe1xuXHRcdFx0XHRcdFx0dGhpcy5fc2hvd1RpbWVyID0gdGhpcy5kZWZlcihmdW5jdGlvbigpeyB0aGlzLnNldChcInN0YXRlXCIsIFNIT1dJTkcpOyB9LCB0aGlzLnNob3dEZWxheSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFNIT1dJTkc6XHRcdC8vIHNob3cgdG9vbHRpcCBhbmQgY2xlYXIgdGltZXJzXG5cdFx0XHRcdFx0dmFyIGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQodGhpcy5fY29ubmVjdE5vZGUpO1xuXHRcdFx0XHRcdGlmKCFjb250ZW50KXtcblx0XHRcdFx0XHRcdHRoaXMuc2V0KFwic3RhdGVcIiwgRE9STUFOVCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU2hvdyB0b29sdGlwIGFuZCBzZXR1cCBjYWxsYmFja3MgZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSBvZiB0b29sdGlwIGl0c2VsZlxuXHRcdFx0XHRcdFRvb2x0aXAuc2hvdyhjb250ZW50LCB0aGlzLl9jb25uZWN0Tm9kZSwgdGhpcy5wb3NpdGlvbiwgIXRoaXMuaXNMZWZ0VG9SaWdodCgpLCB0aGlzLnRleHREaXIsXG5cdFx0XHRcdFx0XHRsYW5nLmhpdGNoKHRoaXMsIFwic2V0XCIsIFwic3RhdGVcIiwgU0hPV0lORyksIGxhbmcuaGl0Y2godGhpcywgXCJzZXRcIiwgXCJzdGF0ZVwiLCBISURFX1RJTUVSKSk7XG5cblx0XHRcdFx0XHR0aGlzLm9uU2hvdyh0aGlzLl9jb25uZWN0Tm9kZSwgdGhpcy5wb3NpdGlvbik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgSElERV9USU1FUjpcdC8vIHNldCB0aW1lciBzZXQgdG8gaGlkZSB0b29sdGlwXG5cdFx0XHRcdFx0dGhpcy5faGlkZVRpbWVyID0gdGhpcy5kZWZlcihmdW5jdGlvbigpeyB0aGlzLnNldChcInN0YXRlXCIsIERPUk1BTlQpOyB9LCB0aGlzLmhpZGVEZWxheSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NldChcInN0YXRlXCIsIHZhbCk7XG5cdFx0fSxcblxuXHRcdF9vbkhvdmVyOiBmdW5jdGlvbigvKkRvbU5vZGUqLyB0YXJnZXQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERlc3BpdGUgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2QsIGl0IGFjdHVhbGx5IGhhbmRsZXMgYm90aCBob3ZlciBhbmQgZm9jdXNcblx0XHRcdC8vXHRcdGV2ZW50cyBvbiB0aGUgdGFyZ2V0IG5vZGUsIHNldHRpbmcgYSB0aW1lciB0byBzaG93IHRoZSB0b29sdGlwLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByaXZhdGVcblxuXHRcdFx0aWYodGhpcy5fY29ubmVjdE5vZGUgJiYgdGFyZ2V0ICE9IHRoaXMuX2Nvbm5lY3ROb2RlKXtcblx0XHRcdFx0Ly8gVG9vbHRpcCBpcyBkaXNwbGF5aW5nIGZvciBhbm90aGVyIG5vZGVcblx0XHRcdFx0dGhpcy5zZXQoXCJzdGF0ZVwiLCBET1JNQU5UKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2Nvbm5lY3ROb2RlID0gdGFyZ2V0O1x0XHQvLyBfY29ubmVjdE5vZGUgbWVhbnMgXCJ0b29sdGlwIGN1cnJlbnRseSBkaXNwbGF5ZWQgZm9yIHRoaXMgbm9kZVwiXG5cblx0XHRcdHRoaXMuc2V0KFwic3RhdGVcIiwgU0hPV19USU1FUik7XHQvLyBuby1vcCBpZiBzaG93LXRpbWVyIGFscmVhZHkgc2V0LCBvciBpZiBhbHJlYWR5IHNob3dpbmdcblx0XHR9LFxuXG5cdFx0X29uVW5Ib3ZlcjogZnVuY3Rpb24oLypEb21Ob2RlKi8gdGFyZ2V0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRIYW5kbGVzIG1vdXNlbGVhdmUgZXZlbnQgb24gdGhlIHRhcmdldCBub2RlLCBoaWRpbmcgdGhlIHRvb2x0aXAuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJpdmF0ZVxuXG5cdFx0XHR0aGlzLnNldChcInN0YXRlXCIsIEhJREVfVElNRVIpO1x0XHQvLyBuby1vcCBpZiBhbHJlYWR5IGRvcm1hbnQsIG9yIGlmIGhpZGUtdGltZXIgYWxyZWFkeSBzZXRcblx0XHR9LFxuXG5cdFx0Ly8gb3BlbigpIGFuZCBjbG9zZSgpIGFyZW4ndCB1c2VkIGFueW1vcmUsIGV4Y2VwdCBmcm9tIHRoZSBfQmlkaVN1cHBvcnQvbWlzYy9Ub29sdGlwIHRlc3QuXG5cdFx0Ly8gU2hvdWxkIHByb2JhYmx5IHJlbW92ZSBmb3IgMi4wLCBidXQgbGVhdmluZyBmb3Igbm93LlxuXHRcdG9wZW46IGZ1bmN0aW9uKC8qRG9tTm9kZSovIHRhcmdldCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RGlzcGxheSB0aGUgdG9vbHRpcDsgdXN1YWxseSBub3QgY2FsbGVkIGRpcmVjdGx5LlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByaXZhdGVcblxuXHRcdFx0dGhpcy5zZXQoXCJzdGF0ZVwiLCBET1JNQU5UKTtcblx0XHRcdHRoaXMuX2Nvbm5lY3ROb2RlID0gdGFyZ2V0O1x0XHQvLyBfY29ubmVjdE5vZGUgbWVhbnMgXCJ0b29sdGlwIGN1cnJlbnRseSBkaXNwbGF5ZWQgZm9yIHRoaXMgbm9kZVwiXG5cdFx0XHR0aGlzLnNldChcInN0YXRlXCIsIFNIT1dJTkcpO1xuXHRcdH0sXG5cblx0XHRjbG9zZTogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRIaWRlIHRoZSB0b29sdGlwIG9yIGNhbmNlbCB0aW1lciBmb3Igc2hvdyBvZiB0b29sdGlwXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJpdmF0ZVxuXG5cdFx0XHR0aGlzLnNldChcInN0YXRlXCIsIERPUk1BTlQpO1xuXHRcdH0sXG5cblx0XHRvblNob3c6IGZ1bmN0aW9uKC8qPT09PT0gdGFyZ2V0LCBwb3NpdGlvbiA9PT09PSovKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYWxsZWQgd2hlbiB0aGUgdG9vbHRpcCBpcyBzaG93blxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdGNhbGxiYWNrXG5cdFx0fSxcblxuXHRcdG9uSGlkZTogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYWxsZWQgd2hlbiB0aGUgdG9vbHRpcCBpcyBoaWRkZW5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRjYWxsYmFja1xuXHRcdH0sXG5cblx0XHRkZXN0cm95OiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5zZXQoXCJzdGF0ZVwiLCBET1JNQU5UKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGNvbm5lY3Rpb25zIG1hbnVhbGx5IHNpbmNlIHRoZXkgYXJlbid0IHJlZ2lzdGVyZWQgdG8gYmUgcmVtb3ZlZCBieSBfV2lkZ2V0QmFzZVxuXHRcdFx0YXJyYXkuZm9yRWFjaCh0aGlzLl9jb25uZWN0aW9ucyB8fCBbXSwgZnVuY3Rpb24obmVzdGVkKXtcblx0XHRcdFx0YXJyYXkuZm9yRWFjaChuZXN0ZWQsIGZ1bmN0aW9uKGhhbmRsZSl7IGhhbmRsZS5yZW1vdmUoKTsgfSk7XG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHR9XG5cdH0pO1xuXG5cdFRvb2x0aXAuX01hc3RlclRvb2x0aXAgPSBNYXN0ZXJUb29sdGlwO1x0XHQvLyBmb3IgbW9ua2V5IHBhdGNoaW5nXG5cdFRvb2x0aXAuc2hvdyA9IGRpaml0LnNob3dUb29sdGlwO1x0XHQvLyBleHBvcnQgZnVuY3Rpb24gdGhyb3VnaCBtb2R1bGUgcmV0dXJuIHZhbHVlXG5cdFRvb2x0aXAuaGlkZSA9IGRpaml0LmhpZGVUb29sdGlwO1x0XHQvLyBleHBvcnQgZnVuY3Rpb24gdGhyb3VnaCBtb2R1bGUgcmV0dXJuIHZhbHVlXG5cblx0VG9vbHRpcC5kZWZhdWx0UG9zaXRpb24gPSBbXCJhZnRlci1jZW50ZXJlZFwiLCBcImJlZm9yZS1jZW50ZXJlZFwiXTtcblxuXHQvKj09PT09XG5cdGxhbmcubWl4aW4oVG9vbHRpcCwge1xuXHRcdCAvLyBkZWZhdWx0UG9zaXRpb246IFN0cmluZ1tdXG5cdFx0IC8vXHRcdFRoaXMgdmFyaWFibGUgY29udHJvbHMgdGhlIHBvc2l0aW9uIG9mIHRvb2x0aXBzLCBpZiB0aGUgcG9zaXRpb24gaXMgbm90IHNwZWNpZmllZCB0b1xuXHRcdCAvL1x0XHR0aGUgVG9vbHRpcCB3aWRnZXQgb3IgKlRleHRCb3ggd2lkZ2V0IGl0c2VsZi4gIEl0J3MgYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSB2YWx1ZXNcblx0XHQgLy9cdFx0cG9zc2libGUgZm9yIGBkaWppdC9wbGFjZS5hcm91bmQoKWAuICAgVGhlIHJlY29tbWVuZGVkIHZhbHVlcyBhcmU6XG5cdFx0IC8vXG5cdFx0IC8vXHRcdC0gYmVmb3JlLWNlbnRlcmVkOiBjZW50ZXJzIHRvb2x0aXAgdG8gdGhlIGxlZnQgb2YgdGhlIGFuY2hvciBub2RlL3dpZGdldCwgb3IgdG8gdGhlIHJpZ2h0XG5cdFx0IC8vXHRcdCAgaW4gdGhlIGNhc2Ugb2YgUlRMIHNjcmlwdHMgbGlrZSBIZWJyZXcgYW5kIEFyYWJpY1xuXHRcdCAvL1x0XHQtIGFmdGVyLWNlbnRlcmVkOiBjZW50ZXJzIHRvb2x0aXAgdG8gdGhlIHJpZ2h0IG9mIHRoZSBhbmNob3Igbm9kZS93aWRnZXQsIG9yIHRvIHRoZSBsZWZ0XG5cdFx0IC8vXHRcdCAgaW4gdGhlIGNhc2Ugb2YgUlRMIHNjcmlwdHMgbGlrZSBIZWJyZXcgYW5kIEFyYWJpY1xuXHRcdCAvL1x0XHQtIGFib3ZlLWNlbnRlcmVkOiB0b29sdGlwIGlzIGNlbnRlcmVkIGFib3ZlIGFuY2hvciBub2RlXG5cdFx0IC8vXHRcdC0gYmVsb3ctY2VudGVyZWQ6IHRvb2x0aXAgaXMgY2VudGVyZWQgYWJvdmUgYW5jaG9yIG5vZGVcblx0XHQgLy9cblx0XHQgLy9cdFx0VGhlIGxpc3QgaXMgcG9zaXRpb25zIGlzIHRyaWVkLCBpbiBvcmRlciwgdW50aWwgYSBwb3NpdGlvbiBpcyBmb3VuZCB3aGVyZSB0aGUgdG9vbHRpcCBmaXRzXG5cdFx0IC8vXHRcdHdpdGhpbiB0aGUgdmlld3BvcnQuXG5cdFx0IC8vXG5cdFx0IC8vXHRcdEJlIGNhcmVmdWwgc2V0dGluZyB0aGlzIHBhcmFtZXRlci4gIEEgdmFsdWUgb2YgXCJhYm92ZS1jZW50ZXJlZFwiIG1heSB3b3JrIGZpbmUgdW50aWwgdGhlIHVzZXIgc2Nyb2xsc1xuXHRcdCAvL1x0XHR0aGUgc2NyZWVuIHNvIHRoYXQgdGhlcmUncyBubyByb29tIGFib3ZlIHRoZSB0YXJnZXQgbm9kZS4gICBOb2RlcyB3aXRoIGRyb3AgZG93bnMsIGxpa2Vcblx0XHQgLy9cdFx0RHJvcERvd25CdXR0b24gb3IgRmlsdGVyaW5nU2VsZWN0LCBhcmUgZXNwZWNpYWxseSBwcm9ibGVtYXRpYywgaW4gdGhhdCB5b3UgbmVlZCB0byBiZSBzdXJlXG5cdFx0IC8vXHRcdHRoYXQgdGhlIGRyb3AgZG93biBhbmQgdG9vbHRpcCBkb24ndCBvdmVybGFwLCBldmVuIHdoZW4gdGhlIHZpZXdwb3J0IGlzIHNjcm9sbGVkIHNvIHRoYXQgdGhlcmVcblx0XHQgLy9cdFx0aXMgb25seSByb29tIGJlbG93IChvciBhYm92ZSkgdGhlIHRhcmdldCBub2RlLCBidXQgbm90IGJvdGguXG5cdCB9KTtcblx0PT09PT0qL1xuXHRyZXR1cm4gVG9vbHRpcDtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCJkb2pvL0V2ZW50ZWRcIixcblx0XCJkb2pvL29uXCIsXG5cdFwiZG9qby9kb21SZWFkeVwiLFxuXHRcImRvam8vc25pZmZcIixcdC8vIGhhcyhcImllXCIpLCBoYXMoXCJpb3NcIilcblx0XCJkb2pvL3dpbmRvd1wiIC8vIGdldEJveCgpXG5dLCBmdW5jdGlvbihFdmVudGVkLCBvbiwgZG9tUmVhZHksIGhhcywgd2luVXRpbHMpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvVmlld3BvcnRcblxuXHQvKj09PT09XG5cdHJldHVybiB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRVdGlsaXR5IHNpbmdsZXRvbiB0byB3YXRjaCBmb3Igdmlld3BvcnQgcmVzaXplcywgYXZvaWRpbmcgZHVwbGljYXRlIG5vdGlmaWNhdGlvbnNcblx0XHQvL1x0XHR3aGljaCBjYW4gbGVhZCB0byBpbmZpbml0ZSBsb29wcy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRVc2FnZTogVmlld3BvcnQub24oXCJyZXNpemVcIiwgbXlDYWxsYmFjaykuXG5cdFx0Ly9cblx0XHQvL1x0XHRteUNhbGxiYWNrKCkgaXMgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzIGluIGNhc2UgaXQncyBfV2lkZ2V0QmFzZS5yZXNpemUoKSxcblx0XHQvL1x0XHR3aGljaCB3b3VsZCBpbnRlcnByZXQgdGhlIGFyZ3VtZW50IGFzIHRoZSBzaXplIHRvIG1ha2UgdGhlIHdpZGdldC5cblx0fTtcblx0PT09PT0qL1xuXG5cdHZhciBWaWV3cG9ydCA9IG5ldyBFdmVudGVkKCk7XG5cblx0dmFyIGZvY3VzZWROb2RlO1xuXG5cdGRvbVJlYWR5KGZ1bmN0aW9uKCl7XG5cdFx0dmFyIG9sZEJveCA9IHdpblV0aWxzLmdldEJveCgpO1xuXHRcdFZpZXdwb3J0Ll9ybGggPSBvbih3aW5kb3csIFwicmVzaXplXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgbmV3Qm94ID0gd2luVXRpbHMuZ2V0Qm94KCk7XG5cdFx0XHRpZihvbGRCb3guaCA9PSBuZXdCb3guaCAmJiBvbGRCb3gudyA9PSBuZXdCb3gudyl7IHJldHVybjsgfVxuXHRcdFx0b2xkQm94ID0gbmV3Qm94O1xuXHRcdFx0Vmlld3BvcnQuZW1pdChcInJlc2l6ZVwiKTtcblx0XHR9KTtcblxuXHRcdC8vIEFsc28gY2F0Y2ggem9vbSBjaGFuZ2VzIG9uIElFOCwgc2luY2UgdGhleSBkb24ndCBuYXR1cmFsbHkgZ2VuZXJhdGUgcmVzaXplIGV2ZW50c1xuXHRcdGlmKGhhcyhcImllXCIpID09IDgpe1xuXHRcdFx0dmFyIGRldmljZVhEUEkgPSBzY3JlZW4uZGV2aWNlWERQSTtcblx0XHRcdHNldEludGVydmFsKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGlmKHNjcmVlbi5kZXZpY2VYRFBJICE9IGRldmljZVhEUEkpe1xuXHRcdFx0XHRcdGRldmljZVhEUEkgPSBzY3JlZW4uZGV2aWNlWERQSTtcblx0XHRcdFx0XHRWaWV3cG9ydC5lbWl0KFwicmVzaXplXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCA1MDApO1xuXHRcdH1cblxuXHRcdC8vIE9uIGlPUywga2VlcCB0cmFjayBvZiB0aGUgZm9jdXNlZCBub2RlIHNvIHdlIGNhbiBndWVzcyB3aGVuIHRoZSBrZXlib2FyZCBpcy9pc24ndCBiZWluZyBkaXNwbGF5ZWQuXG5cdFx0aWYoaGFzKFwiaW9zXCIpKXtcblx0XHRcdG9uKGRvY3VtZW50LCBcImZvY3VzaW5cIiwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0Zm9jdXNlZE5vZGUgPSBldnQudGFyZ2V0O1xuXHRcdFx0fSk7XG5cdFx0XHRvbihkb2N1bWVudCwgXCJmb2N1c291dFwiLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRmb2N1c2VkTm9kZSA9IG51bGw7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xuXG5cdFZpZXdwb3J0LmdldEVmZmVjdGl2ZUJveCA9IGZ1bmN0aW9uKC8qRG9jdW1lbnQqLyBkb2Mpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0R2V0IHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydCwgb3Igb24gbW9iaWxlIGRldmljZXMsIHRoZSBwYXJ0IG9mIHRoZSB2aWV3cG9ydCBub3Qgb2JzY3VyZWQgYnkgdGhlXG5cdFx0Ly9cdFx0dmlydHVhbCBrZXlib2FyZC5cblxuXHRcdHZhciBib3ggPSB3aW5VdGlscy5nZXRCb3goZG9jKTtcblxuXHRcdC8vIEFjY291bnQgZm9yIGlPUyB2aXJ0dWFsIGtleWJvYXJkLCBpZiBpdCdzIGJlaW5nIHNob3duLiAgVW5mb3J0dW5hdGVseSBubyBkaXJlY3Qgd2F5IHRvIGNoZWNrIG9yIG1lYXN1cmUuXG5cdFx0dmFyIHRhZyA9IGZvY3VzZWROb2RlICYmIGZvY3VzZWROb2RlLnRhZ05hbWUgJiYgZm9jdXNlZE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlmKGhhcyhcImlvc1wiKSAmJiBmb2N1c2VkTm9kZSAmJiAhZm9jdXNlZE5vZGUucmVhZE9ubHkgJiYgKHRhZyA9PSBcInRleHRhcmVhXCIgfHwgKHRhZyA9PSBcImlucHV0XCIgJiZcblx0XHRcdC9eKGNvbG9yfGVtYWlsfG51bWJlcnxwYXNzd29yZHxzZWFyY2h8dGVsfHRleHR8dXJsKSQvLnRlc3QoZm9jdXNlZE5vZGUudHlwZSkpKSl7XG5cblx0XHRcdC8vIEJveCByZXByZXNlbnRzIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydC4gIFNvbWUgb2YgdGhlIHZpZXdwb3J0IGlzIGxpa2VseSBjb3ZlcmVkIGJ5IHRoZSBrZXlib2FyZC5cblx0XHRcdC8vIEVzdGltYXRlIGhlaWdodCBvZiB2aXNpYmxlIHZpZXdwb3J0IGFzc3VtaW5nIHZpZXdwb3J0IGdvZXMgdG8gYm90dG9tIG9mIHNjcmVlbiwgYnV0IGlzIGNvdmVyZWQgYnkga2V5Ym9hcmQuXG5cdFx0XHRib3guaCAqPSAob3JpZW50YXRpb24gPT0gMCB8fCBvcmllbnRhdGlvbiA9PSAxODAgPyAwLjY2IDogMC40MCk7XG5cblx0XHRcdC8vIEFib3ZlIG1lYXN1cmVtZW50IHdpbGwgYmUgaW5hY2N1cmF0ZSBpZiB2aWV3cG9ydCB3YXMgc2Nyb2xsZWQgdXAgc28gZmFyIHRoYXQgaXQgZW5kcyBiZWZvcmUgdGhlIGJvdHRvbVxuXHRcdFx0Ly8gb2YgdGhlIHNjcmVlbi4gICBJbiB0aGlzIGNhc2UsIGtleWJvYXJkIGlzbid0IGNvdmVyaW5nIGFzIG11Y2ggb2YgdGhlIHZpZXdwb3J0IGFzIHdlIHRob3VnaHQuXG5cdFx0XHQvLyBXZSBrbm93IHRoZSB2aXNpYmxlIHNpemUgaXMgYXQgbGVhc3QgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQgdG8gdGhlIGZvY3VzZWQgbm9kZS5cblx0XHRcdHZhciByZWN0ID0gZm9jdXNlZE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRib3guaCA9IE1hdGgubWF4KGJveC5oLCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYm94O1xuXHR9O1xuXG5cdHJldHVybiBWaWV3cG9ydDtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCJyZXF1aXJlXCIsXG5cdFwiZG9qby9fYmFzZS9hcnJheVwiLCAvLyBhcnJheS5mb3JFYWNoXG5cdFwiZG9qby9fYmFzZS9jb25uZWN0XCIsXHQvLyByZW1vdmUgZm9yIDIuMFxuXHRcImRvam8vX2Jhc2UvZGVjbGFyZVwiLCAvLyBkZWNsYXJlXG5cdFwiZG9qby9fYmFzZS9sYW5nXCIsIC8vIGxhbmcuZ2V0T2JqZWN0XG5cdFwiZG9qby9tb3VzZVwiLFxuXHRcImRvam8vb25cIixcblx0XCJkb2pvL3RvdWNoXCIsXG5cdFwiLi9fV2lkZ2V0QmFzZVwiXG5dLCBmdW5jdGlvbihyZXF1aXJlLCBhcnJheSwgY29ubmVjdCwgZGVjbGFyZSwgbGFuZywgbW91c2UsIG9uLCB0b3VjaCwgX1dpZGdldEJhc2Upe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvX0F0dGFjaE1peGluXG5cblx0Ly8gTWFwIGZyb20gc3RyaW5nIG5hbWUgbGlrZSBcIm1vdXNlZW50ZXJcIiB0byBzeW50aGV0aWMgZXZlbnQgbGlrZSBtb3VzZS5lbnRlclxuXHR2YXIgc3ludGhFdmVudHMgPSBsYW5nLmRlbGVnYXRlKHRvdWNoLCB7XG5cdFx0XCJtb3VzZWVudGVyXCI6IG1vdXNlLmVudGVyLFxuXHRcdFwibW91c2VsZWF2ZVwiOiBtb3VzZS5sZWF2ZSxcblx0XHRcImtleXByZXNzXCI6IGNvbm5lY3QuX2tleXByZXNzXHQvLyByZW1vdmUgZm9yIDIuMFxuXHR9KTtcblxuXHQvLyBUbyBiZSBsaWdodHdlaWdodCwgX0F0dGFjaE1peGluIGRvZXNuJ3QgcmVxdWlyZSgpIGRpaml0L2ExMXljbGljay5cblx0Ly8gSWYgdGhlIHN1YmNsYXNzIGhhcyBhIHRlbXBsYXRlIHVzaW5nIFwib25kaWppdGNsaWNrXCIsIGl0IG11c3QgbG9hZCBkaWppdC9hMTF5Y2xpY2sgaXRzZWxmLlxuXHQvLyBJbiB0aGF0IGNhc2UsIHRoZSBhMTF5Y2xpY2sgdmFyaWFibGUgYmVsb3cgd2lsbCBnZXQgc2V0IHRvIHBvaW50IHRvIHRoYXQgc3ludGhldGljIGV2ZW50LlxuXHR2YXIgYTExeWNsaWNrO1xuXG5cdHZhciBfQXR0YWNoTWl4aW4gPSBkZWNsYXJlKFwiZGlqaXQuX0F0dGFjaE1peGluXCIsIG51bGwsIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdE1peGluIGZvciB3aWRnZXRzIHRvIGF0dGFjaCB0byBkb20gbm9kZXMgYW5kIHNldHVwIGV2ZW50cyB2aWFcblx0XHQvL1x0XHRjb252ZW5pZW50IGRhdGEtZG9qby1hdHRhY2gtcG9pbnQgYW5kIGRhdGEtZG9qby1hdHRhY2gtZXZlbnQgRE9NIGF0dHJpYnV0ZXMuXG5cdFx0Ly9cblx0XHQvL1x0XHRTdXBlcmNsYXNzIG9mIF9UZW1wbGF0ZWRNaXhpbiwgYW5kIGNhbiBhbHNvIGJlIHVzZWQgc3RhbmRhbG9uZSB3aGVuIHRlbXBsYXRlcyBhcmUgcHJlLXJlbmRlcmVkIG9uIHRoZVxuXHRcdC8vXHRcdHNlcnZlci5cblx0XHQvL1xuXHRcdC8vXHRcdERvZXMgbm90IFt5ZXRdIGhhbmRsZSB3aWRnZXRzIGxpa2UgQ29udGVudFBhbmUgd2l0aCB0aGlzLmNvbnRhaW5lck5vZGUgc2V0LiAgIEl0IHNob3VsZCBza2lwXG5cdFx0Ly9cdFx0c2Nhbm5pbmcgZm9yIGRhdGEtZG9qby1hdHRhY2gtcG9pbnQgYW5kIGRhdGEtZG9qby1hdHRhY2gtZXZlbnQgaW5zaWRlIHRoaXMuY29udGFpbmVyTm9kZSwgYnV0IGl0XG5cdFx0Ly9cdFx0ZG9lc24ndC5cblxuLyo9PT09PVxuXHRcdC8vIF9hdHRhY2hQb2ludHM6IFtwcml2YXRlXSBTdHJpbmdbXVxuXHRcdC8vXHRcdExpc3Qgb2Ygd2lkZ2V0IGF0dHJpYnV0ZSBuYW1lcyBhc3NvY2lhdGVkIHdpdGggZGF0YS1kb2pvLWF0dGFjaC1wb2ludD0uLi4gaW4gdGhlXG5cdFx0Ly9cdFx0dGVtcGxhdGUsIGV4OiBbXCJjb250YWluZXJOb2RlXCIsIFwibGFiZWxOb2RlXCJdXG5cdFx0X2F0dGFjaFBvaW50czogW10sXG5cblx0XHQvLyBfYXR0YWNoRXZlbnRzOiBbcHJpdmF0ZV0gSGFuZGxlW11cblx0XHQvL1x0XHRMaXN0IG9mIGNvbm5lY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCBkYXRhLWRvam8tYXR0YWNoLWV2ZW50PS4uLiBpbiB0aGVcblx0XHQvL1x0XHR0ZW1wbGF0ZVxuXHRcdF9hdHRhY2hFdmVudHM6IFtdLFxuXG5cdFx0Ly8gYXR0YWNoU2NvcGU6IFtwdWJsaWNdIE9iamVjdFxuXHRcdC8vXHRcdE9iamVjdCB0byB3aGljaCBhdHRhY2ggcG9pbnRzIGFuZCBldmVudHMgd2lsbCBiZSBzY29wZWQuICBEZWZhdWx0c1xuXHRcdC8vXHRcdHRvICd0aGlzJy5cblx0XHRhdHRhY2hTY29wZTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gc2VhcmNoQ29udGFpbmVyTm9kZTogW3Byb3RlY3RlZF0gQm9vbGVhblxuXHRcdC8vXHRcdFNlYXJjaCBkZXNjZW5kYW50cyBvZiB0aGlzLmNvbnRhaW5lck5vZGUgZm9yIGRhdGEtZG9qby1hdHRhY2gtcG9pbnQgYW5kIGRhdGEtZG9qby1hdHRhY2gtZXZlbnQuXG5cdFx0Ly9cdFx0U2hvdWxkIGdlbmVyYWxseSBiZSBsZWZ0IGZhbHNlICh0aGUgZGVmYXVsdCB2YWx1ZSkgYm90aCBmb3IgcGVyZm9ybWFuY2UgYW5kIHRvIGF2b2lkIGZhaWx1cmVzIHdoZW5cblx0XHQvL1x0XHR0aGlzLmNvbnRhaW5lck5vZGUgaG9sZHMgb3RoZXIgX0F0dGFjaE1peGluIGluc3RhbmNlcyB3aXRoIHRoZWlyIG93biBhdHRhY2ggcG9pbnRzIGFuZCBldmVudHMuXG4gXHRcdHNlYXJjaENvbnRhaW5lck5vZGU6IGZhbHNlLFxuID09PT09Ki9cblxuXHRcdGNvbnN0cnVjdG9yOiBmdW5jdGlvbigvKj09PT09IHBhcmFtcywgc3JjTm9kZVJlZiA9PT09PSovKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDcmVhdGUgdGhlIHdpZGdldC5cblx0XHRcdC8vIHBhcmFtczogT2JqZWN0fG51bGxcblx0XHRcdC8vXHRcdEhhc2ggb2YgaW5pdGlhbGl6YXRpb24gcGFyYW1ldGVycyBmb3Igd2lkZ2V0LCBpbmNsdWRpbmcgc2NhbGFyIHZhbHVlcyAobGlrZSB0aXRsZSwgZHVyYXRpb24gZXRjLilcblx0XHRcdC8vXHRcdGFuZCBmdW5jdGlvbnMsIHR5cGljYWxseSBjYWxsYmFja3MgbGlrZSBvbkNsaWNrLlxuXHRcdFx0Ly9cdFx0VGhlIGhhc2ggY2FuIGNvbnRhaW4gYW55IG9mIHRoZSB3aWRnZXQncyBwcm9wZXJ0aWVzLCBleGNsdWRpbmcgcmVhZC1vbmx5IHByb3BlcnRpZXMuXG5cdFx0XHQvLyBzcmNOb2RlUmVmOiBET01Ob2RlfFN0cmluZz9cblx0XHRcdC8vXHRcdElmIGEgc3JjTm9kZVJlZiAoRE9NIG5vZGUpIGlzIHNwZWNpZmllZCwgcmVwbGFjZSBzcmNOb2RlUmVmIHdpdGggbXkgZ2VuZXJhdGVkIERPTSB0cmVlLlxuXG5cdFx0XHR0aGlzLl9hdHRhY2hQb2ludHMgPSBbXTtcblx0XHRcdHRoaXMuX2F0dGFjaEV2ZW50cyA9IFtdO1xuXHRcdH0sXG5cblxuXHRcdGJ1aWxkUmVuZGVyaW5nOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEF0dGFjaCB0byBET00gbm9kZXMgbWFya2VkIHdpdGggc3BlY2lhbCBhdHRyaWJ1dGVzLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXG5cdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyByZWN1cnNlIHRocm91Z2ggdGhlIG5vZGUsIGxvb2tpbmcgZm9yLCBhbmQgYXR0YWNoaW5nIHRvLCBvdXJcblx0XHRcdC8vIGF0dGFjaG1lbnQgcG9pbnRzIGFuZCBldmVudHMsIHdoaWNoIHNob3VsZCBiZSBkZWZpbmVkIG9uIHRoZSB0ZW1wbGF0ZSBub2RlLlxuXHRcdFx0dGhpcy5fYXR0YWNoVGVtcGxhdGVOb2Rlcyh0aGlzLmRvbU5vZGUpO1xuXG5cdFx0XHR0aGlzLl9iZWZvcmVGaWxsQ29udGVudCgpO1x0XHQvLyBob29rIGZvciBfV2lkZ2V0c0luVGVtcGxhdGVNaXhpblxuXHRcdH0sXG5cblx0XHRfYmVmb3JlRmlsbENvbnRlbnQ6IGZ1bmN0aW9uKCl7XG5cdFx0fSxcblxuXHRcdF9hdHRhY2hUZW1wbGF0ZU5vZGVzOiBmdW5jdGlvbihyb290Tm9kZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0SXRlcmF0ZSB0aHJvdWdoIHRoZSBkb20gbm9kZXMgYW5kIGF0dGFjaCBmdW5jdGlvbnMgYW5kIG5vZGVzIGFjY29yZGluZ2x5LlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRNYXAgd2lkZ2V0IHByb3BlcnRpZXMgYW5kIGZ1bmN0aW9ucyB0byB0aGUgaGFuZGxlcnMgc3BlY2lmaWVkIGluXG5cdFx0XHQvL1x0XHR0aGUgZG9tIG5vZGUgYW5kIGl0J3MgZGVzY2VuZGFudHMuIFRoaXMgZnVuY3Rpb24gaXRlcmF0ZXMgb3ZlciBhbGxcblx0XHRcdC8vXHRcdG5vZGVzIGFuZCBsb29rcyBmb3IgdGhlc2UgcHJvcGVydGllczpcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHQtIGRvam9BdHRhY2hQb2ludC9kYXRhLWRvam8tYXR0YWNoLXBvaW50XG5cdFx0XHQvL1x0XHQtIGRvam9BdHRhY2hFdmVudC9kYXRhLWRvam8tYXR0YWNoLWV2ZW50XG5cdFx0XHQvLyByb290Tm9kZTogRG9tTm9kZVxuXHRcdFx0Ly9cdFx0VGhlIG5vZGUgdG8gc2VhcmNoIGZvciBwcm9wZXJ0aWVzLiBBbGwgZGVzY2VuZGFudHMgd2lsbCBiZSBzZWFyY2hlZC5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcml2YXRlXG5cblx0XHRcdC8vIERGUyB0byBwcm9jZXNzIGFsbCBub2RlcyBleGNlcHQgdGhvc2UgaW5zaWRlIG9mIHRoaXMuY29udGFpbmVyTm9kZVxuXHRcdFx0dmFyIG5vZGUgPSByb290Tm9kZTtcblx0XHRcdHdoaWxlKHRydWUpe1xuXHRcdFx0XHRpZihub2RlLm5vZGVUeXBlID09IDEgJiYgKHRoaXMuX3Byb2Nlc3NUZW1wbGF0ZU5vZGUobm9kZSwgZnVuY3Rpb24obixwKXsgcmV0dXJuIG4uZ2V0QXR0cmlidXRlKHApOyB9LFxuXHRcdFx0XHRcdFx0dGhpcy5fYXR0YWNoKSB8fCB0aGlzLnNlYXJjaENvbnRhaW5lck5vZGUpICYmIG5vZGUuZmlyc3RDaGlsZCl7XG5cdFx0XHRcdFx0bm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0aWYobm9kZSA9PSByb290Tm9kZSl7IHJldHVybjsgfVxuXHRcdFx0XHRcdHdoaWxlKCFub2RlLm5leHRTaWJsaW5nKXtcblx0XHRcdFx0XHRcdG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0XHRpZihub2RlID09IHJvb3ROb2RlKXsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9wcm9jZXNzVGVtcGxhdGVOb2RlOiBmdW5jdGlvbigvKkRPTU5vZGV8V2lkZ2V0Ki8gYmFzZU5vZGUsIGdldEF0dHJGdW5jLCBhdHRhY2hGdW5jKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRQcm9jZXNzIGRhdGEtZG9qby1hdHRhY2gtcG9pbnQgYW5kIGRhdGEtZG9qby1hdHRhY2gtZXZlbnQgZm9yIGdpdmVuIG5vZGUgb3Igd2lkZ2V0LlxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0cnVlIGlmIGNhbGxlciBzaG91bGQgcHJvY2VzcyBiYXNlTm9kZSdzIGNoaWxkcmVuIHRvby5cblxuXHRcdFx0dmFyIHJldCA9IHRydWU7XG5cblx0XHRcdC8vIFByb2Nlc3MgZGF0YS1kb2pvLWF0dGFjaC1wb2ludFxuXHRcdFx0dmFyIF9hdHRhY2hTY29wZSA9IHRoaXMuYXR0YWNoU2NvcGUgfHwgdGhpcyxcblx0XHRcdFx0YXR0YWNoUG9pbnQgPSBnZXRBdHRyRnVuYyhiYXNlTm9kZSwgXCJkb2pvQXR0YWNoUG9pbnRcIikgfHwgZ2V0QXR0ckZ1bmMoYmFzZU5vZGUsIFwiZGF0YS1kb2pvLWF0dGFjaC1wb2ludFwiKTtcblx0XHRcdGlmKGF0dGFjaFBvaW50KXtcblx0XHRcdFx0dmFyIHBvaW50LCBwb2ludHMgPSBhdHRhY2hQb2ludC5zcGxpdCgvXFxzKixcXHMqLyk7XG5cdFx0XHRcdHdoaWxlKChwb2ludCA9IHBvaW50cy5zaGlmdCgpKSl7XG5cdFx0XHRcdFx0aWYobGFuZy5pc0FycmF5KF9hdHRhY2hTY29wZVtwb2ludF0pKXtcblx0XHRcdFx0XHRcdF9hdHRhY2hTY29wZVtwb2ludF0ucHVzaChiYXNlTm9kZSk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRfYXR0YWNoU2NvcGVbcG9pbnRdID0gYmFzZU5vZGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldCA9IChwb2ludCAhPSBcImNvbnRhaW5lck5vZGVcIik7XG5cdFx0XHRcdFx0dGhpcy5fYXR0YWNoUG9pbnRzLnB1c2gocG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFByb2Nlc3MgZGF0YS1kb2pvLWF0dGFjaC1ldmVudFxuXHRcdFx0dmFyIGF0dGFjaEV2ZW50ID0gZ2V0QXR0ckZ1bmMoYmFzZU5vZGUsIFwiZG9qb0F0dGFjaEV2ZW50XCIpIHx8IGdldEF0dHJGdW5jKGJhc2VOb2RlLCBcImRhdGEtZG9qby1hdHRhY2gtZXZlbnRcIik7XG5cdFx0XHRpZihhdHRhY2hFdmVudCl7XG5cdFx0XHRcdC8vIE5PVEU6IHdlIHdhbnQgdG8gc3VwcG9ydCBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSB0aGUgZm9ybVxuXHRcdFx0XHQvLyBcImRvbUV2ZW50OiBuYXRpdmVFdmVudCwgLi4uXCJcblx0XHRcdFx0dmFyIGV2ZW50LCBldmVudHMgPSBhdHRhY2hFdmVudC5zcGxpdCgvXFxzKixcXHMqLyk7XG5cdFx0XHRcdHZhciB0cmltID0gbGFuZy50cmltO1xuXHRcdFx0XHR3aGlsZSgoZXZlbnQgPSBldmVudHMuc2hpZnQoKSkpe1xuXHRcdFx0XHRcdGlmKGV2ZW50KXtcblx0XHRcdFx0XHRcdHZhciB0aGlzRnVuYyA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZihldmVudC5pbmRleE9mKFwiOlwiKSAhPSAtMSl7XG5cdFx0XHRcdFx0XHRcdC8vIG9oLCBpZiBvbmx5IEpTIGhhZCB0dXBsZSBhc3NpZ25tZW50XG5cdFx0XHRcdFx0XHRcdHZhciBmdW5jTmFtZUFyciA9IGV2ZW50LnNwbGl0KFwiOlwiKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQgPSB0cmltKGZ1bmNOYW1lQXJyWzBdKTtcblx0XHRcdFx0XHRcdFx0dGhpc0Z1bmMgPSB0cmltKGZ1bmNOYW1lQXJyWzFdKTtcblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRldmVudCA9IHRyaW0oZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoIXRoaXNGdW5jKXtcblx0XHRcdFx0XHRcdFx0dGhpc0Z1bmMgPSBldmVudDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGhpcy5fYXR0YWNoRXZlbnRzLnB1c2goYXR0YWNoRnVuYyhiYXNlTm9kZSwgZXZlbnQsIGxhbmcuaGl0Y2goX2F0dGFjaFNjb3BlLCB0aGlzRnVuYykpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9LFxuXG5cdFx0X2F0dGFjaDogZnVuY3Rpb24obm9kZSwgdHlwZSwgZnVuYyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Um91Z2hseSBjb3JyZXNwb25kaW5nIHRvIGRvam8vb24sIHRoaXMgaXMgdGhlIGRlZmF1bHQgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYVxuXHRcdFx0Ly9cdFx0ZGF0YS1kb2pvLWF0dGFjaC1ldmVudC4gIE1lYW50IHRvIGF0dGFjaCB0byBET01Ob2Rlcywgbm90IHRvIHdpZGdldHMuXG5cdFx0XHQvLyBub2RlOiBET01Ob2RlXG5cdFx0XHQvL1x0XHRUaGUgbm9kZSB0byBzZXR1cCBhIGxpc3RlbmVyIG9uLlxuXHRcdFx0Ly8gdHlwZTogU3RyaW5nXG5cdFx0XHQvL1x0XHRFdmVudCBuYW1lIGxpa2UgXCJjbGlja1wiLlxuXHRcdFx0Ly8gZ2V0QXR0ckZ1bmM6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRGdW5jdGlvbiB0byBnZXQgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBmb3IgYSBnaXZlbiBEb21Ob2RlL1dpZGdldC5cblx0XHRcdC8vIGF0dGFjaEZ1bmM6IEZ1bmN0aW9uP1xuXHRcdFx0Ly9cdFx0QXR0YWNoZXMgYW4gZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBzcGVjaWZpZWQgbm9kZS93aWRnZXQgdG8gc3BlY2lmaWVkIGZ1bmN0aW9uLlxuXG5cdFx0XHQvLyBNYXAgc3BlY2lhbCB0eXBlIG5hbWVzIGxpa2UgXCJtb3VzZWVudGVyXCIgdG8gc3ludGhldGljIGV2ZW50cy5cblx0XHRcdC8vIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIHRvIHJlcXVpcmUoKSBkaWppdC9hMTF5Y2xpY2sgaWYgdGhleSB3YW50IHRvIHVzZSBpdC5cblx0XHRcdHR5cGUgPSB0eXBlLnJlcGxhY2UoL15vbi8sIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRpZih0eXBlID09IFwiZGlqaXRjbGlja1wiKXtcblx0XHRcdFx0dHlwZSA9IGExMXljbGljayB8fCAoYTExeWNsaWNrID0gcmVxdWlyZShcIi4vYTExeWNsaWNrXCIpKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHR0eXBlID0gc3ludGhFdmVudHNbdHlwZV0gfHwgdHlwZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9uKG5vZGUsIHR5cGUsIGZ1bmMpO1xuXHRcdH0sXG5cblx0XHRfZGV0YWNoVGVtcGxhdGVOb2RlczogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RGV0YWNoIGFuZCBjbGVhbiB1cCB0aGUgYXR0YWNobWVudHMgbWFkZSBpbiBfYXR0YWNodGVtcGFsdGVOb2Rlcy5cblxuXHRcdFx0Ly8gRGVsZXRlIGFsbCBhdHRhY2ggcG9pbnRzIHRvIHByZXZlbnQgSUU2IG1lbW9yeSBsZWFrcy5cblx0XHRcdHZhciBfYXR0YWNoU2NvcGUgPSB0aGlzLmF0dGFjaFNjb3BlIHx8IHRoaXM7XG5cdFx0XHRhcnJheS5mb3JFYWNoKHRoaXMuX2F0dGFjaFBvaW50cywgZnVuY3Rpb24ocG9pbnQpe1xuXHRcdFx0XHRkZWxldGUgX2F0dGFjaFNjb3BlW3BvaW50XTtcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5fYXR0YWNoUG9pbnRzID0gW107XG5cblx0XHRcdC8vIEFuZCBzYW1lIGZvciBldmVudCBoYW5kbGVyc1xuXHRcdFx0YXJyYXkuZm9yRWFjaCh0aGlzLl9hdHRhY2hFdmVudHMsIGZ1bmN0aW9uKGhhbmRsZSl7IGhhbmRsZS5yZW1vdmUoKTsgfSk7XG5cdFx0XHR0aGlzLl9hdHRhY2hFdmVudHMgPSBbXTtcblx0XHR9LFxuXG5cdFx0ZGVzdHJveVJlbmRlcmluZzogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuX2RldGFjaFRlbXBsYXRlTm9kZXMoKTtcblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBUaGVzZSBhcmd1bWVudHMgY2FuIGJlIHNwZWNpZmllZCBmb3Igd2lkZ2V0cyB3aGljaCBhcmUgdXNlZCBpbiB0ZW1wbGF0ZXMuXG5cdC8vIFNpbmNlIGFueSB3aWRnZXQgY2FuIGJlIHNwZWNpZmllZCBhcyBzdWIgd2lkZ2V0cyBpbiB0ZW1wbGF0ZSwgbWl4IGl0XG5cdC8vIGludG8gdGhlIGJhc2Ugd2lkZ2V0IGNsYXNzLiAgKFRoaXMgaXMgYSBoYWNrLCBidXQgaXQncyBlZmZlY3RpdmUuKS5cblx0Ly8gUmVtb3ZlIGZvciAyLjAuICAgQWxzbywgaGlkZSBmcm9tIEFQSSBkb2MgcGFyc2VyLlxuXHRsYW5nLmV4dGVuZChfV2lkZ2V0QmFzZSwgLyo9PT09PSB7fSB8fCA9PT09PSovIHtcblx0XHRkb2pvQXR0YWNoRXZlbnQ6IFwiXCIsXG5cdFx0ZG9qb0F0dGFjaFBvaW50OiBcIlwiXG5cdH0pO1xuXHRcblx0cmV0dXJuIF9BdHRhY2hNaXhpbjtcbn0pO1xuIiwiZGVmaW5lKFtdLCBmdW5jdGlvbigpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvX0JpZGlNaXhpblxuXG5cdC8vIFVDQyAtIGNvbnN0YW50cyB0aGF0IHdpbGwgYmUgdXNlZCBieSBiaWRpIHN1cHBvcnQuXG5cdHZhciBiaWRpX2NvbnN0ID0ge1xuXHRcdExSTSA6ICdcXHUyMDBFJyxcblx0XHRMUkUgOiAnXFx1MjAyQScsXG5cdFx0UERGIDogJ1xcdTIwMkMnLFxuXHRcdFJMTSA6ICdcXHUyMDBmJyxcblx0XHRSTEUgOiAnXFx1MjAyQidcblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0V2hlbiBoYXMoXCJkb2pvLWJpZGlcIikgaXMgdHJ1ZSwgX1dpZGdldEJhc2Ugd2lsbCBtaXhpbiB0aGlzIGNsYXNzLiAgIEl0IGVuYWJsZXMgc3VwcG9ydCBmb3IgdGhlIHRleHRkaXJcblx0XHQvL1x0XHRwcm9wZXJ0eSB0byBjb250cm9sIHRleHQgZGlyZWN0aW9uIGluZGVwZW5kZW50bHkgZnJvbSB0aGUgR1VJIGRpcmVjdGlvbi5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRUaGVyZSdzIGEgc3BlY2lhbCBuZWVkIGZvciBkaXNwbGF5aW5nIEJJREkgdGV4dCBpbiBydGwgZGlyZWN0aW9uXG5cdFx0Ly9cdFx0aW4gbHRyIEdVSSwgc29tZXRpbWVzIG5lZWRlZCBhdXRvIHN1cHBvcnQuXG5cdFx0Ly9cdFx0SW4gY3JlYXRpb24gb2Ygd2lkZ2V0LCBpZiBpdCdzIHdhbnQgdG8gYWN0aXZhdGUgdGhpcyBjbGFzcyxcblx0XHQvL1x0XHR0aGUgd2lkZ2V0IHNob3VsZCBkZWZpbmUgdGhlIFwidGV4dERpclwiLlxuXG5cdFx0Z2V0VGV4dERpcjogZnVuY3Rpb24oLypTdHJpbmcqLyB0ZXh0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRHZXRzIHRoZSByaWdodCBkaXJlY3Rpb24gb2YgdGV4dC5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0SWYgdGV4dERpciBpcyBsdHIgb3IgcnRsIHJldHVybnMgdGhlIHZhbHVlLlxuXHRcdFx0Ly9cdFx0SWYgaXQncyBhdXRvLCBjYWxscyB0byBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgcmVzcG9uc2libGVcblx0XHRcdC8vXHRcdGZvciBjaGVja2luZyB0aGUgdmFsdWUsIGFuZCBkZWZpbmluZyB0aGUgZGlyZWN0aW9uLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZC5cblx0XHRcdHJldHVybiB0aGlzLnRleHREaXIgPT0gXCJhdXRvXCIgPyB0aGlzLl9jaGVja0NvbnRleHR1YWwodGV4dCkgOiB0aGlzLnRleHREaXI7XG5cdFx0fSxcblxuXHRcdF9jaGVja0NvbnRleHR1YWw6IGZ1bmN0aW9uKHRleHQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEZpbmRzIHRoZSBmaXJzdCBzdHJvbmcgKGRpcmVjdGlvbmFsKSBjaGFyYWN0ZXIsIHJldHVybiBsdHIgaWYgaXNMYXRpblxuXHRcdFx0Ly9cdFx0b3IgcnRsIGlmIGlzQmlkaUNoYXIuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJpdmF0ZS5cblxuXHRcdFx0Ly8gbG9vayBmb3Igc3Ryb25nIChkaXJlY3Rpb25hbCkgY2hhcmFjdGVyc1xuXHRcdFx0dmFyIGZkYyA9IC9bQS1aYS16XFx1MDVkMC1cXHUwNjVmXFx1MDY2YS1cXHUwNmVmXFx1MDZmYS1cXHUwN2ZmXFx1ZmIxZC1cXHVmZGZmXFx1ZmU3MC1cXHVmZWZjXS8uZXhlYyh0ZXh0KTtcblx0XHRcdC8vIGlmIGZvdW5kIHJldHVybiB0aGUgZGlyZWN0aW9uIHRoYXQgZGVmaW5lZCBieSB0aGUgY2hhcmFjdGVyLCBlbHNlIHJldHVybiB3aWRnZXRzIGRpciBhcyBkZWZ1bHQuXG5cdFx0XHRyZXR1cm4gZmRjID8gKCBmZGNbMF0gPD0gJ3onID8gXCJsdHJcIiA6IFwicnRsXCIgKSA6IHRoaXMuZGlyID8gdGhpcy5kaXIgOiB0aGlzLmlzTGVmdFRvUmlnaHQoKSA/IFwibHRyXCIgOiBcInJ0bFwiO1xuXHRcdH0sXG5cblx0XHRhcHBseVRleHREaXI6IGZ1bmN0aW9uKC8qRE9NTm9kZSovIGVsZW1lbnQsIC8qU3RyaW5nPyovIHRleHQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFNldCBlbGVtZW50LmRpciBhY2NvcmRpbmcgdG8gdGhpcy50ZXh0RGlyLCBhc3N1bWluZyB0aGlzLnRleHREaXIgaGFzIGEgdmFsdWUuXG5cdFx0XHQvLyBlbGVtZW50OlxuXHRcdFx0Ly9cdFx0VGhlIHRleHQgZWxlbWVudCB0byBiZSBzZXQuIFNob3VsZCBoYXZlIGRpciBwcm9wZXJ0eS5cblx0XHRcdC8vIHRleHQ6XG5cdFx0XHQvL1x0XHRJZiBzcGVjaWZpZWQsIGFuZCB0aGlzLnRleHREaXIgaXMgXCJhdXRvXCIsIGZvciBjYWxjdWxhdGluZyB0aGUgcmlnaHQgdHJhbnNmb3JtYXRpb25cblx0XHRcdC8vXHRcdE90aGVyd2lzZSB0ZXh0IHJlYWQgZnJvbSBlbGVtZW50LlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRJZiB0ZXh0RGlyIGlzIGx0ciBvciBydGwgcmV0dXJucyB0aGUgdmFsdWUuXG5cdFx0XHQvL1x0XHRJZiBpdCdzIGF1dG8sIGNhbGxzIHRvIGFub3RoZXIgZnVuY3Rpb24gdGhhdCByZXNwb25zaWJsZVxuXHRcdFx0Ly9cdFx0Zm9yIGNoZWNraW5nIHRoZSB2YWx1ZSwgYW5kIGRlZmluaW5nIHRoZSBkaXJlY3Rpb24uXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkLlxuXG5cdFx0XHRpZih0aGlzLnRleHREaXIpe1xuXHRcdFx0XHR2YXIgdGV4dERpciA9IHRoaXMudGV4dERpcjtcblx0XHRcdFx0aWYodGV4dERpciA9PSBcImF1dG9cIil7XG5cdFx0XHRcdFx0Ly8gY29udmVydCBcImF1dG9cIiB0byBlaXRoZXIgXCJsdHJcIiBvciBcInJ0bFwiXG5cdFx0XHRcdFx0aWYodHlwZW9mIHRleHQgPT09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdFx0Ly8gdGV4dCBub3Qgc3BlY2lmaWVkLCBnZXQgdGV4dCBmcm9tIGVsZW1lbnRcblx0XHRcdFx0XHRcdHZhciB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHR0ZXh0ID0gKHRhZ05hbWUgPT0gXCJpbnB1dFwiIHx8IHRhZ05hbWUgPT0gXCJ0ZXh0YXJlYVwiKSA/IGVsZW1lbnQudmFsdWUgOlxuXHRcdFx0XHRcdFx0XHRlbGVtZW50LmlubmVyVGV4dCB8fCBlbGVtZW50LnRleHRDb250ZW50IHx8IFwiXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRleHREaXIgPSB0aGlzLl9jaGVja0NvbnRleHR1YWwodGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihlbGVtZW50LmRpciAhPSB0ZXh0RGlyKXtcblx0XHRcdFx0XHQvLyBzZXQgZWxlbWVudCdzIGRpciB0byBtYXRjaCB0ZXh0RGlyLCBidXQgbm90IHdoZW4gdGV4dERpciBpcyBudWxsIGFuZCBub3Qgd2hlbiBpdCBhbHJlYWR5IG1hdGNoZXNcblx0XHRcdFx0XHRlbGVtZW50LmRpciA9IHRleHREaXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZW5mb3JjZVRleHREaXJXaXRoVWNjOiBmdW5jdGlvbihvcHRpb24sIHRleHQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFdyYXBzIGJ5IFVDQyAoVW5pY29kZSBjb250cm9sIGNoYXJhY3RlcnMpIG9wdGlvbidzIHRleHQgYWNjb3JkaW5nIHRvIHRoaXMudGV4dERpclxuXHRcdFx0Ly8gb3B0aW9uOlxuXHRcdFx0Ly9cdFx0VGhlIGVsZW1lbnQgKGA8b3B0aW9uPmApIHdlIHdyYXBwaW5nIHRoZSB0ZXh0IGZvci5cblx0XHRcdC8vIHRleHQ6XG5cdFx0XHQvL1x0XHRUaGUgdGV4dCB0byBiZSB3cmFwcGVkLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRUaGVyZSdzIGEgZGlyIHByb2JsZW0gd2l0aCBzb21lIEhUTUwgZWxlbWVudHMuIEZvciBzb21lIGVsZW1lbnRzIChlLmcuIGA8b3B0aW9uPmAsIGA8c2VsZWN0PmApXG5cdFx0XHQvL1x0XHRkZWZpbmluZyB0aGUgZGlyIGluIGRpZmZlcmVudCBkaXJlY3Rpb24gdGhlbiB0aGUgR1VJIG9yaWVudGF0aW9uLCB3b24ndCBkaXNwbGF5IGNvcnJlY3RseS5cblx0XHRcdC8vXHRcdEZGIDMuNiB3aWxsIGNoYW5nZSB0aGUgYWxpZ25tZW50IG9mIHRoZSB0ZXh0IGluIG9wdGlvbiAtIHRoaXMgZG9lc24ndCBmb2xsb3cgdGhlIGJpZGkgc3RhbmRhcmRzIChzdGF0aWMgdGV4dFxuXHRcdFx0Ly9cdFx0c2hvdWxkIGJlIGFsaWduZWQgZm9sbG93aW5nIEdVSSBkaXJlY3Rpb24pLiBJRTggYW5kIE9wZXJhMTEuMTAgY29tcGxldGVseSBpZ25vcmUgZGlyIHNldHRpbmcgZm9yIGA8b3B0aW9uPmAuXG5cdFx0XHQvL1x0XHRUaGVyZWZvcmUgdGhlIG9ubHkgc29sdXRpb24gaXMgdG8gdXNlIFVDQyAoVW5pY29kZSAgY29udHJvbCBjaGFyYWN0ZXJzKSB0byBkaXNwbGF5IHRoZSB0ZXh0IGluIGNvcnJlY3Qgb3JpZW50YXRpb24uXG5cdFx0XHQvL1x0XHRUaGlzIGZ1bmN0aW9uIHNhdmVzIHRoZSBvcmlnaW5hbCB0ZXh0IHZhbHVlIGZvciBsYXRlciByZXN0b3JhdGlvbiBpZiBuZWVkZWQsIGZvciBleGFtcGxlIGlmIHRoZSB0ZXh0RGlyIHdpbGwgY2hhbmdlIGV0Yy5cblx0XHRcdGlmKHRoaXMudGV4dERpcil7XG5cdFx0XHRcdGlmKG9wdGlvbil7XG5cdFx0XHRcdFx0b3B0aW9uLm9yaWdpbmFsVGV4dCA9IHRleHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGRpciA9IHRoaXMudGV4dERpciA9PSBcImF1dG9cIiA/IHRoaXMuX2NoZWNrQ29udGV4dHVhbCh0ZXh0KSA6IHRoaXMudGV4dERpcjtcblx0XHRcdFx0cmV0dXJuIChkaXIgPT0gXCJsdHJcIiA/IGJpZGlfY29uc3QuTFJFIDogYmlkaV9jb25zdC5STEUgKSArIHRleHQgKyBiaWRpX2NvbnN0LlBERjtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH0sXG5cblx0XHRyZXN0b3JlT3JpZ2luYWxUZXh0OiBmdW5jdGlvbihvcmlnT2JqKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXN0b3JlcyB0aGUgdGV4dCBvZiBvcmlnT2JqLCBpZiBuZWVkZWQsIGFmdGVyIGVuZm9yY2VUZXh0RGlyV2l0aFVjYywgZS5nLiBzZXQoXCJ0ZXh0RGlyXCIsIHRleHREaXIpLlxuXHRcdFx0Ly8gb3JpZ09iajpcblx0XHRcdC8vXHRcdFRoZSBlbGVtZW50IChgPG9wdGlvbj5gKSB0byByZXN0b3JlLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRTZXRzIHRoZSB0ZXh0IG9mIG9yaWdPYmogdG8gb3JpZ09iai5vcmlnaW5hbFRleHQsIHdoaWNoIGlzIHRoZSBvcmlnaW5hbCB0ZXh0LCB3aXRob3V0IHRoZSBVQ0NzLlxuXHRcdFx0Ly9cdFx0VGhlIGZ1bmN0aW9uIHRoYW4gcmVtb3ZlcyB0aGUgb3JpZ2luYWxUZXh0IGZyb20gb3JpZ09iaiFcblx0XHRcdGlmKG9yaWdPYmoub3JpZ2luYWxUZXh0KXtcblx0XHRcdFx0b3JpZ09iai50ZXh0ID0gb3JpZ09iai5vcmlnaW5hbFRleHQ7XG5cdFx0XHRcdGRlbGV0ZSBvcmlnT2JqLm9yaWdpbmFsVGV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvcmlnT2JqO1xuXHRcdH0sXG5cblx0XHRfc2V0VGV4dERpckF0dHI6IGZ1bmN0aW9uKC8qU3RyaW5nKi8gdGV4dERpcil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0U2V0dGVyIGZvciB0ZXh0RGlyLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRVc2VycyBzaG91bGRuJ3QgY2FsbCB0aGlzIGZ1bmN0aW9uOyB0aGV5IHNob3VsZCBiZSBjYWxsaW5nXG5cdFx0XHQvL1x0XHRzZXQoJ3RleHREaXInLCB2YWx1ZSlcblx0XHRcdGlmKCF0aGlzLl9jcmVhdGVkIHx8IHRoaXMudGV4dERpciAhPSB0ZXh0RGlyKXtcblx0XHRcdFx0dGhpcy5fc2V0KFwidGV4dERpclwiLCB0ZXh0RGlyKTtcblx0XHRcdFx0dmFyIG5vZGUgPSBudWxsO1xuXHRcdFx0XHRpZih0aGlzLmRpc3BsYXlOb2RlKXtcblx0XHRcdFx0XHRub2RlID0gdGhpcy5kaXNwbGF5Tm9kZTtcblx0XHRcdFx0XHR0aGlzLmRpc3BsYXlOb2RlLmFsaWduID0gdGhpcy5kaXIgPT0gXCJydGxcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRub2RlID0gdGhpcy50ZXh0RGlyTm9kZSB8fCB0aGlzLmZvY3VzTm9kZSB8fCB0aGlzLnRleHRib3g7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYobm9kZSl7XG5cdFx0XHRcdFx0dGhpcy5hcHBseVRleHREaXIobm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59KTtcbiIsImRlZmluZShbXG5cdFwiZG9qby9fYmFzZS9hcnJheVwiLCAvLyBhcnJheS5mb3JFYWNoIGFycmF5Lm1hcFxuXHRcImRvam8vX2Jhc2UvZGVjbGFyZVwiLCAvLyBkZWNsYXJlXG5cdFwiZG9qby9kb21cIiwgLy8gZG9tLmlzRGVzY2VuZGFudCgpXG5cdFwiZG9qby9kb20tY2xhc3NcIiwgLy8gZG9tQ2xhc3MudG9nZ2xlXG5cdFwiZG9qby9oYXNcIixcblx0XCJkb2pvL19iYXNlL2xhbmdcIiwgLy8gbGFuZy5oaXRjaFxuXHRcImRvam8vb25cIixcblx0XCJkb2pvL2RvbVJlYWR5XCIsXG5cdFwiZG9qby90b3VjaFwiLFxuXHRcImRvam8vX2Jhc2Uvd2luZG93XCIsIC8vIHdpbi5ib2R5XG5cdFwiLi9hMTF5Y2xpY2tcIixcblx0XCIuL3JlZ2lzdHJ5XCJcbl0sIGZ1bmN0aW9uKGFycmF5LCBkZWNsYXJlLCBkb20sIGRvbUNsYXNzLCBoYXMsIGxhbmcsIG9uLCBkb21SZWFkeSwgdG91Y2gsIHdpbiwgYTExeWNsaWNrLCByZWdpc3RyeSl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9fQ3NzU3RhdGVNaXhpblxuXG5cdHZhciBDc3NTdGF0ZU1peGluID0gZGVjbGFyZShcImRpaml0Ll9Dc3NTdGF0ZU1peGluXCIsIFtdLCB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRNaXhpbiBmb3Igd2lkZ2V0cyB0byBzZXQgQ1NTIGNsYXNzZXMgb24gdGhlIHdpZGdldCBET00gbm9kZXMgZGVwZW5kaW5nIG9uIGhvdmVyL21vdXNlIHByZXNzL2ZvY3VzXG5cdFx0Ly9cdFx0c3RhdGUgY2hhbmdlcywgYW5kIGFsc28gaGlnaGVyLWxldmVsIHN0YXRlIGNoYW5nZXMgc3VjaCBiZWNvbWluZyBkaXNhYmxlZCBvciBzZWxlY3RlZC5cblx0XHQvL1xuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEJ5IG1peGluZyB0aGlzIGNsYXNzIGludG8geW91ciB3aWRnZXQsIGFuZCBzZXR0aW5nIHRoZSB0aGlzLmJhc2VDbGFzcyBhdHRyaWJ1dGUsIGl0IHdpbGwgYXV0b21hdGljYWxseVxuXHRcdC8vXHRcdG1haW50YWluIENTUyBjbGFzc2VzIG9uIHRoZSB3aWRnZXQgcm9vdCBub2RlICh0aGlzLmRvbU5vZGUpIGRlcGVuZGluZyBvbiBob3Zlcixcblx0XHQvL1x0XHRhY3RpdmUsIGZvY3VzLCBldGMuIHN0YXRlLiAgIEV4OiB3aXRoIGEgYmFzZUNsYXNzIG9mIGRpaml0QnV0dG9uLCBpdCB3aWxsIGFwcGx5IHRoZSBjbGFzc2VzXG5cdFx0Ly9cdFx0ZGlqaXRCdXR0b25Ib3ZlcmVkIGFuZCBkaWppdEJ1dHRvbkFjdGl2ZSwgYXMgdGhlIHVzZXIgbW92ZXMgdGhlIG1vdXNlIG92ZXIgdGhlIHdpZGdldCBhbmQgY2xpY2tzIGl0LlxuXHRcdC8vXG5cdFx0Ly9cdFx0SXQgYWxzbyBzZXRzIENTUyBsaWtlIGRpaml0QnV0dG9uRGlzYWJsZWQgYmFzZWQgb24gd2lkZ2V0IHNlbWFudGljIHN0YXRlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0Qnkgc2V0dGluZyB0aGUgY3NzU3RhdGVOb2RlcyBhdHRyaWJ1dGUsIGEgd2lkZ2V0IGNhbiBhbHNvIHRyYWNrIGV2ZW50cyBvbiBzdWJub2RlcyAobGlrZSBidXR0b25zXG5cdFx0Ly9cdFx0d2l0aGluIHRoZSB3aWRnZXQpLlxuXG5cdFx0Lyo9PT09PVxuXHRcdCAvLyBjc3NTdGF0ZU5vZGVzOiBbcHJvdGVjdGVkXSBPYmplY3Rcblx0XHQgLy9cdFx0U3ViY2xhc3NlcyBtYXkgZGVmaW5lIGEgY3NzU3RhdGVOb2RlcyBwcm9wZXJ0eSB0aGF0IGxpc3RzIHN1Yi1ub2RlcyB3aXRoaW4gdGhlIHdpZGdldCB0aGF0XG5cdFx0IC8vXHRcdG5lZWQgQ1NTIGNsYXNzZXMgYXBwbGllZCBvbiBtb3VzZSBob3Zlci9wcmVzcyBhbmQgZm9jdXMuXG5cdFx0IC8vXG5cdFx0IC8vXHRcdEVhY2ggZW50cnkgaW4gdGhpcyBvcHRpb25hbCBoYXNoIGlzIGEgYW4gYXR0YWNoLXBvaW50IG5hbWUgKGxpa2UgXCJ1cEFycm93QnV0dG9uXCIpIG1hcHBlZCB0byBhIENTUyBjbGFzcyBuYW1lXG5cdFx0IC8vXHRcdChsaWtlIFwiZGlqaXRVcEFycm93QnV0dG9uXCIpLiBFeGFtcGxlOlxuXHRcdCAvL1x0fFx0XHR7XG5cdFx0IC8vXHR8XHRcdFx0XCJ1cEFycm93QnV0dG9uXCI6IFwiZGlqaXRVcEFycm93QnV0dG9uXCIsXG5cdFx0IC8vXHR8XHRcdFx0XCJkb3duQXJyb3dCdXR0b25cIjogXCJkaWppdERvd25BcnJvd0J1dHRvblwiXG5cdFx0IC8vXHR8XHRcdH1cblx0XHQgLy9cdFx0VGhlIGFib3ZlIHdpbGwgc2V0IHRoZSBDU1MgY2xhc3MgZGlqaXRVcEFycm93QnV0dG9uIHRvIHRoZSB0aGlzLnVwQXJyb3dCdXR0b24gRE9NTm9kZSB3aGVuIGl0XG5cdFx0IC8vXHRcdGlzIGhvdmVyZWQsIGV0Yy5cblx0XHQgY3NzU3RhdGVOb2Rlczoge30sXG5cdFx0ID09PT09Ki9cblxuXHRcdC8vIGhvdmVyaW5nOiBbcmVhZG9ubHldIEJvb2xlYW5cblx0XHQvL1x0XHRUcnVlIGlmIGN1cnNvciBpcyBvdmVyIHRoaXMgd2lkZ2V0XG5cdFx0aG92ZXJpbmc6IGZhbHNlLFxuXG5cdFx0Ly8gYWN0aXZlOiBbcmVhZG9ubHldIEJvb2xlYW5cblx0XHQvL1x0XHRUcnVlIGlmIG1vdXNlIHdhcyBwcmVzc2VkIHdoaWxlIG92ZXIgdGhpcyB3aWRnZXQsIGFuZCBoYXNuJ3QgYmVlbiByZWxlYXNlZCB5ZXRcblx0XHRhY3RpdmU6IGZhbHNlLFxuXG5cdFx0X2FwcGx5QXR0cmlidXRlczogZnVuY3Rpb24oKXtcblx0XHRcdC8vIFRoaXMgY29kZSB3b3VsZCB0eXBpY2FsbHkgYmUgaW4gcG9zdENyZWF0ZSgpLCBidXQgcHV0dGluZyBpbiBfYXBwbHlBdHRyaWJ1dGVzKCkgZm9yXG5cdFx0XHQvLyBwZXJmb3JtYW5jZTogc28gdGhlIGNsYXNzIGNoYW5nZXMgaGFwcGVuIGJlZm9yZSBET00gaXMgaW5zZXJ0ZWQgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0XHQvLyBDaGFuZ2UgYmFjayB0byBwb3N0Q3JlYXRlKCkgaW4gMi4wLiAgU2VlICMxMTYzNS5cblxuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblxuXHRcdFx0Ly8gTW9uaXRvcmluZyBjaGFuZ2VzIHRvIGRpc2FibGVkLCByZWFkb25seSwgZXRjLiBzdGF0ZSwgYW5kIHVwZGF0ZSBDU1MgY2xhc3Mgb2Ygcm9vdCBub2RlXG5cdFx0XHRhcnJheS5mb3JFYWNoKFtcImRpc2FibGVkXCIsIFwicmVhZE9ubHlcIiwgXCJjaGVja2VkXCIsIFwic2VsZWN0ZWRcIiwgXCJmb2N1c2VkXCIsIFwic3RhdGVcIiwgXCJob3ZlcmluZ1wiLCBcImFjdGl2ZVwiLCBcIl9vcGVuZWRcIl0sIGZ1bmN0aW9uKGF0dHIpe1xuXHRcdFx0XHR0aGlzLndhdGNoKGF0dHIsIGxhbmcuaGl0Y2godGhpcywgXCJfc2V0U3RhdGVDbGFzc1wiKSk7XG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0Ly8gVHJhY2sgaG92ZXIgYW5kIGFjdGl2ZSBtb3VzZSBldmVudHMgb24gd2lkZ2V0IHJvb3Qgbm9kZSwgcGx1cyBwb3NzaWJseSBvbiBzdWJub2Rlc1xuXHRcdFx0Zm9yKHZhciBhcCBpbiB0aGlzLmNzc1N0YXRlTm9kZXMgfHwge30pe1xuXHRcdFx0XHR0aGlzLl90cmFja01vdXNlU3RhdGUodGhpc1thcF0sIHRoaXMuY3NzU3RhdGVOb2Rlc1thcF0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdHJhY2tNb3VzZVN0YXRlKHRoaXMuZG9tTm9kZSwgdGhpcy5iYXNlQ2xhc3MpO1xuXG5cdFx0XHQvLyBTZXQgc3RhdGUgaW5pdGlhbGx5OyB0aGVyZSdzIHByb2JhYmx5IG5vIGhvdmVyL2FjdGl2ZS9mb2N1cyBzdGF0ZSBidXQgd2lkZ2V0IG1pZ2h0IGJlXG5cdFx0XHQvLyBkaXNhYmxlZC9yZWFkb25seS9jaGVja2VkL3NlbGVjdGVkIHNvIHdlIHdhbnQgdG8gc2V0IENTUyBjbGFzc2VzIGZvciB0aG9zZSBjb25kaXRpb25zLlxuXHRcdFx0dGhpcy5fc2V0U3RhdGVDbGFzcygpO1xuXHRcdH0sXG5cblx0XHRfY3NzTW91c2VFdmVudDogZnVuY3Rpb24oLypFdmVudCovIGV2ZW50KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRIYW5kbGVyIGZvciBDU1MgZXZlbnQgb24gdGhpcy5kb21Ob2RlLiBTZXRzIGhvdmVyaW5nIGFuZCBhY3RpdmUgcHJvcGVydGllcyBkZXBlbmRpbmcgb24gbW91c2Ugc3RhdGUsXG5cdFx0XHQvL1x0XHR3aGljaCB0cmlnZ2VycyBfc2V0U3RhdGVDbGFzcygpIHRvIHNldCBhcHByb3ByaWF0ZSBDU1MgY2xhc3NlcyBmb3IgdGhpcy5kb21Ob2RlLlxuXG5cdFx0XHRpZighdGhpcy5kaXNhYmxlZCl7XG5cdFx0XHRcdHN3aXRjaChldmVudC50eXBlKXtcblx0XHRcdFx0XHRjYXNlIFwibW91c2VvdmVyXCI6XG5cdFx0XHRcdFx0Y2FzZSBcIk1TUG9pbnRlck92ZXJcIjpcblx0XHRcdFx0XHRjYXNlIFwicG9pbnRlcm92ZXJcIjpcblx0XHRcdFx0XHRcdHRoaXMuX3NldChcImhvdmVyaW5nXCIsIHRydWUpO1xuXHRcdFx0XHRcdFx0dGhpcy5fc2V0KFwiYWN0aXZlXCIsIHRoaXMuX21vdXNlRG93bik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwibW91c2VvdXRcIjpcblx0XHRcdFx0XHRjYXNlIFwiTVNQb2ludGVyT3V0XCI6XG5cdFx0XHRcdFx0Y2FzZSBcInBvaW50ZXJvdXRcIjpcblx0XHRcdFx0XHRcdHRoaXMuX3NldChcImhvdmVyaW5nXCIsIGZhbHNlKTtcblx0XHRcdFx0XHRcdHRoaXMuX3NldChcImFjdGl2ZVwiLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwibW91c2Vkb3duXCI6XG5cdFx0XHRcdFx0Y2FzZSBcInRvdWNoc3RhcnRcIjpcblx0XHRcdFx0XHRjYXNlIFwiTVNQb2ludGVyRG93blwiOlxuXHRcdFx0XHRcdGNhc2UgXCJwb2ludGVyZG93blwiOlxuXHRcdFx0XHRcdGNhc2UgXCJrZXlkb3duXCI6XG5cdFx0XHRcdFx0XHR0aGlzLl9zZXQoXCJhY3RpdmVcIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwibW91c2V1cFwiOlxuXHRcdFx0XHRcdGNhc2UgXCJkb2pvdG91Y2hlbmRcIjpcblx0XHRcdFx0XHRjYXNlIFwiTVNQb2ludGVyVXBcIjpcblx0XHRcdFx0XHRjYXNlIFwicG9pbnRlcnVwXCI6XG5cdFx0XHRcdFx0Y2FzZSBcImtleXVwXCI6XG5cdFx0XHRcdFx0XHR0aGlzLl9zZXQoXCJhY3RpdmVcIiwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3NldFN0YXRlQ2xhc3M6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0VXBkYXRlIHRoZSB2aXN1YWwgc3RhdGUgb2YgdGhlIHdpZGdldCBieSBzZXR0aW5nIHRoZSBjc3MgY2xhc3NlcyBvbiB0aGlzLmRvbU5vZGVcblx0XHRcdC8vXHRcdChvciB0aGlzLnN0YXRlTm9kZSBpZiBkZWZpbmVkKSBieSBjb21iaW5pbmcgdGhpcy5iYXNlQ2xhc3Mgd2l0aFxuXHRcdFx0Ly9cdFx0dmFyaW91cyBzdWZmaXhlcyB0aGF0IHJlcHJlc2VudCB0aGUgY3VycmVudCB3aWRnZXQgc3RhdGUocykuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRJbiB0aGUgY2FzZSB3aGVyZSBhIHdpZGdldCBoYXMgbXVsdGlwbGVcblx0XHRcdC8vXHRcdHN0YXRlcywgaXQgc2V0cyB0aGUgY2xhc3MgYmFzZWQgb24gYWxsIHBvc3NpYmxlXG5cdFx0XHQvL1x0XHRjb21iaW5hdGlvbnMuICBGb3IgZXhhbXBsZSwgYW4gaW52YWxpZCBmb3JtIHdpZGdldCB0aGF0IGlzIGJlaW5nIGhvdmVyZWRcblx0XHRcdC8vXHRcdHdpbGwgYmUgXCJkaWppdElucHV0IGRpaml0SW5wdXRJbnZhbGlkIGRpaml0SW5wdXRIb3ZlciBkaWppdElucHV0SW52YWxpZEhvdmVyXCIuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VGhlIHdpZGdldCBtYXkgaGF2ZSBvbmUgb3IgbW9yZSBvZiB0aGUgZm9sbG93aW5nIHN0YXRlcywgZGV0ZXJtaW5lZFxuXHRcdFx0Ly9cdFx0YnkgdGhpcy5zdGF0ZSwgdGhpcy5jaGVja2VkLCB0aGlzLnZhbGlkLCBhbmQgdGhpcy5zZWxlY3RlZDpcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHQtIEVycm9yIC0gVmFsaWRhdGlvblRleHRCb3ggc2V0cyB0aGlzLnN0YXRlIHRvIFwiRXJyb3JcIiBpZiB0aGUgY3VycmVudCBpbnB1dCB2YWx1ZSBpcyBpbnZhbGlkXG5cdFx0XHQvL1x0XHQtIEluY29tcGxldGUgLSBWYWxpZGF0aW9uVGV4dEJveCBzZXRzIHRoaXMuc3RhdGUgdG8gXCJJbmNvbXBsZXRlXCIgaWYgdGhlIGN1cnJlbnQgaW5wdXQgdmFsdWUgaXMgbm90IGZpbmlzaGVkIHlldFxuXHRcdFx0Ly9cdFx0LSBDaGVja2VkIC0gZXg6IGEgY2hlY2ttYXJrIG9yIGEgVG9nZ2xlQnV0dG9uIGluIGEgY2hlY2tlZCBzdGF0ZSwgd2lsbCBoYXZlIHRoaXMuY2hlY2tlZD09dHJ1ZVxuXHRcdFx0Ly9cdFx0LSBTZWxlY3RlZCAtIGV4OiBjdXJyZW50bHkgc2VsZWN0ZWQgdGFiIHdpbGwgaGF2ZSB0aGlzLnNlbGVjdGVkPT10cnVlXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0SW4gYWRkaXRpb24sIGl0IG1heSBoYXZlIG9uZSBvciBtb3JlIG9mIHRoZSBmb2xsb3dpbmcgc3RhdGVzLFxuXHRcdFx0Ly9cdFx0YmFzZWQgb24gdGhpcy5kaXNhYmxlZCBhbmQgZmxhZ3Mgc2V0IGluIF9vbk1vdXNlICh0aGlzLmFjdGl2ZSwgdGhpcy5ob3ZlcmluZykgYW5kIGZyb20gZm9jdXMgbWFuYWdlciAodGhpcy5mb2N1c2VkKTpcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHQtIERpc2FibGVkXHQtIGlmIHRoZSB3aWRnZXQgaXMgZGlzYWJsZWRcblx0XHRcdC8vXHRcdC0gQWN0aXZlXHRcdC0gaWYgdGhlIG1vdXNlIChvciBzcGFjZS9lbnRlciBrZXk/KSBpcyBiZWluZyBwcmVzc2VkIGRvd25cblx0XHRcdC8vXHRcdC0gRm9jdXNlZFx0XHQtIGlmIHRoZSB3aWRnZXQgaGFzIGZvY3VzXG5cdFx0XHQvL1x0XHQtIEhvdmVyXHRcdC0gaWYgdGhlIG1vdXNlIGlzIG92ZXIgdGhlIHdpZGdldFxuXG5cdFx0XHQvLyBDb21wdXRlIG5ldyBzZXQgb2YgY2xhc3Nlc1xuXHRcdFx0dmFyIG5ld1N0YXRlQ2xhc3NlcyA9IHRoaXMuYmFzZUNsYXNzLnNwbGl0KFwiIFwiKTtcblxuXHRcdFx0ZnVuY3Rpb24gbXVsdGlwbHkobW9kaWZpZXIpe1xuXHRcdFx0XHRuZXdTdGF0ZUNsYXNzZXMgPSBuZXdTdGF0ZUNsYXNzZXMuY29uY2F0KGFycmF5Lm1hcChuZXdTdGF0ZUNsYXNzZXMsIGZ1bmN0aW9uKGMpe1xuXHRcdFx0XHRcdHJldHVybiBjICsgbW9kaWZpZXI7XG5cdFx0XHRcdH0pLCBcImRpaml0XCIgKyBtb2RpZmllcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCF0aGlzLmlzTGVmdFRvUmlnaHQoKSl7XG5cdFx0XHRcdC8vIEZvciBSVEwgbW9kZSB3ZSBuZWVkIHRvIHNldCBhbiBhZGRpdGlvbiBjbGFzcyBsaWtlIGRpaml0VGV4dEJveFJ0bC5cblx0XHRcdFx0bXVsdGlwbHkoXCJSdGxcIik7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjaGVja2VkU3RhdGUgPSB0aGlzLmNoZWNrZWQgPT0gXCJtaXhlZFwiID8gXCJNaXhlZFwiIDogKHRoaXMuY2hlY2tlZCA/IFwiQ2hlY2tlZFwiIDogXCJcIik7XG5cdFx0XHRpZih0aGlzLmNoZWNrZWQpe1xuXHRcdFx0XHRtdWx0aXBseShjaGVja2VkU3RhdGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5zdGF0ZSl7XG5cdFx0XHRcdG11bHRpcGx5KHRoaXMuc3RhdGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5zZWxlY3RlZCl7XG5cdFx0XHRcdG11bHRpcGx5KFwiU2VsZWN0ZWRcIik7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLl9vcGVuZWQpe1xuXHRcdFx0XHRtdWx0aXBseShcIk9wZW5lZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYodGhpcy5kaXNhYmxlZCl7XG5cdFx0XHRcdG11bHRpcGx5KFwiRGlzYWJsZWRcIik7XG5cdFx0XHR9ZWxzZSBpZih0aGlzLnJlYWRPbmx5KXtcblx0XHRcdFx0bXVsdGlwbHkoXCJSZWFkT25seVwiKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRpZih0aGlzLmFjdGl2ZSl7XG5cdFx0XHRcdFx0bXVsdGlwbHkoXCJBY3RpdmVcIik7XG5cdFx0XHRcdH1lbHNlIGlmKHRoaXMuaG92ZXJpbmcpe1xuXHRcdFx0XHRcdG11bHRpcGx5KFwiSG92ZXJcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYodGhpcy5mb2N1c2VkKXtcblx0XHRcdFx0bXVsdGlwbHkoXCJGb2N1c2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgb2xkIHN0YXRlIGNsYXNzZXMgYW5kIGFkZCBuZXcgb25lcy5cblx0XHRcdC8vIEZvciBwZXJmb3JtYW5jZSBjb25jZXJucyB3ZSBvbmx5IHdyaXRlIGludG8gZG9tTm9kZS5jbGFzc05hbWUgb25jZS5cblx0XHRcdHZhciB0biA9IHRoaXMuc3RhdGVOb2RlIHx8IHRoaXMuZG9tTm9kZSxcblx0XHRcdFx0Y2xhc3NIYXNoID0ge307XHQvLyBzZXQgb2YgYWxsIGNsYXNzZXMgKHN0YXRlIGFuZCBvdGhlcndpc2UpIGZvciBub2RlXG5cblx0XHRcdGFycmF5LmZvckVhY2godG4uY2xhc3NOYW1lLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oYyl7XG5cdFx0XHRcdGNsYXNzSGFzaFtjXSA9IHRydWU7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYoXCJfc3RhdGVDbGFzc2VzXCIgaW4gdGhpcyl7XG5cdFx0XHRcdGFycmF5LmZvckVhY2godGhpcy5fc3RhdGVDbGFzc2VzLCBmdW5jdGlvbihjKXtcblx0XHRcdFx0XHRkZWxldGUgY2xhc3NIYXNoW2NdO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0YXJyYXkuZm9yRWFjaChuZXdTdGF0ZUNsYXNzZXMsIGZ1bmN0aW9uKGMpe1xuXHRcdFx0XHRjbGFzc0hhc2hbY10gPSB0cnVlO1xuXHRcdFx0fSk7XG5cblx0XHRcdHZhciBuZXdDbGFzc2VzID0gW107XG5cdFx0XHRmb3IodmFyIGMgaW4gY2xhc3NIYXNoKXtcblx0XHRcdFx0bmV3Q2xhc3Nlcy5wdXNoKGMpO1xuXHRcdFx0fVxuXHRcdFx0dG4uY2xhc3NOYW1lID0gbmV3Q2xhc3Nlcy5qb2luKFwiIFwiKTtcblxuXHRcdFx0dGhpcy5fc3RhdGVDbGFzc2VzID0gbmV3U3RhdGVDbGFzc2VzO1xuXHRcdH0sXG5cblx0XHRfc3Vibm9kZUNzc01vdXNlRXZlbnQ6IGZ1bmN0aW9uKG5vZGUsIGNsYXp6LCBldnQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEhhbmRsZXIgZm9yIGhvdmVyL2FjdGl2ZSBtb3VzZSBldmVudCBvbiB3aWRnZXQncyBzdWJub2RlXG5cdFx0XHRpZih0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZE9ubHkpe1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGhvdmVyKGlzSG92ZXJpbmcpe1xuXHRcdFx0XHRkb21DbGFzcy50b2dnbGUobm9kZSwgY2xhenogKyBcIkhvdmVyXCIsIGlzSG92ZXJpbmcpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBhY3RpdmUoaXNBY3RpdmUpe1xuXHRcdFx0XHRkb21DbGFzcy50b2dnbGUobm9kZSwgY2xhenogKyBcIkFjdGl2ZVwiLCBpc0FjdGl2ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGZvY3VzZWQoaXNGb2N1c2VkKXtcblx0XHRcdFx0ZG9tQ2xhc3MudG9nZ2xlKG5vZGUsIGNsYXp6ICsgXCJGb2N1c2VkXCIsIGlzRm9jdXNlZCk7XG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaChldnQudHlwZSl7XG5cdFx0XHRcdGNhc2UgXCJtb3VzZW92ZXJcIjpcblx0XHRcdFx0Y2FzZSBcIk1TUG9pbnRlck92ZXJcIjpcblx0XHRcdFx0Y2FzZSBcInBvaW50ZXJvdmVyXCI6XG5cdFx0XHRcdFx0aG92ZXIodHJ1ZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJtb3VzZW91dFwiOlxuXHRcdFx0XHRjYXNlIFwiTVNQb2ludGVyT3V0XCI6XG5cdFx0XHRcdGNhc2UgXCJwb2ludGVyb3V0XCI6XG5cdFx0XHRcdFx0aG92ZXIoZmFsc2UpO1xuXHRcdFx0XHRcdGFjdGl2ZShmYWxzZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJtb3VzZWRvd25cIjpcblx0XHRcdFx0Y2FzZSBcInRvdWNoc3RhcnRcIjpcblx0XHRcdFx0Y2FzZSBcIk1TUG9pbnRlckRvd25cIjpcblx0XHRcdFx0Y2FzZSBcInBvaW50ZXJkb3duXCI6XG5cdFx0XHRcdGNhc2UgXCJrZXlkb3duXCI6XG5cdFx0XHRcdFx0YWN0aXZlKHRydWUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwibW91c2V1cFwiOlxuXHRcdFx0XHRjYXNlIFwiTVNQb2ludGVyVXBcIjpcblx0XHRcdFx0Y2FzZSBcInBvaW50ZXJ1cFwiOlxuXHRcdFx0XHRjYXNlIFwiZG9qb3RvdWNoZW5kXCI6XG5cdFx0XHRcdGNhc2UgXCJrZXl1cFwiOlxuXHRcdFx0XHRcdGFjdGl2ZShmYWxzZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJmb2N1c1wiOlxuXHRcdFx0XHRjYXNlIFwiZm9jdXNpblwiOlxuXHRcdFx0XHRcdGZvY3VzZWQodHJ1ZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJibHVyXCI6XG5cdFx0XHRcdGNhc2UgXCJmb2N1c291dFwiOlxuXHRcdFx0XHRcdGZvY3VzZWQoZmFsc2UpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfdHJhY2tNb3VzZVN0YXRlOiBmdW5jdGlvbigvKkRvbU5vZGUqLyBub2RlLCAvKlN0cmluZyovIGNsYXp6KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRUcmFjayBtb3VzZS9mb2N1cyBldmVudHMgb24gc3BlY2lmaWVkIG5vZGUgYW5kIHNldCBDU1MgY2xhc3Mgb24gdGhhdCBub2RlIHRvIGluZGljYXRlXG5cdFx0XHQvL1x0XHRjdXJyZW50IHN0YXRlLiAgIFVzdWFsbHkgbm90IGNhbGxlZCBkaXJlY3RseSwgYnV0IHZpYSBjc3NTdGF0ZU5vZGVzIGF0dHJpYnV0ZS5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0R2l2ZW4gY2xhc3M9Zm9vLCB3aWxsIHNldCB0aGUgZm9sbG93aW5nIENTUyBjbGFzcyBvbiB0aGUgbm9kZVxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdC0gZm9vQWN0aXZlOiBpZiB0aGUgdXNlciBpcyBjdXJyZW50bHkgcHJlc3NpbmcgZG93biB0aGUgbW91c2UgYnV0dG9uIHdoaWxlIG92ZXIgdGhlIG5vZGVcblx0XHRcdC8vXHRcdC0gZm9vSG92ZXI6IGlmIHRoZSB1c2VyIGlzIGhvdmVyaW5nIHRoZSBtb3VzZSBvdmVyIHRoZSBub2RlLCBidXQgbm90IHByZXNzaW5nIGRvd24gYSBidXR0b25cblx0XHRcdC8vXHRcdC0gZm9vRm9jdXM6IGlmIHRoZSBub2RlIGlzIGZvY3VzZWRcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHROb3RlIHRoYXQgaXQgd29uJ3Qgc2V0IGFueSBjbGFzc2VzIGlmIHRoZSB3aWRnZXQgaXMgZGlzYWJsZWQuXG5cdFx0XHQvLyBub2RlOiBEb21Ob2RlXG5cdFx0XHQvL1x0XHRTaG91bGQgYmUgYSBzdWItbm9kZSBvZiB0aGUgd2lkZ2V0LCBub3QgdGhlIHRvcCBub2RlICh0aGlzLmRvbU5vZGUpLCBzaW5jZSB0aGUgdG9wIG5vZGVcblx0XHRcdC8vXHRcdGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFuZCBhdXRvbWF0aWNhbGx5IGp1c3QgYnkgbWl4aW5nIGluIHRoaXMgY2xhc3MuXG5cdFx0XHQvLyBjbGF6ejogU3RyaW5nXG5cdFx0XHQvL1x0XHRDU1MgY2xhc3MgbmFtZSAoZXg6IGRpaml0U2xpZGVyVXBBcnJvdylcblxuXHRcdFx0Ly8gRmxhZyBmb3IgbGlzdGVuZXIgY29kZSBiZWxvdyB0byBjYWxsIHRoaXMuX2Nzc01vdXNlRXZlbnQoKSBvciB0aGlzLl9zdWJub2RlQ3NzTW91c2VFdmVudCgpXG5cdFx0XHQvLyB3aGVuIG5vZGUgaXMgaG92ZXJlZC9hY3RpdmVcblx0XHRcdG5vZGUuX2Nzc1N0YXRlID0gY2xheno7XG5cdFx0fVxuXHR9KTtcblxuXHRkb21SZWFkeShmdW5jdGlvbigpe1xuXHRcdC8vIERvY3VtZW50IGxldmVsIGxpc3RlbmVyIHRvIGNhdGNoIGhvdmVyIGV0Yy4gZXZlbnRzIG9uIHdpZGdldCByb290IG5vZGVzIGFuZCBzdWJub2Rlcy5cblx0XHQvLyBOb3RlIHRoYXQgd2hlbiB0aGUgbW91c2UgaXMgbW92ZWQgcXVpY2tseSwgYSBzaW5nbGUgb25tb3VzZWVudGVyIGV2ZW50IGNvdWxkIHNpZ25hbCB0aGF0IG11bHRpcGxlIHdpZGdldHNcblx0XHQvLyBoYXZlIGJlZW4gaG92ZXJlZCBvciB1bmhvdmVyZWQgKHRyeSB0ZXN0X0FjY29yZGlvbi5odG1sKVxuXG5cdFx0ZnVuY3Rpb24gcG9pbnRlckhhbmRsZXIoZXZ0LCB0YXJnZXQsIHJlbGF0ZWRUYXJnZXQpe1xuXHRcdFx0Ly8gSGFuZGxlciBmb3IgbW91c2VvdmVyLCBtb3VzZW91dCwgYTExeWNsaWNrLnByZXNzIGFuZCBhMTFjbGljay5yZWxlYXNlIGV2ZW50c1xuXG5cdFx0XHQvLyBQb29yIG1hbidzIGV2ZW50IHByb3BhZ2F0aW9uLiAgRG9uJ3QgcHJvcGFnYXRlIGV2ZW50IHRvIGFuY2VzdG9ycyBvZiBldnQucmVsYXRlZFRhcmdldCxcblx0XHRcdC8vIHRvIGF2b2lkIHByb2Nlc3NpbmcgbW91c2VvdXQgZXZlbnRzIG1vdmluZyBmcm9tIGEgd2lkZ2V0J3MgZG9tTm9kZSB0byBhIGRlc2NlbmRhbnQgbm9kZTtcblx0XHRcdC8vIHN1Y2ggZXZlbnRzIHNob3VsZG4ndCBiZSBpbnRlcnByZXRlZCBhcyBhIG1vdXNlbGVhdmUgb24gdGhlIHdpZGdldC5cblx0XHRcdGlmKHJlbGF0ZWRUYXJnZXQgJiYgZG9tLmlzRGVzY2VuZGFudChyZWxhdGVkVGFyZ2V0LCB0YXJnZXQpKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IodmFyIG5vZGUgPSB0YXJnZXQ7IG5vZGUgJiYgbm9kZSAhPSByZWxhdGVkVGFyZ2V0OyBub2RlID0gbm9kZS5wYXJlbnROb2RlKXtcblx0XHRcdFx0Ly8gUHJvY2VzcyBhbnkgbm9kZXMgd2l0aCBfY3NzU3RhdGUgcHJvcGVydHkuICAgVGhleSBhcmUgZ2VuZXJhbGx5IHdpZGdldCByb290IG5vZGVzLFxuXHRcdFx0XHQvLyBidXQgY291bGQgYWxzbyBiZSBzdWItbm9kZXMgd2l0aGluIGEgd2lkZ2V0XG5cdFx0XHRcdGlmKG5vZGUuX2Nzc1N0YXRlKXtcblx0XHRcdFx0XHR2YXIgd2lkZ2V0ID0gcmVnaXN0cnkuZ2V0RW5jbG9zaW5nV2lkZ2V0KG5vZGUpO1xuXHRcdFx0XHRcdGlmKHdpZGdldCl7XG5cdFx0XHRcdFx0XHRpZihub2RlID09IHdpZGdldC5kb21Ob2RlKXtcblx0XHRcdFx0XHRcdFx0Ly8gZXZlbnQgb24gdGhlIHdpZGdldCdzIHJvb3Qgbm9kZVxuXHRcdFx0XHRcdFx0XHR3aWRnZXQuX2Nzc01vdXNlRXZlbnQoZXZ0KTtcblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHQvLyBldmVudCBvbiB3aWRnZXQncyBzdWItbm9kZVxuXHRcdFx0XHRcdFx0XHR3aWRnZXQuX3N1Ym5vZGVDc3NNb3VzZUV2ZW50KG5vZGUsIG5vZGUuX2Nzc1N0YXRlLCBldnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBib2R5ID0gd2luLmJvZHkoKSwgYWN0aXZlTm9kZTtcblxuXHRcdC8vIEhhbmRsZSBwb2ludGVyIHJlbGF0ZWQgZXZlbnRzIChpLmUuIG1vdXNlIG9yIHRvdWNoKVxuXHRcdG9uKGJvZHksIHRvdWNoLm92ZXIsIGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHQvLyBVc2luZyB0b3VjaC5vdmVyIHJhdGhlciB0aGFuIG1vdXNlb3ZlciBtYWlubHkgdG8gaWdub3JlIHBoYW50b20gbW91c2UgZXZlbnRzIG9uIGlPUy5cblx0XHRcdHBvaW50ZXJIYW5kbGVyKGV2dCwgZXZ0LnRhcmdldCwgZXZ0LnJlbGF0ZWRUYXJnZXQpO1xuXHRcdH0pO1xuXHRcdG9uKGJvZHksIHRvdWNoLm91dCwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdC8vIFVzaW5nIHRvdWNoLm91dCByYXRoZXIgdGhhbiBtb3VzZW91dCBtYWlubHkgdG8gaWdub3JlIHBoYW50b20gbW91c2UgZXZlbnRzIG9uIGlPUy5cblx0XHRcdHBvaW50ZXJIYW5kbGVyKGV2dCwgZXZ0LnRhcmdldCwgZXZ0LnJlbGF0ZWRUYXJnZXQpO1xuXHRcdH0pO1xuXHRcdG9uKGJvZHksIGExMXljbGljay5wcmVzcywgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdC8vIFNhdmUgdGhlIGExMXljbGljay5wcmVzcyB0YXJnZXQgdG8gcmVmZXJlbmNlIHdoZW4gdGhlIGExMXljbGljay5yZWxlYXNlIGNvbWVzLlxuXHRcdFx0YWN0aXZlTm9kZSA9IGV2dC50YXJnZXQ7XG5cdFx0XHRwb2ludGVySGFuZGxlcihldnQsIGFjdGl2ZU5vZGUpXG5cdFx0fSk7XG5cdFx0b24oYm9keSwgYTExeWNsaWNrLnJlbGVhc2UsIGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHQvLyBUaGUgcmVsZWFzZSBldmVudCBjb3VsZCBjb21lIG9uIGEgc2VwYXJhdGUgbm9kZSB0aGFuIHRoZSBwcmVzcyBldmVudCwgaWYgZm9yIGV4YW1wbGUgdXNlciBzbGlkIGZpbmdlci5cblx0XHRcdC8vIFJlZmVyZW5jZSBhY3RpdmVOb2RlIHRvIHJlc2V0IHRoZSBzdGF0ZSBvZiB0aGUgbm9kZSB0aGF0IGdvdCBzdGF0ZSBzZXQgaW4gdGhlIGExMXljbGljay5wcmVzcyBoYW5kbGVyLlxuXHRcdFx0cG9pbnRlckhhbmRsZXIoZXZ0LCBhY3RpdmVOb2RlKTtcblx0XHRcdGFjdGl2ZU5vZGUgPSBudWxsO1xuXHRcdH0pO1xuXG5cdFx0Ly8gVHJhY2sgZm9jdXMgZXZlbnRzIG9uIHdpZGdldCBzdWItbm9kZXMgdGhhdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB2aWEgX3RyYWNrTW91c2VTdGF0ZSgpLlxuXHRcdC8vIEhvd2V2ZXIsIGRvbid0IHRyYWNrIGZvY3VzIGV2ZW50cyBvbiB0aGUgd2lkZ2V0IHJvb3Qgbm9kZXMsIGJlY2F1c2UgZm9jdXMgaXMgdHJhY2tlZCB2aWEgdGhlXG5cdFx0Ly8gZm9jdXMgbWFuYWdlciAoYW5kIGl0J3Mgbm90IHJlYWxseSB0cmFja2luZyBmb2N1cywgYnV0IHJhdGhlciB0cmFja2luZyB0aGF0IGZvY3VzIGlzIG9uIG9uZSBvZiB0aGUgd2lkZ2V0J3Ncblx0XHQvLyBub2RlcyBvciBhIHN1YndpZGdldCdzIG5vZGUgb3IgYSBwb3B1cCBub2RlLCBldGMuKVxuXHRcdC8vIFJlbW92ZSBmb3IgMi4wIChpZiBmb2N1cyBDU1MgbmVlZGVkLCBqdXN0IHVzZSA6Zm9jdXMgcHNldWRvLXNlbGVjdG9yKS5cblx0XHRvbihib2R5LCBcImZvY3VzaW4sIGZvY3Vzb3V0XCIsIGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHR2YXIgbm9kZSA9IGV2dC50YXJnZXQ7XG5cdFx0XHRpZihub2RlLl9jc3NTdGF0ZSAmJiAhbm9kZS5nZXRBdHRyaWJ1dGUoXCJ3aWRnZXRJZFwiKSl7XG5cdFx0XHRcdHZhciB3aWRnZXQgPSByZWdpc3RyeS5nZXRFbmNsb3NpbmdXaWRnZXQobm9kZSk7XG5cdFx0XHRcdGlmKHdpZGdldCl7XG5cdFx0XHRcdFx0d2lkZ2V0Ll9zdWJub2RlQ3NzTW91c2VFdmVudChub2RlLCBub2RlLl9jc3NTdGF0ZSwgZXZ0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblxuXHRyZXR1cm4gQ3NzU3RhdGVNaXhpbjtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCIuL2ZvY3VzXCIsXG5cdFwiLi9fV2lkZ2V0QmFzZVwiLFxuXHRcImRvam8vX2Jhc2UvZGVjbGFyZVwiLCAvLyBkZWNsYXJlXG5cdFwiZG9qby9fYmFzZS9sYW5nXCIgLy8gbGFuZy5leHRlbmRcbl0sIGZ1bmN0aW9uKGZvY3VzLCBfV2lkZ2V0QmFzZSwgZGVjbGFyZSwgbGFuZyl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9fRm9jdXNNaXhpblxuXG5cdC8vIFdlIGRvbid0IGtub3cgd2hlcmUgX0ZvY3VzTWl4aW4gd2lsbCBvY2N1ciBpbiB0aGUgaW5oZXJpdGFuY2UgY2hhaW4sIGJ1dCB3ZSBuZWVkIHRoZSBfb25Gb2N1cygpL19vbkJsdXIoKSBiZWxvd1xuXHQvLyB0byBiZSBsYXN0IGluIHRoZSBpbmhlcml0YW5jZSBjaGFpbiwgc28gbWl4aW4gdG8gX1dpZGdldEJhc2UuXG5cdGxhbmcuZXh0ZW5kKF9XaWRnZXRCYXNlLCB7XG5cdFx0Ly8gZm9jdXNlZDogW3JlYWRvbmx5XSBCb29sZWFuXG5cdFx0Ly9cdFx0VGhpcyB3aWRnZXQgb3IgYSB3aWRnZXQgaXQgY29udGFpbnMgaGFzIGZvY3VzLCBvciBpcyBcImFjdGl2ZVwiIGJlY2F1c2Vcblx0XHQvL1x0XHRpdCB3YXMgcmVjZW50bHkgY2xpY2tlZC5cblx0XHRmb2N1c2VkOiBmYWxzZSxcblxuXHRcdG9uRm9jdXM6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2FsbGVkIHdoZW4gdGhlIHdpZGdldCBiZWNvbWVzIFwiYWN0aXZlXCIgYmVjYXVzZVxuXHRcdFx0Ly9cdFx0aXQgb3IgYSB3aWRnZXQgaW5zaWRlIG9mIGl0IGVpdGhlciBoYXMgZm9jdXMsIG9yIGhhcyByZWNlbnRseVxuXHRcdFx0Ly9cdFx0YmVlbiBjbGlja2VkLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdGNhbGxiYWNrXG5cdFx0fSxcblxuXHRcdG9uQmx1cjogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYWxsZWQgd2hlbiB0aGUgd2lkZ2V0IHN0b3BzIGJlaW5nIFwiYWN0aXZlXCIgYmVjYXVzZVxuXHRcdFx0Ly9cdFx0Zm9jdXMgbW92ZWQgdG8gc29tZXRoaW5nIG91dHNpZGUgb2YgaXQsIG9yIHRoZSB1c2VyXG5cdFx0XHQvL1x0XHRjbGlja2VkIHNvbWV3aGVyZSBvdXRzaWRlIG9mIGl0LCBvciB0aGUgd2lkZ2V0IHdhc1xuXHRcdFx0Ly9cdFx0aGlkZGVuLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdGNhbGxiYWNrXG5cdFx0fSxcblxuXHRcdF9vbkZvY3VzOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRoaXMgaXMgd2hlcmUgd2lkZ2V0cyBkbyBwcm9jZXNzaW5nIGZvciB3aGVuIHRoZXkgYXJlIGFjdGl2ZSxcblx0XHRcdC8vXHRcdHN1Y2ggYXMgY2hhbmdpbmcgQ1NTIGNsYXNzZXMuICBTZWUgb25Gb2N1cygpIGZvciBtb3JlIGRldGFpbHMuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cdFx0XHR0aGlzLm9uRm9jdXMoKTtcblx0XHR9LFxuXG5cdFx0X29uQmx1cjogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRUaGlzIGlzIHdoZXJlIHdpZGdldHMgZG8gcHJvY2Vzc2luZyBmb3Igd2hlbiB0aGV5IHN0b3AgYmVpbmcgYWN0aXZlLFxuXHRcdFx0Ly9cdFx0c3VjaCBhcyBjaGFuZ2luZyBDU1MgY2xhc3Nlcy4gIFNlZSBvbkJsdXIoKSBmb3IgbW9yZSBkZXRhaWxzLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXHRcdFx0dGhpcy5vbkJsdXIoKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBkZWNsYXJlKFwiZGlqaXQuX0ZvY3VzTWl4aW5cIiwgbnVsbCwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0TWl4aW4gdG8gd2lkZ2V0IHRvIHByb3ZpZGUgX29uRm9jdXMoKSBhbmQgX29uQmx1cigpIG1ldGhvZHMgdGhhdFxuXHRcdC8vXHRcdGZpcmUgd2hlbiBhIHdpZGdldCBvciBpdHMgZGVzY2VuZGFudHMgZ2V0L2xvc2UgZm9jdXNcblxuXHRcdC8vIGZsYWcgdGhhdCBJIHdhbnQgX29uRm9jdXMoKS9fb25CbHVyKCkgbm90aWZpY2F0aW9ucyBmcm9tIGZvY3VzIG1hbmFnZXJcblx0XHRfZm9jdXNNYW5hZ2VyOiBmb2N1c1xuXHR9KTtcblxufSk7XG4iLCJkZWZpbmUoW1xuXHRcImRvam8vb25cIixcblx0XCJkb2pvL19iYXNlL2FycmF5XCIsIC8vIGFycmF5LmZvckVhY2hcblx0XCJkb2pvL2tleXNcIiwgLy8ga2V5cy5FTlRFUiBrZXlzLlNQQUNFXG5cdFwiZG9qby9fYmFzZS9kZWNsYXJlXCIsIC8vIGRlY2xhcmVcblx0XCJkb2pvL2hhc1wiLCAvLyBoYXMoXCJkb20tYWRkZXZlbnRsaXN0ZW5lclwiKVxuXHRcIi4vYTExeWNsaWNrXCJcbl0sIGZ1bmN0aW9uKG9uLCBhcnJheSwga2V5cywgZGVjbGFyZSwgaGFzLCBhMTF5Y2xpY2spe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvX09uRGlqaXRDbGlja01peGluXG5cblx0dmFyIHJldCA9IGRlY2xhcmUoXCJkaWppdC5fT25EaWppdENsaWNrTWl4aW5cIiwgbnVsbCwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0RGVwcmVjYXRlZC4gICBOZXcgY29kZSBzaG91bGQgYWNjZXNzIHRoZSBkaWppdC9hMTF5Y2xpY2sgZXZlbnQgZGlyZWN0bHksIGV4OlxuXHRcdC8vXHRcdHxcdHRoaXMub3duKG9uKG5vZGUsIGExMXljbGljaywgZnVuY3Rpb24oKXsgLi4uIH0pKTtcblx0XHQvL1xuXHRcdC8vXHRcdE1peGluZyBpbiB0aGlzIGNsYXNzIHdpbGwgbWFrZSBfV2lkZ2V0QmFzZS5jb25uZWN0KG5vZGUsIFwib25kaWppdGNsaWNrXCIsIC4uLikgd29yay5cblx0XHQvL1x0XHRJdCBhbHNvIHVzZWQgdG8gYmUgbmVjZXNzYXJ5IHRvIG1ha2UgdGVtcGxhdGVzIHdpdGggb25kaWppdGNsaWNrIHdvcmssIGJ1dCBub3cgeW91IGNhbiBqdXN0IHJlcXVpcmVcblx0XHQvL1x0XHRkaWppdC9hMTF5Y2xpY2suXG5cblx0XHRjb25uZWN0OiBmdW5jdGlvbihvYmosIGV2ZW50LCBtZXRob2Qpe1xuXHRcdFx0Ly8gb3ZlcnJpZGUgX1dpZGdldEJhc2UuY29ubmVjdCgpIHRvIG1ha2UgdGhpcy5jb25uZWN0KG5vZGUsIFwib25kaWppdGNsaWNrXCIsIC4uLikgd29ya1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cywgW29iaiwgZXZlbnQgPT0gXCJvbmRpaml0Y2xpY2tcIiA/IGExMXljbGljayA6IGV2ZW50LCBtZXRob2RdKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldC5hMTF5Y2xpY2sgPSBhMTF5Y2xpY2s7XHQvLyBiYWNrIGNvbXBhdFxuXG5cdHJldHVybiByZXQ7XG59KTtcbiIsImRlZmluZShbXG5cdFwiZG9qby9jYWNoZVwiLFx0Ly8gZG9qby5jYWNoZVxuXHRcImRvam8vX2Jhc2UvZGVjbGFyZVwiLCAvLyBkZWNsYXJlXG5cdFwiZG9qby9kb20tY29uc3RydWN0XCIsIC8vIGRvbUNvbnN0cnVjdC5kZXN0cm95LCBkb21Db25zdHJ1Y3QudG9Eb21cblx0XCJkb2pvL19iYXNlL2xhbmdcIiwgLy8gbGFuZy5nZXRPYmplY3Rcblx0XCJkb2pvL29uXCIsXG5cdFwiZG9qby9zbmlmZlwiLCAvLyBoYXMoXCJpZVwiKVxuXHRcImRvam8vc3RyaW5nXCIsIC8vIHN0cmluZy5zdWJzdGl0dXRlIHN0cmluZy50cmltXG5cdFwiLi9fQXR0YWNoTWl4aW5cIlxuXSwgZnVuY3Rpb24oY2FjaGUsIGRlY2xhcmUsIGRvbUNvbnN0cnVjdCwgbGFuZywgb24sIGhhcywgc3RyaW5nLCBfQXR0YWNoTWl4aW4pe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvX1RlbXBsYXRlZE1peGluXG5cblx0dmFyIF9UZW1wbGF0ZWRNaXhpbiA9IGRlY2xhcmUoXCJkaWppdC5fVGVtcGxhdGVkTWl4aW5cIiwgX0F0dGFjaE1peGluLCB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRNaXhpbiBmb3Igd2lkZ2V0cyB0aGF0IGFyZSBpbnN0YW50aWF0ZWQgZnJvbSBhIHRlbXBsYXRlXG5cblx0XHQvLyB0ZW1wbGF0ZVN0cmluZzogW3Byb3RlY3RlZF0gU3RyaW5nXG5cdFx0Ly9cdFx0QSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSB3aWRnZXQgdGVtcGxhdGUuXG5cdFx0Ly9cdFx0VXNlIGluIGNvbmp1bmN0aW9uIHdpdGggZG9qby5jYWNoZSgpIHRvIGxvYWQgZnJvbSBhIGZpbGUuXG5cdFx0dGVtcGxhdGVTdHJpbmc6IG51bGwsXG5cblx0XHQvLyB0ZW1wbGF0ZVBhdGg6IFtwcm90ZWN0ZWQgZGVwcmVjYXRlZF0gU3RyaW5nXG5cdFx0Ly9cdFx0UGF0aCB0byB0ZW1wbGF0ZSAoSFRNTCBmaWxlKSBmb3IgdGhpcyB3aWRnZXQgcmVsYXRpdmUgdG8gZG9qby5iYXNlVXJsLlxuXHRcdC8vXHRcdERlcHJlY2F0ZWQ6IHVzZSB0ZW1wbGF0ZVN0cmluZyB3aXRoIHJlcXVpcmUoWy4uLiBcImRvam8vdGV4dCEuLi5cIl0sIC4uLikgaW5zdGVhZFxuXHRcdHRlbXBsYXRlUGF0aDogbnVsbCxcblxuXHRcdC8vIHNraXBOb2RlQ2FjaGU6IFtwcm90ZWN0ZWRdIEJvb2xlYW5cblx0XHQvL1x0XHRJZiB1c2luZyBhIGNhY2hlZCB3aWRnZXQgdGVtcGxhdGUgbm9kZXMgcG9zZXMgaXNzdWVzIGZvciBhXG5cdFx0Ly9cdFx0cGFydGljdWxhciB3aWRnZXQgY2xhc3MsIGl0IGNhbiBzZXQgdGhpcyBwcm9wZXJ0eSB0byBlbnN1cmVcblx0XHQvL1x0XHR0aGF0IGl0cyB0ZW1wbGF0ZSBpcyBhbHdheXMgcmUtYnVpbHQgZnJvbSBhIHN0cmluZ1xuXHRcdF9za2lwTm9kZUNhY2hlOiBmYWxzZSxcblxuLyo9PT09PVxuXHRcdC8vIF9yZW5kZXJlZDogQm9vbGVhblxuXHRcdC8vXHRcdE5vdCBub3JtYWxseSB1c2UsIGJ1dCB0aGlzIGZsYWcgY2FuIGJlIHNldCBieSB0aGUgYXBwIGlmIHRoZSBzZXJ2ZXIgaGFzIGFscmVhZHkgcmVuZGVyZWQgdGhlIHRlbXBsYXRlLFxuXHRcdC8vXHRcdGkuZS4gYWxyZWFkeSBpbmxpbmluZyB0aGUgdGVtcGxhdGUgZm9yIHRoZSB3aWRnZXQgaW50byB0aGUgbWFpbiBwYWdlLiAgIFJlZHVjZXMgX1RlbXBsYXRlZE1peGluIHRvXG5cdFx0Ly9cdFx0anVzdCBmdW5jdGlvbiBsaWtlIF9BdHRhY2hNaXhpbi5cblx0XHRfcmVuZGVyZWQ6IGZhbHNlLFxuPT09PT0qL1xuXG5cdFx0Ly8gU2V0IF9BdHRhY2hNaXhpbi5zZWFyY2hDb250YWluZXJOb2RlIHRvIHRydWUgZm9yIGJhY2stY29tcGF0IGZvciB3aWRnZXRzIHRoYXQgaGF2ZSBkYXRhLWRvam8tYXR0YWNoLXBvaW50J3Ncblx0XHQvLyBhbmQgZXZlbnRzIGluc2lkZSB0aGlzLmNvbnRhaW5lck5vZGUuICAgUmVtb3ZlIGZvciAyLjAuXG5cdFx0c2VhcmNoQ29udGFpbmVyTm9kZTogdHJ1ZSxcblxuXHRcdF9zdHJpbmdSZXBsOiBmdW5jdGlvbih0bXBsKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREb2VzIHN1YnN0aXR1dGlvbiBvZiAke2Zvb30gdHlwZSBwcm9wZXJ0aWVzIGluIHRlbXBsYXRlIHN0cmluZ1xuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByaXZhdGVcblx0XHRcdHZhciBjbGFzc05hbWUgPSB0aGlzLmRlY2xhcmVkQ2xhc3MsIF90aGlzID0gdGhpcztcblx0XHRcdC8vIENhY2hlIGNvbnRhaW5zIGEgc3RyaW5nIGJlY2F1c2Ugd2UgbmVlZCB0byBkbyBwcm9wZXJ0eSByZXBsYWNlbWVudFxuXHRcdFx0Ly8gZG8gdGhlIHByb3BlcnR5IHJlcGxhY2VtZW50XG5cdFx0XHRyZXR1cm4gc3RyaW5nLnN1YnN0aXR1dGUodG1wbCwgdGhpcywgZnVuY3Rpb24odmFsdWUsIGtleSl7XG5cdFx0XHRcdGlmKGtleS5jaGFyQXQoMCkgPT0gJyEnKXsgdmFsdWUgPSBsYW5nLmdldE9iamVjdChrZXkuc3Vic3RyKDEpLCBmYWxzZSwgX3RoaXMpOyB9XG5cdFx0XHRcdGlmKHR5cGVvZiB2YWx1ZSA9PSBcInVuZGVmaW5lZFwiKXsgdGhyb3cgbmV3IEVycm9yKGNsYXNzTmFtZStcIiB0ZW1wbGF0ZTpcIitrZXkpOyB9IC8vIGEgZGVidWdnaW5nIGFpZGVcblx0XHRcdFx0aWYodmFsdWUgPT0gbnVsbCl7IHJldHVybiBcIlwiOyB9XG5cblx0XHRcdFx0Ly8gU3Vic3RpdHV0aW9uIGtleXMgYmVnaW5uaW5nIHdpdGggISB3aWxsIHNraXAgdGhlIHRyYW5zZm9ybSBzdGVwLFxuXHRcdFx0XHQvLyBpbiBjYXNlIGEgdXNlciB3aXNoZXMgdG8gaW5zZXJ0IHVuZXNjYXBlZCBtYXJrdXAsIGUuZy4gJHshZm9vfVxuXHRcdFx0XHRyZXR1cm4ga2V5LmNoYXJBdCgwKSA9PSBcIiFcIiA/IHZhbHVlIDogdGhpcy5fZXNjYXBlVmFsdWUoXCJcIiArIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRfZXNjYXBlVmFsdWU6IGZ1bmN0aW9uKC8qU3RyaW5nKi8gdmFsKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRFc2NhcGUgYSB2YWx1ZSB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSB0ZW1wbGF0ZSwgZWl0aGVyIGludG8gYW4gYXR0cmlidXRlIHZhbHVlXG5cdFx0XHQvL1x0XHQoZXg6IGZvbz1cIiR7YmFyfVwiKSBvciBhcyBpbm5lciB0ZXh0IG9mIGFuIGVsZW1lbnQgKGV4OiA8c3Bhbj4ke2Zvb308L3NwYW4+KVxuXG5cdFx0XHQvLyBTYWZlciBzdWJzdGl0dXRpb24sIHNlZSBoZWFkaW5nIFwiQXR0cmlidXRlIHZhbHVlc1wiIGluXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMtaHRtbDQwL2FwcGVuZGl4L25vdGVzLmh0bWwjaC1CLjMuMlxuXHRcdFx0Ly8gYW5kIGFsc28gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfJTI4Q3Jvc3NfU2l0ZV9TY3JpcHRpbmclMjlfUHJldmVudGlvbl9DaGVhdF9TaGVldCNSVUxFXy4yMzFfLV9IVE1MX0VzY2FwZV9CZWZvcmVfSW5zZXJ0aW5nX1VudHJ1c3RlZF9EYXRhX2ludG9fSFRNTF9FbGVtZW50X0NvbnRlbnRcblx0XHRcdHJldHVybiB2YWwucmVwbGFjZSgvW1wiJzw+Jl0vZywgZnVuY3Rpb24odmFsKXtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcIiZcIjogXCImYW1wO1wiLFxuXHRcdFx0XHRcdFwiPFwiOiBcIiZsdDtcIixcblx0XHRcdFx0XHRcIj5cIjogXCImZ3Q7XCIsXG5cdFx0XHRcdFx0XCJcXFwiXCI6IFwiJnF1b3Q7XCIsXG5cdFx0XHRcdFx0XCInXCI6IFwiJiN4Mjc7XCJcblx0XHRcdFx0fVt2YWxdO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGJ1aWxkUmVuZGVyaW5nOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENvbnN0cnVjdCB0aGUgVUkgZm9yIHRoaXMgd2lkZ2V0IGZyb20gYSB0ZW1wbGF0ZSwgc2V0dGluZyB0aGlzLmRvbU5vZGUuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cblx0XHRcdGlmKCF0aGlzLl9yZW5kZXJlZCl7XG5cdFx0XHRcdGlmKCF0aGlzLnRlbXBsYXRlU3RyaW5nKXtcblx0XHRcdFx0XHR0aGlzLnRlbXBsYXRlU3RyaW5nID0gY2FjaGUodGhpcy50ZW1wbGF0ZVBhdGgsIHtzYW5pdGl6ZTogdHJ1ZX0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9va3VwIGNhY2hlZCB2ZXJzaW9uIG9mIHRlbXBsYXRlLCBhbmQgZG93bmxvYWQgdG8gY2FjaGUgaWYgaXRcblx0XHRcdFx0Ly8gaXNuJ3QgdGhlcmUgYWxyZWFkeS4gIFJldHVybnMgZWl0aGVyIGEgRG9tTm9kZSBvciBhIHN0cmluZywgZGVwZW5kaW5nIG9uXG5cdFx0XHRcdC8vIHdoZXRoZXIgb3Igbm90IHRoZSB0ZW1wbGF0ZSBjb250YWlucyAke2Zvb30gcmVwbGFjZW1lbnQgcGFyYW1ldGVycy5cblx0XHRcdFx0dmFyIGNhY2hlZCA9IF9UZW1wbGF0ZWRNaXhpbi5nZXRDYWNoZWRUZW1wbGF0ZSh0aGlzLnRlbXBsYXRlU3RyaW5nLCB0aGlzLl9za2lwTm9kZUNhY2hlLCB0aGlzLm93bmVyRG9jdW1lbnQpO1xuXG5cdFx0XHRcdHZhciBub2RlO1xuXHRcdFx0XHRpZihsYW5nLmlzU3RyaW5nKGNhY2hlZCkpe1xuXHRcdFx0XHRcdG5vZGUgPSBkb21Db25zdHJ1Y3QudG9Eb20odGhpcy5fc3RyaW5nUmVwbChjYWNoZWQpLCB0aGlzLm93bmVyRG9jdW1lbnQpO1xuXHRcdFx0XHRcdGlmKG5vZGUubm9kZVR5cGUgIT0gMSl7XG5cdFx0XHRcdFx0XHQvLyBGbGFnIGNvbW1vbiBwcm9ibGVtcyBzdWNoIGFzIHRlbXBsYXRlcyB3aXRoIG11bHRpcGxlIHRvcCBsZXZlbCBub2RlcyAobm9kZVR5cGUgPT0gMTEpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRlbXBsYXRlOiBcIiArIGNhY2hlZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHQvLyBpZiBpdCdzIGEgbm9kZSwgYWxsIHdlIGhhdmUgdG8gZG8gaXMgY2xvbmUgaXRcblx0XHRcdFx0XHRub2RlID0gY2FjaGVkLmNsb25lTm9kZSh0cnVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuZG9tTm9kZSA9IG5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgZG93biB0byBfV2lkZ2V0QmFzZS5idWlsZFJlbmRlcmluZygpIHRvIGdldCBiYXNlIGNsYXNzZXMgYXNzaWduZWRcblx0XHRcdC8vIFRPRE86IGNoYW5nZSB0aGUgYmFzZUNsYXNzIGFzc2lnbm1lbnQgdG8gX3NldEJhc2VDbGFzc0F0dHJcblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cblx0XHRcdGlmKCF0aGlzLl9yZW5kZXJlZCl7XG5cdFx0XHRcdHRoaXMuX2ZpbGxDb250ZW50KHRoaXMuc3JjTm9kZVJlZik7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3JlbmRlcmVkID0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0X2ZpbGxDb250ZW50OiBmdW5jdGlvbigvKkRvbU5vZGUqLyBzb3VyY2Upe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlbG9jYXRlIHNvdXJjZSBjb250ZW50cyB0byB0ZW1wbGF0ZWQgY29udGFpbmVyIG5vZGUuXG5cdFx0XHQvL1x0XHR0aGlzLmNvbnRhaW5lck5vZGUgbXVzdCBiZSBhYmxlIHRvIHJlY2VpdmUgY2hpbGRyZW4sIG9yIGV4Y2VwdGlvbnMgd2lsbCBiZSB0aHJvd24uXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cdFx0XHR2YXIgZGVzdCA9IHRoaXMuY29udGFpbmVyTm9kZTtcblx0XHRcdGlmKHNvdXJjZSAmJiBkZXN0KXtcblx0XHRcdFx0d2hpbGUoc291cmNlLmhhc0NoaWxkTm9kZXMoKSl7XG5cdFx0XHRcdFx0ZGVzdC5hcHBlbmRDaGlsZChzb3VyY2UuZmlyc3RDaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0fSk7XG5cblx0Ly8ga2V5IGlzIHRlbXBsYXRlU3RyaW5nOyBvYmplY3QgaXMgZWl0aGVyIHN0cmluZyBvciBET00gdHJlZVxuXHRfVGVtcGxhdGVkTWl4aW4uX3RlbXBsYXRlQ2FjaGUgPSB7fTtcblxuXHRfVGVtcGxhdGVkTWl4aW4uZ2V0Q2FjaGVkVGVtcGxhdGUgPSBmdW5jdGlvbih0ZW1wbGF0ZVN0cmluZywgYWx3YXlzVXNlU3RyaW5nLCBkb2Mpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0U3RhdGljIG1ldGhvZCB0byBnZXQgYSB0ZW1wbGF0ZSBiYXNlZCBvbiB0aGUgdGVtcGxhdGVQYXRoIG9yXG5cdFx0Ly9cdFx0dGVtcGxhdGVTdHJpbmcga2V5XG5cdFx0Ly8gdGVtcGxhdGVTdHJpbmc6IFN0cmluZ1xuXHRcdC8vXHRcdFRoZSB0ZW1wbGF0ZVxuXHRcdC8vIGFsd2F5c1VzZVN0cmluZzogQm9vbGVhblxuXHRcdC8vXHRcdERvbid0IGNhY2hlIHRoZSBET00gdHJlZSBmb3IgdGhpcyB0ZW1wbGF0ZSwgZXZlbiBpZiBpdCBkb2Vzbid0IGhhdmUgYW55IHZhcmlhYmxlc1xuXHRcdC8vIGRvYzogRG9jdW1lbnQ/XG5cdFx0Ly9cdFx0VGhlIHRhcmdldCBkb2N1bWVudC4gICBEZWZhdWx0cyB0byBkb2N1bWVudCBnbG9iYWwgaWYgdW5zcGVjaWZpZWQuXG5cdFx0Ly8gcmV0dXJuczogTWl4ZWRcblx0XHQvL1x0XHRFaXRoZXIgc3RyaW5nIChpZiB0aGVyZSBhcmUgJHt9IHZhcmlhYmxlcyB0aGF0IG5lZWQgdG8gYmUgcmVwbGFjZWQpIG9yIGp1c3Rcblx0XHQvL1x0XHRhIERPTSB0cmVlIChpZiB0aGUgbm9kZSBjYW4gYmUgY2xvbmVkIGRpcmVjdGx5KVxuXG5cdFx0Ly8gaXMgaXQgYWxyZWFkeSBjYWNoZWQ/XG5cdFx0dmFyIHRtcGx0cyA9IF9UZW1wbGF0ZWRNaXhpbi5fdGVtcGxhdGVDYWNoZTtcblx0XHR2YXIga2V5ID0gdGVtcGxhdGVTdHJpbmc7XG5cdFx0dmFyIGNhY2hlZCA9IHRtcGx0c1trZXldO1xuXHRcdGlmKGNhY2hlZCl7XG5cdFx0XHR0cnl7XG5cdFx0XHRcdC8vIGlmIHRoZSBjYWNoZWQgdmFsdWUgaXMgYW4gaW5uZXJIVE1MIHN0cmluZyAobm8gb3duZXJEb2N1bWVudCkgb3IgYSBET00gdHJlZSBjcmVhdGVkIHdpdGhpbiB0aGVcblx0XHRcdFx0Ly8gY3VycmVudCBkb2N1bWVudCwgdGhlbiB1c2UgdGhlIGN1cnJlbnQgY2FjaGVkIHZhbHVlXG5cdFx0XHRcdGlmKCFjYWNoZWQub3duZXJEb2N1bWVudCB8fCBjYWNoZWQub3duZXJEb2N1bWVudCA9PSAoZG9jIHx8IGRvY3VtZW50KSl7XG5cdFx0XHRcdFx0Ly8gc3RyaW5nIG9yIG5vZGUgb2YgdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRcdFx0XHRyZXR1cm4gY2FjaGVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9Y2F0Y2goZSl7IC8qIHNxdWVsY2ggKi8gfSAvLyBJRSBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGNhY2hlZC5vd25lckRvY3VtZW50IHdhcyByZWxvYWRlZFxuXHRcdFx0ZG9tQ29uc3RydWN0LmRlc3Ryb3koY2FjaGVkKTtcblx0XHR9XG5cblx0XHR0ZW1wbGF0ZVN0cmluZyA9IHN0cmluZy50cmltKHRlbXBsYXRlU3RyaW5nKTtcblxuXHRcdGlmKGFsd2F5c1VzZVN0cmluZyB8fCB0ZW1wbGF0ZVN0cmluZy5tYXRjaCgvXFwkXFx7KFteXFx9XSspXFx9L2cpKXtcblx0XHRcdC8vIHRoZXJlIGFyZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlIHNvIGFsbCB3ZSBjYW4gZG8gaXMgY2FjaGUgdGhlIHN0cmluZ1xuXHRcdFx0cmV0dXJuICh0bXBsdHNba2V5XSA9IHRlbXBsYXRlU3RyaW5nKTsgLy9TdHJpbmdcblx0XHR9ZWxzZXtcblx0XHRcdC8vIHRoZXJlIGFyZSBubyB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlIHNvIHdlIGNhbiBjYWNoZSB0aGUgRE9NIHRyZWVcblx0XHRcdHZhciBub2RlID0gZG9tQ29uc3RydWN0LnRvRG9tKHRlbXBsYXRlU3RyaW5nLCBkb2MpO1xuXHRcdFx0aWYobm9kZS5ub2RlVHlwZSAhPSAxKXtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0ZW1wbGF0ZTogXCIgKyB0ZW1wbGF0ZVN0cmluZyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHRtcGx0c1trZXldID0gbm9kZSk7IC8vTm9kZVxuXHRcdH1cblx0fTtcblxuXHRpZihoYXMoXCJpZVwiKSl7XG5cdFx0b24od2luZG93LCBcInVubG9hZFwiLCBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGNhY2hlID0gX1RlbXBsYXRlZE1peGluLl90ZW1wbGF0ZUNhY2hlO1xuXHRcdFx0Zm9yKHZhciBrZXkgaW4gY2FjaGUpe1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBjYWNoZVtrZXldO1xuXHRcdFx0XHRpZih0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIil7IC8vIHZhbHVlIGlzIGVpdGhlciBhIHN0cmluZyBvciBhIERPTSBub2RlIHRlbXBsYXRlXG5cdFx0XHRcdFx0ZG9tQ29uc3RydWN0LmRlc3Ryb3kodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVtrZXldO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIF9UZW1wbGF0ZWRNaXhpbjtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCJkb2pvL2FzcGVjdFwiLFx0Ly8gYXNwZWN0LmFyb3VuZFxuXHRcImRvam8vX2Jhc2UvY29uZmlnXCIsXHQvLyBjb25maWcuaXNEZWJ1Z1xuXHRcImRvam8vX2Jhc2UvY29ubmVjdFwiLFx0Ly8gY29ubmVjdC5jb25uZWN0XG5cdFwiZG9qby9fYmFzZS9kZWNsYXJlXCIsIC8vIGRlY2xhcmVcblx0XCJkb2pvL2hhc1wiLFxuXHRcImRvam8vX2Jhc2Uva2VybmVsXCIsIC8vIGtlcm5lbC5kZXByZWNhdGVkXG5cdFwiZG9qby9fYmFzZS9sYW5nXCIsIC8vIGxhbmcuaGl0Y2hcblx0XCJkb2pvL3F1ZXJ5XCIsXG5cdFwiZG9qby9yZWFkeVwiLFxuXHRcIi4vcmVnaXN0cnlcIixcdC8vIHJlZ2lzdHJ5LmJ5Tm9kZVxuXHRcIi4vX1dpZGdldEJhc2VcIixcblx0XCIuL19PbkRpaml0Q2xpY2tNaXhpblwiLFxuXHRcIi4vX0ZvY3VzTWl4aW5cIixcblx0XCJkb2pvL3VhY3NzXCIsXHRcdC8vIGJyb3dzZXIgc25pZmZpbmcgKGluY2x1ZGVkIGZvciBiYWNrLWNvbXBhdDsgc3ViY2xhc3NlcyBtYXkgYmUgdXNpbmcpXG5cdFwiLi9oY2Nzc1wiXHRcdC8vIGhpZ2ggY29udHJhc3QgbW9kZSBzbmlmZmluZyAoaW5jbHVkZWQgdG8gc2V0IENTUyBjbGFzc2VzIG9uIDxib2R5PiwgbW9kdWxlIHJldCB2YWx1ZSB1bnVzZWQpXG5dLCBmdW5jdGlvbihhc3BlY3QsIGNvbmZpZywgY29ubmVjdCwgZGVjbGFyZSwgaGFzLCBrZXJuZWwsIGxhbmcsIHF1ZXJ5LCByZWFkeSxcblx0XHRcdHJlZ2lzdHJ5LCBfV2lkZ2V0QmFzZSwgX09uRGlqaXRDbGlja01peGluLCBfRm9jdXNNaXhpbil7XG5cblxuLy8gbW9kdWxlOlxuLy9cdFx0ZGlqaXQvX1dpZGdldFxuXG5cbmZ1bmN0aW9uIGNvbm5lY3RUb0RvbU5vZGUoKXtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0SWYgdXNlciBjb25uZWN0cyB0byBhIHdpZGdldCBtZXRob2QgPT09IHRoaXMgZnVuY3Rpb24sIHRoZW4gdGhleSB3aWxsXG5cdC8vXHRcdGluc3RlYWQgYWN0dWFsbHkgYmUgY29ubmVjdGluZyB0aGUgZXF1aXZhbGVudCBldmVudCBvbiB0aGlzLmRvbU5vZGVcbn1cblxuLy8gVHJhcCBkb2pvLmNvbm5lY3QoKSBjYWxscyB0byBjb25uZWN0VG9Eb21Ob2RlIG1ldGhvZHMsIGFuZCByZWRpcmVjdCB0byBfV2lkZ2V0Lm9uKClcbmZ1bmN0aW9uIGFyb3VuZEFkdmljZShvcmlnaW5hbENvbm5lY3Qpe1xuXHRyZXR1cm4gZnVuY3Rpb24ob2JqLCBldmVudCwgc2NvcGUsIG1ldGhvZCl7XG5cdFx0aWYob2JqICYmIHR5cGVvZiBldmVudCA9PSBcInN0cmluZ1wiICYmIG9ialtldmVudF0gPT0gY29ubmVjdFRvRG9tTm9kZSl7XG5cdFx0XHRyZXR1cm4gb2JqLm9uKGV2ZW50LnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpLCBsYW5nLmhpdGNoKHNjb3BlLCBtZXRob2QpKTtcblx0XHR9XG5cdFx0cmV0dXJuIG9yaWdpbmFsQ29ubmVjdC5hcHBseShjb25uZWN0LCBhcmd1bWVudHMpO1xuXHR9O1xufVxuYXNwZWN0LmFyb3VuZChjb25uZWN0LCBcImNvbm5lY3RcIiwgYXJvdW5kQWR2aWNlKTtcbmlmKGtlcm5lbC5jb25uZWN0KXtcblx0YXNwZWN0LmFyb3VuZChrZXJuZWwsIFwiY29ubmVjdFwiLCBhcm91bmRBZHZpY2UpO1xufVxuXG52YXIgX1dpZGdldCA9IGRlY2xhcmUoXCJkaWppdC5fV2lkZ2V0XCIsIFtfV2lkZ2V0QmFzZSwgX09uRGlqaXRDbGlja01peGluLCBfRm9jdXNNaXhpbl0sIHtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0T2xkIGJhc2UgY2xhc3MgZm9yIHdpZGdldHMuICAgTmV3IHdpZGdldHMgc2hvdWxkIGV4dGVuZCBgZGlqaXQvX1dpZGdldEJhc2VgIGluc3RlYWRcblx0Ly8gZGVzY3JpcHRpb246XG5cdC8vXHRcdE9sZCBCYXNlIGNsYXNzIGZvciBEaWppdCB3aWRnZXRzLlxuXHQvL1xuXHQvL1x0XHRFeHRlbmRzIF9XaWRnZXRCYXNlLCBhZGRpbmcgc3VwcG9ydCBmb3I6XG5cdC8vXG5cdC8vXHRcdC0gZGVjbGFyYXRpdmVseS9wcm9ncmFtYXRpY2FsbHkgc3BlY2lmeWluZyB3aWRnZXQgaW5pdGlhbGl6YXRpb24gcGFyYW1ldGVycyBsaWtlXG5cdC8vXHRcdFx0b25Nb3VzZU1vdmU9XCJmb29cIiB0aGF0IGNhbGwgZm9vIHdoZW4gdGhpcy5kb21Ob2RlIGdldHMgYSBtb3VzZW1vdmUgZXZlbnRcblx0Ly9cdFx0LSBvbmRpaml0Y2xpY2s6XG5cdC8vXHRcdFx0U3VwcG9ydCBuZXcgZGF0YS1kb2pvLWF0dGFjaC1ldmVudD1cIm9uZGlqaXRjbGljazogLi4uXCIgdGhhdCBpcyB0cmlnZ2VyZWQgYnkgYSBtb3VzZSBjbGljayBvciBhIFNQQUNFL0VOVEVSIGtleXByZXNzXG5cdC8vXHRcdC0gZm9jdXMgcmVsYXRlZCBmdW5jdGlvbnM6XG5cdC8vXHRcdFx0SW4gcGFydGljdWxhciwgdGhlIG9uRm9jdXMoKS9vbkJsdXIoKSBjYWxsYmFja3MuICAgRHJpdmVuIGludGVybmFsbHkgYnlcblx0Ly9cdFx0XHRkaWppdC9fYmFzZS9mb2N1cy5qcy5cblx0Ly9cdFx0LSBkZXByZWNhdGVkIG1ldGhvZHNcblx0Ly9cdFx0LSBvblNob3coKSwgb25IaWRlKCksIG9uQ2xvc2UoKVxuXHQvL1xuXHQvL1x0XHRBbHNvLCBieSBsb2FkaW5nIGNvZGUgaW4gZGlqaXQvX2Jhc2UsIHR1cm5zIG9uOlxuXHQvL1xuXHQvL1x0XHQtIGJyb3dzZXIgc25pZmZpbmcgKHB1dHRpbmcgYnJvd3NlciBjbGFzcyBsaWtlIGBkal9pZWAgb24gYDxodG1sPmAgbm9kZSlcblx0Ly9cdFx0LSBoaWdoIGNvbnRyYXN0IG1vZGUgc25pZmZpbmcgKGFkZCBgZGlqaXRfYTExeWAgY2xhc3MgdG8gYDxib2R5PmAgaWYgbWFjaGluZSBpcyBpbiBoaWdoIGNvbnRyYXN0IG1vZGUpXG5cblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8gREVGRVJSRUQgQ09OTkVDVFMgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdG9uQ2xpY2s6IGNvbm5lY3RUb0RvbU5vZGUsXG5cdC8qPT09PT1cblx0b25DbGljazogZnVuY3Rpb24oZXZlbnQpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0Q29ubmVjdCB0byB0aGlzIGZ1bmN0aW9uIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiBtb3VzZSBjbGljayBldmVudHMuXG5cdFx0Ly8gZXZlbnQ6XG5cdFx0Ly9cdFx0bW91c2UgRXZlbnRcblx0XHQvLyB0YWdzOlxuXHRcdC8vXHRcdGNhbGxiYWNrXG5cdH0sXG5cdD09PT09Ki9cblx0b25EYmxDbGljazogY29ubmVjdFRvRG9tTm9kZSxcblx0Lyo9PT09PVxuXHRvbkRibENsaWNrOiBmdW5jdGlvbihldmVudCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRDb25uZWN0IHRvIHRoaXMgZnVuY3Rpb24gdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIG1vdXNlIGRvdWJsZSBjbGljayBldmVudHMuXG5cdFx0Ly8gZXZlbnQ6XG5cdFx0Ly9cdFx0bW91c2UgRXZlbnRcblx0XHQvLyB0YWdzOlxuXHRcdC8vXHRcdGNhbGxiYWNrXG5cdH0sXG5cdD09PT09Ki9cblx0b25LZXlEb3duOiBjb25uZWN0VG9Eb21Ob2RlLFxuXHQvKj09PT09XG5cdG9uS2V5RG93bjogZnVuY3Rpb24oZXZlbnQpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0Q29ubmVjdCB0byB0aGlzIGZ1bmN0aW9uIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiBrZXlzIGJlaW5nIHByZXNzZWQgZG93bi5cblx0XHQvLyBldmVudDpcblx0XHQvL1x0XHRrZXkgRXZlbnRcblx0XHQvLyB0YWdzOlxuXHRcdC8vXHRcdGNhbGxiYWNrXG5cdH0sXG5cdD09PT09Ki9cblx0b25LZXlQcmVzczogY29ubmVjdFRvRG9tTm9kZSxcblx0Lyo9PT09PVxuXHRvbktleVByZXNzOiBmdW5jdGlvbihldmVudCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRDb25uZWN0IHRvIHRoaXMgZnVuY3Rpb24gdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHByaW50YWJsZSBrZXlzIGJlaW5nIHR5cGVkLlxuXHRcdC8vIGV2ZW50OlxuXHRcdC8vXHRcdGtleSBFdmVudFxuXHRcdC8vIHRhZ3M6XG5cdFx0Ly9cdFx0Y2FsbGJhY2tcblx0fSxcblx0PT09PT0qL1xuXHRvbktleVVwOiBjb25uZWN0VG9Eb21Ob2RlLFxuXHQvKj09PT09XG5cdG9uS2V5VXA6IGZ1bmN0aW9uKGV2ZW50KXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENvbm5lY3QgdG8gdGhpcyBmdW5jdGlvbiB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2Yga2V5cyBiZWluZyByZWxlYXNlZC5cblx0XHQvLyBldmVudDpcblx0XHQvL1x0XHRrZXkgRXZlbnRcblx0XHQvLyB0YWdzOlxuXHRcdC8vXHRcdGNhbGxiYWNrXG5cdH0sXG5cdD09PT09Ki9cblx0b25Nb3VzZURvd246IGNvbm5lY3RUb0RvbU5vZGUsXG5cdC8qPT09PT1cblx0b25Nb3VzZURvd246IGZ1bmN0aW9uKGV2ZW50KXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENvbm5lY3QgdG8gdGhpcyBmdW5jdGlvbiB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2Ygd2hlbiB0aGUgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQgZG93bi5cblx0XHQvLyBldmVudDpcblx0XHQvL1x0XHRtb3VzZSBFdmVudFxuXHRcdC8vIHRhZ3M6XG5cdFx0Ly9cdFx0Y2FsbGJhY2tcblx0fSxcblx0PT09PT0qL1xuXHRvbk1vdXNlTW92ZTogY29ubmVjdFRvRG9tTm9kZSxcblx0Lyo9PT09PVxuXHRvbk1vdXNlTW92ZTogZnVuY3Rpb24oZXZlbnQpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0Q29ubmVjdCB0byB0aGlzIGZ1bmN0aW9uIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIG5vZGVzIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyB3aWRnZXQuXG5cdFx0Ly8gZXZlbnQ6XG5cdFx0Ly9cdFx0bW91c2UgRXZlbnRcblx0XHQvLyB0YWdzOlxuXHRcdC8vXHRcdGNhbGxiYWNrXG5cdH0sXG5cdD09PT09Ki9cblx0b25Nb3VzZU91dDogY29ubmVjdFRvRG9tTm9kZSxcblx0Lyo9PT09PVxuXHRvbk1vdXNlT3V0OiBmdW5jdGlvbihldmVudCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRDb25uZWN0IHRvIHRoaXMgZnVuY3Rpb24gdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHdoZW4gdGhlIG1vdXNlIG1vdmVzIG9mZiBvZiBub2RlcyBjb250YWluZWQgd2l0aGluIHRoaXMgd2lkZ2V0LlxuXHRcdC8vIGV2ZW50OlxuXHRcdC8vXHRcdG1vdXNlIEV2ZW50XG5cdFx0Ly8gdGFnczpcblx0XHQvL1x0XHRjYWxsYmFja1xuXHR9LFxuXHQ9PT09PSovXG5cdG9uTW91c2VPdmVyOiBjb25uZWN0VG9Eb21Ob2RlLFxuXHQvKj09PT09XG5cdG9uTW91c2VPdmVyOiBmdW5jdGlvbihldmVudCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRDb25uZWN0IHRvIHRoaXMgZnVuY3Rpb24gdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHdoZW4gdGhlIG1vdXNlIG1vdmVzIG9udG8gbm9kZXMgY29udGFpbmVkIHdpdGhpbiB0aGlzIHdpZGdldC5cblx0XHQvLyBldmVudDpcblx0XHQvL1x0XHRtb3VzZSBFdmVudFxuXHRcdC8vIHRhZ3M6XG5cdFx0Ly9cdFx0Y2FsbGJhY2tcblx0fSxcblx0PT09PT0qL1xuXHRvbk1vdXNlTGVhdmU6IGNvbm5lY3RUb0RvbU5vZGUsXG5cdC8qPT09PT1cblx0b25Nb3VzZUxlYXZlOiBmdW5jdGlvbihldmVudCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRDb25uZWN0IHRvIHRoaXMgZnVuY3Rpb24gdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHdoZW4gdGhlIG1vdXNlIG1vdmVzIG9mZiBvZiB0aGlzIHdpZGdldC5cblx0XHQvLyBldmVudDpcblx0XHQvL1x0XHRtb3VzZSBFdmVudFxuXHRcdC8vIHRhZ3M6XG5cdFx0Ly9cdFx0Y2FsbGJhY2tcblx0fSxcblx0PT09PT0qL1xuXHRvbk1vdXNlRW50ZXI6IGNvbm5lY3RUb0RvbU5vZGUsXG5cdC8qPT09PT1cblx0b25Nb3VzZUVudGVyOiBmdW5jdGlvbihldmVudCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRDb25uZWN0IHRvIHRoaXMgZnVuY3Rpb24gdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHdoZW4gdGhlIG1vdXNlIG1vdmVzIG9udG8gdGhpcyB3aWRnZXQuXG5cdFx0Ly8gZXZlbnQ6XG5cdFx0Ly9cdFx0bW91c2UgRXZlbnRcblx0XHQvLyB0YWdzOlxuXHRcdC8vXHRcdGNhbGxiYWNrXG5cdH0sXG5cdD09PT09Ki9cblx0b25Nb3VzZVVwOiBjb25uZWN0VG9Eb21Ob2RlLFxuXHQvKj09PT09XG5cdG9uTW91c2VVcDogZnVuY3Rpb24oZXZlbnQpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0Q29ubmVjdCB0byB0aGlzIGZ1bmN0aW9uIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB3aGVuIHRoZSBtb3VzZSBidXR0b24gaXMgcmVsZWFzZWQuXG5cdFx0Ly8gZXZlbnQ6XG5cdFx0Ly9cdFx0bW91c2UgRXZlbnRcblx0XHQvLyB0YWdzOlxuXHRcdC8vXHRcdGNhbGxiYWNrXG5cdH0sXG5cdD09PT09Ki9cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24ocGFyYW1zIC8qPT09PT0gLHNyY05vZGVSZWYgPT09PT0qLyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRDcmVhdGUgdGhlIHdpZGdldC5cblx0XHQvLyBwYXJhbXM6IE9iamVjdHxudWxsXG5cdFx0Ly9cdFx0SGFzaCBvZiBpbml0aWFsaXphdGlvbiBwYXJhbWV0ZXJzIGZvciB3aWRnZXQsIGluY2x1ZGluZyBzY2FsYXIgdmFsdWVzIChsaWtlIHRpdGxlLCBkdXJhdGlvbiBldGMuKVxuXHRcdC8vXHRcdGFuZCBmdW5jdGlvbnMsIHR5cGljYWxseSBjYWxsYmFja3MgbGlrZSBvbkNsaWNrLlxuXHRcdC8vXHRcdFRoZSBoYXNoIGNhbiBjb250YWluIGFueSBvZiB0aGUgd2lkZ2V0J3MgcHJvcGVydGllcywgZXhjbHVkaW5nIHJlYWQtb25seSBwcm9wZXJ0aWVzLlxuXHRcdC8vIHNyY05vZGVSZWY6IERPTU5vZGV8U3RyaW5nP1xuXHRcdC8vXHRcdElmIGEgc3JjTm9kZVJlZiAoRE9NIG5vZGUpIGlzIHNwZWNpZmllZDpcblx0XHQvL1xuXHRcdC8vXHRcdC0gdXNlIHNyY05vZGVSZWYuaW5uZXJIVE1MIGFzIG15IGNvbnRlbnRzXG5cdFx0Ly9cdFx0LSBpZiB0aGlzIGlzIGEgYmVoYXZpb3JhbCB3aWRnZXQgdGhlbiBhcHBseSBiZWhhdmlvciB0byB0aGF0IHNyY05vZGVSZWZcblx0XHQvL1x0XHQtIG90aGVyd2lzZSwgcmVwbGFjZSBzcmNOb2RlUmVmIHdpdGggbXkgZ2VuZXJhdGVkIERPTSB0cmVlXG5cblx0XHQvLyBleHRyYWN0IHBhcmFtZXRlcnMgbGlrZSBvbk1vdXNlTW92ZSB0aGF0IHNob3VsZCBjb25uZWN0IGRpcmVjdGx5IHRvIHRoaXMuZG9tTm9kZVxuXHRcdHRoaXMuX3RvQ29ubmVjdCA9IHt9O1xuXHRcdGZvcih2YXIgbmFtZSBpbiBwYXJhbXMpe1xuXHRcdFx0aWYodGhpc1tuYW1lXSA9PT0gY29ubmVjdFRvRG9tTm9kZSl7XG5cdFx0XHRcdHRoaXMuX3RvQ29ubmVjdFtuYW1lLnJlcGxhY2UoL15vbi8sIFwiXCIpLnRvTG93ZXJDYXNlKCldID0gcGFyYW1zW25hbWVdO1xuXHRcdFx0XHRkZWxldGUgcGFyYW1zW25hbWVdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwb3N0Q3JlYXRlOiBmdW5jdGlvbigpe1xuXHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cblx0XHQvLyBwZXJmb3JtIGNvbm5lY3Rpb24gZnJvbSB0aGlzLmRvbU5vZGUgdG8gdXNlciBzcGVjaWZpZWQgaGFuZGxlcnMgKGV4OiBvbk1vdXNlTW92ZSlcblx0XHRmb3IodmFyIG5hbWUgaW4gdGhpcy5fdG9Db25uZWN0KXtcblx0XHRcdHRoaXMub24obmFtZSwgdGhpcy5fdG9Db25uZWN0W25hbWVdKTtcblx0XHR9XG5cdFx0ZGVsZXRlIHRoaXMuX3RvQ29ubmVjdDtcblx0fSxcblxuXHRvbjogZnVuY3Rpb24oLypTdHJpbmd8RnVuY3Rpb24qLyB0eXBlLCAvKkZ1bmN0aW9uKi8gZnVuYyl7XG5cdFx0aWYodGhpc1t0aGlzLl9vbk1hcCh0eXBlKV0gPT09IGNvbm5lY3RUb0RvbU5vZGUpe1xuXHRcdFx0Ly8gVXNlIGNvbm5lY3QuY29ubmVjdCgpIHJhdGhlciB0aGFuIG9uKCkgdG8gZ2V0IGhhbmRsaW5nIGZvciBcIm9ubW91c2VlbnRlclwiIG9uIG5vbi1JRSxcblx0XHRcdC8vIG5vcm1hbGl6YXRpb24gb2Ygb25rZXlwcmVzcy9vbmtleWRvd24gdG8gYmVoYXZlIGxpa2UgZmlyZWZveCwgZXRjLlxuXHRcdFx0Ly8gQWxzbywgbmVlZCB0byBzcGVjaWZ5IGNvbnRleHQgYXMgXCJ0aGlzXCIgcmF0aGVyIHRoYW4gdGhlIGRlZmF1bHQgY29udGV4dCBvZiB0aGUgRE9NTm9kZVxuXHRcdFx0Ly8gUmVtb3ZlIGluIDIuMC5cblx0XHRcdHJldHVybiBjb25uZWN0LmNvbm5lY3QodGhpcy5kb21Ob2RlLCB0eXBlLnRvTG93ZXJDYXNlKCksIHRoaXMsIGZ1bmMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0fSxcblxuXHRfc2V0Rm9jdXNlZEF0dHI6IGZ1bmN0aW9uKHZhbCl7XG5cdFx0Ly8gUmVtb3ZlIHRoaXMgbWV0aG9kIGluIDIuMCAob3Igc29vbmVyKSwganVzdCBoZXJlIHRvIHNldCBfZm9jdXNlZCA9PSBmb2N1c2VkLCBmb3IgYmFjayBjb21wYXRcblx0XHQvLyAoYnV0IHNpbmNlIGl0J3MgYSBwcml2YXRlIHZhcmlhYmxlIHdlIGFyZW4ndCByZXF1aXJlZCB0byBrZWVwIHN1cHBvcnRpbmcgaXQpLlxuXHRcdHRoaXMuX2ZvY3VzZWQgPSB2YWw7XG5cdFx0dGhpcy5fc2V0KFwiZm9jdXNlZFwiLCB2YWwpO1xuXHR9LFxuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLyBERVBSRUNBVEVEIE1FVEhPRFMgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdHNldEF0dHJpYnV0ZTogZnVuY3Rpb24oLypTdHJpbmcqLyBhdHRyLCAvKmFueXRoaW5nKi8gdmFsdWUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0RGVwcmVjYXRlZC4gIFVzZSBzZXQoKSBpbnN0ZWFkLlxuXHRcdC8vIHRhZ3M6XG5cdFx0Ly9cdFx0ZGVwcmVjYXRlZFxuXHRcdGtlcm5lbC5kZXByZWNhdGVkKHRoaXMuZGVjbGFyZWRDbGFzcytcIjo6c2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKSBpcyBkZXByZWNhdGVkLiBVc2Ugc2V0KCkgaW5zdGVhZC5cIiwgXCJcIiwgXCIyLjBcIik7XG5cdFx0dGhpcy5zZXQoYXR0ciwgdmFsdWUpO1xuXHR9LFxuXG5cdGF0dHI6IGZ1bmN0aW9uKC8qU3RyaW5nfE9iamVjdCovbmFtZSwgLypPYmplY3Q/Ki92YWx1ZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLCB1c2UgZ2V0KCkgb3Igc2V0KCkgZGlyZWN0bHkuXG5cdFx0Ly8gbmFtZTpcblx0XHQvL1x0XHRUaGUgcHJvcGVydHkgdG8gZ2V0IG9yIHNldC4gSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCBoZXJlIGFuZCBub3Rcblx0XHQvL1x0XHRhIHN0cmluZywgaXRzIGtleXMgYXJlIHVzZWQgYXMgbmFtZXMgb2YgYXR0cmlidXRlcyB0byBiZSBzZXRcblx0XHQvL1x0XHRhbmQgdGhlIHZhbHVlIG9mIHRoZSBvYmplY3QgYXMgdmFsdWVzIHRvIHNldCBpbiB0aGUgd2lkZ2V0LlxuXHRcdC8vIHZhbHVlOlxuXHRcdC8vXHRcdE9wdGlvbmFsLiBJZiBwcm92aWRlZCwgYXR0cigpIG9wZXJhdGVzIGFzIGEgc2V0dGVyLiBJZiBvbWl0dGVkLFxuXHRcdC8vXHRcdHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBuYW1lZCBwcm9wZXJ0eSBpcyByZXR1cm5lZC5cblx0XHQvLyB0YWdzOlxuXHRcdC8vXHRcdGRlcHJlY2F0ZWRcblxuXHRcdHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZihhcmdzID49IDIgfHwgdHlwZW9mIG5hbWUgPT09IFwib2JqZWN0XCIpeyAvLyBzZXR0ZXJcblx0XHRcdHJldHVybiB0aGlzLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1lbHNleyAvLyBnZXR0ZXJcblx0XHRcdHJldHVybiB0aGlzLmdldChuYW1lKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RGVzY2VuZGFudHM6IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRSZXR1cm5zIGFsbCB0aGUgd2lkZ2V0cyBjb250YWluZWQgYnkgdGhpcywgaS5lLiwgYWxsIHdpZGdldHMgdW5kZXJuZWF0aCB0aGlzLmNvbnRhaW5lck5vZGUuXG5cdFx0Ly9cdFx0VGhpcyBtZXRob2Qgc2hvdWxkIGdlbmVyYWxseSBiZSBhdm9pZGVkIGFzIGl0IHJldHVybnMgd2lkZ2V0cyBkZWNsYXJlZCBpbiB0ZW1wbGF0ZXMsIHdoaWNoIGFyZVxuXHRcdC8vXHRcdHN1cHBvc2VkIHRvIGJlIGludGVybmFsL2hpZGRlbiwgYnV0IGl0J3MgbGVmdCBoZXJlIGZvciBiYWNrLWNvbXBhdCByZWFzb25zLlxuXG5cdFx0a2VybmVsLmRlcHJlY2F0ZWQodGhpcy5kZWNsYXJlZENsYXNzK1wiOjpnZXREZXNjZW5kYW50cygpIGlzIGRlcHJlY2F0ZWQuIFVzZSBnZXRDaGlsZHJlbigpIGluc3RlYWQuXCIsIFwiXCIsIFwiMi4wXCIpO1xuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lck5vZGUgPyBxdWVyeSgnW3dpZGdldElkXScsIHRoaXMuY29udGFpbmVyTm9kZSkubWFwKHJlZ2lzdHJ5LmJ5Tm9kZSkgOiBbXTsgLy8gZGlqaXQvX1dpZGdldEJhc2VbXVxuXHR9LFxuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLyBNSVNDRUxMQU5FT1VTIE1FVEhPRFMgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdF9vblNob3c6IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRJbnRlcm5hbCBtZXRob2QgY2FsbGVkIHdoZW4gdGhpcyB3aWRnZXQgaXMgbWFkZSB2aXNpYmxlLlxuXHRcdC8vXHRcdFNlZSBgb25TaG93YCBmb3IgZGV0YWlscy5cblx0XHR0aGlzLm9uU2hvdygpO1xuXHR9LFxuXG5cdG9uU2hvdzogZnVuY3Rpb24oKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENhbGxlZCB3aGVuIHRoaXMgd2lkZ2V0IGJlY29tZXMgdGhlIHNlbGVjdGVkIHBhbmUgaW4gYVxuXHRcdC8vXHRcdGBkaWppdC9sYXlvdXQvVGFiQ29udGFpbmVyYCwgYGRpaml0L2xheW91dC9TdGFja0NvbnRhaW5lcmAsXG5cdFx0Ly9cdFx0YGRpaml0L2xheW91dC9BY2NvcmRpb25Db250YWluZXJgLCBldGMuXG5cdFx0Ly9cblx0XHQvL1x0XHRBbHNvIGNhbGxlZCB0byBpbmRpY2F0ZSBkaXNwbGF5IG9mIGEgYGRpaml0LkRpYWxvZ2AsIGBkaWppdC5Ub29sdGlwRGlhbG9nYCwgb3IgYGRpaml0LlRpdGxlUGFuZWAuXG5cdFx0Ly8gdGFnczpcblx0XHQvL1x0XHRjYWxsYmFja1xuXHR9LFxuXG5cdG9uSGlkZTogZnVuY3Rpb24oKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENhbGxlZCB3aGVuIGFub3RoZXIgd2lkZ2V0IGJlY29tZXMgdGhlIHNlbGVjdGVkIHBhbmUgaW4gYVxuXHRcdC8vXHRcdGBkaWppdC9sYXlvdXQvVGFiQ29udGFpbmVyYCwgYGRpaml0L2xheW91dC9TdGFja0NvbnRhaW5lcmAsXG5cdFx0Ly9cdFx0YGRpaml0L2xheW91dC9BY2NvcmRpb25Db250YWluZXJgLCBldGMuXG5cdFx0Ly9cblx0XHQvL1x0XHRBbHNvIGNhbGxlZCB0byBpbmRpY2F0ZSBoaWRlIG9mIGEgYGRpaml0LkRpYWxvZ2AsIGBkaWppdC5Ub29sdGlwRGlhbG9nYCwgb3IgYGRpaml0LlRpdGxlUGFuZWAuXG5cdFx0Ly8gdGFnczpcblx0XHQvL1x0XHRjYWxsYmFja1xuXHR9LFxuXG5cdG9uQ2xvc2U6IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRDYWxsZWQgd2hlbiB0aGlzIHdpZGdldCBpcyBiZWluZyBkaXNwbGF5ZWQgYXMgYSBwb3B1cCAoZXg6IGEgQ2FsZW5kYXIgcG9wcGVkXG5cdFx0Ly9cdFx0dXAgZnJvbSBhIERhdGVUZXh0Qm94KSwgYW5kIGl0IGlzIGhpZGRlbi5cblx0XHQvL1x0XHRUaGlzIGlzIGNhbGxlZCBmcm9tIHRoZSBkaWppdC5wb3B1cCBjb2RlLCBhbmQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuXG5cdFx0Ly9cblx0XHQvL1x0XHRBbHNvIHVzZWQgYXMgYSBwYXJhbWV0ZXIgZm9yIGNoaWxkcmVuIG9mIGBkaWppdC9sYXlvdXQvU3RhY2tDb250YWluZXJgIG9yIHN1YmNsYXNzZXMuXG5cdFx0Ly9cdFx0Q2FsbGJhY2sgaWYgYSB1c2VyIHRyaWVzIHRvIGNsb3NlIHRoZSBjaGlsZC4gICBDaGlsZCB3aWxsIGJlIGNsb3NlZCBpZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cblx0XHQvLyB0YWdzOlxuXHRcdC8vXHRcdGV4dGVuc2lvblxuXG5cdFx0cmV0dXJuIHRydWU7XHRcdC8vIEJvb2xlYW5cblx0fVxufSk7XG5cbi8vIEZvciBiYWNrLWNvbXBhdCwgcmVtb3ZlIGluIDIuMC5cbmlmKGhhcyhcImRpaml0LWxlZ2FjeS1yZXF1aXJlc1wiKSl7XG5cdHJlYWR5KDAsIGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHJlcXVpcmVzID0gW1wiZGlqaXQvX2Jhc2VcIl07XG5cdFx0cmVxdWlyZShyZXF1aXJlcyk7XHQvLyB1c2UgaW5kaXJlY3Rpb24gc28gbW9kdWxlcyBub3Qgcm9sbGVkIGludG8gYSBidWlsZFxuXHR9KTtcbn1cbnJldHVybiBfV2lkZ2V0O1xufSk7XG4iLCJkZWZpbmUoW1xuXHRcInJlcXVpcmVcIiwgLy8gcmVxdWlyZS50b1VybFxuXHRcImRvam8vX2Jhc2UvYXJyYXlcIiwgLy8gYXJyYXkuZm9yRWFjaCBhcnJheS5tYXBcblx0XCJkb2pvL2FzcGVjdFwiLFxuXHRcImRvam8vX2Jhc2UvY29uZmlnXCIsIC8vIGNvbmZpZy5ibGFua0dpZlxuXHRcImRvam8vX2Jhc2UvY29ubmVjdFwiLCAvLyBjb25uZWN0LmNvbm5lY3Rcblx0XCJkb2pvL19iYXNlL2RlY2xhcmVcIiwgLy8gZGVjbGFyZVxuXHRcImRvam8vZG9tXCIsIC8vIGRvbS5ieUlkXG5cdFwiZG9qby9kb20tYXR0clwiLCAvLyBkb21BdHRyLnNldCBkb21BdHRyLnJlbW92ZVxuXHRcImRvam8vZG9tLWNsYXNzXCIsIC8vIGRvbUNsYXNzLmFkZCBkb21DbGFzcy5yZXBsYWNlXG5cdFwiZG9qby9kb20tY29uc3RydWN0XCIsIC8vIGRvbUNvbnN0cnVjdC5kZXN0cm95IGRvbUNvbnN0cnVjdC5wbGFjZVxuXHRcImRvam8vZG9tLWdlb21ldHJ5XCIsIC8vIGlzQm9keUx0clxuXHRcImRvam8vZG9tLXN0eWxlXCIsIC8vIGRvbVN0eWxlLnNldCwgZG9tU3R5bGUuZ2V0XG5cdFwiZG9qby9oYXNcIixcblx0XCJkb2pvL19iYXNlL2tlcm5lbFwiLFxuXHRcImRvam8vX2Jhc2UvbGFuZ1wiLCAvLyBtaXhpbigpLCBpc0FycmF5KCksIGV0Yy5cblx0XCJkb2pvL29uXCIsXG5cdFwiZG9qby9yZWFkeVwiLFxuXHRcImRvam8vU3RhdGVmdWxcIiwgLy8gU3RhdGVmdWxcblx0XCJkb2pvL3RvcGljXCIsXG5cdFwiZG9qby9fYmFzZS93aW5kb3dcIiwgLy8gd2luLmJvZHkoKVxuXHRcIi4vRGVzdHJveWFibGVcIixcblx0XCJkb2pvL2hhcyFkb2pvLWJpZGk/Li9fQmlkaU1peGluXCIsXG5cdFwiLi9yZWdpc3RyeVwiICAgIC8vIHJlZ2lzdHJ5LmdldFVuaXF1ZUlkKCksIHJlZ2lzdHJ5LmZpbmRXaWRnZXRzKClcbl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGFycmF5LCBhc3BlY3QsIGNvbmZpZywgY29ubmVjdCwgZGVjbGFyZSxcblx0XHRcdGRvbSwgZG9tQXR0ciwgZG9tQ2xhc3MsIGRvbUNvbnN0cnVjdCwgZG9tR2VvbWV0cnksIGRvbVN0eWxlLCBoYXMsIGtlcm5lbCxcblx0XHRcdGxhbmcsIG9uLCByZWFkeSwgU3RhdGVmdWwsIHRvcGljLCB3aW4sIERlc3Ryb3lhYmxlLCBfQmlkaU1peGluLCByZWdpc3RyeSl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9fV2lkZ2V0QmFzZVxuXG5cdC8vIEZsYWcgdG8gbWFrZSBkaWppdCBsb2FkIG1vZHVsZXMgdGhlIGFwcCBkaWRuJ3QgZXhwbGljaXRseSByZXF1ZXN0LCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0aGFzLmFkZChcImRpaml0LWxlZ2FjeS1yZXF1aXJlc1wiLCAha2VybmVsLmlzQXN5bmMpO1xuXG5cdC8vIEZsYWcgdG8gZW5hYmxlIHN1cHBvcnQgZm9yIHRleHRkaXIgYXR0cmlidXRlXG5cdGhhcy5hZGQoXCJkb2pvLWJpZGlcIiwgZmFsc2UpO1xuXG5cblx0Ly8gRm9yIGJhY2stY29tcGF0LCByZW1vdmUgaW4gMi4wLlxuXHRpZihoYXMoXCJkaWppdC1sZWdhY3ktcmVxdWlyZXNcIikpe1xuXHRcdHJlYWR5KDAsIGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgcmVxdWlyZXMgPSBbXCJkaWppdC9fYmFzZS9tYW5hZ2VyXCJdO1xuXHRcdFx0cmVxdWlyZShyZXF1aXJlcyk7XHQvLyB1c2UgaW5kaXJlY3Rpb24gc28gbW9kdWxlcyBub3Qgcm9sbGVkIGludG8gYSBidWlsZFxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gTmVzdGVkIGhhc2ggbGlzdGluZyBhdHRyaWJ1dGVzIGZvciBlYWNoIHRhZywgYWxsIHN0cmluZ3MgaW4gbG93ZXJjYXNlLlxuXHQvLyBleDoge1wiZGl2XCI6IHtcInN0eWxlXCI6IHRydWUsIFwidGFiaW5kZXhcIiB0cnVlfSwgXCJmb3JtXCI6IHsgLi4uXG5cdHZhciB0YWdBdHRycyA9IHt9O1xuXG5cdGZ1bmN0aW9uIGdldEF0dHJzKG9iail7XG5cdFx0dmFyIHJldCA9IHt9O1xuXHRcdGZvcih2YXIgYXR0ciBpbiBvYmope1xuXHRcdFx0cmV0W2F0dHIudG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gbm9uRW1wdHlBdHRyVG9Eb20oYXR0cil7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRSZXR1cm5zIGEgc2V0dGVyIGZ1bmN0aW9uIHRoYXQgY29waWVzIHRoZSBhdHRyaWJ1dGUgdG8gdGhpcy5kb21Ob2RlLFxuXHRcdC8vXHRcdG9yIHJlbW92ZXMgdGhlIGF0dHJpYnV0ZSBmcm9tIHRoaXMuZG9tTm9kZSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlXG5cdFx0Ly9cdFx0dmFsdWUgaXMgZGVmaW5lZCBvciBub3QuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbCl7XG5cdFx0XHRkb21BdHRyW3ZhbCA/IFwic2V0XCIgOiBcInJlbW92ZVwiXSh0aGlzLmRvbU5vZGUsIGF0dHIsIHZhbCk7XG5cdFx0XHR0aGlzLl9zZXQoYXR0ciwgdmFsKTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNFcXVhbChhLCBiKXtcblx0XHQvL1x0c3VtbWFyeTpcblx0XHQvL1x0XHRGdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0d28gdmFsdWVzIGFyZSBpZGVudGljYWwsXG5cdFx0Ly9cdFx0dGFraW5nIGludG8gYWNjb3VudCB0aGF0IE5hTiBpcyBub3Qgbm9ybWFsbHkgZXF1YWwgdG8gaXRzZWxmXG5cdFx0Ly9cdFx0aW4gSlMuXG5cblx0XHRyZXR1cm4gYSA9PT0gYiB8fCAoLyogYSBpcyBOYU4gKi8gYSAhPT0gYSAmJiAvKiBiIGlzIE5hTiAqLyBiICE9PSBiKTtcblx0fVxuXG5cdHZhciBfV2lkZ2V0QmFzZSA9IGRlY2xhcmUoXCJkaWppdC5fV2lkZ2V0QmFzZVwiLCBbU3RhdGVmdWwsIERlc3Ryb3lhYmxlXSwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0RnV0dXJlIGJhc2UgY2xhc3MgZm9yIGFsbCBEaWppdCB3aWRnZXRzLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEZ1dHVyZSBiYXNlIGNsYXNzIGZvciBhbGwgRGlqaXQgd2lkZ2V0cy5cblx0XHQvL1x0XHRfV2lkZ2V0IGV4dGVuZHMgdGhpcyBjbGFzcyBhZGRpbmcgc3VwcG9ydCBmb3IgdmFyaW91cyBmZWF0dXJlcyBuZWVkZWQgYnkgZGVza3RvcC5cblx0XHQvL1xuXHRcdC8vXHRcdFByb3ZpZGVzIHN0dWJzIGZvciB3aWRnZXQgbGlmZWN5Y2xlIG1ldGhvZHMgZm9yIHN1YmNsYXNzZXMgdG8gZXh0ZW5kLCBsaWtlIHBvc3RNaXhJblByb3BlcnRpZXMoKSwgYnVpbGRSZW5kZXJpbmcoKSxcblx0XHQvL1x0XHRwb3N0Q3JlYXRlKCksIHN0YXJ0dXAoKSwgYW5kIGRlc3Ryb3koKSwgYW5kIGFsc28gcHVibGljIEFQSSBtZXRob2RzIGxpa2Ugc2V0KCksIGdldCgpLCBhbmQgd2F0Y2goKS5cblx0XHQvL1xuXHRcdC8vXHRcdFdpZGdldHMgY2FuIHByb3ZpZGUgY3VzdG9tIHNldHRlcnMvZ2V0dGVycyBmb3Igd2lkZ2V0IGF0dHJpYnV0ZXMsIHdoaWNoIGFyZSBjYWxsZWQgYXV0b21hdGljYWxseSBieSBzZXQobmFtZSwgdmFsdWUpLlxuXHRcdC8vXHRcdEZvciBhbiBhdHRyaWJ1dGUgWFhYLCBkZWZpbmUgbWV0aG9kcyBfc2V0WFhYQXR0cigpIGFuZC9vciBfZ2V0WFhYQXR0cigpLlxuXHRcdC8vXG5cdFx0Ly9cdFx0X3NldFhYWEF0dHIgY2FuIGFsc28gYmUgYSBzdHJpbmcvaGFzaC9hcnJheSBtYXBwaW5nIGZyb20gYSB3aWRnZXQgYXR0cmlidXRlIFhYWCB0byB0aGUgd2lkZ2V0J3MgRE9NTm9kZXM6XG5cdFx0Ly9cblx0XHQvL1x0XHQtIERPTSBub2RlIGF0dHJpYnV0ZVxuXHRcdC8vIHxcdFx0X3NldEZvY3VzQXR0cjoge25vZGU6IFwiZm9jdXNOb2RlXCIsIHR5cGU6IFwiYXR0cmlidXRlXCJ9XG5cdFx0Ly8gfFx0XHRfc2V0Rm9jdXNBdHRyOiBcImZvY3VzTm9kZVwiXHQoc2hvcnRoYW5kKVxuXHRcdC8vIHxcdFx0X3NldEZvY3VzQXR0cjogXCJcIlx0XHQoc2hvcnRoYW5kLCBtYXBzIHRvIHRoaXMuZG9tTm9kZSlcblx0XHQvL1x0XHRNYXBzIHRoaXMuZm9jdXMgdG8gdGhpcy5mb2N1c05vZGUuZm9jdXMsIG9yIChsYXN0IGV4YW1wbGUpIHRoaXMuZG9tTm9kZS5mb2N1c1xuXHRcdC8vXG5cdFx0Ly9cdFx0LSBET00gbm9kZSBpbm5lckhUTUxcblx0XHQvL1x0fFx0XHRfc2V0VGl0bGVBdHRyOiB7IG5vZGU6IFwidGl0bGVOb2RlXCIsIHR5cGU6IFwiaW5uZXJIVE1MXCIgfVxuXHRcdC8vXHRcdE1hcHMgdGhpcy50aXRsZSB0byB0aGlzLnRpdGxlTm9kZS5pbm5lckhUTUxcblx0XHQvL1xuXHRcdC8vXHRcdC0gRE9NIG5vZGUgaW5uZXJUZXh0XG5cdFx0Ly9cdHxcdFx0X3NldFRpdGxlQXR0cjogeyBub2RlOiBcInRpdGxlTm9kZVwiLCB0eXBlOiBcImlubmVyVGV4dFwiIH1cblx0XHQvL1x0XHRNYXBzIHRoaXMudGl0bGUgdG8gdGhpcy50aXRsZU5vZGUuaW5uZXJUZXh0XG5cdFx0Ly9cblx0XHQvL1x0XHQtIERPTSBub2RlIENTUyBjbGFzc1xuXHRcdC8vIHxcdFx0X3NldE15Q2xhc3NBdHRyOiB7IG5vZGU6IFwiZG9tTm9kZVwiLCB0eXBlOiBcImNsYXNzXCIgfVxuXHRcdC8vXHRcdE1hcHMgdGhpcy5teUNsYXNzIHRvIHRoaXMuZG9tTm9kZS5jbGFzc05hbWVcblx0XHQvL1xuXHRcdC8vXHRcdC0gVG9nZ2xlIERPTSBub2RlIENTUyBjbGFzc1xuXHRcdC8vIHxcdFx0X3NldE15Q2xhc3NBdHRyOiB7IG5vZGU6IFwiZG9tTm9kZVwiLCB0eXBlOiBcInRvZ2dsZUNsYXNzXCIgfVxuXHRcdC8vXHRcdFRvZ2dsZXMgbXlDbGFzcyBvbiB0aGlzLmRvbU5vZGUgYnkgdGhpcy5teUNsYXNzXG5cdFx0Ly9cblx0XHQvL1x0XHRJZiB0aGUgdmFsdWUgb2YgX3NldFhYWEF0dHIgaXMgYW4gYXJyYXksIHRoZW4gZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSBtYXRjaGVzIG9uZSBvZiB0aGVcblx0XHQvL1x0XHRmb3JtYXRzIG9mIHRoZSBhYm92ZSBsaXN0LlxuXHRcdC8vXG5cdFx0Ly9cdFx0SWYgdGhlIGN1c3RvbSBzZXR0ZXIgaXMgbnVsbCwgbm8gYWN0aW9uIGlzIHBlcmZvcm1lZCBvdGhlciB0aGFuIHNhdmluZyB0aGUgbmV3IHZhbHVlXG5cdFx0Ly9cdFx0aW4gdGhlIHdpZGdldCAoaW4gdGhpcykuXG5cdFx0Ly9cblx0XHQvL1x0XHRJZiBubyBjdXN0b20gc2V0dGVyIGlzIGRlZmluZWQgZm9yIGFuIGF0dHJpYnV0ZSwgdGhlbiBpdCB3aWxsIGJlIGNvcGllZFxuXHRcdC8vXHRcdHRvIHRoaXMuZm9jdXNOb2RlIChpZiB0aGUgd2lkZ2V0IGRlZmluZXMgYSBmb2N1c05vZGUpLCBvciB0aGlzLmRvbU5vZGUgb3RoZXJ3aXNlLlxuXHRcdC8vXHRcdFRoYXQncyBvbmx5IGRvbmUgdGhvdWdoIGZvciBhdHRyaWJ1dGVzIHRoYXQgbWF0Y2ggRE9NTm9kZSBhdHRyaWJ1dGVzICh0aXRsZSxcblx0XHQvL1x0XHRhbHQsIGFyaWEtbGFiZWxsZWRieSwgZXRjLilcblxuXHRcdC8vIGlkOiBbY29uc3RdIFN0cmluZ1xuXHRcdC8vXHRcdEEgdW5pcXVlLCBvcGFxdWUgSUQgc3RyaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkIGJ5IHVzZXJzIG9yIGJ5IHRoZVxuXHRcdC8vXHRcdHN5c3RlbS4gSWYgdGhlIGRldmVsb3BlciBwYXNzZXMgYW4gSUQgd2hpY2ggaXMga25vd24gbm90IHRvIGJlXG5cdFx0Ly9cdFx0dW5pcXVlLCB0aGUgc3BlY2lmaWVkIElEIGlzIGlnbm9yZWQgYW5kIHRoZSBzeXN0ZW0tZ2VuZXJhdGVkIElEIGlzXG5cdFx0Ly9cdFx0dXNlZCBpbnN0ZWFkLlxuXHRcdGlkOiBcIlwiLFxuXHRcdF9zZXRJZEF0dHI6IFwiZG9tTm9kZVwiLCAvLyB0byBjb3B5IHRvIHRoaXMuZG9tTm9kZSBldmVuIGZvciBhdXRvLWdlbmVyYXRlZCBpZCdzXG5cblx0XHQvLyBsYW5nOiBbY29uc3RdIFN0cmluZ1xuXHRcdC8vXHRcdFJhcmVseSB1c2VkLiAgT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IERvam8gbG9jYWxlIHVzZWQgdG8gcmVuZGVyIHRoaXMgd2lkZ2V0LFxuXHRcdC8vXHRcdGFzIGRlZmluZWQgYnkgdGhlIFtIVE1MIExBTkddKGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw0MDEvc3RydWN0L2RpcmxhbmcuaHRtbCNhZGVmLWxhbmcpIGF0dHJpYnV0ZS5cblx0XHQvL1x0XHRWYWx1ZSBtdXN0IGJlIGFtb25nIHRoZSBsaXN0IG9mIGxvY2FsZXMgc3BlY2lmaWVkIGR1cmluZyBieSB0aGUgRG9qbyBib290c3RyYXAsXG5cdFx0Ly9cdFx0Zm9ybWF0dGVkIGFjY29yZGluZyB0byBbUkZDIDMwNjZdKGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMwNjYudHh0KSAobGlrZSBlbi11cykuXG5cdFx0bGFuZzogXCJcIixcblx0XHQvLyBzZXQgb24gZG9tTm9kZSBldmVuIHdoZW4gdGhlcmUncyBhIGZvY3VzIG5vZGUuXHRidXQgZG9uJ3Qgc2V0IGxhbmc9XCJcIiwgc2luY2UgdGhhdCdzIGludmFsaWQuXG5cdFx0X3NldExhbmdBdHRyOiBub25FbXB0eUF0dHJUb0RvbShcImxhbmdcIiksXG5cblx0XHQvLyBkaXI6IFtjb25zdF0gU3RyaW5nXG5cdFx0Ly9cdFx0QmktZGlyZWN0aW9uYWwgc3VwcG9ydCwgYXMgZGVmaW5lZCBieSB0aGUgW0hUTUwgRElSXShodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNDAxL3N0cnVjdC9kaXJsYW5nLmh0bWwjYWRlZi1kaXIpXG5cdFx0Ly9cdFx0YXR0cmlidXRlLiBFaXRoZXIgbGVmdC10by1yaWdodCBcImx0clwiIG9yIHJpZ2h0LXRvLWxlZnQgXCJydGxcIi4gIElmIHVuZGVmaW5lZCwgd2lkZ2V0cyByZW5kZXJzIGluIHBhZ2Unc1xuXHRcdC8vXHRcdGRlZmF1bHQgZGlyZWN0aW9uLlxuXHRcdGRpcjogXCJcIixcblx0XHQvLyBzZXQgb24gZG9tTm9kZSBldmVuIHdoZW4gdGhlcmUncyBhIGZvY3VzIG5vZGUuXHRidXQgZG9uJ3Qgc2V0IGRpcj1cIlwiLCBzaW5jZSB0aGF0J3MgaW52YWxpZC5cblx0XHRfc2V0RGlyQXR0cjogbm9uRW1wdHlBdHRyVG9Eb20oXCJkaXJcIiksIC8vIHRvIHNldCBvbiBkb21Ob2RlIGV2ZW4gd2hlbiB0aGVyZSdzIGEgZm9jdXMgbm9kZVxuXG5cdFx0Ly8gY2xhc3M6IFN0cmluZ1xuXHRcdC8vXHRcdEhUTUwgY2xhc3MgYXR0cmlidXRlXG5cdFx0XCJjbGFzc1wiOiBcIlwiLFxuXHRcdF9zZXRDbGFzc0F0dHI6IHsgbm9kZTogXCJkb21Ob2RlXCIsIHR5cGU6IFwiY2xhc3NcIiB9LFxuXG5cdFx0Ly8gT3ZlcnJpZGUgYXV0b21hdGljIGFzc2lnbmluZyB0eXBlIC0tPiBmb2N1c05vZGUsIGl0IGNhdXNlcyBleGNlcHRpb24gb24gSUU2LTguXG5cdFx0Ly8gSW5zdGVhZCwgdHlwZSBtdXN0IGJlIHNwZWNpZmllZCBhcyAke3R5cGV9IGluIHRoZSB0ZW1wbGF0ZSwgYXMgcGFydCBvZiB0aGUgb3JpZ2luYWwgRE9NLlxuXHRcdF9zZXRUeXBlQXR0cjogbnVsbCxcblxuXHRcdC8vIHN0eWxlOiBTdHJpbmd8fE9iamVjdFxuXHRcdC8vXHRcdEhUTUwgc3R5bGUgYXR0cmlidXRlcyBhcyBjc3NUZXh0IHN0cmluZyBvciBuYW1lL3ZhbHVlIGhhc2hcblx0XHRzdHlsZTogXCJcIixcblxuXHRcdC8vIHRpdGxlOiBTdHJpbmdcblx0XHQvL1x0XHRIVE1MIHRpdGxlIGF0dHJpYnV0ZS5cblx0XHQvL1xuXHRcdC8vXHRcdEZvciBmb3JtIHdpZGdldHMgdGhpcyBzcGVjaWZpZXMgYSB0b29sdGlwIHRvIGRpc3BsYXkgd2hlbiBob3ZlcmluZyBvdmVyXG5cdFx0Ly9cdFx0dGhlIHdpZGdldCAoanVzdCBsaWtlIHRoZSBuYXRpdmUgSFRNTCB0aXRsZSBhdHRyaWJ1dGUpLlxuXHRcdC8vXG5cdFx0Ly9cdFx0Rm9yIFRpdGxlUGFuZSBvciBmb3Igd2hlbiB0aGlzIHdpZGdldCBpcyBhIGNoaWxkIG9mIGEgVGFiQ29udGFpbmVyLCBBY2NvcmRpb25Db250YWluZXIsXG5cdFx0Ly9cdFx0ZXRjLiwgaXQncyB1c2VkIHRvIHNwZWNpZnkgdGhlIHRhYiBsYWJlbCwgYWNjb3JkaW9uIHBhbmUgdGl0bGUsIGV0Yy4gIEluIHRoaXMgY2FzZSBpdCdzXG5cdFx0Ly9cdFx0aW50ZXJwcmV0ZWQgYXMgSFRNTC5cblx0XHR0aXRsZTogXCJcIixcblxuXHRcdC8vIHRvb2x0aXA6IFN0cmluZ1xuXHRcdC8vXHRcdFdoZW4gdGhpcyB3aWRnZXQncyB0aXRsZSBhdHRyaWJ1dGUgaXMgdXNlZCB0byBmb3IgYSB0YWIgbGFiZWwsIGFjY29yZGlvbiBwYW5lIHRpdGxlLCBldGMuLFxuXHRcdC8vXHRcdHRoaXMgc3BlY2lmaWVzIHRoZSB0b29sdGlwIHRvIGFwcGVhciB3aGVuIHRoZSBtb3VzZSBpcyBob3ZlcmVkIG92ZXIgdGhhdCB0ZXh0LlxuXHRcdHRvb2x0aXA6IFwiXCIsXG5cblx0XHQvLyBiYXNlQ2xhc3M6IFtwcm90ZWN0ZWRdIFN0cmluZ1xuXHRcdC8vXHRcdFJvb3QgQ1NTIGNsYXNzIG9mIHRoZSB3aWRnZXQgKGV4OiBkaWppdFRleHRCb3gpLCB1c2VkIHRvIGNvbnN0cnVjdCBDU1MgY2xhc3NlcyB0byBpbmRpY2F0ZVxuXHRcdC8vXHRcdHdpZGdldCBzdGF0ZS5cblx0XHRiYXNlQ2xhc3M6IFwiXCIsXG5cblx0XHQvLyBzcmNOb2RlUmVmOiBbcmVhZG9ubHldIERvbU5vZGVcblx0XHQvL1x0XHRwb2ludGVyIHRvIG9yaWdpbmFsIERPTSBub2RlXG5cdFx0c3JjTm9kZVJlZjogbnVsbCxcblxuXHRcdC8vIGRvbU5vZGU6IFtyZWFkb25seV0gRG9tTm9kZVxuXHRcdC8vXHRcdFRoaXMgaXMgb3VyIHZpc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHdpZGdldCEgT3RoZXIgRE9NXG5cdFx0Ly9cdFx0Tm9kZXMgbWF5IGJ5IGFzc2lnbmVkIHRvIG90aGVyIHByb3BlcnRpZXMsIHVzdWFsbHkgdGhyb3VnaCB0aGVcblx0XHQvL1x0XHR0ZW1wbGF0ZSBzeXN0ZW0ncyBkYXRhLWRvam8tYXR0YWNoLXBvaW50IHN5bnRheCwgYnV0IHRoZSBkb21Ob2RlXG5cdFx0Ly9cdFx0cHJvcGVydHkgaXMgdGhlIGNhbm9uaWNhbCBcInRvcCBsZXZlbFwiIG5vZGUgaW4gd2lkZ2V0IFVJLlxuXHRcdGRvbU5vZGU6IG51bGwsXG5cblx0XHQvLyBjb250YWluZXJOb2RlOiBbcmVhZG9ubHldIERvbU5vZGVcblx0XHQvL1x0XHREZXNpZ25hdGVzIHdoZXJlIGNoaWxkcmVuIG9mIHRoZSBzb3VyY2UgRE9NIG5vZGUgd2lsbCBiZSBwbGFjZWQuXG5cdFx0Ly9cdFx0XCJDaGlsZHJlblwiIGluIHRoaXMgY2FzZSByZWZlcnMgdG8gYm90aCBET00gbm9kZXMgYW5kIHdpZGdldHMuXG5cdFx0Ly9cdFx0Rm9yIGV4YW1wbGUsIGZvciBteVdpZGdldDpcblx0XHQvL1xuXHRcdC8vXHRcdHxcdDxkaXYgZGF0YS1kb2pvLXR5cGU9bXlXaWRnZXQ+XG5cdFx0Ly9cdFx0fFx0XHQ8Yj4gaGVyZSdzIGEgcGxhaW4gRE9NIG5vZGVcblx0XHQvL1x0XHR8XHRcdDxzcGFuIGRhdGEtZG9qby10eXBlPXN1YldpZGdldD5hbmQgYSB3aWRnZXQ8L3NwYW4+XG5cdFx0Ly9cdFx0fFx0XHQ8aT4gYW5kIGFub3RoZXIgcGxhaW4gRE9NIG5vZGUgPC9pPlxuXHRcdC8vXHRcdHxcdDwvZGl2PlxuXHRcdC8vXG5cdFx0Ly9cdFx0Y29udGFpbmVyTm9kZSB3b3VsZCBwb2ludCB0bzpcblx0XHQvL1xuXHRcdC8vXHRcdHxcdFx0PGI+IGhlcmUncyBhIHBsYWluIERPTSBub2RlXG5cdFx0Ly9cdFx0fFx0XHQ8c3BhbiBkYXRhLWRvam8tdHlwZT1zdWJXaWRnZXQ+YW5kIGEgd2lkZ2V0PC9zcGFuPlxuXHRcdC8vXHRcdHxcdFx0PGk+IGFuZCBhbm90aGVyIHBsYWluIERPTSBub2RlIDwvaT5cblx0XHQvL1xuXHRcdC8vXHRcdEluIHRlbXBsYXRlZCB3aWRnZXRzLCBcImNvbnRhaW5lck5vZGVcIiBpcyBzZXQgdmlhIGFcblx0XHQvL1x0XHRkYXRhLWRvam8tYXR0YWNoLXBvaW50IGFzc2lnbm1lbnQuXG5cdFx0Ly9cblx0XHQvL1x0XHRjb250YWluZXJOb2RlIG11c3QgYmUgZGVmaW5lZCBmb3IgYW55IHdpZGdldCB0aGF0IGFjY2VwdHMgaW5uZXJIVE1MXG5cdFx0Ly9cdFx0KGxpa2UgQ29udGVudFBhbmUgb3IgQm9yZGVyQ29udGFpbmVyIG9yIGV2ZW4gQnV0dG9uKSwgYW5kIGNvbnZlcnNlbHlcblx0XHQvL1x0XHRpcyBudWxsIGZvciB3aWRnZXRzIHRoYXQgZG9uJ3QsIGxpa2UgVGV4dEJveC5cblx0XHRjb250YWluZXJOb2RlOiBudWxsLFxuXG5cdFx0Ly8gb3duZXJEb2N1bWVudDogW2NvbnN0XSBEb2N1bWVudD9cblx0XHQvL1x0XHRUaGUgZG9jdW1lbnQgdGhpcyB3aWRnZXQgYmVsb25ncyB0by4gIElmIG5vdCBzcGVjaWZpZWQgdG8gY29uc3RydWN0b3IsIHdpbGwgZGVmYXVsdCB0b1xuXHRcdC8vXHRcdHNyY05vZGVSZWYub3duZXJEb2N1bWVudCwgb3IgaWYgbm8gc291cmNlUmVmIHNwZWNpZmllZCwgdGhlbiB0byB0aGUgZG9jdW1lbnQgZ2xvYmFsXG5cdFx0b3duZXJEb2N1bWVudDogbnVsbCxcblx0XHRfc2V0T3duZXJEb2N1bWVudEF0dHI6IGZ1bmN0aW9uKHZhbCl7XG5cdFx0XHQvLyB0aGlzIHNldHRlciBpcyBtZXJlbHkgdG8gYXZvaWQgYXV0b21hdGljYWxseSB0cnlpbmcgdG8gc2V0IHRoaXMuZG9tTm9kZS5vd25lckRvY3VtZW50XG5cdFx0XHR0aGlzLl9zZXQoXCJvd25lckRvY3VtZW50XCIsIHZhbCk7XG5cdFx0fSxcblxuXHRcdC8qPT09PT1cblx0XHQvLyBfc3RhcnRlZDogW3JlYWRvbmx5XSBCb29sZWFuXG5cdFx0Ly9cdFx0c3RhcnR1cCgpIGhhcyBjb21wbGV0ZWQuXG5cdFx0X3N0YXJ0ZWQ6IGZhbHNlLFxuXHRcdD09PT09Ki9cblxuXHRcdC8vIGF0dHJpYnV0ZU1hcDogW3Byb3RlY3RlZF0gT2JqZWN0XG5cdFx0Ly9cdFx0RGVwcmVjYXRlZC5cdEluc3RlYWQgb2YgYXR0cmlidXRlTWFwLCB3aWRnZXQgc2hvdWxkIGhhdmUgYSBfc2V0WFhYQXR0ciBhdHRyaWJ1dGVcblx0XHQvL1x0XHRmb3IgZWFjaCBYWFggYXR0cmlidXRlIHRvIGJlIG1hcHBlZCB0byB0aGUgRE9NLlxuXHRcdC8vXG5cdFx0Ly9cdFx0YXR0cmlidXRlTWFwIHNldHMgdXAgYSBcImJpbmRpbmdcIiBiZXR3ZWVuIGF0dHJpYnV0ZXMgKGFrYSBwcm9wZXJ0aWVzKVxuXHRcdC8vXHRcdG9mIHRoZSB3aWRnZXQgYW5kIHRoZSB3aWRnZXQncyBET00uXG5cdFx0Ly9cdFx0Q2hhbmdlcyB0byB3aWRnZXQgYXR0cmlidXRlcyBsaXN0ZWQgaW4gYXR0cmlidXRlTWFwIHdpbGwgYmVcblx0XHQvL1x0XHRyZWZsZWN0ZWQgaW50byB0aGUgRE9NLlxuXHRcdC8vXG5cdFx0Ly9cdFx0Rm9yIGV4YW1wbGUsIGNhbGxpbmcgc2V0KCd0aXRsZScsICdoZWxsbycpXG5cdFx0Ly9cdFx0b24gYSBUaXRsZVBhbmUgd2lsbCBhdXRvbWF0aWNhbGx5IGNhdXNlIHRoZSBUaXRsZVBhbmUncyBET00gdG8gdXBkYXRlXG5cdFx0Ly9cdFx0d2l0aCB0aGUgbmV3IHRpdGxlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0YXR0cmlidXRlTWFwIGlzIGEgaGFzaCB3aGVyZSB0aGUga2V5IGlzIGFuIGF0dHJpYnV0ZSBvZiB0aGUgd2lkZ2V0LFxuXHRcdC8vXHRcdGFuZCB0aGUgdmFsdWUgcmVmbGVjdHMgYSBiaW5kaW5nIHRvIGE6XG5cdFx0Ly9cblx0XHQvL1x0XHQtIERPTSBub2RlIGF0dHJpYnV0ZVxuXHRcdC8vIHxcdFx0Zm9jdXM6IHtub2RlOiBcImZvY3VzTm9kZVwiLCB0eXBlOiBcImF0dHJpYnV0ZVwifVxuXHRcdC8vXHRcdE1hcHMgdGhpcy5mb2N1cyB0byB0aGlzLmZvY3VzTm9kZS5mb2N1c1xuXHRcdC8vXG5cdFx0Ly9cdFx0LSBET00gbm9kZSBpbm5lckhUTUxcblx0XHQvL1x0fFx0XHR0aXRsZTogeyBub2RlOiBcInRpdGxlTm9kZVwiLCB0eXBlOiBcImlubmVySFRNTFwiIH1cblx0XHQvL1x0XHRNYXBzIHRoaXMudGl0bGUgdG8gdGhpcy50aXRsZU5vZGUuaW5uZXJIVE1MXG5cdFx0Ly9cblx0XHQvL1x0XHQtIERPTSBub2RlIGlubmVyVGV4dFxuXHRcdC8vXHR8XHRcdHRpdGxlOiB7IG5vZGU6IFwidGl0bGVOb2RlXCIsIHR5cGU6IFwiaW5uZXJUZXh0XCIgfVxuXHRcdC8vXHRcdE1hcHMgdGhpcy50aXRsZSB0byB0aGlzLnRpdGxlTm9kZS5pbm5lclRleHRcblx0XHQvL1xuXHRcdC8vXHRcdC0gRE9NIG5vZGUgQ1NTIGNsYXNzXG5cdFx0Ly8gfFx0XHRteUNsYXNzOiB7IG5vZGU6IFwiZG9tTm9kZVwiLCB0eXBlOiBcImNsYXNzXCIgfVxuXHRcdC8vXHRcdE1hcHMgdGhpcy5teUNsYXNzIHRvIHRoaXMuZG9tTm9kZS5jbGFzc05hbWVcblx0XHQvL1xuXHRcdC8vXHRcdElmIHRoZSB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IG1hdGNoZXMgb25lIG9mIHRoZVxuXHRcdC8vXHRcdGZvcm1hdHMgb2YgdGhlIGFib3ZlIGxpc3QuXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGVyZSBhcmUgYWxzbyBzb21lIHNob3J0aGFuZHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OlxuXHRcdC8vXG5cdFx0Ly9cdFx0LSBzdHJpbmcgLS0+IHsgbm9kZTogc3RyaW5nLCB0eXBlOiBcImF0dHJpYnV0ZVwiIH0sIGZvciBleGFtcGxlOlxuXHRcdC8vXG5cdFx0Ly9cdHxcdFwiZm9jdXNOb2RlXCIgLS0tPiB7IG5vZGU6IFwiZm9jdXNOb2RlXCIsIHR5cGU6IFwiYXR0cmlidXRlXCIgfVxuXHRcdC8vXG5cdFx0Ly9cdFx0LSBcIlwiIC0tPiB7IG5vZGU6IFwiZG9tTm9kZVwiLCB0eXBlOiBcImF0dHJpYnV0ZVwiIH1cblx0XHRhdHRyaWJ1dGVNYXA6IHt9LFxuXG5cdFx0Ly8gX2JsYW5rR2lmOiBbcHJvdGVjdGVkXSBTdHJpbmdcblx0XHQvL1x0XHRQYXRoIHRvIGEgYmxhbmsgMXgxIGltYWdlLlxuXHRcdC8vXHRcdFVzZWQgYnkgYDxpbWc+YCBub2RlcyBpbiB0ZW1wbGF0ZXMgdGhhdCByZWFsbHkgZ2V0IHRoZWlyIGltYWdlIHZpYSBDU1MgYmFja2dyb3VuZC1pbWFnZS5cblx0XHRfYmxhbmtHaWY6IGNvbmZpZy5ibGFua0dpZiB8fCByZXF1aXJlLnRvVXJsKFwiZG9qby9yZXNvdXJjZXMvYmxhbmsuZ2lmXCIpLFxuXG5cdFx0Ly8gdGV4dERpcjogU3RyaW5nXG5cdFx0Ly9cdFx0QmktZGlyZWN0aW9uYWwgc3VwcG9ydCxcdHRoZSBtYWluIHZhcmlhYmxlIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0ZXh0LlxuXHRcdC8vXHRcdFRoZSB0ZXh0IGRpcmVjdGlvbiBjYW4gYmUgZGlmZmVyZW50IHRoYW4gdGhlIEdVSSBkaXJlY3Rpb24gYnkgdXNpbmcgdGhpcyBwYXJhbWV0ZXIgaW4gY3JlYXRpb25cblx0XHQvL1x0XHRvZiBhIHdpZGdldC5cblx0XHQvL1xuXHRcdC8vXHRcdFRoaXMgcHJvcGVydHkgaXMgb25seSBlZmZlY3RpdmUgd2hlbiBgaGFzKFwiZG9qby1iaWRpXCIpYCBpcyBkZWZpbmVkIHRvIGJlIHRydWUuXG5cdFx0Ly9cblx0XHQvL1x0XHRBbGxvd2VkIHZhbHVlczpcblx0XHQvL1xuXHRcdC8vXHRcdDEuIFwiXCIgLSBkZWZhdWx0IHZhbHVlOyB0ZXh0IGlzIHNhbWUgZGlyZWN0aW9uIGFzIHdpZGdldFxuXHRcdC8vXHRcdDIuIFwibHRyXCJcblx0XHQvL1x0XHQzLiBcInJ0bFwiXG5cdFx0Ly9cdFx0NC4gXCJhdXRvXCIgLSBjb250ZXh0dWFsIHRoZSBkaXJlY3Rpb24gb2YgYSB0ZXh0IGRlZmluZWQgYnkgZmlyc3Qgc3Ryb25nIGxldHRlci5cblx0XHR0ZXh0RGlyOiBcIlwiLFxuXG5cdFx0Ly8vLy8vLy8vLy8vIElOSVRJQUxJWkFUSU9OIE1FVEhPRFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0XHQvKj09PT09XG5cdFx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKHBhcmFtcywgc3JjTm9kZVJlZil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q3JlYXRlIHRoZSB3aWRnZXQuXG5cdFx0XHQvLyBwYXJhbXM6IE9iamVjdHxudWxsXG5cdFx0XHQvL1x0XHRIYXNoIG9mIGluaXRpYWxpemF0aW9uIHBhcmFtZXRlcnMgZm9yIHdpZGdldCwgaW5jbHVkaW5nIHNjYWxhciB2YWx1ZXMgKGxpa2UgdGl0bGUsIGR1cmF0aW9uIGV0Yy4pXG5cdFx0XHQvL1x0XHRhbmQgZnVuY3Rpb25zLCB0eXBpY2FsbHkgY2FsbGJhY2tzIGxpa2Ugb25DbGljay5cblx0XHRcdC8vXHRcdFRoZSBoYXNoIGNhbiBjb250YWluIGFueSBvZiB0aGUgd2lkZ2V0J3MgcHJvcGVydGllcywgZXhjbHVkaW5nIHJlYWQtb25seSBwcm9wZXJ0aWVzLlxuXHRcdFx0Ly8gc3JjTm9kZVJlZjogRE9NTm9kZXxTdHJpbmc/XG5cdFx0XHQvL1x0XHRJZiBhIHNyY05vZGVSZWYgKERPTSBub2RlKSBpcyBzcGVjaWZpZWQ6XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0LSB1c2Ugc3JjTm9kZVJlZi5pbm5lckhUTUwgYXMgbXkgY29udGVudHNcblx0XHRcdC8vXHRcdC0gaWYgdGhpcyBpcyBhIGJlaGF2aW9yYWwgd2lkZ2V0IHRoZW4gYXBwbHkgYmVoYXZpb3IgdG8gdGhhdCBzcmNOb2RlUmVmXG5cdFx0XHQvL1x0XHQtIG90aGVyd2lzZSwgcmVwbGFjZSBzcmNOb2RlUmVmIHdpdGggbXkgZ2VuZXJhdGVkIERPTSB0cmVlXG5cdFx0fSxcblx0XHQ9PT09PSovXG5cblx0XHRfaW50cm9zcGVjdDogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDb2xsZWN0IG1ldGFkYXRhIGFib3V0IHRoaXMgd2lkZ2V0IChvbmx5IG9uY2UgcGVyIGNsYXNzLCBub3Qgb25jZSBwZXIgaW5zdGFuY2UpOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdFx0LSBsaXN0IG9mIGF0dHJpYnV0ZXMgd2l0aCBjdXN0b20gc2V0dGVycywgc3RvcmluZyBpbiB0aGlzLmNvbnN0cnVjdG9yLl9zZXR0ZXJBdHRyc1xuXHRcdFx0Ly9cdFx0XHQtIGdlbmVyYXRlIHRoaXMuY29uc3RydWN0b3IuX29uTWFwLCBtYXBwaW5nIG5hbWVzIGxpa2UgXCJtb3VzZWRvd25cIiB0byBmdW5jdGlvbnMgbGlrZSBvbk1vdXNlRG93blxuXG5cdFx0XHR2YXIgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG5cdFx0XHRpZighY3Rvci5fc2V0dGVyQXR0cnMpe1xuXHRcdFx0XHR2YXIgcHJvdG8gPSBjdG9yLnByb3RvdHlwZSxcblx0XHRcdFx0XHRhdHRycyA9IGN0b3IuX3NldHRlckF0dHJzID0gW10sIC8vIGF0dHJpYnV0ZXMgd2l0aCBjdXN0b20gc2V0dGVyc1xuXHRcdFx0XHRcdG9uTWFwID0gKGN0b3IuX29uTWFwID0ge30pO1xuXG5cdFx0XHRcdC8vIEl0ZW1zIGluIHRoaXMuYXR0cmlidXRlTWFwIGFyZSBsaWtlIGN1c3RvbSBzZXR0ZXJzLiAgRm9yIGJhY2stY29tcGF0LCByZW1vdmUgZm9yIDIuMC5cblx0XHRcdFx0Zm9yKHZhciBuYW1lIGluIHByb3RvLmF0dHJpYnV0ZU1hcCl7XG5cdFx0XHRcdFx0YXR0cnMucHVzaChuYW1lKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3Agb3ZlciB3aWRnZXQgcHJvcGVydGllcywgY29sbGVjdGluZyBwcm9wZXJ0aWVzIHdpdGggY3VzdG9tIHNldHRlcnMgYW5kIGZpbGxpbmcgaW4gY3Rvci5fb25NYXAuXG5cdFx0XHRcdGZvcihuYW1lIGluIHByb3RvKXtcblx0XHRcdFx0XHRpZigvXm9uLy50ZXN0KG5hbWUpKXtcblx0XHRcdFx0XHRcdG9uTWFwW25hbWUuc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCldID0gbmFtZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZigvXl9zZXRbQS1aXSguKilBdHRyJC8udGVzdChuYW1lKSl7XG5cdFx0XHRcdFx0XHRuYW1lID0gbmFtZS5jaGFyQXQoNCkudG9Mb3dlckNhc2UoKSArIG5hbWUuc3Vic3RyKDUsIG5hbWUubGVuZ3RoIC0gOSk7XG5cdFx0XHRcdFx0XHRpZighcHJvdG8uYXR0cmlidXRlTWFwIHx8ICEobmFtZSBpbiBwcm90by5hdHRyaWJ1dGVNYXApKXtcblx0XHRcdFx0XHRcdFx0YXR0cnMucHVzaChuYW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBOb3RlOiB0aGlzIGlzbid0IHBpY2tpbmcgdXAgaW5mbyBvbiBwcm9wZXJ0aWVzIGxpa2UgYXJpYS1sYWJlbCBhbmQgcm9sZSwgdGhhdCBkb24ndCBoYXZlIGN1c3RvbSBzZXR0ZXJzXG5cdFx0XHRcdC8vIGJ1dCB0aGF0IHNldCgpIG1hcHMgdG8gYXR0cmlidXRlcyBvbiB0aGlzLmRvbU5vZGUgb3IgdGhpcy5mb2N1c05vZGVcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cG9zdHNjcmlwdDogZnVuY3Rpb24oLypPYmplY3Q/Ki9wYXJhbXMsIC8qRG9tTm9kZXxTdHJpbmcqL3NyY05vZGVSZWYpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEtpY2tzIG9mZiB3aWRnZXQgaW5zdGFudGlhdGlvbi4gIFNlZSBjcmVhdGUoKSBmb3IgZGV0YWlscy5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcml2YXRlXG5cblx0XHRcdC8vIE5vdGUgdGhhdCB3ZSBza2lwIGNhbGxpbmcgdGhpcy5pbmhlcml0ZWQoKSwgaS5lLiBkb2pvL1N0YXRlZnVsOjpwb3N0c2NyaXB0KCksIGJlY2F1c2UgMS54IHdpZGdldHMgZG9uJ3Rcblx0XHRcdC8vIGV4cGVjdCB0aGVpciBjdXN0b20gc2V0dGVycyB0byBnZXQgY2FsbGVkIHVudGlsIGFmdGVyIGJ1aWxkUmVuZGVyaW5nKCkuICBDb25zaWRlciBjaGFuZ2luZyBmb3IgMi4wLlxuXG5cdFx0XHR0aGlzLmNyZWF0ZShwYXJhbXMsIHNyY05vZGVSZWYpO1xuXHRcdH0sXG5cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKHBhcmFtcywgc3JjTm9kZVJlZil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0S2ljayBvZmYgdGhlIGxpZmUtY3ljbGUgb2YgYSB3aWRnZXRcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0Q3JlYXRlIGNhbGxzIGEgbnVtYmVyIG9mIHdpZGdldCBtZXRob2RzIChwb3N0TWl4SW5Qcm9wZXJ0aWVzLCBidWlsZFJlbmRlcmluZywgcG9zdENyZWF0ZSxcblx0XHRcdC8vXHRcdGV0Yy4pLCBzb21lIG9mIHdoaWNoIG9mIHlvdSdsbCB3YW50IHRvIG92ZXJyaWRlLiBTZWUgaHR0cDovL2Rvam90b29sa2l0Lm9yZy9yZWZlcmVuY2UtZ3VpZGUvZGlqaXQvX1dpZGdldEJhc2UuaHRtbFxuXHRcdFx0Ly9cdFx0Zm9yIGEgZGlzY3Vzc2lvbiBvZiB0aGUgd2lkZ2V0IGNyZWF0aW9uIGxpZmVjeWNsZS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRPZiBjb3Vyc2UsIGFkdmVudHVyb3VzIGRldmVsb3BlcnMgY291bGQgb3ZlcnJpZGUgY3JlYXRlIGVudGlyZWx5LCBidXQgdGhpcyBzaG91bGRcblx0XHRcdC8vXHRcdG9ubHkgYmUgZG9uZSBhcyBhIGxhc3QgcmVzb3J0LlxuXHRcdFx0Ly8gcGFyYW1zOiBPYmplY3R8bnVsbFxuXHRcdFx0Ly9cdFx0SGFzaCBvZiBpbml0aWFsaXphdGlvbiBwYXJhbWV0ZXJzIGZvciB3aWRnZXQsIGluY2x1ZGluZyBzY2FsYXIgdmFsdWVzIChsaWtlIHRpdGxlLCBkdXJhdGlvbiBldGMuKVxuXHRcdFx0Ly9cdFx0YW5kIGZ1bmN0aW9ucywgdHlwaWNhbGx5IGNhbGxiYWNrcyBsaWtlIG9uQ2xpY2suXG5cdFx0XHQvL1x0XHRUaGUgaGFzaCBjYW4gY29udGFpbiBhbnkgb2YgdGhlIHdpZGdldCdzIHByb3BlcnRpZXMsIGV4Y2x1ZGluZyByZWFkLW9ubHkgcHJvcGVydGllcy5cblx0XHRcdC8vIHNyY05vZGVSZWY6IERPTU5vZGV8U3RyaW5nP1xuXHRcdFx0Ly9cdFx0SWYgYSBzcmNOb2RlUmVmIChET00gbm9kZSkgaXMgc3BlY2lmaWVkOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdC0gdXNlIHNyY05vZGVSZWYuaW5uZXJIVE1MIGFzIG15IGNvbnRlbnRzXG5cdFx0XHQvL1x0XHQtIGlmIHRoaXMgaXMgYSBiZWhhdmlvcmFsIHdpZGdldCB0aGVuIGFwcGx5IGJlaGF2aW9yIHRvIHRoYXQgc3JjTm9kZVJlZlxuXHRcdFx0Ly9cdFx0LSBvdGhlcndpc2UsIHJlcGxhY2Ugc3JjTm9kZVJlZiB3aXRoIG15IGdlbmVyYXRlZCBET00gdHJlZVxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByaXZhdGVcblxuXHRcdFx0Ly8gRmlyc3QgdGltZSB3aWRnZXQgaXMgaW5zdGFudGlhdGVkLCBzY2FuIHByb3RvdHlwZSB0byBmaWd1cmUgb3V0IGluZm8gYWJvdXQgY3VzdG9tIHNldHRlcnMgZXRjLlxuXHRcdFx0dGhpcy5faW50cm9zcGVjdCgpO1xuXG5cdFx0XHQvLyBzdG9yZSBwb2ludGVyIHRvIG9yaWdpbmFsIERPTSB0cmVlXG5cdFx0XHR0aGlzLnNyY05vZGVSZWYgPSBkb20uYnlJZChzcmNOb2RlUmVmKTtcblxuXHRcdFx0Ly8gTm8gbG9uZ2VyIHVzZWQsIHJlbW92ZSBmb3IgMi4wLlxuXHRcdFx0dGhpcy5fY29ubmVjdHMgPSBbXTtcblx0XHRcdHRoaXMuX3N1cHBvcnRpbmdXaWRnZXRzID0gW107XG5cblx0XHRcdC8vIHRoaXMgaXMgaGVyZSBmb3IgYmFjay1jb21wYXQsIHJlbW92ZSBpbiAyLjAgKGJ1dCBjaGVjayBOb2RlTGlzdC1pbnN0YW50aWF0ZS5odG1sIHRlc3QpXG5cdFx0XHRpZih0aGlzLnNyY05vZGVSZWYgJiYgdGhpcy5zcmNOb2RlUmVmLmlkICAmJiAodHlwZW9mIHRoaXMuc3JjTm9kZVJlZi5pZCA9PSBcInN0cmluZ1wiKSl7XG5cdFx0XHRcdHRoaXMuaWQgPSB0aGlzLnNyY05vZGVSZWYuaWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG1peCBpbiBvdXIgcGFzc2VkIHBhcmFtZXRlcnNcblx0XHRcdGlmKHBhcmFtcyl7XG5cdFx0XHRcdHRoaXMucGFyYW1zID0gcGFyYW1zO1xuXHRcdFx0XHRsYW5nLm1peGluKHRoaXMsIHBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBvc3RNaXhJblByb3BlcnRpZXMoKTtcblxuXHRcdFx0Ly8gR2VuZXJhdGUgYW4gaWQgZm9yIHRoZSB3aWRnZXQgaWYgb25lIHdhc24ndCBzcGVjaWZpZWQsIG9yIGl0IHdhcyBzcGVjaWZpZWQgYXMgaWQ6IHVuZGVmaW5lZC5cblx0XHRcdC8vIERvIHRoaXMgYmVmb3JlIGJ1aWxkUmVuZGVyaW5nKCkgYmVjYXVzZSBpdCBtaWdodCBleHBlY3QgdGhlIGlkIHRvIGJlIHRoZXJlLlxuXHRcdFx0aWYoIXRoaXMuaWQpe1xuXHRcdFx0XHR0aGlzLmlkID0gcmVnaXN0cnkuZ2V0VW5pcXVlSWQodGhpcy5kZWNsYXJlZENsYXNzLnJlcGxhY2UoL1xcLi9nLCBcIl9cIikpO1xuXHRcdFx0XHRpZih0aGlzLnBhcmFtcyl7XG5cdFx0XHRcdFx0Ly8gaWYgcGFyYW1zIGNvbnRhaW5zIHtpZDogdW5kZWZpbmVkfSwgcHJldmVudCBfYXBwbHlBdHRyaWJ1dGVzKCkgZnJvbSBwcm9jZXNzaW5nIGl0XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMucGFyYW1zLmlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBkb2N1bWVudCBhbmQgPGJvZHk+IG5vZGUgdGhpcyB3aWRnZXQgaXMgYXNzb2NpYXRlZCB3aXRoXG5cdFx0XHR0aGlzLm93bmVyRG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgKHRoaXMuc3JjTm9kZVJlZiA/IHRoaXMuc3JjTm9kZVJlZi5vd25lckRvY3VtZW50IDogZG9jdW1lbnQpO1xuXHRcdFx0dGhpcy5vd25lckRvY3VtZW50Qm9keSA9IHdpbi5ib2R5KHRoaXMub3duZXJEb2N1bWVudCk7XG5cblx0XHRcdHJlZ2lzdHJ5LmFkZCh0aGlzKTtcblxuXHRcdFx0dGhpcy5idWlsZFJlbmRlcmluZygpO1xuXG5cdFx0XHR2YXIgZGVsZXRlU3JjTm9kZVJlZjtcblxuXHRcdFx0aWYodGhpcy5kb21Ob2RlKXtcblx0XHRcdFx0Ly8gQ29weSBhdHRyaWJ1dGVzIGxpc3RlZCBpbiBhdHRyaWJ1dGVNYXAgaW50byB0aGUgW25ld2x5IGNyZWF0ZWRdIERPTSBmb3IgdGhlIHdpZGdldC5cblx0XHRcdFx0Ly8gQWxzbyBjYWxscyBjdXN0b20gc2V0dGVycyBmb3IgYWxsIGF0dHJpYnV0ZXMgd2l0aCBjdXN0b20gc2V0dGVycy5cblx0XHRcdFx0dGhpcy5fYXBwbHlBdHRyaWJ1dGVzKCk7XG5cblx0XHRcdFx0Ly8gSWYgc3JjTm9kZVJlZiB3YXMgc3BlY2lmaWVkLCB0aGVuIHN3YXAgb3V0IG9yaWdpbmFsIHNyY05vZGUgZm9yIHRoaXMgd2lkZ2V0J3MgRE9NIHRyZWUuXG5cdFx0XHRcdC8vIEZvciAyLjAsIG1vdmUgdGhpcyBhZnRlciBwb3N0Q3JlYXRlKCkuICBwb3N0Q3JlYXRlKCkgc2hvdWxkbid0IGRlcGVuZCBvbiB0aGVcblx0XHRcdFx0Ly8gd2lkZ2V0IGJlaW5nIGF0dGFjaGVkIHRvIHRoZSBET00gc2luY2UgaXQgaXNuJ3Qgd2hlbiBhIHdpZGdldCBpcyBjcmVhdGVkIHByb2dyYW1tYXRpY2FsbHkgbGlrZVxuXHRcdFx0XHQvLyBuZXcgTXlXaWRnZXQoe30pLlx0U2VlICMxMTYzNS5cblx0XHRcdFx0dmFyIHNvdXJjZSA9IHRoaXMuc3JjTm9kZVJlZjtcblx0XHRcdFx0aWYoc291cmNlICYmIHNvdXJjZS5wYXJlbnROb2RlICYmIHRoaXMuZG9tTm9kZSAhPT0gc291cmNlKXtcblx0XHRcdFx0XHRzb3VyY2UucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5kb21Ob2RlLCBzb3VyY2UpO1xuXHRcdFx0XHRcdGRlbGV0ZVNyY05vZGVSZWYgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTm90ZTogZm9yIDIuMCBtYXkgd2FudCB0byByZW5hbWUgd2lkZ2V0SWQgdG8gZG9qby5fc2NvcGVOYW1lICsgXCJfd2lkZ2V0SWRcIixcblx0XHRcdFx0Ly8gYXNzdW1pbmcgdGhhdCBkb2pvLl9zY29wZU5hbWUgZXZlbiBleGlzdHMgaW4gMi4wXG5cdFx0XHRcdHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWRnZXRJZFwiLCB0aGlzLmlkKTtcblx0XHRcdH1cblx0XHRcdHRoaXMucG9zdENyZWF0ZSgpO1xuXG5cdFx0XHQvLyBJZiBzcmNOb2RlUmVmIGhhcyBiZWVuIHByb2Nlc3NlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBET00gKGUuZy4gVGVtcGxhdGVkV2lkZ2V0KSB0aGVuIGRlbGV0ZSBpdCB0byBhbGxvdyBHQy5cblx0XHRcdC8vIEkgdGhpbmsgZm9yIGJhY2stY29tcGF0aWJpbGl0eSBpdCBpc24ndCBkZWxldGluZyBzcmNOb2RlUmVmIHVudGlsIGFmdGVyIHBvc3RDcmVhdGUoKSBoYXMgcnVuLlxuXHRcdFx0aWYoZGVsZXRlU3JjTm9kZVJlZil7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLnNyY05vZGVSZWY7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2NyZWF0ZWQgPSB0cnVlO1xuXHRcdH0sXG5cblx0XHRfYXBwbHlBdHRyaWJ1dGVzOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFN0ZXAgZHVyaW5nIHdpZGdldCBjcmVhdGlvbiB0byBjb3B5ICB3aWRnZXQgYXR0cmlidXRlcyB0byB0aGVcblx0XHRcdC8vXHRcdERPTSBhY2NvcmRpbmcgdG8gYXR0cmlidXRlTWFwIGFuZCBfc2V0WFhYQXR0ciBvYmplY3RzLCBhbmQgYWxzbyB0byBjYWxsXG5cdFx0XHQvL1x0XHRjdXN0b20gX3NldFhYWEF0dHIoKSBtZXRob2RzLlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdFNraXBzIG92ZXIgYmxhbmsvZmFsc2UgYXR0cmlidXRlIHZhbHVlcywgdW5sZXNzIHRoZXkgd2VyZSBleHBsaWNpdGx5IHNwZWNpZmllZFxuXHRcdFx0Ly9cdFx0YXMgcGFyYW1ldGVycyB0byB0aGUgd2lkZ2V0LCBzaW5jZSB0aG9zZSBhcmUgdGhlIGRlZmF1bHQgYW55d2F5LFxuXHRcdFx0Ly9cdFx0YW5kIHNldHRpbmcgdGFiSW5kZXg9XCJcIiBpcyBkaWZmZXJlbnQgdGhhbiBub3Qgc2V0dGluZyB0YWJJbmRleCBhdCBhbGwuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Rm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHJlYXNvbnMgYXR0cmlidXRlTWFwIG92ZXJyaWRlcyBfc2V0WFhYQXR0ciB3aGVuXG5cdFx0XHQvL1x0XHRfc2V0WFhYQXR0ciBpcyBhIGhhc2gvc3RyaW5nL2FycmF5LCBidXQgX3NldFhYWEF0dHIgYXMgYSBmdW5jdGlvbnMgb3ZlcnJpZGUgYXR0cmlidXRlTWFwLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByaXZhdGVcblxuXHRcdFx0Ly8gQ2FsbCB0aGlzLnNldCgpIGZvciBlYWNoIHByb3BlcnR5IHRoYXQgd2FzIGVpdGhlciBzcGVjaWZpZWQgYXMgcGFyYW1ldGVyIHRvIGNvbnN0cnVjdG9yLFxuXHRcdFx0Ly8gb3IgaXMgaW4gdGhlIGxpc3QgZm91bmQgYWJvdmUuXHRGb3IgY29ycmVsYXRlZCBwcm9wZXJ0aWVzIGxpa2UgdmFsdWUgYW5kIGRpc3BsYXllZFZhbHVlLCB0aGUgb25lXG5cdFx0XHQvLyBzcGVjaWZpZWQgYXMgYSBwYXJhbWV0ZXIgc2hvdWxkIHRha2UgcHJlY2VkZW5jZS5cblx0XHRcdC8vIFBhcnRpY3VsYXJseSBpbXBvcnRhbnQgZm9yIG5ldyBEYXRlVGV4dEJveCh7ZGlzcGxheWVkVmFsdWU6IC4uLn0pIHNpbmNlIERhdGVUZXh0Qm94J3MgZGVmYXVsdCB2YWx1ZSBpc1xuXHRcdFx0Ly8gTmFOIGFuZCB0aHVzIGlzIG5vdCBpZ25vcmVkIGxpa2UgYSBkZWZhdWx0IHZhbHVlIG9mIFwiXCIuXG5cblx0XHRcdC8vIFN0ZXAgMTogU2F2ZSB0aGUgY3VycmVudCB2YWx1ZXMgb2YgdGhlIHdpZGdldCBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBzcGVjaWZpZWQgYXMgcGFyYW1ldGVycyB0byB0aGUgY29uc3RydWN0b3IuXG5cdFx0XHQvLyBHZW5lcmFsbHkgdGhpcy5mb28gPT0gdGhpcy5wYXJhbXMuZm9vLCBleGNlcHQgaWYgcG9zdE1peEluUHJvcGVydGllcygpIGNoYW5nZWQgdGhlIHZhbHVlIG9mIHRoaXMuZm9vLlxuXHRcdFx0dmFyIHBhcmFtcyA9IHt9O1xuXHRcdFx0Zm9yKHZhciBrZXkgaW4gdGhpcy5wYXJhbXMgfHwge30pe1xuXHRcdFx0XHRwYXJhbXNba2V5XSA9IHRoaXMuX2dldChrZXkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGVwIDI6IENhbGwgc2V0KCkgZm9yIGVhY2ggcHJvcGVydHkgd2l0aCBhIG5vbi1mYWxzeSB2YWx1ZSB0aGF0IHdhc24ndCBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgdG8gdGhlIGNvbnN0cnVjdG9yXG5cdFx0XHRhcnJheS5mb3JFYWNoKHRoaXMuY29uc3RydWN0b3IuX3NldHRlckF0dHJzLCBmdW5jdGlvbihrZXkpe1xuXHRcdFx0XHRpZighKGtleSBpbiBwYXJhbXMpKXtcblx0XHRcdFx0XHR2YXIgdmFsID0gdGhpcy5fZ2V0KGtleSk7XG5cdFx0XHRcdFx0aWYodmFsKXtcblx0XHRcdFx0XHRcdHRoaXMuc2V0KGtleSwgdmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHQvLyBTdGVwIDM6IENhbGwgc2V0KCkgZm9yIGVhY2ggcHJvcGVydHkgdGhhdCB3YXMgc3BlY2lmaWVkIGFzIHBhcmFtZXRlciB0byBjb25zdHJ1Y3Rvci5cblx0XHRcdC8vIFVzZSBwYXJhbXMgaGFzaCBjcmVhdGVkIGFib3ZlIHRvIGlnbm9yZSBzaWRlIGVmZmVjdHMgZnJvbSBzdGVwICMyIGFib3ZlLlxuXHRcdFx0Zm9yKGtleSBpbiBwYXJhbXMpe1xuXHRcdFx0XHR0aGlzLnNldChrZXksIHBhcmFtc1trZXldKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cG9zdE1peEluUHJvcGVydGllczogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYWxsZWQgYWZ0ZXIgdGhlIHBhcmFtZXRlcnMgdG8gdGhlIHdpZGdldCBoYXZlIGJlZW4gcmVhZC1pbixcblx0XHRcdC8vXHRcdGJ1dCBiZWZvcmUgdGhlIHdpZGdldCB0ZW1wbGF0ZSBpcyBpbnN0YW50aWF0ZWQuIEVzcGVjaWFsbHlcblx0XHRcdC8vXHRcdHVzZWZ1bCB0byBzZXQgcHJvcGVydGllcyB0aGF0IGFyZSByZWZlcmVuY2VkIGluIHRoZSB3aWRnZXRcblx0XHRcdC8vXHRcdHRlbXBsYXRlLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXHRcdH0sXG5cblx0XHRidWlsZFJlbmRlcmluZzogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDb25zdHJ1Y3QgdGhlIFVJIGZvciB0aGlzIHdpZGdldCwgc2V0dGluZyB0aGlzLmRvbU5vZGUuXG5cdFx0XHQvL1x0XHRNb3N0IHdpZGdldHMgd2lsbCBtaXhpbiBgZGlqaXQuX1RlbXBsYXRlZE1peGluYCwgd2hpY2ggaW1wbGVtZW50cyB0aGlzIG1ldGhvZC5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblxuXHRcdFx0aWYoIXRoaXMuZG9tTm9kZSl7XG5cdFx0XHRcdC8vIENyZWF0ZSByb290IG5vZGUgaWYgaXQgd2Fzbid0IGNyZWF0ZWQgYnkgX1RlbXBsYXRlZE1peGluXG5cdFx0XHRcdHRoaXMuZG9tTm9kZSA9IHRoaXMuc3JjTm9kZVJlZiB8fCB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFzZUNsYXNzIGlzIGEgc2luZ2xlIGNsYXNzIG5hbWUgb3Igb2NjYXNpb25hbGx5IGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgbmFtZXMuXG5cdFx0XHQvLyBBZGQgdGhvc2UgY2xhc3NlcyB0byB0aGUgRE9NTm9kZS4gIElmIFJUTCBtb2RlIHRoZW4gYWxzbyBhZGQgd2l0aCBSdGwgc3VmZml4LlxuXHRcdFx0Ly8gVE9ETzogbWFrZSBiYXNlQ2xhc3MgY3VzdG9tIHNldHRlclxuXHRcdFx0aWYodGhpcy5iYXNlQ2xhc3Mpe1xuXHRcdFx0XHR2YXIgY2xhc3NlcyA9IHRoaXMuYmFzZUNsYXNzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0aWYoIXRoaXMuaXNMZWZ0VG9SaWdodCgpKXtcblx0XHRcdFx0XHRjbGFzc2VzID0gY2xhc3Nlcy5jb25jYXQoYXJyYXkubWFwKGNsYXNzZXMsIGZ1bmN0aW9uKG5hbWUpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5hbWUgKyBcIlJ0bFwiO1xuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkb21DbGFzcy5hZGQodGhpcy5kb21Ob2RlLCBjbGFzc2VzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cG9zdENyZWF0ZTogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRQcm9jZXNzaW5nIGFmdGVyIHRoZSBET00gZnJhZ21lbnQgaXMgY3JlYXRlZFxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRDYWxsZWQgYWZ0ZXIgdGhlIERPTSBmcmFnbWVudCBoYXMgYmVlbiBjcmVhdGVkLCBidXQgbm90IG5lY2Vzc2FyaWx5XG5cdFx0XHQvL1x0XHRhZGRlZCB0byB0aGUgZG9jdW1lbnQuICBEbyBub3QgaW5jbHVkZSBhbnkgb3BlcmF0aW9ucyB3aGljaCByZWx5IG9uXG5cdFx0XHQvL1x0XHRub2RlIGRpbWVuc2lvbnMgb3IgcGxhY2VtZW50LlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXHRcdH0sXG5cblx0XHRzdGFydHVwOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFByb2Nlc3NpbmcgYWZ0ZXIgdGhlIERPTSBmcmFnbWVudCBpcyBhZGRlZCB0byB0aGUgZG9jdW1lbnRcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0Q2FsbGVkIGFmdGVyIGEgd2lkZ2V0IGFuZCBpdHMgY2hpbGRyZW4gaGF2ZSBiZWVuIGNyZWF0ZWQgYW5kIGFkZGVkIHRvIHRoZSBwYWdlLFxuXHRcdFx0Ly9cdFx0YW5kIGFsbCByZWxhdGVkIHdpZGdldHMgaGF2ZSBmaW5pc2hlZCB0aGVpciBjcmVhdGUoKSBjeWNsZSwgdXAgdGhyb3VnaCBwb3N0Q3JlYXRlKCkuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Tm90ZSB0aGF0IHN0YXJ0dXAoKSBtYXkgYmUgY2FsbGVkIHdoaWxlIHRoZSB3aWRnZXQgaXMgc3RpbGwgaGlkZGVuLCBmb3IgZXhhbXBsZSBpZiB0aGUgd2lkZ2V0IGlzXG5cdFx0XHQvL1x0XHRpbnNpZGUgYSBoaWRkZW4gZGlqaXQvRGlhbG9nIG9yIGFuIHVuc2VsZWN0ZWQgdGFiIG9mIGEgZGlqaXQvbGF5b3V0L1RhYkNvbnRhaW5lci5cblx0XHRcdC8vXHRcdEZvciB3aWRnZXRzIHRoYXQgbmVlZCB0byBkbyBsYXlvdXQsIGl0J3MgYmVzdCB0byBwdXQgdGhhdCBsYXlvdXQgY29kZSBpbnNpZGUgcmVzaXplKCksIGFuZCB0aGVuXG5cdFx0XHQvL1x0XHRleHRlbmQgZGlqaXQvbGF5b3V0L19MYXlvdXRXaWRnZXQgc28gdGhhdCByZXNpemUoKSBpcyBjYWxsZWQgd2hlbiB0aGUgd2lkZ2V0IGlzIHZpc2libGUuXG5cdFx0XHRpZih0aGlzLl9zdGFydGVkKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc3RhcnRlZCA9IHRydWU7XG5cdFx0XHRhcnJheS5mb3JFYWNoKHRoaXMuZ2V0Q2hpbGRyZW4oKSwgZnVuY3Rpb24ob2JqKXtcblx0XHRcdFx0aWYoIW9iai5fc3RhcnRlZCAmJiAhb2JqLl9kZXN0cm95ZWQgJiYgbGFuZy5pc0Z1bmN0aW9uKG9iai5zdGFydHVwKSl7XG5cdFx0XHRcdFx0b2JqLnN0YXJ0dXAoKTtcblx0XHRcdFx0XHRvYmouX3N0YXJ0ZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Ly8vLy8vLy8vLy8vIERFU1RST1kgRlVOQ1RJT05TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0XHRkZXN0cm95UmVjdXJzaXZlOiBmdW5jdGlvbigvKkJvb2xlYW4/Ki8gcHJlc2VydmVEb20pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERlc3Ryb3kgdGhpcyB3aWRnZXQgYW5kIGl0cyBkZXNjZW5kYW50c1xuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRUaGlzIGlzIHRoZSBnZW5lcmljIFwiZGVzdHJ1Y3RvclwiIGZ1bmN0aW9uIHRoYXQgYWxsIHdpZGdldCB1c2Vyc1xuXHRcdFx0Ly9cdFx0c2hvdWxkIGNhbGwgdG8gY2xlYW5seSBkaXNjYXJkIHdpdGggYSB3aWRnZXQuIE9uY2UgYSB3aWRnZXQgaXNcblx0XHRcdC8vXHRcdGRlc3Ryb3llZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYW5hZ2VyIG9iamVjdC5cblx0XHRcdC8vIHByZXNlcnZlRG9tOlxuXHRcdFx0Ly9cdFx0SWYgdHJ1ZSwgdGhpcyBtZXRob2Qgd2lsbCBsZWF2ZSB0aGUgb3JpZ2luYWwgRE9NIHN0cnVjdHVyZVxuXHRcdFx0Ly9cdFx0YWxvbmUgb2YgZGVzY2VuZGFudCBXaWRnZXRzLiBOb3RlOiBUaGlzIHdpbGwgTk9UIHdvcmsgd2l0aFxuXHRcdFx0Ly9cdFx0ZGlqaXQuX1RlbXBsYXRlZE1peGluIHdpZGdldHMuXG5cblx0XHRcdHRoaXMuX2JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuZGVzdHJveURlc2NlbmRhbnRzKHByZXNlcnZlRG9tKTtcblx0XHRcdHRoaXMuZGVzdHJveShwcmVzZXJ2ZURvbSk7XG5cdFx0fSxcblxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKC8qQm9vbGVhbiovIHByZXNlcnZlRG9tKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXN0cm95IHRoaXMgd2lkZ2V0LCBidXQgbm90IGl0cyBkZXNjZW5kYW50cy4gIERlc2NlbmRhbnRzIG1lYW5zIHdpZGdldHMgaW5zaWRlIG9mXG5cdFx0XHQvL1x0XHR0aGlzLmNvbnRhaW5lck5vZGUuICAgV2lsbCBhbHNvIGRlc3Ryb3kgYW55IHJlc291cmNlcyAoaW5jbHVkaW5nIHdpZGdldHMpIHJlZ2lzdGVyZWQgdmlhIHRoaXMub3duKCkuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VGhpcyBtZXRob2Qgd2lsbCBhbHNvIGRlc3Ryb3kgaW50ZXJuYWwgd2lkZ2V0cyBzdWNoIGFzIHRob3NlIGNyZWF0ZWQgZnJvbSBhIHRlbXBsYXRlLFxuXHRcdFx0Ly9cdFx0YXNzdW1pbmcgdGhvc2Ugd2lkZ2V0cyBleGlzdCBpbnNpZGUgb2YgdGhpcy5kb21Ob2RlIGJ1dCBvdXRzaWRlIG9mIHRoaXMuY29udGFpbmVyTm9kZS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRGb3IgMi4wIGl0J3MgcGxhbm5lZCB0aGF0IHRoaXMgbWV0aG9kIHdpbGwgYWxzbyBkZXN0cm95IGRlc2NlbmRhbnQgd2lkZ2V0cywgc28gYXBwcyBzaG91bGQgbm90XG5cdFx0XHQvL1x0XHRkZXBlbmQgb24gdGhlIGN1cnJlbnQgYWJpbGl0eSB0byBkZXN0cm95IGEgd2lkZ2V0IHdpdGhvdXQgZGVzdHJveWluZyBpdHMgZGVzY2VuZGFudHMuICAgR2VuZXJhbGx5XG5cdFx0XHQvL1x0XHR0aGV5IHNob3VsZCB1c2UgZGVzdHJveVJlY3Vyc2l2ZSgpIGZvciB3aWRnZXRzIHdpdGggY2hpbGRyZW4uXG5cdFx0XHQvLyBwcmVzZXJ2ZURvbTogQm9vbGVhblxuXHRcdFx0Ly9cdFx0SWYgdHJ1ZSwgdGhpcyBtZXRob2Qgd2lsbCBsZWF2ZSB0aGUgb3JpZ2luYWwgRE9NIHN0cnVjdHVyZSBhbG9uZS5cblx0XHRcdC8vXHRcdE5vdGU6IFRoaXMgd2lsbCBub3QgeWV0IHdvcmsgd2l0aCBfVGVtcGxhdGVkTWl4aW4gd2lkZ2V0c1xuXG5cdFx0XHR0aGlzLl9iZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG5cdFx0XHR0aGlzLnVuaW5pdGlhbGl6ZSgpO1xuXG5cdFx0XHRmdW5jdGlvbiBkZXN0cm95KHcpe1xuXHRcdFx0XHRpZih3LmRlc3Ryb3lSZWN1cnNpdmUpe1xuXHRcdFx0XHRcdHcuZGVzdHJveVJlY3Vyc2l2ZShwcmVzZXJ2ZURvbSk7XG5cdFx0XHRcdH1lbHNlIGlmKHcuZGVzdHJveSl7XG5cdFx0XHRcdFx0dy5kZXN0cm95KHByZXNlcnZlRG9tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBCYWNrLWNvbXBhdCwgcmVtb3ZlIGZvciAyLjBcblx0XHRcdGFycmF5LmZvckVhY2godGhpcy5fY29ubmVjdHMsIGxhbmcuaGl0Y2godGhpcywgXCJkaXNjb25uZWN0XCIpKTtcblx0XHRcdGFycmF5LmZvckVhY2godGhpcy5fc3VwcG9ydGluZ1dpZGdldHMsIGRlc3Ryb3kpO1xuXG5cdFx0XHQvLyBEZXN0cm95IHN1cHBvcnRpbmcgd2lkZ2V0cywgYnV0IG5vdCBjaGlsZCB3aWRnZXRzIHVuZGVyIHRoaXMuY29udGFpbmVyTm9kZSAoZm9yIDIuMCwgZGVzdHJveSBjaGlsZCB3aWRnZXRzXG5cdFx0XHQvLyBoZXJlIHRvbykuICAgaWYoKSBzdGF0ZW1lbnQgaXMgdG8gZ3VhcmQgYWdhaW5zdCBleGNlcHRpb24gaWYgZGVzdHJveSgpIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyAoc2VlICMxNTgxNSkuXG5cdFx0XHRpZih0aGlzLmRvbU5vZGUpe1xuXHRcdFx0XHRhcnJheS5mb3JFYWNoKHJlZ2lzdHJ5LmZpbmRXaWRnZXRzKHRoaXMuZG9tTm9kZSwgdGhpcy5jb250YWluZXJOb2RlKSwgZGVzdHJveSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZGVzdHJveVJlbmRlcmluZyhwcmVzZXJ2ZURvbSk7XG5cdFx0XHRyZWdpc3RyeS5yZW1vdmUodGhpcy5pZCk7XG5cdFx0XHR0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuXHRcdH0sXG5cblx0XHRkZXN0cm95UmVuZGVyaW5nOiBmdW5jdGlvbigvKkJvb2xlYW4/Ki8gcHJlc2VydmVEb20pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERlc3Ryb3lzIHRoZSBET00gbm9kZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd2lkZ2V0LlxuXHRcdFx0Ly8gcHJlc2VydmVEb206XG5cdFx0XHQvL1x0XHRJZiB0cnVlLCB0aGlzIG1ldGhvZCB3aWxsIGxlYXZlIHRoZSBvcmlnaW5hbCBET00gc3RydWN0dXJlIGFsb25lXG5cdFx0XHQvL1x0XHRkdXJpbmcgdGVhci1kb3duLiBOb3RlOiB0aGlzIHdpbGwgbm90IHdvcmsgd2l0aCBfVGVtcGxhdGVkXG5cdFx0XHQvL1x0XHR3aWRnZXRzIHlldC5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblxuXHRcdFx0aWYodGhpcy5iZ0lmcmFtZSl7XG5cdFx0XHRcdHRoaXMuYmdJZnJhbWUuZGVzdHJveShwcmVzZXJ2ZURvbSk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmJnSWZyYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLmRvbU5vZGUpe1xuXHRcdFx0XHRpZihwcmVzZXJ2ZURvbSl7XG5cdFx0XHRcdFx0ZG9tQXR0ci5yZW1vdmUodGhpcy5kb21Ob2RlLCBcIndpZGdldElkXCIpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRkb21Db25zdHJ1Y3QuZGVzdHJveSh0aGlzLmRvbU5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmRvbU5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuc3JjTm9kZVJlZil7XG5cdFx0XHRcdGlmKCFwcmVzZXJ2ZURvbSl7XG5cdFx0XHRcdFx0ZG9tQ29uc3RydWN0LmRlc3Ryb3kodGhpcy5zcmNOb2RlUmVmKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgdGhpcy5zcmNOb2RlUmVmO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRkZXN0cm95RGVzY2VuZGFudHM6IGZ1bmN0aW9uKC8qQm9vbGVhbj8qLyBwcmVzZXJ2ZURvbSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVjdXJzaXZlbHkgZGVzdHJveSB0aGUgY2hpbGRyZW4gb2YgdGhpcyB3aWRnZXQgYW5kIHRoZWlyXG5cdFx0XHQvL1x0XHRkZXNjZW5kYW50cy5cblx0XHRcdC8vIHByZXNlcnZlRG9tOlxuXHRcdFx0Ly9cdFx0SWYgdHJ1ZSwgdGhlIHByZXNlcnZlRG9tIGF0dHJpYnV0ZSBpcyBwYXNzZWQgdG8gYWxsIGRlc2NlbmRhbnRcblx0XHRcdC8vXHRcdHdpZGdldCdzIC5kZXN0cm95KCkgbWV0aG9kLiBOb3QgZm9yIHVzZSB3aXRoIF9UZW1wbGF0ZWRcblx0XHRcdC8vXHRcdHdpZGdldHMuXG5cblx0XHRcdC8vIGdldCBhbGwgZGlyZWN0IGRlc2NlbmRhbnRzIGFuZCBkZXN0cm95IHRoZW0gcmVjdXJzaXZlbHlcblx0XHRcdGFycmF5LmZvckVhY2godGhpcy5nZXRDaGlsZHJlbigpLCBmdW5jdGlvbih3aWRnZXQpe1xuXHRcdFx0XHRpZih3aWRnZXQuZGVzdHJveVJlY3Vyc2l2ZSl7XG5cdFx0XHRcdFx0d2lkZ2V0LmRlc3Ryb3lSZWN1cnNpdmUocHJlc2VydmVEb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0dW5pbml0aWFsaXplOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERlcHJlY2F0ZWQuIE92ZXJyaWRlIGRlc3Ryb3koKSBpbnN0ZWFkIHRvIGltcGxlbWVudCBjdXN0b20gd2lkZ2V0IHRlYXItZG93blxuXHRcdFx0Ly9cdFx0YmVoYXZpb3IuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8vLy8vLy8vLy8vLy8vLy8vLyBHRVQvU0VULCBDVVNUT00gU0VUVEVSUywgRVRDLiAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0XHRfc2V0U3R5bGVBdHRyOiBmdW5jdGlvbigvKlN0cmluZ3x8T2JqZWN0Ki8gdmFsdWUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFNldHMgdGhlIHN0eWxlIGF0dHJpYnV0ZSBvZiB0aGUgd2lkZ2V0IGFjY29yZGluZyB0byB2YWx1ZSxcblx0XHRcdC8vXHRcdHdoaWNoIGlzIGVpdGhlciBhIGhhc2ggbGlrZSB7aGVpZ2h0OiBcIjVweFwiLCB3aWR0aDogXCIzcHhcIn1cblx0XHRcdC8vXHRcdG9yIGEgcGxhaW4gc3RyaW5nXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdERldGVybWluZXMgd2hpY2ggbm9kZSB0byBzZXQgdGhlIHN0eWxlIG9uIGJhc2VkIG9uIHN0eWxlIHNldHRpbmdcblx0XHRcdC8vXHRcdGluIGF0dHJpYnV0ZU1hcC5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblxuXHRcdFx0dmFyIG1hcE5vZGUgPSB0aGlzLmRvbU5vZGU7XG5cblx0XHRcdC8vIE5vdGU6IHRlY2huaWNhbGx5IHdlIHNob3VsZCByZXZlcnQgYW55IHN0eWxlIHNldHRpbmcgbWFkZSBpbiBhIHByZXZpb3VzIGNhbGxcblx0XHRcdC8vIHRvIGhpcyBtZXRob2QsIGJ1dCB0aGF0J3MgZGlmZmljdWx0IHRvIGtlZXAgdHJhY2sgb2YuXG5cblx0XHRcdGlmKGxhbmcuaXNPYmplY3QodmFsdWUpKXtcblx0XHRcdFx0ZG9tU3R5bGUuc2V0KG1hcE5vZGUsIHZhbHVlKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRpZihtYXBOb2RlLnN0eWxlLmNzc1RleHQpe1xuXHRcdFx0XHRcdG1hcE5vZGUuc3R5bGUuY3NzVGV4dCArPSBcIjsgXCIgKyB2YWx1ZTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0bWFwTm9kZS5zdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2V0KFwic3R5bGVcIiwgdmFsdWUpO1xuXHRcdH0sXG5cblx0XHRfYXR0clRvRG9tOiBmdW5jdGlvbigvKlN0cmluZyovIGF0dHIsIC8qU3RyaW5nKi8gdmFsdWUsIC8qT2JqZWN0PyovIGNvbW1hbmRzKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZWZsZWN0IGEgd2lkZ2V0IGF0dHJpYnV0ZSAodGl0bGUsIHRhYkluZGV4LCBkdXJhdGlvbiBldGMuKSB0b1xuXHRcdFx0Ly9cdFx0dGhlIHdpZGdldCBET00sIGFzIHNwZWNpZmllZCBieSBjb21tYW5kcyBwYXJhbWV0ZXIuXG5cdFx0XHQvL1x0XHRJZiBjb21tYW5kcyBpc24ndCBzcGVjaWZpZWQgdGhlbiBpdCdzIGxvb2tlZCB1cCBmcm9tIGF0dHJpYnV0ZU1hcC5cblx0XHRcdC8vXHRcdE5vdGUgc29tZSBhdHRyaWJ1dGVzIGxpa2UgXCJ0eXBlXCJcblx0XHRcdC8vXHRcdGNhbm5vdCBiZSBwcm9jZXNzZWQgdGhpcyB3YXkgYXMgdGhleSBhcmUgbm90IG11dGFibGUuXG5cdFx0XHQvLyBhdHRyOlxuXHRcdFx0Ly9cdFx0TmFtZSBvZiBtZW1iZXIgdmFyaWFibGUgKGV4OiBcImZvY3VzTm9kZVwiIG1hcHMgdG8gdGhpcy5mb2N1c05vZGUpIHBvaW50aW5nXG5cdFx0XHQvL1x0XHR0byBET01Ob2RlIGluc2lkZSB0aGUgd2lkZ2V0LCBvciBhbHRlcm5hdGVseSBwb2ludGluZyB0byBhIHN1YndpZGdldFxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByaXZhdGVcblxuXHRcdFx0Y29tbWFuZHMgPSBhcmd1bWVudHMubGVuZ3RoID49IDMgPyBjb21tYW5kcyA6IHRoaXMuYXR0cmlidXRlTWFwW2F0dHJdO1xuXG5cdFx0XHRhcnJheS5mb3JFYWNoKGxhbmcuaXNBcnJheShjb21tYW5kcykgPyBjb21tYW5kcyA6IFtjb21tYW5kc10sIGZ1bmN0aW9uKGNvbW1hbmQpe1xuXG5cdFx0XHRcdC8vIEdldCB0YXJnZXQgbm9kZSBhbmQgd2hhdCB3ZSBhcmUgZG9pbmcgdG8gdGhhdCBub2RlXG5cdFx0XHRcdHZhciBtYXBOb2RlID0gdGhpc1tjb21tYW5kLm5vZGUgfHwgY29tbWFuZCB8fCBcImRvbU5vZGVcIl07XHQvLyBET00gbm9kZVxuXHRcdFx0XHR2YXIgdHlwZSA9IGNvbW1hbmQudHlwZSB8fCBcImF0dHJpYnV0ZVwiO1x0Ly8gY2xhc3MsIGlubmVySFRNTCwgaW5uZXJUZXh0LCBvciBhdHRyaWJ1dGVcblxuXHRcdFx0XHRzd2l0Y2godHlwZSl7XG5cdFx0XHRcdFx0Y2FzZSBcImF0dHJpYnV0ZVwiOlxuXHRcdFx0XHRcdFx0aWYobGFuZy5pc0Z1bmN0aW9uKHZhbHVlKSl7IC8vIGZ1bmN0aW9ucyBleGVjdXRlIGluIHRoZSBjb250ZXh0IG9mIHRoZSB3aWRnZXRcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBsYW5nLmhpdGNoKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBuYW1lIG9mIHRoZSBET00gbm9kZSBhdHRyaWJ1dGU7IHVzdWFsbHkgaXQncyB0aGUgc2FtZVxuXHRcdFx0XHRcdFx0Ly8gYXMgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBpbiB0aGUgd2lkZ2V0IChhdHRyKSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuLlxuXHRcdFx0XHRcdFx0Ly8gQWxzbyBtYXBzIGhhbmRsZXIgbmFtZXMgdG8gbG93ZXJjYXNlLCBsaWtlIG9uU3VibWl0IC0tPiBvbnN1Ym1pdFxuXHRcdFx0XHRcdFx0dmFyIGF0dHJOYW1lID0gY29tbWFuZC5hdHRyaWJ1dGUgPyBjb21tYW5kLmF0dHJpYnV0ZSA6XG5cdFx0XHRcdFx0XHRcdCgvXm9uW0EtWl1bYS16QS1aXSokLy50ZXN0KGF0dHIpID8gYXR0ci50b0xvd2VyQ2FzZSgpIDogYXR0cik7XG5cblx0XHRcdFx0XHRcdGlmKG1hcE5vZGUudGFnTmFtZSl7XG5cdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBjYXNlLCBtYXBwaW5nIHRvIGEgRE9NTm9kZS4gIE5vdGUgdGhhdCBtb2Rlcm4gYnJvd3NlcnMgd2lsbCBoYXZlIGEgbWFwTm9kZS5zZXQoKVxuXHRcdFx0XHRcdFx0XHQvLyBtZXRob2QsIGJ1dCBmb3IgY29uc2lzdGVuY3kgd2Ugc3RpbGwgY2FsbCBkb21BdHRyXG5cdFx0XHRcdFx0XHRcdGRvbUF0dHIuc2V0KG1hcE5vZGUsIGF0dHJOYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0Ly8gbWFwcGluZyB0byBhIHN1Yi13aWRnZXRcblx0XHRcdFx0XHRcdFx0bWFwTm9kZS5zZXQoYXR0ck5hbWUsIHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJpbm5lclRleHRcIjpcblx0XHRcdFx0XHRcdC8vIERlcHJlY2F0ZWQsIHVzZSBcInRleHRDb250ZW50XCIgaW5zdGVhZC5cblx0XHRcdFx0XHRcdG1hcE5vZGUuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRcdFx0XHRcdG1hcE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwidGV4dENvbnRlbnRcIjpcblx0XHRcdFx0XHRcdG1hcE5vZGUudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJpbm5lckhUTUxcIjpcblx0XHRcdFx0XHRcdG1hcE5vZGUuaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiY2xhc3NcIjpcblx0XHRcdFx0XHRcdGRvbUNsYXNzLnJlcGxhY2UobWFwTm9kZSwgdmFsdWUsIHRoaXNbYXR0cl0pO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcInRvZ2dsZUNsYXNzXCI6XG5cdFx0XHRcdFx0XHRkb21DbGFzcy50b2dnbGUobWFwTm9kZSwgY29tbWFuZC5jbGFzc05hbWUgfHwgYXR0ciwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRnZXQ6IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEdldCBhIHByb3BlcnR5IGZyb20gYSB3aWRnZXQuXG5cdFx0XHQvLyBuYW1lOlxuXHRcdFx0Ly9cdFx0VGhlIHByb3BlcnR5IHRvIGdldC5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0R2V0IGEgbmFtZWQgcHJvcGVydHkgZnJvbSBhIHdpZGdldC4gVGhlIHByb3BlcnR5IG1heVxuXHRcdFx0Ly9cdFx0cG90ZW50aWFsbHkgYmUgcmV0cmlldmVkIHZpYSBhIGdldHRlciBtZXRob2QuIElmIG5vIGdldHRlciBpcyBkZWZpbmVkLCB0aGlzXG5cdFx0XHQvL1x0XHRqdXN0IHJldHJpZXZlcyB0aGUgb2JqZWN0J3MgcHJvcGVydHkuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Rm9yIGV4YW1wbGUsIGlmIHRoZSB3aWRnZXQgaGFzIHByb3BlcnRpZXMgYGZvb2AgYW5kIGBiYXJgXG5cdFx0XHQvL1x0XHRhbmQgYSBtZXRob2QgbmFtZWQgYF9nZXRGb29BdHRyKClgLCBjYWxsaW5nOlxuXHRcdFx0Ly9cdFx0YG15V2lkZ2V0LmdldChcImZvb1wiKWAgd291bGQgYmUgZXF1aXZhbGVudCB0byBjYWxsaW5nXG5cdFx0XHQvL1x0XHRgd2lkZ2V0Ll9nZXRGb29BdHRyKClgIGFuZCBgbXlXaWRnZXQuZ2V0KFwiYmFyXCIpYFxuXHRcdFx0Ly9cdFx0d291bGQgYmUgZXF1aXZhbGVudCB0byB0aGUgZXhwcmVzc2lvblxuXHRcdFx0Ly9cdFx0YHdpZGdldC5iYXIyYFxuXHRcdFx0dmFyIG5hbWVzID0gdGhpcy5fZ2V0QXR0ck5hbWVzKG5hbWUpO1xuXHRcdFx0cmV0dXJuIHRoaXNbbmFtZXMuZ10gPyB0aGlzW25hbWVzLmddKCkgOiB0aGlzLl9nZXQobmFtZSk7XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFNldCBhIHByb3BlcnR5IG9uIGEgd2lkZ2V0XG5cdFx0XHQvLyBuYW1lOlxuXHRcdFx0Ly9cdFx0VGhlIHByb3BlcnR5IHRvIHNldC5cblx0XHRcdC8vIHZhbHVlOlxuXHRcdFx0Ly9cdFx0VGhlIHZhbHVlIHRvIHNldCBpbiB0aGUgcHJvcGVydHkuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFNldHMgbmFtZWQgcHJvcGVydGllcyBvbiBhIHdpZGdldCB3aGljaCBtYXkgcG90ZW50aWFsbHkgYmUgaGFuZGxlZCBieSBhXG5cdFx0XHQvL1x0XHRzZXR0ZXIgaW4gdGhlIHdpZGdldC5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRGb3IgZXhhbXBsZSwgaWYgdGhlIHdpZGdldCBoYXMgcHJvcGVydGllcyBgZm9vYCBhbmQgYGJhcmBcblx0XHRcdC8vXHRcdGFuZCBhIG1ldGhvZCBuYW1lZCBgX3NldEZvb0F0dHIoKWAsIGNhbGxpbmdcblx0XHRcdC8vXHRcdGBteVdpZGdldC5zZXQoXCJmb29cIiwgXCJIb3dkeSFcIilgIHdvdWxkIGJlIGVxdWl2YWxlbnQgdG8gY2FsbGluZ1xuXHRcdFx0Ly9cdFx0YHdpZGdldC5fc2V0Rm9vQXR0cihcIkhvd2R5IVwiKWAgYW5kIGBteVdpZGdldC5zZXQoXCJiYXJcIiwgMylgXG5cdFx0XHQvL1x0XHR3b3VsZCBiZSBlcXVpdmFsZW50IHRvIHRoZSBzdGF0ZW1lbnQgYHdpZGdldC5iYXIgPSAzO2Bcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRzZXQoKSBtYXkgYWxzbyBiZSBjYWxsZWQgd2l0aCBhIGhhc2ggb2YgbmFtZS92YWx1ZSBwYWlycywgZXg6XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdHxcdG15V2lkZ2V0LnNldCh7XG5cdFx0XHQvL1x0fFx0XHRmb286IFwiSG93ZHlcIixcblx0XHRcdC8vXHR8XHRcdGJhcjogM1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vXHRUaGlzIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBgc2V0KGZvbywgXCJIb3dkeVwiKWAgYW5kIGBzZXQoYmFyLCAzKWBcblxuXHRcdFx0aWYodHlwZW9mIG5hbWUgPT09IFwib2JqZWN0XCIpe1xuXHRcdFx0XHRmb3IodmFyIHggaW4gbmFtZSl7XG5cdFx0XHRcdFx0dGhpcy5zZXQoeCwgbmFtZVt4XSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbmFtZXMgPSB0aGlzLl9nZXRBdHRyTmFtZXMobmFtZSksXG5cdFx0XHRcdHNldHRlciA9IHRoaXNbbmFtZXMuc107XG5cdFx0XHRpZihsYW5nLmlzRnVuY3Rpb24oc2V0dGVyKSl7XG5cdFx0XHRcdC8vIHVzZSB0aGUgZXhwbGljaXQgc2V0dGVyXG5cdFx0XHRcdHZhciByZXN1bHQgPSBzZXR0ZXIuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Ly8gTWFwcGluZyBmcm9tIHdpZGdldCBhdHRyaWJ1dGUgdG8gRE9NTm9kZS9zdWJ3aWRnZXQgYXR0cmlidXRlL3ZhbHVlL2V0Yy5cblx0XHRcdFx0Ly8gTWFwIGFjY29yZGluZyB0bzpcblx0XHRcdFx0Ly9cdFx0MS4gYXR0cmlidXRlTWFwIHNldHRpbmcsIGlmIG9uZSBleGlzdHMgKFRPRE86IGF0dHJpYnV0ZU1hcCBkZXByZWNhdGVkLCByZW1vdmUgaW4gMi4wKVxuXHRcdFx0XHQvL1x0XHQyLiBfc2V0Rm9vQXR0cjogey4uLn0gdHlwZSBhdHRyaWJ1dGUgaW4gdGhlIHdpZGdldCAoaWYgb25lIGV4aXN0cylcblx0XHRcdFx0Ly9cdFx0My4gYXBwbHkgdG8gZm9jdXNOb2RlIG9yIGRvbU5vZGUgaWYgc3RhbmRhcmQgYXR0cmlidXRlIG5hbWUsIGV4Y2x1ZGluZyBmdW5jcyBsaWtlIG9uQ2xpY2suXG5cdFx0XHRcdC8vIENoZWNrcyBpZiBhbiBhdHRyaWJ1dGUgaXMgYSBcInN0YW5kYXJkIGF0dHJpYnV0ZVwiIGJ5IHdoZXRoZXIgdGhlIERPTU5vZGUgSlMgb2JqZWN0IGhhcyBhIHNpbWlsYXJcblx0XHRcdFx0Ly8gYXR0cmlidXRlIG5hbWUgKGV4OiBhY2NlcHQtY2hhcnNldCBhdHRyaWJ1dGUgbWF0Y2hlcyBqc09iamVjdC5hY2NlcHRDaGFyc2V0KS5cblx0XHRcdFx0Ly8gTm90ZSBhbHNvIHRoYXQgVHJlZS5mb2N1c05vZGUoKSBpcyBhIGZ1bmN0aW9uIG5vdCBhIERPTU5vZGUsIHNvIHRlc3QgZm9yIHRoYXQuXG5cdFx0XHRcdHZhciBkZWZhdWx0Tm9kZSA9IHRoaXMuZm9jdXNOb2RlICYmICFsYW5nLmlzRnVuY3Rpb24odGhpcy5mb2N1c05vZGUpID8gXCJmb2N1c05vZGVcIiA6IFwiZG9tTm9kZVwiLFxuXHRcdFx0XHRcdHRhZyA9IHRoaXNbZGVmYXVsdE5vZGVdICYmIHRoaXNbZGVmYXVsdE5vZGVdLnRhZ05hbWUsXG5cdFx0XHRcdFx0YXR0cnNGb3JUYWcgPSB0YWcgJiYgKHRhZ0F0dHJzW3RhZ10gfHwgKHRhZ0F0dHJzW3RhZ10gPSBnZXRBdHRycyh0aGlzW2RlZmF1bHROb2RlXSkpKSxcblx0XHRcdFx0XHRtYXAgPSBuYW1lIGluIHRoaXMuYXR0cmlidXRlTWFwID8gdGhpcy5hdHRyaWJ1dGVNYXBbbmFtZV0gOlxuXHRcdFx0XHRcdFx0bmFtZXMucyBpbiB0aGlzID8gdGhpc1tuYW1lcy5zXSA6XG5cdFx0XHRcdFx0XHRcdCgoYXR0cnNGb3JUYWcgJiYgbmFtZXMubCBpbiBhdHRyc0ZvclRhZyAmJiB0eXBlb2YgdmFsdWUgIT0gXCJmdW5jdGlvblwiKSB8fFxuXHRcdFx0XHRcdFx0XHRcdC9eYXJpYS18XmRhdGEtfF5yb2xlJC8udGVzdChuYW1lKSkgPyBkZWZhdWx0Tm9kZSA6IG51bGw7XG5cdFx0XHRcdGlmKG1hcCAhPSBudWxsKXtcblx0XHRcdFx0XHR0aGlzLl9hdHRyVG9Eb20obmFtZSwgdmFsdWUsIG1hcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fc2V0KG5hbWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQgfHwgdGhpcztcblx0XHR9LFxuXG5cdFx0X2F0dHJQYWlyTmFtZXM6IHt9LCAvLyBzaGFyZWQgYmV0d2VlbiBhbGwgd2lkZ2V0c1xuXHRcdF9nZXRBdHRyTmFtZXM6IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0KCkgYW5kIHNldCgpLlxuXHRcdFx0Ly9cdFx0Q2FjaGVzIGF0dHJpYnV0ZSBuYW1lIHZhbHVlcyBzbyB3ZSBkb24ndCBkbyB0aGUgc3RyaW5nIG9wcyBldmVyeSB0aW1lLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByaXZhdGVcblxuXHRcdFx0dmFyIGFwbiA9IHRoaXMuX2F0dHJQYWlyTmFtZXM7XG5cdFx0XHRpZihhcG5bbmFtZV0pe1xuXHRcdFx0XHRyZXR1cm4gYXBuW25hbWVdO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHVjID0gbmFtZS5yZXBsYWNlKC9eW2Etel18LVthLXpBLVpdL2csIGZ1bmN0aW9uKGMpe1xuXHRcdFx0XHRyZXR1cm4gYy5jaGFyQXQoYy5sZW5ndGggLSAxKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gKGFwbltuYW1lXSA9IHtcblx0XHRcdFx0bjogbmFtZSArIFwiTm9kZVwiLFxuXHRcdFx0XHRzOiBcIl9zZXRcIiArIHVjICsgXCJBdHRyXCIsIC8vIGNvbnZlcnRzIGRhc2hlcyB0byBjYW1lbCBjYXNlLCBleDogYWNjZXB0LWNoYXJzZXQgLS0+IF9zZXRBY2NlcHRDaGFyc2V0QXR0clxuXHRcdFx0XHRnOiBcIl9nZXRcIiArIHVjICsgXCJBdHRyXCIsXG5cdFx0XHRcdGw6IHVjLnRvTG93ZXJDYXNlKCkgICAgICAgIC8vIGxvd2VyY2FzZSBuYW1lIHcvb3V0IGRhc2hlcywgZXg6IGFjY2VwdGNoYXJzZXRcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRfc2V0OiBmdW5jdGlvbigvKlN0cmluZyovIG5hbWUsIC8qYW55dGhpbmcqLyB2YWx1ZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0SGVscGVyIGZ1bmN0aW9uIHRvIHNldCBuZXcgdmFsdWUgZm9yIHNwZWNpZmllZCBwcm9wZXJ0eSwgYW5kIGNhbGwgaGFuZGxlcnNcblx0XHRcdC8vXHRcdHJlZ2lzdGVyZWQgd2l0aCB3YXRjaCgpIGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZC5cblx0XHRcdHZhciBvbGRWYWx1ZSA9IHRoaXNbbmFtZV07XG5cdFx0XHR0aGlzW25hbWVdID0gdmFsdWU7XG5cdFx0XHRpZih0aGlzLl9jcmVhdGVkICYmICFpc0VxdWFsKG9sZFZhbHVlLCB2YWx1ZSkpe1xuXHRcdFx0XHRpZih0aGlzLl93YXRjaENhbGxiYWNrcyl7XG5cdFx0XHRcdFx0dGhpcy5fd2F0Y2hDYWxsYmFja3MobmFtZSwgb2xkVmFsdWUsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmVtaXQoXCJhdHRybW9kaWZpZWQtXCIgKyBuYW1lLCB7XG5cdFx0XHRcdFx0ZGV0YWlsOiB7XG5cdFx0XHRcdFx0XHRwcmV2VmFsdWU6IG9sZFZhbHVlLFxuXHRcdFx0XHRcdFx0bmV3VmFsdWU6IHZhbHVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2dldDogZnVuY3Rpb24oLypTdHJpbmcqLyBuYW1lKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHZhbHVlIGZvciBzcGVjaWZpZWQgcHJvcGVydHkgc3RvcmVkIGJ5IHRoaXMuX3NldCgpLFxuXHRcdFx0Ly9cdFx0aS5lLiBmb3IgcHJvcGVydGllcyB3aXRoIGN1c3RvbSBzZXR0ZXJzLiAgVXNlZCBtYWlubHkgYnkgY3VzdG9tIGdldHRlcnMuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Rm9yIGV4YW1wbGUsIENoZWNrQm94Ll9nZXRWYWx1ZUF0dHIoKSBjYWxscyB0aGlzLl9nZXQoXCJ2YWx1ZVwiKS5cblxuXHRcdFx0Ly8gZnV0dXJlOiByZXR1cm4gbmFtZSBpbiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1tuYW1lXSA6IHRoaXNbbmFtZV07XG5cdFx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0XHR9LFxuXG5cdFx0ZW1pdDogZnVuY3Rpb24oLypTdHJpbmcqLyB0eXBlLCAvKk9iamVjdD8qLyBldmVudE9iaiwgLypBcnJheT8qLyBjYWxsYmFja0FyZ3Mpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFVzZWQgYnkgd2lkZ2V0cyB0byBzaWduYWwgdGhhdCBhIHN5bnRoZXRpYyBldmVudCBvY2N1cnJlZCwgZXg6XG5cdFx0XHQvL1x0fFx0bXlXaWRnZXQuZW1pdChcImF0dHJtb2RpZmllZC1zZWxlY3RlZENoaWxkV2lkZ2V0XCIsIHt9KS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRFbWl0cyBhbiBldmVudCBvbiB0aGlzLmRvbU5vZGUgbmFtZWQgdHlwZS50b0xvd2VyQ2FzZSgpLCBiYXNlZCBvbiBldmVudE9iai5cblx0XHRcdC8vXHRcdEFsc28gY2FsbHMgb25UeXBlKCkgbWV0aG9kLCBpZiBwcmVzZW50LCBhbmQgcmV0dXJucyB2YWx1ZSBmcm9tIHRoYXQgbWV0aG9kLlxuXHRcdFx0Ly9cdFx0QnkgZGVmYXVsdCBwYXNzZXMgZXZlbnRPYmogdG8gY2FsbGJhY2ssIGJ1dCB3aWxsIHBhc3MgY2FsbGJhY2tBcmdzIGluc3RlYWQsIGlmIHNwZWNpZmllZC5cblx0XHRcdC8vXHRcdE1vZGlmaWVzIGV2ZW50T2JqIGJ5IGFkZGluZyBtaXNzaW5nIHBhcmFtZXRlcnMgKGJ1YmJsZXMsIGNhbmNlbGFibGUsIHdpZGdldCkuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cblx0XHRcdC8vIFNwZWNpZnkgZmFsbGJhY2sgdmFsdWVzIGZvciBidWJibGVzLCBjYW5jZWxhYmxlIGluIGNhc2UgdGhleSBhcmUgbm90IHNldCBpbiBldmVudE9iai5cblx0XHRcdC8vIEFsc28gc2V0IHBvaW50ZXIgdG8gd2lkZ2V0LCBhbHRob3VnaCBzaW5jZSB3ZSBjYW4ndCBhZGQgYSBwb2ludGVyIHRvIHRoZSB3aWRnZXQgZm9yIG5hdGl2ZSBldmVudHNcblx0XHRcdC8vIChzZWUgIzE0NzI5KSwgbWF5YmUgd2Ugc2hvdWxkbid0IGRvIGl0IGhlcmU/XG5cdFx0XHRldmVudE9iaiA9IGV2ZW50T2JqIHx8IHt9O1xuXHRcdFx0aWYoZXZlbnRPYmouYnViYmxlcyA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0ZXZlbnRPYmouYnViYmxlcyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZihldmVudE9iai5jYW5jZWxhYmxlID09PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRldmVudE9iai5jYW5jZWxhYmxlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmKCFldmVudE9iai5kZXRhaWwpe1xuXHRcdFx0XHRldmVudE9iai5kZXRhaWwgPSB7fTtcblx0XHRcdH1cblx0XHRcdGV2ZW50T2JqLmRldGFpbC53aWRnZXQgPSB0aGlzO1xuXG5cdFx0XHR2YXIgcmV0LCBjYWxsYmFjayA9IHRoaXNbXCJvblwiICsgdHlwZV07XG5cdFx0XHRpZihjYWxsYmFjayl7XG5cdFx0XHRcdHJldCA9IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGNhbGxiYWNrQXJncyA/IGNhbGxiYWNrQXJncyA6IFtldmVudE9ial0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBFbWl0IGV2ZW50LCBidXQgYXZvaWQgc3B1cmlvdXMgZW1pdCgpJ3MgYXMgcGFyZW50IHNldHMgcHJvcGVydGllcyBvbiBjaGlsZCBkdXJpbmcgc3RhcnR1cC9kZXN0cm95XG5cdFx0XHRpZih0aGlzLl9zdGFydGVkICYmICF0aGlzLl9iZWluZ0Rlc3Ryb3llZCl7XG5cdFx0XHRcdG9uLmVtaXQodGhpcy5kb21Ob2RlLCB0eXBlLnRvTG93ZXJDYXNlKCksIGV2ZW50T2JqKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9LFxuXG5cdFx0b246IGZ1bmN0aW9uKC8qU3RyaW5nfEZ1bmN0aW9uKi8gdHlwZSwgLypGdW5jdGlvbiovIGZ1bmMpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbGwgc3BlY2lmaWVkIGZ1bmN0aW9uIHdoZW4gZXZlbnQgb2NjdXJzLCBleDogbXlXaWRnZXQub24oXCJjbGlja1wiLCBmdW5jdGlvbigpeyAuLi4gfSkuXG5cdFx0XHQvLyB0eXBlOlxuXHRcdFx0Ly9cdFx0TmFtZSBvZiBldmVudCAoZXg6IFwiY2xpY2tcIikgb3IgZXh0ZW5zaW9uIGV2ZW50IGxpa2UgdG91Y2gucHJlc3MuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdENhbGwgc3BlY2lmaWVkIGZ1bmN0aW9uIHdoZW4gZXZlbnQgYHR5cGVgIG9jY3VycywgZXg6IGBteVdpZGdldC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7IC4uLiB9KWAuXG5cdFx0XHQvL1x0XHROb3RlIHRoYXQgdGhlIGZ1bmN0aW9uIGlzIG5vdCBydW4gaW4gYW55IHBhcnRpY3VsYXIgc2NvcGUsIHNvIGlmIChmb3IgZXhhbXBsZSkgeW91IHdhbnQgaXQgdG8gcnVuIGluIHRoZVxuXHRcdFx0Ly9cdFx0d2lkZ2V0J3Mgc2NvcGUgeW91IG11c3QgZG8gYG15V2lkZ2V0Lm9uKFwiY2xpY2tcIiwgbGFuZy5oaXRjaChteVdpZGdldCwgZnVuYykpYC5cblxuXHRcdFx0Ly8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBpZiB0aGVyZSdzIGFuIG9uVHlwZSgpIG1ldGhvZCBpbiB0aGUgd2lkZ2V0IHRoZW4gY29ubmVjdCB0byB0aGF0LlxuXHRcdFx0Ly8gUmVtb3ZlIGluIDIuMC5cblx0XHRcdHZhciB3aWRnZXRNZXRob2QgPSB0aGlzLl9vbk1hcCh0eXBlKTtcblx0XHRcdGlmKHdpZGdldE1ldGhvZCl7XG5cdFx0XHRcdHJldHVybiBhc3BlY3QuYWZ0ZXIodGhpcywgd2lkZ2V0TWV0aG9kLCBmdW5jLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBqdXN0IGxpc3RlbiBmb3IgdGhlIGV2ZW50IG9uIHRoaXMuZG9tTm9kZS5cblx0XHRcdHJldHVybiB0aGlzLm93bihvbih0aGlzLmRvbU5vZGUsIHR5cGUsIGZ1bmMpKVswXTtcblx0XHR9LFxuXG5cdFx0X29uTWFwOiBmdW5jdGlvbigvKlN0cmluZ3xGdW5jdGlvbiovIHR5cGUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdE1hcHMgb24oKSB0eXBlIHBhcmFtZXRlciAoZXg6IFwibW91c2Vtb3ZlXCIpIHRvIG1ldGhvZCBuYW1lIChleDogXCJvbk1vdXNlTW92ZVwiKS5cblx0XHRcdC8vXHRcdElmIHR5cGUgaXMgYSBzeW50aGV0aWMgZXZlbnQgbGlrZSB0b3VjaC5wcmVzcyB0aGVuIHJldHVybnMgdW5kZWZpbmVkLlxuXHRcdFx0dmFyIGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yLCBtYXAgPSBjdG9yLl9vbk1hcDtcblx0XHRcdGlmKCFtYXApe1xuXHRcdFx0XHRtYXAgPSAoY3Rvci5fb25NYXAgPSB7fSk7XG5cdFx0XHRcdGZvcih2YXIgYXR0ciBpbiBjdG9yLnByb3RvdHlwZSl7XG5cdFx0XHRcdFx0aWYoL15vbi8udGVzdChhdHRyKSl7XG5cdFx0XHRcdFx0XHRtYXBbYXR0ci5yZXBsYWNlKC9eb24vLCBcIlwiKS50b0xvd2VyQ2FzZSgpXSA9IGF0dHI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWFwW3R5cGVvZiB0eXBlID09IFwic3RyaW5nXCIgJiYgdHlwZS50b0xvd2VyQ2FzZSgpXTtcdC8vIFN0cmluZ1xuXHRcdH0sXG5cblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgd2lkZ2V0LlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRXaGVuIGEgd2lkZ2V0IGlzIGNhc3QgdG8gYSBzdHJpbmcsIHRoaXMgbWV0aG9kIHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGVcblx0XHRcdC8vXHRcdG91dHB1dC4gQ3VycmVudGx5LCBpdCBkb2VzIG5vdCBpbXBsZW1lbnQgYW55IHNvcnQgb2YgcmV2ZXJzaWJsZVxuXHRcdFx0Ly9cdFx0c2VyaWFsaXphdGlvbi5cblx0XHRcdHJldHVybiAnW1dpZGdldCAnICsgdGhpcy5kZWNsYXJlZENsYXNzICsgJywgJyArICh0aGlzLmlkIHx8ICdOTyBJRCcpICsgJ10nOyAvLyBTdHJpbmdcblx0XHR9LFxuXG5cdFx0Z2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhbGwgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgd2lkZ2V0LCBpLmUuIGFsbCB3aWRnZXRzIHVuZGVybmVhdGggdGhpcy5jb250YWluZXJOb2RlIHdob3NlIHBhcmVudFxuXHRcdFx0Ly9cdFx0aXMgdGhpcyB3aWRnZXQuICAgTm90ZSB0aGF0IGl0IGRvZXMgbm90IHJldHVybiBhbGwgZGVzY2VuZGFudHMsIGJ1dCByYXRoZXIganVzdCBkaXJlY3QgY2hpbGRyZW4uXG5cdFx0XHQvL1x0XHRBbmFsb2dvdXMgdG8gW05vZGUuY2hpbGROb2Rlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vTm9kZS5jaGlsZE5vZGVzKSxcblx0XHRcdC8vXHRcdGV4Y2VwdCBjb250YWluaW5nIHdpZGdldHMgcmF0aGVyIHRoYW4gRE9NTm9kZXMuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VGhlIHJlc3VsdCBpbnRlbnRpb25hbGx5IGV4Y2x1ZGVzIGludGVybmFsbHkgY3JlYXRlZCB3aWRnZXRzIChhLmsuYS4gc3VwcG9ydGluZyB3aWRnZXRzKVxuXHRcdFx0Ly9cdFx0b3V0c2lkZSBvZiB0aGlzLmNvbnRhaW5lck5vZGUuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Tm90ZSB0aGF0IHRoZSBhcnJheSByZXR1cm5lZCBpcyBhIHNpbXBsZSBhcnJheS4gIEFwcGxpY2F0aW9uIGNvZGUgc2hvdWxkIG5vdCBhc3N1bWVcblx0XHRcdC8vXHRcdGV4aXN0ZW5jZSBvZiBtZXRob2RzIGxpa2UgZm9yRWFjaCgpLlxuXG5cdFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJOb2RlID8gcmVnaXN0cnkuZmluZFdpZGdldHModGhpcy5jb250YWluZXJOb2RlKSA6IFtdOyAvLyBkaWppdC9fV2lkZ2V0QmFzZVtdXG5cdFx0fSxcblxuXHRcdGdldFBhcmVudDogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRoZSBwYXJlbnQgd2lkZ2V0IG9mIHRoaXMgd2lkZ2V0LlxuXG5cdFx0XHRyZXR1cm4gcmVnaXN0cnkuZ2V0RW5jbG9zaW5nV2lkZ2V0KHRoaXMuZG9tTm9kZS5wYXJlbnROb2RlKTtcblx0XHR9LFxuXG5cdFx0Y29ubmVjdDogZnVuY3Rpb24oLypPYmplY3R8bnVsbCovIG9iaiwgLypTdHJpbmd8RnVuY3Rpb24qLyBldmVudCwgLypTdHJpbmd8RnVuY3Rpb24qLyBtZXRob2Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiAyLjAsIHVzZSB0aGlzLm93bihvbiguLi4pKSBvciB0aGlzLm93bihhc3BlY3QuYWZ0ZXIoLi4uKSkgaW5zdGVhZC5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRDb25uZWN0cyBzcGVjaWZpZWQgb2JqL2V2ZW50IHRvIHNwZWNpZmllZCBtZXRob2Qgb2YgdGhpcyBvYmplY3Rcblx0XHRcdC8vXHRcdGFuZCByZWdpc3RlcnMgZm9yIGRpc2Nvbm5lY3QoKSBvbiB3aWRnZXQgZGVzdHJveS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRQcm92aWRlIHdpZGdldC1zcGVjaWZpYyBhbmFsb2cgdG8gZG9qby5jb25uZWN0LCBleGNlcHQgd2l0aCB0aGVcblx0XHRcdC8vXHRcdGltcGxpY2l0IHVzZSBvZiB0aGlzIHdpZGdldCBhcyB0aGUgdGFyZ2V0IG9iamVjdC5cblx0XHRcdC8vXHRcdEV2ZW50cyBjb25uZWN0ZWQgd2l0aCBgdGhpcy5jb25uZWN0YCBhcmUgZGlzY29ubmVjdGVkIHVwb25cblx0XHRcdC8vXHRcdGRlc3RydWN0aW9uLlxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdEEgaGFuZGxlIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBgZGlzY29ubmVjdGAgaW4gb3JkZXIgdG8gZGlzY29ubmVjdCBiZWZvcmVcblx0XHRcdC8vXHRcdHRoZSB3aWRnZXQgaXMgZGVzdHJveWVkLlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHR2YXIgYnRuID0gbmV3IEJ1dHRvbigpO1xuXHRcdFx0Ly9cdHxcdC8vIHdoZW4gZm9vLmJhcigpIGlzIGNhbGxlZCwgY2FsbCB0aGUgbGlzdGVuZXIgd2UncmUgZ29pbmcgdG9cblx0XHRcdC8vXHR8XHQvLyBwcm92aWRlIGluIHRoZSBzY29wZSBvZiBidG5cblx0XHRcdC8vXHR8XHRidG4uY29ubmVjdChmb28sIFwiYmFyXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHQvL1x0fFx0XHRjb25zb2xlLmRlYnVnKHRoaXMudG9TdHJpbmcoKSk7XG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cblx0XHRcdHJldHVybiB0aGlzLm93bihjb25uZWN0LmNvbm5lY3Qob2JqLCBldmVudCwgdGhpcywgbWV0aG9kKSlbMF07XHQvLyBoYW5kbGVcblx0XHR9LFxuXG5cdFx0ZGlzY29ubmVjdDogZnVuY3Rpb24oaGFuZGxlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gMi4wLCB1c2UgaGFuZGxlLnJlbW92ZSgpIGluc3RlYWQuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0RGlzY29ubmVjdHMgaGFuZGxlIGNyZWF0ZWQgYnkgYGNvbm5lY3RgLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXG5cdFx0XHRoYW5kbGUucmVtb3ZlKCk7XG5cdFx0fSxcblxuXHRcdHN1YnNjcmliZTogZnVuY3Rpb24odCwgbWV0aG9kKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gMi4wLCB1c2UgdGhpcy5vd24odG9waWMuc3Vic2NyaWJlKCkpIGluc3RlYWQuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0U3Vic2NyaWJlcyB0byB0aGUgc3BlY2lmaWVkIHRvcGljIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIG1ldGhvZFxuXHRcdFx0Ly9cdFx0b2YgdGhpcyBvYmplY3QgYW5kIHJlZ2lzdGVycyBmb3IgdW5zdWJzY3JpYmUoKSBvbiB3aWRnZXQgZGVzdHJveS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRQcm92aWRlIHdpZGdldC1zcGVjaWZpYyBhbmFsb2cgdG8gZG9qby5zdWJzY3JpYmUsIGV4Y2VwdCB3aXRoIHRoZVxuXHRcdFx0Ly9cdFx0aW1wbGljaXQgdXNlIG9mIHRoaXMgd2lkZ2V0IGFzIHRoZSB0YXJnZXQgb2JqZWN0LlxuXHRcdFx0Ly8gdDogU3RyaW5nXG5cdFx0XHQvL1x0XHRUaGUgdG9waWNcblx0XHRcdC8vIG1ldGhvZDogRnVuY3Rpb25cblx0XHRcdC8vXHRcdFRoZSBjYWxsYmFja1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHR2YXIgYnRuID0gbmV3IEJ1dHRvbigpO1xuXHRcdFx0Ly9cdHxcdC8vIHdoZW4gL215L3RvcGljIGlzIHB1Ymxpc2hlZCwgdGhpcyBidXR0b24gY2hhbmdlcyBpdHMgbGFiZWwgdG9cblx0XHRcdC8vXHR8XHQvLyBiZSB0aGUgcGFyYW1ldGVyIG9mIHRoZSB0b3BpYy5cblx0XHRcdC8vXHR8XHRidG4uc3Vic2NyaWJlKFwiL215L3RvcGljXCIsIGZ1bmN0aW9uKHYpe1xuXHRcdFx0Ly9cdHxcdFx0dGhpcy5zZXQoXCJsYWJlbFwiLCB2KTtcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblx0XHRcdHJldHVybiB0aGlzLm93bih0b3BpYy5zdWJzY3JpYmUodCwgbGFuZy5oaXRjaCh0aGlzLCBtZXRob2QpKSlbMF07XHQvLyBoYW5kbGVcblx0XHR9LFxuXG5cdFx0dW5zdWJzY3JpYmU6IGZ1bmN0aW9uKC8qT2JqZWN0Ki8gaGFuZGxlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gMi4wLCB1c2UgaGFuZGxlLnJlbW92ZSgpIGluc3RlYWQuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VW5zdWJzY3JpYmVzIGhhbmRsZSBjcmVhdGVkIGJ5IHRoaXMuc3Vic2NyaWJlLlxuXHRcdFx0Ly9cdFx0QWxzbyByZW1vdmVzIGhhbmRsZSBmcm9tIHRoaXMgd2lkZ2V0J3MgbGlzdCBvZiBzdWJzY3JpcHRpb25zXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cblx0XHRcdGhhbmRsZS5yZW1vdmUoKTtcblx0XHR9LFxuXG5cdFx0aXNMZWZ0VG9SaWdodDogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm4gdGhpcyB3aWRnZXQncyBleHBsaWNpdCBvciBpbXBsaWNpdCBvcmllbnRhdGlvbiAodHJ1ZSBmb3IgTFRSLCBmYWxzZSBmb3IgUlRMKVxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXHRcdFx0cmV0dXJuIHRoaXMuZGlyID8gKHRoaXMuZGlyLnRvTG93ZXJDYXNlKCkgPT0gXCJsdHJcIikgOiBkb21HZW9tZXRyeS5pc0JvZHlMdHIodGhpcy5vd25lckRvY3VtZW50KTsgLy9Cb29sZWFuXG5cdFx0fSxcblxuXHRcdGlzRm9jdXNhYmxlOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybiB0cnVlIGlmIHRoaXMgd2lkZ2V0IGNhbiBjdXJyZW50bHkgYmUgZm9jdXNlZFxuXHRcdFx0Ly9cdFx0YW5kIGZhbHNlIGlmIG5vdFxuXHRcdFx0cmV0dXJuIHRoaXMuZm9jdXMgJiYgKGRvbVN0eWxlLmdldCh0aGlzLmRvbU5vZGUsIFwiZGlzcGxheVwiKSAhPSBcIm5vbmVcIik7XG5cdFx0fSxcblxuXHRcdHBsYWNlQXQ6IGZ1bmN0aW9uKC8qU3RyaW5nfERvbU5vZGV8RG9jdW1lbnRGcmFnbWVudHxkaWppdC9fV2lkZ2V0QmFzZSovIHJlZmVyZW5jZSwgLypTdHJpbmd8SW50PyovIHBvc2l0aW9uKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRQbGFjZSB0aGlzIHdpZGdldCBzb21ld2hlcmUgaW4gdGhlIERPTSBiYXNlZFxuXHRcdFx0Ly9cdFx0b24gc3RhbmRhcmQgZG9tQ29uc3RydWN0LnBsYWNlKCkgY29udmVudGlvbnMuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEEgY29udmVuaWVuY2UgZnVuY3Rpb24gcHJvdmlkZWQgaW4gYWxsIF9XaWRnZXRzLCBwcm92aWRpbmcgYSBzaW1wbGVcblx0XHRcdC8vXHRcdHNob3J0aGFuZCBtZWNoYW5pc20gdG8gcHV0IGFuIGV4aXN0aW5nIChvciBuZXdseSBjcmVhdGVkKSBXaWRnZXRcblx0XHRcdC8vXHRcdHNvbWV3aGVyZSBpbiB0aGUgZG9tLCBhbmQgYWxsb3cgY2hhaW5pbmcuXG5cdFx0XHQvLyByZWZlcmVuY2U6XG5cdFx0XHQvL1x0XHRXaWRnZXQsIERPTU5vZGUsIERvY3VtZW50RnJhZ21lbnQsIG9yIGlkIG9mIHdpZGdldCBvciBET01Ob2RlXG5cdFx0XHQvLyBwb3NpdGlvbjpcblx0XHRcdC8vXHRcdElmIHJlZmVyZW5jZSBpcyBhIHdpZGdldCAob3IgaWQgb2Ygd2lkZ2V0KSwgYW5kIHRoYXQgd2lkZ2V0IGhhcyBhbiBcIi5hZGRDaGlsZFwiIG1ldGhvZCxcblx0XHRcdC8vXHRcdGl0IHdpbGwgYmUgY2FsbGVkIHBhc3NpbmcgdGhpcyB3aWRnZXQgaW5zdGFuY2UgaW50byB0aGF0IG1ldGhvZCwgc3VwcGx5aW5nIHRoZSBvcHRpb25hbFxuXHRcdFx0Ly9cdFx0cG9zaXRpb24gaW5kZXggcGFzc2VkLiAgSW4gdGhpcyBjYXNlIHBvc2l0aW9uIChpZiBzcGVjaWZpZWQpIHNob3VsZCBiZSBhbiBpbnRlZ2VyLlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdElmIHJlZmVyZW5jZSBpcyBhIERPTU5vZGUgKG9yIGlkIG1hdGNoaW5nIGEgRE9NTm9kZSBidXQgbm90IGEgd2lkZ2V0KSxcblx0XHRcdC8vXHRcdHRoZSBwb3NpdGlvbiBhcmd1bWVudCBjYW4gYmUgYSBudW1lcmljIGluZGV4IG9yIGEgc3RyaW5nXG5cdFx0XHQvL1x0XHRcImZpcnN0XCIsIFwibGFzdFwiLCBcImJlZm9yZVwiLCBvciBcImFmdGVyXCIsIHNhbWUgYXMgZG9qby9kb20tY29uc3RydWN0OjpwbGFjZSgpLlxuXHRcdFx0Ly8gcmV0dXJuczogZGlqaXQvX1dpZGdldEJhc2Vcblx0XHRcdC8vXHRcdFByb3ZpZGVzIGEgdXNlZnVsIHJldHVybiBvZiB0aGUgbmV3bHkgY3JlYXRlZCBkaWppdC5fV2lkZ2V0IGluc3RhbmNlIHNvIHlvdVxuXHRcdFx0Ly9cdFx0Y2FuIFwiY2hhaW5cIiB0aGlzIGZ1bmN0aW9uIGJ5IGluc3RhbnRpYXRpbmcsIHBsYWNpbmcsIHRoZW4gc2F2aW5nIHRoZSByZXR1cm4gdmFsdWVcblx0XHRcdC8vXHRcdHRvIGEgdmFyaWFibGUuXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdC8vIGNyZWF0ZSBhIEJ1dHRvbiB3aXRoIG5vIHNyY05vZGVSZWYsIGFuZCBwbGFjZSBpdCBpbiB0aGUgYm9keTpcblx0XHRcdC8vXHR8XHR2YXIgYnV0dG9uID0gbmV3IEJ1dHRvbih7IGxhYmVsOlwiY2xpY2tcIiB9KS5wbGFjZUF0KHdpbi5ib2R5KCkpO1xuXHRcdFx0Ly9cdHxcdC8vIG5vdywgJ2J1dHRvbicgaXMgc3RpbGwgdGhlIHdpZGdldCByZWZlcmVuY2UgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgYnV0dG9uXG5cdFx0XHQvL1x0fFx0YnV0dG9uLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSl7IGNvbnNvbGUubG9nKCdjbGljaycpOyB9KSk7XG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdC8vIGNyZWF0ZSBhIGJ1dHRvbiBvdXQgb2YgYSBub2RlIHdpdGggaWQ9XCJzcmNcIiBhbmQgYXBwZW5kIGl0IHRvIGlkPVwid3JhcHBlclwiOlxuXHRcdFx0Ly9cdHxcdHZhciBidXR0b24gPSBuZXcgQnV0dG9uKHt9LFwic3JjXCIpLnBsYWNlQXQoXCJ3cmFwcGVyXCIpO1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHQvLyBwbGFjZSBhIG5ldyBidXR0b24gYXMgdGhlIGZpcnN0IGVsZW1lbnQgb2Ygc29tZSBkaXZcblx0XHRcdC8vXHR8XHR2YXIgYnV0dG9uID0gbmV3IEJ1dHRvbih7IGxhYmVsOlwiY2xpY2tcIiB9KS5wbGFjZUF0KFwid3JhcHBlclwiLFwiZmlyc3RcIik7XG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdC8vIGNyZWF0ZSBhIGNvbnRlbnRwYW5lIGFuZCBhZGQgaXQgdG8gYSBUYWJDb250YWluZXJcblx0XHRcdC8vXHR8XHR2YXIgdGMgPSBkaWppdC5ieUlkKFwibXlUYWJzXCIpO1xuXHRcdFx0Ly9cdHxcdG5ldyBDb250ZW50UGFuZSh7IGhyZWY6XCJmb28uaHRtbFwiLCB0aXRsZTpcIldvdyFcIiB9KS5wbGFjZUF0KHRjKVxuXG5cdFx0XHR2YXIgcmVmV2lkZ2V0ID0gIXJlZmVyZW5jZS50YWdOYW1lICYmIHJlZ2lzdHJ5LmJ5SWQocmVmZXJlbmNlKTtcblx0XHRcdGlmKHJlZldpZGdldCAmJiByZWZXaWRnZXQuYWRkQ2hpbGQgJiYgKCFwb3NpdGlvbiB8fCB0eXBlb2YgcG9zaXRpb24gPT09IFwibnVtYmVyXCIpKXtcblx0XHRcdFx0Ly8gQWRkaW5nIHRoaXMgdG8gcmVmV2lkZ2V0IGFuZCBjYW4gdXNlIHJlZldpZGdldC5hZGRDaGlsZCgpIHRvIGhhbmRsZSBldmVyeXRoaW5nLlxuXHRcdFx0XHRyZWZXaWRnZXQuYWRkQ2hpbGQodGhpcywgcG9zaXRpb24pO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIFwicmVmZXJlbmNlXCIgaXMgYSBwbGFpbiBET01Ob2RlLCBvciB3ZSBjYW4ndCB1c2UgcmVmV2lkZ2V0LmFkZENoaWxkKCkuICAgVXNlIGRvbUNvbnN0cnVjdC5wbGFjZSgpIGFuZFxuXHRcdFx0XHQvLyB0YXJnZXQgcmVmV2lkZ2V0LmNvbnRhaW5lck5vZGUgZm9yIG5lc3RlZCBwbGFjZW1lbnQgKHBvc2l0aW9uPT1udW1iZXIsIFwiZmlyc3RcIiwgXCJsYXN0XCIsIFwib25seVwiKSwgYW5kXG5cdFx0XHRcdC8vIHJlZldpZGdldC5kb21Ob2RlIG90aGVyd2lzZSAoXCJhZnRlclwiL1wiYmVmb3JlXCIvXCJyZXBsYWNlXCIpLiAgKEJ1dCBub3Qgc3VwcG9ydGVkIG9mZmljaWFsbHksIHNlZSAjMTQ5NDYuKVxuXHRcdFx0XHR2YXIgcmVmID0gcmVmV2lkZ2V0ICYmIChcImRvbU5vZGVcIiBpbiByZWZXaWRnZXQpID9cblx0XHRcdFx0XHQocmVmV2lkZ2V0LmNvbnRhaW5lck5vZGUgJiYgIS9hZnRlcnxiZWZvcmV8cmVwbGFjZS8udGVzdChwb3NpdGlvbiB8fCBcIlwiKSA/XG5cdFx0XHRcdFx0XHRyZWZXaWRnZXQuY29udGFpbmVyTm9kZSA6IHJlZldpZGdldC5kb21Ob2RlKSA6IGRvbS5ieUlkKHJlZmVyZW5jZSwgdGhpcy5vd25lckRvY3VtZW50KTtcblx0XHRcdFx0ZG9tQ29uc3RydWN0LnBsYWNlKHRoaXMuZG9tTm9kZSwgcmVmLCBwb3NpdGlvbik7XG5cblx0XHRcdFx0Ly8gU3RhcnQgdGhpcyBpZmYgaXQgaGFzIGEgcGFyZW50IHdpZGdldCB0aGF0J3MgYWxyZWFkeSBzdGFydGVkLlxuXHRcdFx0XHQvLyBUT0RPOiBmb3IgMi4wIG1heWJlIGl0IHNob3VsZCBhbHNvIHN0YXJ0IHRoZSB3aWRnZXQgd2hlbiB0aGlzLmdldFBhcmVudCgpIHJldHVybnMgbnVsbD8/XG5cdFx0XHRcdGlmKCF0aGlzLl9zdGFydGVkICYmICh0aGlzLmdldFBhcmVudCgpIHx8IHt9KS5fc3RhcnRlZCl7XG5cdFx0XHRcdFx0dGhpcy5zdGFydHVwKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRkZWZlcjogZnVuY3Rpb24oZmNuLCBkZWxheSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0V3JhcHBlciB0byBzZXRUaW1lb3V0IHRvIGF2b2lkIGRlZmVycmVkIGZ1bmN0aW9ucyBleGVjdXRpbmdcblx0XHRcdC8vXHRcdGFmdGVyIHRoZSBvcmlnaW5hdGluZyB3aWRnZXQgaGFzIGJlZW4gZGVzdHJveWVkLlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhbiBvYmplY3QgaGFuZGxlIHdpdGggYSByZW1vdmUgbWV0aG9kICh0aGF0IHJldHVybnMgbnVsbCkgKHJlcGxhY2VzIGNsZWFyVGltZW91dCkuXG5cdFx0XHQvLyBmY246IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRGdW5jdGlvbiByZWZlcmVuY2UuXG5cdFx0XHQvLyBkZWxheTogTnVtYmVyP1xuXHRcdFx0Ly9cdFx0RGVsYXksIGRlZmF1bHRzIHRvIDAuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cblx0XHRcdHZhciB0aW1lciA9IHNldFRpbWVvdXQobGFuZy5oaXRjaCh0aGlzLFxuXHRcdFx0XHRmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmKCF0aW1lcil7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWVyID0gbnVsbDtcblx0XHRcdFx0XHRpZighdGhpcy5fZGVzdHJveWVkKXtcblx0XHRcdFx0XHRcdGxhbmcuaGl0Y2godGhpcywgZmNuKSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSksXG5cdFx0XHRcdGRlbGF5IHx8IDBcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0aWYodGltZXIpe1xuXHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdFx0XHRcdHRpbWVyID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIHNvIHRoaXMgd29ya3Mgd2VsbDogaGFuZGxlID0gaGFuZGxlLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fSk7XG5cblx0aWYoaGFzKFwiZG9qby1iaWRpXCIpKXtcblx0XHRfV2lkZ2V0QmFzZS5leHRlbmQoX0JpZGlNaXhpbik7XG5cdH1cblxuXHRyZXR1cm4gX1dpZGdldEJhc2U7XG59KTtcbiIsImRlZmluZShbXG5cdFwiZG9qby9fYmFzZS9hcnJheVwiLFxuXHRcImRvam8vX2Jhc2UvY29uZmlnXCIsIC8vIGRlZmF1bHREdXJhdGlvblxuXHRcImRvam8vX2Jhc2UvbGFuZ1wiLFxuXHRcIi4uL3JlZ2lzdHJ5XCIsXG5cdFwiLi4vbWFpblwiXHQvLyBmb3Igc2V0dGluZyBleHBvcnRzIHRvIGRpaml0IG5hbWVzcGFjZVxuXSwgZnVuY3Rpb24oYXJyYXksIGNvbmZpZywgbGFuZywgcmVnaXN0cnksIGRpaml0KXtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRpaml0L19iYXNlL21hbmFnZXJcblxuXHR2YXIgZXhwb3J0cyA9IHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdERlcHJlY2F0ZWQuICBTaGltIHRvIG1ldGhvZHMgb24gcmVnaXN0cnksIHBsdXMgYSBmZXcgb3RoZXIgZGVjbGFyYXRpb25zLlxuXHRcdC8vXHRcdE5ldyBjb2RlIHNob3VsZCBhY2Nlc3MgZGlqaXQvcmVnaXN0cnkgZGlyZWN0bHkgd2hlbiBwb3NzaWJsZS5cblx0fTtcblxuXHRhcnJheS5mb3JFYWNoKFtcImJ5SWRcIiwgXCJnZXRVbmlxdWVJZFwiLCBcImZpbmRXaWRnZXRzXCIsIFwiX2Rlc3Ryb3lBbGxcIiwgXCJieU5vZGVcIiwgXCJnZXRFbmNsb3NpbmdXaWRnZXRcIl0sIGZ1bmN0aW9uKG5hbWUpe1xuXHRcdGV4cG9ydHNbbmFtZV0gPSByZWdpc3RyeVtuYW1lXTtcblx0fSk7XG5cblx0IGxhbmcubWl4aW4oZXhwb3J0cywge1xuXHRcdCAvLyBkZWZhdWx0RHVyYXRpb246IEludGVnZXJcblx0XHQgLy9cdFx0VGhlIGRlZmF1bHQgZnguYW5pbWF0aW9uIHNwZWVkIChpbiBtcykgdG8gdXNlIGZvciBhbGwgRGlqaXRcblx0XHQgLy9cdFx0dHJhbnNpdGlvbmFsIGZ4LmFuaW1hdGlvbnMsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkXG5cdFx0IC8vXHRcdG9uIGEgcGVyLWluc3RhbmNlIGJhc2lzLiBEZWZhdWx0cyB0byAyMDAsIG92ZXJyaWRlZCBieVxuXHRcdCAvL1x0XHRgZGpDb25maWcuZGVmYXVsdER1cmF0aW9uYFxuXHRcdCBkZWZhdWx0RHVyYXRpb246IGNvbmZpZ1tcImRlZmF1bHREdXJhdGlvblwiXSB8fCAyMDBcblx0IH0pO1xuXG5cdGxhbmcubWl4aW4oZGlqaXQsIGV4cG9ydHMpO1xuXG5cdC8qPT09PT0gcmV0dXJuIGV4cG9ydHM7ID09PT09Ki9cblx0cmV0dXJuIGRpaml0O1x0Ly8gZm9yIGJhY2sgY29tcGF0IDotKFxufSk7XG4iLCJkZWZpbmUoW1xuXHRcImRvam8vX2Jhc2UvYXJyYXlcIiwgLy8gYXJyYXkuZm9yRWFjaCBhcnJheS5tYXBcblx0XCJkb2pvL2RvbVwiLFx0XHRcdC8vIGRvbS5ieUlkXG5cdFwiZG9qby9kb20tYXR0clwiLCAvLyBkb21BdHRyLmF0dHIgZG9tQXR0ci5oYXNcblx0XCJkb2pvL2RvbS1zdHlsZVwiLCAvLyBkb21TdHlsZS5zdHlsZVxuXHRcImRvam8vX2Jhc2UvbGFuZ1wiLCAvLyBsYW5nLm1peGluKClcblx0XCJkb2pvL3NuaWZmXCIsIC8vIGhhcyhcImllXCIpIGhhcyhcImV4dGVuZC1kb2pvXCIpXG5cdFwiLi9tYWluXCJcdC8vIGZvciBleHBvcnRpbmcgbWV0aG9kcyB0byBkaWppdCBuYW1lc3BhY2Vcbl0sIGZ1bmN0aW9uKGFycmF5LCBkb20sIGRvbUF0dHIsIGRvbVN0eWxlLCBsYW5nLCBoYXMsIGRpaml0KXtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRpaml0L2ExMXlcblxuXHR2YXIgdW5kZWZpbmVkO1xuXG5cdHZhciBhMTF5ID0ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0QWNjZXNzaWJpbGl0eSB1dGlsaXR5IGZ1bmN0aW9ucyAoa2V5Ym9hcmQsIHRhYiBzdG9wcywgZXRjLilcblxuXHRcdF9pc0VsZW1lbnRTaG93bjogZnVuY3Rpb24oLypFbGVtZW50Ki8gZWxlbSl7XG5cdFx0XHR2YXIgcyA9IGRvbVN0eWxlLmdldChlbGVtKTtcblx0XHRcdHJldHVybiAocy52aXNpYmlsaXR5ICE9IFwiaGlkZGVuXCIpXG5cdFx0XHRcdCYmIChzLnZpc2liaWxpdHkgIT0gXCJjb2xsYXBzZWRcIilcblx0XHRcdFx0JiYgKHMuZGlzcGxheSAhPSBcIm5vbmVcIilcblx0XHRcdFx0JiYgKGRvbUF0dHIuZ2V0KGVsZW0sIFwidHlwZVwiKSAhPSBcImhpZGRlblwiKTtcblx0XHR9LFxuXG5cdFx0aGFzRGVmYXVsdFRhYlN0b3A6IGZ1bmN0aW9uKC8qRWxlbWVudCovIGVsZW0pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRlc3RzIGlmIGVsZW1lbnQgaXMgdGFiLW5hdmlnYWJsZSBldmVuIHdpdGhvdXQgYW4gZXhwbGljaXQgdGFiSW5kZXggc2V0dGluZ1xuXG5cdFx0XHQvLyBObyBleHBsaWNpdCB0YWJJbmRleCBzZXR0aW5nLCBuZWVkIHRvIGludmVzdGlnYXRlIG5vZGUgdHlwZVxuXHRcdFx0c3dpdGNoKGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSl7XG5cdFx0XHRcdGNhc2UgXCJhXCI6XG5cdFx0XHRcdFx0Ly8gQW4gPGE+IHcvb3V0IGEgdGFiaW5kZXggaXMgb25seSBuYXZpZ2FibGUgaWYgaXQgaGFzIGFuIGhyZWZcblx0XHRcdFx0XHRyZXR1cm4gZG9tQXR0ci5oYXMoZWxlbSwgXCJocmVmXCIpO1xuXHRcdFx0XHRjYXNlIFwiYXJlYVwiOlxuXHRcdFx0XHRjYXNlIFwiYnV0dG9uXCI6XG5cdFx0XHRcdGNhc2UgXCJpbnB1dFwiOlxuXHRcdFx0XHRjYXNlIFwib2JqZWN0XCI6XG5cdFx0XHRcdGNhc2UgXCJzZWxlY3RcIjpcblx0XHRcdFx0Y2FzZSBcInRleHRhcmVhXCI6XG5cdFx0XHRcdFx0Ly8gVGhlc2UgYXJlIG5hdmlnYWJsZSBieSBkZWZhdWx0XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdGNhc2UgXCJpZnJhbWVcIjpcblx0XHRcdFx0XHQvLyBJZiBpdCdzIGFuIGVkaXRvciA8aWZyYW1lPiB0aGVuIGl0J3MgdGFiIG5hdmlnYWJsZS5cblx0XHRcdFx0XHR2YXIgYm9keTtcblx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHQvLyBub24tSUVcblx0XHRcdFx0XHRcdHZhciBjb250ZW50RG9jdW1lbnQgPSBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHRcdFx0XHRcdGlmKFwiZGVzaWduTW9kZVwiIGluIGNvbnRlbnREb2N1bWVudCAmJiBjb250ZW50RG9jdW1lbnQuZGVzaWduTW9kZSA9PSBcIm9uXCIpe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJvZHkgPSBjb250ZW50RG9jdW1lbnQuYm9keTtcblx0XHRcdFx0XHR9Y2F0Y2goZTEpe1xuXHRcdFx0XHRcdFx0Ly8gY29udGVudFdpbmRvdy5kb2N1bWVudCBpc24ndCBhY2Nlc3NpYmxlIHdpdGhpbiBJRTcvOFxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGlmcmFtZS5zcmMgcG9pbnRzIHRvIGEgZm9yZWlnbiB1cmwgYW5kIHRoaXNcblx0XHRcdFx0XHRcdC8vIHBhZ2UgY29udGFpbnMgYW4gZWxlbWVudCwgdGhhdCBjb3VsZCBnZXQgZm9jdXNcblx0XHRcdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRcdFx0Ym9keSA9IGVsZW0uY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5O1xuXHRcdFx0XHRcdFx0fWNhdGNoKGUyKXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gYm9keSAmJiAoYm9keS5jb250ZW50RWRpdGFibGUgPT0gJ3RydWUnIHx8XG5cdFx0XHRcdFx0XHQoYm9keS5maXJzdENoaWxkICYmIGJvZHkuZmlyc3RDaGlsZC5jb250ZW50RWRpdGFibGUgPT0gJ3RydWUnKSk7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uY29udGVudEVkaXRhYmxlID09ICd0cnVlJztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZWZmZWN0aXZlVGFiSW5kZXg6IGZ1bmN0aW9uKC8qRWxlbWVudCovIGVsZW0pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgZWZmZWN0aXZlIHRhYkluZGV4IG9mIGFuIGVsZW1lbnQsIGVpdGhlciBhIG51bWJlciwgb3IgdW5kZWZpbmVkIGlmIGVsZW1lbnQgaXNuJ3QgZm9jdXNhYmxlLlxuXG5cdFx0XHRpZihkb21BdHRyLmdldChlbGVtLCBcImRpc2FibGVkXCIpKXtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdH1lbHNlIGlmKGRvbUF0dHIuaGFzKGVsZW0sIFwidGFiSW5kZXhcIikpe1xuXHRcdFx0XHQvLyBFeHBsaWNpdCB0YWIgaW5kZXggc2V0dGluZ1xuXHRcdFx0XHRyZXR1cm4gK2RvbUF0dHIuZ2V0KGVsZW0sIFwidGFiSW5kZXhcIik7Ly8gKyB0byBjb252ZXJ0IHN0cmluZyAtLT4gbnVtYmVyXG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Ly8gTm8gZXhwbGljaXQgdGFiSW5kZXggc2V0dGluZywgc28gZGVwZW5kcyBvbiBub2RlIHR5cGVcblx0XHRcdFx0cmV0dXJuIGExMXkuaGFzRGVmYXVsdFRhYlN0b3AoZWxlbSkgPyAwIDogdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRpc1RhYk5hdmlnYWJsZTogZnVuY3Rpb24oLypFbGVtZW50Ki8gZWxlbSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0VGVzdHMgaWYgYW4gZWxlbWVudCBpcyB0YWItbmF2aWdhYmxlXG5cblx0XHRcdHJldHVybiBhMTF5LmVmZmVjdGl2ZVRhYkluZGV4KGVsZW0pID49IDA7XG5cdFx0fSxcblxuXHRcdGlzRm9jdXNhYmxlOiBmdW5jdGlvbigvKkVsZW1lbnQqLyBlbGVtKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRUZXN0cyBpZiBhbiBlbGVtZW50IGlzIGZvY3VzYWJsZSBieSB0YWJiaW5nIHRvIGl0LCBvciBjbGlja2luZyBpdCB3aXRoIHRoZSBtb3VzZS5cblxuXHRcdFx0cmV0dXJuIGExMXkuZWZmZWN0aXZlVGFiSW5kZXgoZWxlbSkgPj0gLTE7XG5cdFx0fSxcblxuXHRcdF9nZXRUYWJOYXZpZ2FibGU6IGZ1bmN0aW9uKC8qRE9NTm9kZSovIHJvb3Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEZpbmRzIGRlc2NlbmRhbnRzIG9mIHRoZSBzcGVjaWZpZWQgcm9vdCBub2RlLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRGaW5kcyB0aGUgZm9sbG93aW5nIGRlc2NlbmRhbnRzIG9mIHRoZSBzcGVjaWZpZWQgcm9vdCBub2RlOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdC0gdGhlIGZpcnN0IHRhYi1uYXZpZ2FibGUgZWxlbWVudCBpbiBkb2N1bWVudCBvcmRlclxuXHRcdFx0Ly9cdFx0ICB3aXRob3V0IGEgdGFiSW5kZXggb3Igd2l0aCB0YWJJbmRleD1cIjBcIlxuXHRcdFx0Ly9cdFx0LSB0aGUgbGFzdCB0YWItbmF2aWdhYmxlIGVsZW1lbnQgaW4gZG9jdW1lbnQgb3JkZXJcblx0XHRcdC8vXHRcdCAgd2l0aG91dCBhIHRhYkluZGV4IG9yIHdpdGggdGFiSW5kZXg9XCIwXCJcblx0XHRcdC8vXHRcdC0gdGhlIGZpcnN0IGVsZW1lbnQgaW4gZG9jdW1lbnQgb3JkZXIgd2l0aCB0aGUgbG93ZXN0XG5cdFx0XHQvL1x0XHQgIHBvc2l0aXZlIHRhYkluZGV4IHZhbHVlXG5cdFx0XHQvL1x0XHQtIHRoZSBsYXN0IGVsZW1lbnQgaW4gZG9jdW1lbnQgb3JkZXIgd2l0aCB0aGUgaGlnaGVzdFxuXHRcdFx0Ly9cdFx0ICBwb3NpdGl2ZSB0YWJJbmRleCB2YWx1ZVxuXHRcdFx0dmFyIGZpcnN0LCBsYXN0LCBsb3dlc3QsIGxvd2VzdFRhYmluZGV4LCBoaWdoZXN0LCBoaWdoZXN0VGFiaW5kZXgsIHJhZGlvU2VsZWN0ZWQgPSB7fTtcblxuXHRcdFx0ZnVuY3Rpb24gcmFkaW9OYW1lKG5vZGUpe1xuXHRcdFx0XHQvLyBJZiB0aGlzIGVsZW1lbnQgaXMgcGFydCBvZiBhIHJhZGlvIGJ1dHRvbiBncm91cCwgcmV0dXJuIHRoZSBuYW1lIGZvciB0aGF0IGdyb3VwLlxuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImlucHV0XCIgJiZcblx0XHRcdFx0XHRub2RlLnR5cGUgJiYgbm9kZS50eXBlLnRvTG93ZXJDYXNlKCkgPT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZS5uYW1lICYmIG5vZGUubmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc2hvd24gPSBhMTF5Ll9pc0VsZW1lbnRTaG93biwgZWZmZWN0aXZlVGFiSW5kZXggPSBhMTF5LmVmZmVjdGl2ZVRhYkluZGV4O1xuXHRcdFx0dmFyIHdhbGtUcmVlID0gZnVuY3Rpb24oLypET01Ob2RlKi8gcGFyZW50KXtcblx0XHRcdFx0Zm9yKHZhciBjaGlsZCA9IHBhcmVudC5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZyl7XG5cdFx0XHRcdFx0Ly8gU2tpcCB0ZXh0IGVsZW1lbnRzLCBoaWRkZW4gZWxlbWVudHMsIGFuZCBhbHNvIG5vbi1IVE1MIGVsZW1lbnRzICh0aG9zZSBpbiBjdXN0b20gbmFtZXNwYWNlcykgaW4gSUUsXG5cdFx0XHRcdFx0Ly8gc2luY2Ugc2hvdygpIGludm9rZXMgZ2V0QXR0cmlidXRlKFwidHlwZVwiKSwgd2hpY2ggY3Jhc2ggb24gVk1MIG5vZGVzIGluIElFLlxuXHRcdFx0XHRcdGlmKGNoaWxkLm5vZGVUeXBlICE9IDEgfHwgKGhhcyhcImllXCIpIDw9IDkgJiYgY2hpbGQuc2NvcGVOYW1lICE9PSBcIkhUTUxcIikgfHwgIXNob3duKGNoaWxkKSl7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgdGFiaW5kZXggPSBlZmZlY3RpdmVUYWJJbmRleChjaGlsZCk7XG5cdFx0XHRcdFx0aWYodGFiaW5kZXggPj0gMCl7XG5cdFx0XHRcdFx0XHRpZih0YWJpbmRleCA9PSAwKXtcblx0XHRcdFx0XHRcdFx0aWYoIWZpcnN0KXtcblx0XHRcdFx0XHRcdFx0XHRmaXJzdCA9IGNoaWxkO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGxhc3QgPSBjaGlsZDtcblx0XHRcdFx0XHRcdH1lbHNlIGlmKHRhYmluZGV4ID4gMCl7XG5cdFx0XHRcdFx0XHRcdGlmKCFsb3dlc3QgfHwgdGFiaW5kZXggPCBsb3dlc3RUYWJpbmRleCl7XG5cdFx0XHRcdFx0XHRcdFx0bG93ZXN0VGFiaW5kZXggPSB0YWJpbmRleDtcblx0XHRcdFx0XHRcdFx0XHRsb3dlc3QgPSBjaGlsZDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZighaGlnaGVzdCB8fCB0YWJpbmRleCA+PSBoaWdoZXN0VGFiaW5kZXgpe1xuXHRcdFx0XHRcdFx0XHRcdGhpZ2hlc3RUYWJpbmRleCA9IHRhYmluZGV4O1xuXHRcdFx0XHRcdFx0XHRcdGhpZ2hlc3QgPSBjaGlsZDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHJuID0gcmFkaW9OYW1lKGNoaWxkKTtcblx0XHRcdFx0XHRcdGlmKGRvbUF0dHIuZ2V0KGNoaWxkLCBcImNoZWNrZWRcIikgJiYgcm4pe1xuXHRcdFx0XHRcdFx0XHRyYWRpb1NlbGVjdGVkW3JuXSA9IGNoaWxkO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihjaGlsZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9ICdTRUxFQ1QnKXtcblx0XHRcdFx0XHRcdHdhbGtUcmVlKGNoaWxkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRpZihzaG93bihyb290KSl7XG5cdFx0XHRcdHdhbGtUcmVlKHJvb3QpO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gcnMobm9kZSl7XG5cdFx0XHRcdC8vIHN1YnN0aXR1dGUgY2hlY2tlZCByYWRpbyBidXR0b24gZm9yIHVuY2hlY2tlZCBvbmUsIGlmIHRoZXJlIGlzIGEgY2hlY2tlZCBvbmUgd2l0aCB0aGUgc2FtZSBuYW1lLlxuXHRcdFx0XHRyZXR1cm4gcmFkaW9TZWxlY3RlZFtyYWRpb05hbWUobm9kZSldIHx8IG5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IGZpcnN0OiBycyhmaXJzdCksIGxhc3Q6IHJzKGxhc3QpLCBsb3dlc3Q6IHJzKGxvd2VzdCksIGhpZ2hlc3Q6IHJzKGhpZ2hlc3QpIH07XG5cdFx0fSxcblxuXHRcdGdldEZpcnN0SW5UYWJiaW5nT3JkZXI6IGZ1bmN0aW9uKC8qU3RyaW5nfERPTU5vZGUqLyByb290LCAvKkRvY3VtZW50PyovIGRvYyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RmluZHMgdGhlIGRlc2NlbmRhbnQgb2YgdGhlIHNwZWNpZmllZCByb290IG5vZGVcblx0XHRcdC8vXHRcdHRoYXQgaXMgZmlyc3QgaW4gdGhlIHRhYmJpbmcgb3JkZXJcblx0XHRcdHZhciBlbGVtcyA9IGExMXkuX2dldFRhYk5hdmlnYWJsZShkb20uYnlJZChyb290LCBkb2MpKTtcblx0XHRcdHJldHVybiBlbGVtcy5sb3dlc3QgPyBlbGVtcy5sb3dlc3QgOiBlbGVtcy5maXJzdDsgLy8gRG9tTm9kZVxuXHRcdH0sXG5cblx0XHRnZXRMYXN0SW5UYWJiaW5nT3JkZXI6IGZ1bmN0aW9uKC8qU3RyaW5nfERPTU5vZGUqLyByb290LCAvKkRvY3VtZW50PyovIGRvYyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RmluZHMgdGhlIGRlc2NlbmRhbnQgb2YgdGhlIHNwZWNpZmllZCByb290IG5vZGVcblx0XHRcdC8vXHRcdHRoYXQgaXMgbGFzdCBpbiB0aGUgdGFiYmluZyBvcmRlclxuXHRcdFx0dmFyIGVsZW1zID0gYTExeS5fZ2V0VGFiTmF2aWdhYmxlKGRvbS5ieUlkKHJvb3QsIGRvYykpO1xuXHRcdFx0cmV0dXJuIGVsZW1zLmxhc3QgPyBlbGVtcy5sYXN0IDogZWxlbXMuaGlnaGVzdDsgLy8gRG9tTm9kZVxuXHRcdH1cblx0fTtcblxuXHRoYXMoXCJleHRlbmQtZG9qb1wiKSAmJiBsYW5nLm1peGluKGRpaml0LCBhMTF5KTtcblxuXHRyZXR1cm4gYTExeTtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCJkb2pvL2tleXNcIiwgLy8ga2V5cy5FTlRFUiBrZXlzLlNQQUNFXG5cdFwiZG9qby9tb3VzZVwiLFxuXHRcImRvam8vb25cIixcblx0XCJkb2pvL3RvdWNoXCIgLy8gdG91Y2ggc3VwcG9ydCBmb3IgY2xpY2sgaXMgbm93IHRoZXJlXG5dLCBmdW5jdGlvbihrZXlzLCBtb3VzZSwgb24sIHRvdWNoKXtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRpaml0L2ExMXljbGlja1xuXG5cdC8qPT09PT1cblx0cmV0dXJuIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEN1c3RvbSBwcmVzcywgcmVsZWFzZSwgYW5kIGNsaWNrIHN5bnRoZXRpYyBldmVudHNcblx0XHQvL1x0XHR3aGljaCB0cmlnZ2VyIG9uIGEgbGVmdCBtb3VzZSBjbGljaywgdG91Y2gsIG9yIHNwYWNlL2VudGVyIGtleXVwLlxuXG5cdFx0Y2xpY2s6IGZ1bmN0aW9uKG5vZGUsIGxpc3RlbmVyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRMb2dpY2FsIGNsaWNrIG9wZXJhdGlvbiBmb3IgbW91c2UsIHRvdWNoLCBvciBrZXlib2FyZCAoc3BhY2UvZW50ZXIga2V5KVxuXHRcdH0sXG5cdFx0cHJlc3M6IGZ1bmN0aW9uKG5vZGUsIGxpc3RlbmVyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRNb3VzZWRvd24gKGxlZnQgYnV0dG9uKSwgdG91Y2hzdGFydCwgb3Iga2V5ZG93biAoc3BhY2Ugb3IgZW50ZXIpIGNvcnJlc3BvbmRpbmcgdG8gbG9naWNhbCBjbGljayBvcGVyYXRpb24uXG5cdFx0fSxcblx0XHRyZWxlYXNlOiBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0TW91c2V1cCAobGVmdCBidXR0b24pLCB0b3VjaGVuZCwgb3Iga2V5dXAgKHNwYWNlIG9yIGVudGVyKSBjb3JyZXNwb25kaW5nIHRvIGxvZ2ljYWwgY2xpY2sgb3BlcmF0aW9uLlxuXHRcdH0sXG5cdFx0bW92ZTogZnVuY3Rpb24obm9kZSwgbGlzdGVuZXIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdE1vdXNlIGN1cnNvciBvciBhIGZpbmdlciBpcyBkcmFnZ2VkIG92ZXIgdGhlIGdpdmVuIG5vZGUuXG5cdFx0fVxuXHR9O1xuXHQ9PT09PSovXG5cblx0ZnVuY3Rpb24gY2xpY2tLZXkoLypFdmVudCovIGUpe1xuXHRcdC8vIFRlc3QgaWYgdGhpcyBrZXlib2FyZCBldmVudCBzaG91bGQgYmUgdHJhY2tlZCBhcyB0aGUgc3RhcnQgKGlmIGtleWRvd24pIG9yIGVuZCAoaWYga2V5dXApIG9mIGEgY2xpY2sgZXZlbnQuXG5cdFx0Ly8gT25seSB0cmFjayBmb3Igbm9kZXMgbWFya2VkIHRvIGJlIHRyYWNrZWQsIGFuZCBub3QgZm9yIGJ1dHRvbnMgb3IgaW5wdXRzLFxuXHRcdC8vIHNpbmNlIGJ1dHRvbnMgaGFuZGxlIGtleWJvYXJkIGNsaWNrIG5hdGl2ZWx5LCBhbmQgdGV4dCBpbnB1dHMgc2hvdWxkIG5vdFxuXHRcdC8vIHByZXZlbnQgdHlwaW5nIHNwYWNlcyBvciBuZXdsaW5lcy5cblx0XHRpZigoZS5rZXlDb2RlID09PSBrZXlzLkVOVEVSIHx8IGUua2V5Q29kZSA9PT0ga2V5cy5TUEFDRSkgJiYgIS9pbnB1dHxidXR0b258dGV4dGFyZWEvaS50ZXN0KGUudGFyZ2V0Lm5vZGVOYW1lKSl7XG5cblx0XHRcdC8vIFRlc3QgaWYgYSBub2RlIG9yIGl0cyBhbmNlc3RvciBoYXMgYmVlbiBtYXJrZWQgd2l0aCB0aGUgZG9qb0NsaWNrIHByb3BlcnR5IHRvIGluZGljYXRlIHNwZWNpYWwgcHJvY2Vzc2luZ1xuXHRcdFx0Zm9yKHZhciBub2RlID0gZS50YXJnZXQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpe1xuXHRcdFx0XHRpZihub2RlLmRvam9DbGljayl7IHJldHVybiB0cnVlOyB9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGxhc3RLZXlEb3duTm9kZTtcblxuXHRvbihkb2N1bWVudCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpe1xuXHRcdC8vY29uc29sZS5sb2coXCJhMTF5Y2xpY2s6IG9ua2V5ZG93biwgZS50YXJnZXQgPSBcIiwgZS50YXJnZXQsIFwiLCBsYXN0S2V5RG93bk5vZGUgd2FzIFwiLCBsYXN0S2V5RG93bk5vZGUsIFwiLCBlcXVhbGl0eSBpcyBcIiwgKGUudGFyZ2V0ID09PSBsYXN0S2V5RG93bk5vZGUpKTtcblx0XHRpZihjbGlja0tleShlKSl7XG5cdFx0XHQvLyBuZWVkZWQgb24gSUUgZm9yIHdoZW4gZm9jdXMgY2hhbmdlcyBiZXR3ZWVuIGtleWRvd24gYW5kIGtleXVwIC0gb3RoZXJ3aXNlIGRyb3Bkb3duIG1lbnVzIGRvIG5vdCB3b3JrXG5cdFx0XHRsYXN0S2V5RG93bk5vZGUgPSBlLnRhcmdldDtcblxuXHRcdFx0Ly8gUHJldmVudCB2aWV3cG9ydCBzY3JvbGxpbmcgb24gc3BhY2Uga2V5IGluIElFPDkuXG5cdFx0XHQvLyAoUmVwcm9kdWNpYmxlIG9uIHRlc3RfQnV0dG9uLmh0bWwgb24gYW55IG9mIHRoZSBmaXJzdCBkaWppdC9mb3JtL0J1dHRvbiBleGFtcGxlcylcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9ZWxzZXtcblx0XHRcdGxhc3RLZXlEb3duTm9kZSA9IG51bGw7XG5cdFx0fVxuXHR9KTtcblxuXHRvbihkb2N1bWVudCwgXCJrZXl1cFwiLCBmdW5jdGlvbihlKXtcblx0XHQvL2NvbnNvbGUubG9nKFwiYTExeWNsaWNrOiBvbmtleXVwLCBlLnRhcmdldCA9IFwiLCBlLnRhcmdldCwgXCIsIGxhc3RLZXlEb3duTm9kZSB3YXMgXCIsIGxhc3RLZXlEb3duTm9kZSwgXCIsIGVxdWFsaXR5IGlzIFwiLCAoZS50YXJnZXQgPT09IGxhc3RLZXlEb3duTm9kZSkpO1xuXHRcdGlmKGNsaWNrS2V5KGUpICYmIGUudGFyZ2V0ID09IGxhc3RLZXlEb3duTm9kZSl7XHQvLyA9PT0gYnJlYWtzIGdyZWFzZW1vbmtleVxuXHRcdFx0Ly9uZWVkIHJlc2V0IGhlcmUgb3IgaGF2ZSBwcm9ibGVtcyBpbiBGRiB3aGVuIGZvY3VzIHJldHVybnMgdG8gdHJpZ2dlciBlbGVtZW50IGFmdGVyIGNsb3NpbmcgcG9wdXAvYWxlcnRcblx0XHRcdGxhc3RLZXlEb3duTm9kZSA9IG51bGw7XG5cblx0XHRcdG9uLmVtaXQoZS50YXJnZXQsIFwiY2xpY2tcIiwge1xuXHRcdFx0XHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRcdFx0XHRidWJibGVzOiB0cnVlLFxuXHRcdFx0XHRjdHJsS2V5OiBlLmN0cmxLZXksXG5cdFx0XHRcdHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuXHRcdFx0XHRtZXRhS2V5OiBlLm1ldGFLZXksXG5cdFx0XHRcdGFsdEtleTogZS5hbHRLZXksXG5cdFx0XHRcdF9vcmlnVHlwZTogZS50eXBlXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIEkgd2FudCB0byByZXR1cm4gYSBoYXNoIG9mIHRoZSBzeW50aGV0aWMgZXZlbnRzLCBidXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRoZSBtYWluIHJldHVybiB2YWx1ZVxuXHQvLyBuZWVkcyB0byBiZSB0aGUgY2xpY2sgZXZlbnQuICAgQ2hhbmdlIGZvciAyLjAuXG5cblx0dmFyIGNsaWNrID0gZnVuY3Rpb24obm9kZSwgbGlzdGVuZXIpe1xuXHRcdC8vIFNldCBmbGFnIG9uIG5vZGUgc28gdGhhdCBrZXlkb3duL2tleXVwIGFib3ZlIGVtaXRzIGNsaWNrIGV2ZW50LlxuXHRcdC8vIEFsc28gZW5hYmxlcyBmYXN0IGNsaWNrIHByb2Nlc3NpbmcgZnJvbSBkb2pvL3RvdWNoLlxuXHRcdG5vZGUuZG9qb0NsaWNrID0gdHJ1ZTtcblxuXHRcdHJldHVybiBvbihub2RlLCBcImNsaWNrXCIsIGxpc3RlbmVyKTtcblx0fTtcblx0Y2xpY2suY2xpY2sgPSBjbGljaztcdC8vIGZvcndhcmQgY29tcGF0aWJpbGl0eSB3aXRoIDIuMFxuXG5cdGNsaWNrLnByZXNzID0gIGZ1bmN0aW9uKG5vZGUsIGxpc3RlbmVyKXtcblx0XHR2YXIgdG91Y2hMaXN0ZW5lciA9IG9uKG5vZGUsIHRvdWNoLnByZXNzLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0aWYoZXZ0LnR5cGUgPT0gXCJtb3VzZWRvd25cIiAmJiAhbW91c2UuaXNMZWZ0KGV2dCkpe1xuXHRcdFx0XHQvLyBJZ25vcmUgcmlnaHQgY2xpY2tcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0bGlzdGVuZXIoZXZ0KTtcblx0XHR9KSwga2V5TGlzdGVuZXIgPSBvbihub2RlLCBcImtleWRvd25cIiwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdGlmKGV2dC5rZXlDb2RlID09PSBrZXlzLkVOVEVSIHx8IGV2dC5rZXlDb2RlID09PSBrZXlzLlNQQUNFKXtcblx0XHRcdFx0bGlzdGVuZXIoZXZ0KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHR0b3VjaExpc3RlbmVyLnJlbW92ZSgpO1xuXHRcdFx0XHRrZXlMaXN0ZW5lci5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXG5cdGNsaWNrLnJlbGVhc2UgPSAgZnVuY3Rpb24obm9kZSwgbGlzdGVuZXIpe1xuXHRcdHZhciB0b3VjaExpc3RlbmVyID0gb24obm9kZSwgdG91Y2gucmVsZWFzZSwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdGlmKGV2dC50eXBlID09IFwibW91c2V1cFwiICYmICFtb3VzZS5pc0xlZnQoZXZ0KSl7XG5cdFx0XHRcdC8vIElnbm9yZSByaWdodCBjbGlja1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRsaXN0ZW5lcihldnQpO1xuXHRcdH0pLCBrZXlMaXN0ZW5lciA9IG9uKG5vZGUsIFwia2V5dXBcIiwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdGlmKGV2dC5rZXlDb2RlID09PSBrZXlzLkVOVEVSIHx8IGV2dC5rZXlDb2RlID09PSBrZXlzLlNQQUNFKXtcblx0XHRcdFx0bGlzdGVuZXIoZXZ0KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHR0b3VjaExpc3RlbmVyLnJlbW92ZSgpO1xuXHRcdFx0XHRrZXlMaXN0ZW5lci5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXG5cdGNsaWNrLm1vdmUgPSB0b3VjaC5tb3ZlO1x0Ly8ganVzdCBmb3IgY29udmVuaWVuY2VcblxuXHRyZXR1cm4gY2xpY2s7XG59KTtcbiIsImRlZmluZShbXG5cdFwiZG9qby9hc3BlY3RcIixcblx0XCJkb2pvL19iYXNlL2RlY2xhcmVcIiwgLy8gZGVjbGFyZVxuXHRcImRvam8vZG9tXCIsIC8vIGRvbUF0dHIuZ2V0IGRvbS5pc0Rlc2NlbmRhbnRcblx0XCJkb2pvL2RvbS1hdHRyXCIsIC8vIGRvbUF0dHIuZ2V0IGRvbS5pc0Rlc2NlbmRhbnRcblx0XCJkb2pvL2RvbS1jbGFzc1wiLFxuXHRcImRvam8vZG9tLWNvbnN0cnVjdFwiLCAvLyBjb25uZWN0IHRvIGRvbUNvbnN0cnVjdC5lbXB0eSwgZG9tQ29uc3RydWN0LmRlc3Ryb3lcblx0XCJkb2pvL0V2ZW50ZWRcIixcblx0XCJkb2pvL19iYXNlL2xhbmdcIiwgLy8gbGFuZy5oaXRjaFxuXHRcImRvam8vb25cIixcblx0XCJkb2pvL2RvbVJlYWR5XCIsXG5cdFwiZG9qby9zbmlmZlwiLCAvLyBoYXMoXCJpZVwiKVxuXHRcImRvam8vU3RhdGVmdWxcIixcblx0XCJkb2pvL19iYXNlL3dpbmRvd1wiLCAvLyB3aW4uYm9keVxuXHRcImRvam8vd2luZG93XCIsIC8vIHdpblV0aWxzLmdldFxuXHRcIi4vYTExeVwiLFx0Ly8gYTExeS5pc1RhYk5hdmlnYWJsZVxuXHRcIi4vcmVnaXN0cnlcIixcdC8vIHJlZ2lzdHJ5LmJ5SWRcblx0XCIuL21haW5cIlx0XHQvLyB0byBzZXQgZGlqaXQuZm9jdXNcbl0sIGZ1bmN0aW9uKGFzcGVjdCwgZGVjbGFyZSwgZG9tLCBkb21BdHRyLCBkb21DbGFzcywgZG9tQ29uc3RydWN0LCBFdmVudGVkLCBsYW5nLCBvbiwgZG9tUmVhZHksIGhhcywgU3RhdGVmdWwsIHdpbiwgd2luVXRpbHMsXG5cdFx0XHRhMTF5LCByZWdpc3RyeSwgZGlqaXQpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvZm9jdXNcblxuXHQvLyBUaW1lIG9mIHRoZSBsYXN0IGZvY3VzaW4gZXZlbnRcblx0dmFyIGxhc3RGb2N1c2luO1xuXG5cdC8vIFRpbWUgb2YgdGhlIGxhc3QgdG91Y2gvbW91c2Vkb3duIG9yIGZvY3VzaW4gZXZlbnRcblx0dmFyIGxhc3RUb3VjaE9yRm9jdXNpbjtcblxuXHR2YXIgRm9jdXNNYW5hZ2VyID0gZGVjbGFyZShbU3RhdGVmdWwsIEV2ZW50ZWRdLCB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUcmFja3MgdGhlIGN1cnJlbnRseSBmb2N1c2VkIG5vZGUsIGFuZCB3aGljaCB3aWRnZXRzIGFyZSBjdXJyZW50bHkgXCJhY3RpdmVcIi5cblx0XHQvL1x0XHRBY2Nlc3MgdmlhIHJlcXVpcmUoW1wiZGlqaXQvZm9jdXNcIl0sIGZ1bmN0aW9uKGZvY3VzKXsgLi4uIH0pLlxuXHRcdC8vXG5cdFx0Ly9cdFx0QSB3aWRnZXQgaXMgY29uc2lkZXJlZCBhY3RpdmUgaWYgaXQgb3IgYSBkZXNjZW5kYW50IHdpZGdldCBoYXMgZm9jdXMsXG5cdFx0Ly9cdFx0b3IgaWYgYSBub24tZm9jdXNhYmxlIG5vZGUgb2YgdGhpcyB3aWRnZXQgb3IgYSBkZXNjZW5kYW50IHdhcyByZWNlbnRseSBjbGlja2VkLlxuXHRcdC8vXG5cdFx0Ly9cdFx0Q2FsbCBmb2N1cy53YXRjaChcImN1ck5vZGVcIiwgY2FsbGJhY2spIHRvIHRyYWNrIHRoZSBjdXJyZW50IGZvY3VzZWQgRE9NTm9kZSxcblx0XHQvL1x0XHRvciBmb2N1cy53YXRjaChcImFjdGl2ZVN0YWNrXCIsIGNhbGxiYWNrKSB0byB0cmFjayB0aGUgY3VycmVudGx5IGZvY3VzZWQgc3RhY2sgb2Ygd2lkZ2V0cy5cblx0XHQvL1xuXHRcdC8vXHRcdENhbGwgZm9jdXMub24oXCJ3aWRnZXQtYmx1clwiLCBmdW5jKSBvciBmb2N1cy5vbihcIndpZGdldC1mb2N1c1wiLCAuLi4pIHRvIG1vbml0b3Igd2hlblxuXHRcdC8vXHRcdHdoZW4gd2lkZ2V0cyBiZWNvbWUgYWN0aXZlL2luYWN0aXZlXG5cdFx0Ly9cblx0XHQvL1x0XHRGaW5hbGx5LCBmb2N1cyhub2RlKSB3aWxsIGZvY3VzIGEgbm9kZSwgc3VwcHJlc3NpbmcgZXJyb3JzIGlmIHRoZSBub2RlIGRvZXNuJ3QgZXhpc3QuXG5cblx0XHQvLyBjdXJOb2RlOiBEb21Ob2RlXG5cdFx0Ly9cdFx0Q3VycmVudGx5IGZvY3VzZWQgaXRlbSBvbiBzY3JlZW5cblx0XHRjdXJOb2RlOiBudWxsLFxuXG5cdFx0Ly8gYWN0aXZlU3RhY2s6IGRpaml0L19XaWRnZXRCYXNlW11cblx0XHQvL1x0XHRMaXN0IG9mIGN1cnJlbnRseSBhY3RpdmUgd2lkZ2V0cyAoZm9jdXNlZCB3aWRnZXQgYW5kIGl0J3MgYW5jZXN0b3JzKVxuXHRcdGFjdGl2ZVN0YWNrOiBbXSxcblxuXHRcdGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gRG9uJ3QgbGVhdmUgY3VyTm9kZS9wcmV2Tm9kZSBwb2ludGluZyB0byBib2d1cyBlbGVtZW50c1xuXHRcdFx0dmFyIGNoZWNrID0gbGFuZy5oaXRjaCh0aGlzLCBmdW5jdGlvbihub2RlKXtcblx0XHRcdFx0aWYoZG9tLmlzRGVzY2VuZGFudCh0aGlzLmN1ck5vZGUsIG5vZGUpKXtcblx0XHRcdFx0XHR0aGlzLnNldChcImN1ck5vZGVcIiwgbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZG9tLmlzRGVzY2VuZGFudCh0aGlzLnByZXZOb2RlLCBub2RlKSl7XG5cdFx0XHRcdFx0dGhpcy5zZXQoXCJwcmV2Tm9kZVwiLCBudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRhc3BlY3QuYmVmb3JlKGRvbUNvbnN0cnVjdCwgXCJlbXB0eVwiLCBjaGVjayk7XG5cdFx0XHRhc3BlY3QuYmVmb3JlKGRvbUNvbnN0cnVjdCwgXCJkZXN0cm95XCIsIGNoZWNrKTtcblx0XHR9LFxuXG5cdFx0cmVnaXN0ZXJJZnJhbWU6IGZ1bmN0aW9uKC8qRG9tTm9kZSovIGlmcmFtZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVnaXN0ZXJzIGxpc3RlbmVycyBvbiB0aGUgc3BlY2lmaWVkIGlmcmFtZSBzbyB0aGF0IGFueSBjbGlja1xuXHRcdFx0Ly9cdFx0b3IgZm9jdXMgZXZlbnQgb24gdGhhdCBpZnJhbWUgKG9yIGFueXRoaW5nIGluIGl0KSBpcyByZXBvcnRlZFxuXHRcdFx0Ly9cdFx0YXMgYSBmb2N1cy9jbGljayBldmVudCBvbiB0aGUgYDxpZnJhbWU+YCBpdHNlbGYuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEN1cnJlbnRseSBvbmx5IHVzZWQgYnkgZWRpdG9yLlxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdEhhbmRsZSB3aXRoIHJlbW92ZSgpIG1ldGhvZCB0byBkZXJlZ2lzdGVyLlxuXHRcdFx0cmV0dXJuIHRoaXMucmVnaXN0ZXJXaW4oaWZyYW1lLmNvbnRlbnRXaW5kb3csIGlmcmFtZSk7XG5cdFx0fSxcblxuXHRcdHJlZ2lzdGVyV2luOiBmdW5jdGlvbigvKldpbmRvdz8qL3RhcmdldFdpbmRvdywgLypEb21Ob2RlPyovIGVmZmVjdGl2ZU5vZGUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlZ2lzdGVycyBsaXN0ZW5lcnMgb24gdGhlIHNwZWNpZmllZCB3aW5kb3cgKGVpdGhlciB0aGUgbWFpblxuXHRcdFx0Ly9cdFx0d2luZG93IG9yIGFuIGlmcmFtZSdzIHdpbmRvdykgdG8gZGV0ZWN0IHdoZW4gdGhlIHVzZXIgaGFzIGNsaWNrZWQgc29tZXdoZXJlXG5cdFx0XHQvL1x0XHRvciBmb2N1c2VkIHNvbWV3aGVyZS5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0VXNlcnMgc2hvdWxkIGNhbGwgcmVnaXN0ZXJJZnJhbWUoKSBpbnN0ZWFkIG9mIHRoaXMgbWV0aG9kLlxuXHRcdFx0Ly8gdGFyZ2V0V2luZG93OlxuXHRcdFx0Ly9cdFx0SWYgc3BlY2lmaWVkIHRoaXMgaXMgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGlmcmFtZSxcblx0XHRcdC8vXHRcdGkuZS4gaWZyYW1lLmNvbnRlbnRXaW5kb3cuXG5cdFx0XHQvLyBlZmZlY3RpdmVOb2RlOlxuXHRcdFx0Ly9cdFx0SWYgc3BlY2lmaWVkLCByZXBvcnQgYW55IGZvY3VzIGV2ZW50cyBpbnNpZGUgdGFyZ2V0V2luZG93IGFzXG5cdFx0XHQvL1x0XHRhbiBldmVudCBvbiBlZmZlY3RpdmVOb2RlLCByYXRoZXIgdGhhbiBvbiBldnQudGFyZ2V0LlxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdEhhbmRsZSB3aXRoIHJlbW92ZSgpIG1ldGhvZCB0byBkZXJlZ2lzdGVyLlxuXG5cdFx0XHQvLyBUT0RPOiBtYWtlIHRoaXMgZnVuY3Rpb24gcHJpdmF0ZSBpbiAyLjA7IEVkaXRvci91c2VycyBzaG91bGQgY2FsbCByZWdpc3RlcklmcmFtZSgpLFxuXG5cdFx0XHQvLyBMaXN0ZW4gZm9yIGJsdXIgYW5kIGZvY3VzIGV2ZW50cyBvbiB0YXJnZXRXaW5kb3cncyBkb2N1bWVudC5cblx0XHRcdHZhciBfdGhpcyA9IHRoaXMsXG5cdFx0XHRcdGJvZHkgPSB0YXJnZXRXaW5kb3cuZG9jdW1lbnQgJiYgdGFyZ2V0V2luZG93LmRvY3VtZW50LmJvZHk7XG5cblx0XHRcdGlmKGJvZHkpe1xuXHRcdFx0XHQvLyBMaXN0ZW4gZm9yIHRvdWNoZXMgb3IgbW91c2Vkb3ducy4uLiBjb3VsZCBhbHNvIHVzZSBkb2pvL3RvdWNoLnByZXNzIGhlcmUuXG5cdFx0XHRcdHZhciBldmVudCA9IGhhcyhcInBvaW50ZXItZXZlbnRzXCIpID8gXCJwb2ludGVyZG93blwiIDogaGFzKFwiTVNQb2ludGVyXCIpID8gXCJNU1BvaW50ZXJEb3duXCIgOlxuXHRcdFx0XHRcdGhhcyhcInRvdWNoLWV2ZW50c1wiKSA/IFwibW91c2Vkb3duLCB0b3VjaHN0YXJ0XCIgOiBcIm1vdXNlZG93blwiO1xuXHRcdFx0XHR2YXIgbWRoID0gb24odGFyZ2V0V2luZG93LmRvY3VtZW50LCBldmVudCwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0XHQvLyB3b3JrYXJvdW5kIHdlaXJkIElFIGJ1ZyB3aGVyZSB0aGUgY2xpY2sgaXMgb24gYW4gb3JwaGFuZWQgbm9kZVxuXHRcdFx0XHRcdC8vIChmaXJzdCB0aW1lIGNsaWNraW5nIGEgU2VsZWN0L0Ryb3BEb3duQnV0dG9uIGluc2lkZSBhIFRvb2x0aXBEaWFsb2cpLlxuXHRcdFx0XHRcdC8vIGFjdHVhbGx5LCBzdHJhbmdlbHkgdGhpcyBpcyBoYXBwZW5pbmcgb24gbGF0ZXN0IGNocm9tZSB0b28uXG5cdFx0XHRcdFx0aWYoZXZ0ICYmIGV2dC50YXJnZXQgJiYgZXZ0LnRhcmdldC5wYXJlbnROb2RlID09IG51bGwpe1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF90aGlzLl9vblRvdWNoTm9kZShlZmZlY3RpdmVOb2RlIHx8IGV2dC50YXJnZXQsIFwibW91c2VcIik7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHZhciBmaWggPSBvbihib2R5LCAnZm9jdXNpbicsIGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHRcdFx0Ly8gV2hlbiB5b3UgcmVmb2N1cyB0aGUgYnJvd3NlciB3aW5kb3csIElFIGdpdmVzIGFuIGV2ZW50IHdpdGggYW4gZW1wdHkgc3JjRWxlbWVudFxuXHRcdFx0XHRcdGlmKCFldnQudGFyZ2V0LnRhZ05hbWUpIHsgcmV0dXJuOyB9XG5cblx0XHRcdFx0XHQvLyBJRSByZXBvcnRzIHRoYXQgbm9kZXMgbGlrZSA8Ym9keT4gaGF2ZSBnb3R0ZW4gZm9jdXMsIGV2ZW4gdGhvdWdoIHRoZXkgaGF2ZSB0YWJJbmRleD0tMSxcblx0XHRcdFx0XHQvLyBpZ25vcmUgdGhvc2UgZXZlbnRzXG5cdFx0XHRcdFx0dmFyIHRhZyA9IGV2dC50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGlmKHRhZyA9PSBcIiNkb2N1bWVudFwiIHx8IHRhZyA9PSBcImJvZHlcIil7IHJldHVybjsgfVxuXG5cdFx0XHRcdFx0aWYoYTExeS5pc0ZvY3VzYWJsZShldnQudGFyZ2V0KSl7XG5cdFx0XHRcdFx0XHRfdGhpcy5fb25Gb2N1c05vZGUoZWZmZWN0aXZlTm9kZSB8fCBldnQudGFyZ2V0KTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdC8vIFByZXZpb3VzIGNvZGUgY2FsbGVkIF9vblRvdWNoTm9kZSgpIGZvciBhbnkgYWN0aXZhdGUgZXZlbnQgb24gYSBub24tZm9jdXNhYmxlIG5vZGUuICAgQ2FuXG5cdFx0XHRcdFx0XHQvLyBwcm9iYWJseSBqdXN0IGlnbm9yZSBzdWNoIGFuIGV2ZW50IGFzIGl0IHdpbGwgYmUgaGFuZGxlZCBieSBvbm1vdXNlZG93biBoYW5kbGVyIGFib3ZlLCBidXRcblx0XHRcdFx0XHRcdC8vIGxlYXZpbmcgdGhlIGNvZGUgZm9yIG5vdy5cblx0XHRcdFx0XHRcdF90aGlzLl9vblRvdWNoTm9kZShlZmZlY3RpdmVOb2RlIHx8IGV2dC50YXJnZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dmFyIGZvaCA9IG9uKGJvZHksICdmb2N1c291dCcsIGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHRcdFx0X3RoaXMuX29uQmx1ck5vZGUoZWZmZWN0aXZlTm9kZSB8fCBldnQudGFyZ2V0KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRtZGgucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRmaWgucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRmb2gucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRtZGggPSBmaWggPSBmb2ggPSBudWxsO1xuXHRcdFx0XHRcdFx0Ym9keSA9IG51bGw7XHQvLyBwcmV2ZW50IG1lbW9yeSBsZWFrIChhcHBhcmVudCBjaXJjdWxhciByZWZlcmVuY2UgdmlhIGNsb3N1cmUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfb25CbHVyTm9kZTogZnVuY3Rpb24oLypEb21Ob2RlKi8gbm9kZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2FsbGVkIHdoZW4gZm9jdXMgbGVhdmVzIGEgbm9kZS5cblx0XHRcdC8vXHRcdFVzdWFsbHkgaWdub3JlZCwgX3VubGVzc18gaXQgKmlzbid0KiBmb2xsb3dlZCBieSB0b3VjaGluZyBhbm90aGVyIG5vZGUsXG5cdFx0XHQvL1x0XHR3aGljaCBpbmRpY2F0ZXMgdGhhdCB3ZSB0YWJiZWQgb2ZmIHRoZSBsYXN0IGZpZWxkIG9uIHRoZSBwYWdlLFxuXHRcdFx0Ly9cdFx0aW4gd2hpY2ggY2FzZSBldmVyeSB3aWRnZXQgaXMgbWFya2VkIGluYWN0aXZlXG5cblx0XHRcdHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG5cdFx0XHQvLyBJRTkrIGFuZCBjaHJvbWUgaGF2ZSBhIHByb2JsZW0gd2hlcmUgZm9jdXNvdXQgZXZlbnRzIGNvbWUgYWZ0ZXIgdGhlIGNvcnJlc3BvbmRpbmcgZm9jdXNpbiBldmVudC5cblx0XHRcdC8vIEZvciBjaHJvbWUgcHJvYmxlbSBzZWUgaHR0cHM6Ly9idWdzLmRvam90b29sa2l0Lm9yZy90aWNrZXQvMTc2NjguXG5cdFx0XHQvLyBJRSBwcm9ibGVtIGhhcHBlbnMgd2hlbiBtb3ZpbmcgZm9jdXMgZnJvbSB0aGUgRWRpdG9yJ3MgPGlmcmFtZT4gdG8gYSBub3JtYWwgRE9NTm9kZS5cblx0XHRcdGlmKG5vdyA8IGxhc3RGb2N1c2luICsgMTAwKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgYmx1ciBldmVudCBpc24ndCBmb2xsb3dlZCBieSBhIGZvY3VzIGV2ZW50LCBpdCBtZWFucyB0aGUgdXNlciBjbGlja2VkIG9uIHNvbWV0aGluZyB1bmZvY3VzYWJsZSxcblx0XHRcdC8vIHNvIGNsZWFyIGZvY3VzLlxuXHRcdFx0aWYodGhpcy5fY2xlYXJGb2N1c1RpbWVyKXtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2NsZWFyRm9jdXNUaW1lcik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jbGVhckZvY3VzVGltZXIgPSBzZXRUaW1lb3V0KGxhbmcuaGl0Y2godGhpcywgZnVuY3Rpb24oKXtcblx0XHRcdFx0dGhpcy5zZXQoXCJwcmV2Tm9kZVwiLCB0aGlzLmN1ck5vZGUpO1xuXHRcdFx0XHR0aGlzLnNldChcImN1ck5vZGVcIiwgbnVsbCk7XG5cdFx0XHR9KSwgMCk7XG5cblx0XHRcdC8vIFVuc2V0IHRpbWVyIHRvIHplcm8tb3V0IHdpZGdldCBzdGFjazsgd2UnbGwgcmVzZXQgaXQgYmVsb3cgaWYgYXBwcm9wcmlhdGUuXG5cdFx0XHRpZih0aGlzLl9jbGVhckFjdGl2ZVdpZGdldHNUaW1lcil7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9jbGVhckFjdGl2ZVdpZGdldHNUaW1lcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmKG5vdyA8IGxhc3RUb3VjaE9yRm9jdXNpbiArIDEwMCl7XG5cdFx0XHRcdC8vIFRoaXMgYmx1ciBldmVudCBpcyBjb21pbmcgbGF0ZSAoYWZ0ZXIgdGhlIGNhbGwgdG8gX29uVG91Y2hOb2RlKCkgcmF0aGVyIHRoYW4gYmVmb3JlLlxuXHRcdFx0XHQvLyBTbyBsZXQgX29uVG91Y2hOb2RlKCkgaGFuZGxlIHNldHRpbmcgdGhlIHdpZGdldCBzdGFjay5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vYnVncy5kb2pvdG9vbGtpdC5vcmcvdGlja2V0LzE3NjY4XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIGJsdXIgZXZlbnQgaXNuJ3QgZm9sbG93ZWQgKG9yIHByZWNlZGVkKSBieSBhIGZvY3VzIG9yIHRvdWNoIGV2ZW50IHRoZW4gbWFyayBhbGwgd2lkZ2V0cyBhcyBpbmFjdGl2ZS5cblx0XHRcdHRoaXMuX2NsZWFyQWN0aXZlV2lkZ2V0c1RpbWVyID0gc2V0VGltZW91dChsYW5nLmhpdGNoKHRoaXMsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9jbGVhckFjdGl2ZVdpZGdldHNUaW1lcjtcblx0XHRcdFx0dGhpcy5fc2V0U3RhY2soW10pO1xuXHRcdFx0fSksIDApO1xuXHRcdH0sXG5cblx0XHRfb25Ub3VjaE5vZGU6IGZ1bmN0aW9uKC8qRG9tTm9kZSovIG5vZGUsIC8qU3RyaW5nKi8gYnkpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbGxiYWNrIHdoZW4gbm9kZSBpcyBmb2N1c2VkIG9yIHRvdWNoZWQuXG5cdFx0XHQvL1x0XHROb3RlIHRoYXQgX29uRm9jdXNOb2RlKCkgY2FsbHMgX29uVG91Y2hOb2RlKCkuXG5cdFx0XHQvLyBub2RlOlxuXHRcdFx0Ly9cdFx0VGhlIG5vZGUgdGhhdCB3YXMgdG91Y2hlZC5cblx0XHRcdC8vIGJ5OlxuXHRcdFx0Ly9cdFx0XCJtb3VzZVwiIGlmIHRoZSBmb2N1cy90b3VjaCB3YXMgY2F1c2VkIGJ5IGEgbW91c2UgZG93biBldmVudFxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHRpbWUgb2YgbGFzdCBmb2N1c2luIG9yIHRvdWNoIGV2ZW50LlxuXHRcdFx0bGFzdFRvdWNoT3JGb2N1c2luID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0aWYodGhpcy5fY2xlYXJBY3RpdmVXaWRnZXRzVGltZXIpe1xuXHRcdFx0XHQvLyBmb3JnZXQgdGhlIHJlY2VudCBibHVyIGV2ZW50XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9jbGVhckFjdGl2ZVdpZGdldHNUaW1lcik7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9jbGVhckFjdGl2ZVdpZGdldHNUaW1lcjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgdGhlIGNsaWNrIG9jY3VycmVkIG9uIHRoZSBzY3JvbGxiYXIgb2YgYSBkcm9wZG93biwgdHJlYXQgaXQgYXMgYSBjbGljayBvbiB0aGUgZHJvcGRvd24sXG5cdFx0XHQvLyBldmVuIHRob3VnaCB0aGUgc2Nyb2xsYmFyIGlzIHRlY2huaWNhbGx5IG9uIHRoZSBwb3B1cCB3cmFwcGVyIChzZWUgIzEwNjMxKVxuXHRcdFx0aWYoZG9tQ2xhc3MuY29udGFpbnMobm9kZSwgXCJkaWppdFBvcHVwXCIpKXtcblx0XHRcdFx0bm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY29tcHV0ZSBzdGFjayBvZiBhY3RpdmUgd2lkZ2V0cyAoZXg6IENvbWJvQnV0dG9uIC0tPiBNZW51IC0tPiBNZW51SXRlbSlcblx0XHRcdHZhciBuZXdTdGFjaz1bXTtcblx0XHRcdHRyeXtcblx0XHRcdFx0d2hpbGUobm9kZSl7XG5cdFx0XHRcdFx0dmFyIHBvcHVwUGFyZW50ID0gZG9tQXR0ci5nZXQobm9kZSwgXCJkaWppdFBvcHVwUGFyZW50XCIpO1xuXHRcdFx0XHRcdGlmKHBvcHVwUGFyZW50KXtcblx0XHRcdFx0XHRcdG5vZGU9cmVnaXN0cnkuYnlJZChwb3B1cFBhcmVudCkuZG9tTm9kZTtcblx0XHRcdFx0XHR9ZWxzZSBpZihub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJib2R5XCIpe1xuXHRcdFx0XHRcdFx0Ly8gaXMgdGhpcyB0aGUgcm9vdCBvZiB0aGUgZG9jdW1lbnQgb3IganVzdCB0aGUgcm9vdCBvZiBhbiBpZnJhbWU/XG5cdFx0XHRcdFx0XHRpZihub2RlID09PSB3aW4uYm9keSgpKXtcblx0XHRcdFx0XHRcdFx0Ly8gbm9kZSBpcyB0aGUgcm9vdCBvZiB0aGUgbWFpbiBkb2N1bWVudFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIG90aGVyd2lzZSwgZmluZCB0aGUgaWZyYW1lIHRoaXMgbm9kZSByZWZlcnMgdG8gKGNhbid0IGFjY2VzcyBpdCB2aWEgcGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdC8vIG5lZWQgdG8gZG8gdGhpcyB0cmljayBpbnN0ZWFkKS4gd2luZG93LmZyYW1lRWxlbWVudCBpcyBzdXBwb3J0ZWQgaW4gSUUvRkYvV2Via2l0XG5cdFx0XHRcdFx0XHRub2RlPXdpblV0aWxzLmdldChub2RlLm93bmVyRG9jdW1lbnQpLmZyYW1lRWxlbWVudDtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdC8vIGlmIHRoaXMgbm9kZSBpcyB0aGUgcm9vdCBub2RlIG9mIGEgd2lkZ2V0LCB0aGVuIGFkZCB3aWRnZXQgaWQgdG8gc3RhY2ssXG5cdFx0XHRcdFx0XHQvLyBleGNlcHQgaWdub3JlIGNsaWNrcyBvbiBkaXNhYmxlZCB3aWRnZXRzIChhY3R1YWxseSBmb2N1c2luZyBhIGRpc2FibGVkIHdpZGdldCBzdGlsbCB3b3Jrcyxcblx0XHRcdFx0XHRcdC8vIHRvIHN1cHBvcnQgTWVudUl0ZW0pXG5cdFx0XHRcdFx0XHR2YXIgaWQgPSBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShcIndpZGdldElkXCIpLFxuXHRcdFx0XHRcdFx0XHR3aWRnZXQgPSBpZCAmJiByZWdpc3RyeS5ieUlkKGlkKTtcblx0XHRcdFx0XHRcdGlmKHdpZGdldCAmJiAhKGJ5ID09IFwibW91c2VcIiAmJiB3aWRnZXQuZ2V0KFwiZGlzYWJsZWRcIikpKXtcblx0XHRcdFx0XHRcdFx0bmV3U3RhY2sudW5zaGlmdChpZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRub2RlPW5vZGUucGFyZW50Tm9kZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1jYXRjaChlKXsgLyogc3F1ZWxjaCAqLyB9XG5cblx0XHRcdHRoaXMuX3NldFN0YWNrKG5ld1N0YWNrLCBieSk7XG5cdFx0fSxcblxuXHRcdF9vbkZvY3VzTm9kZTogZnVuY3Rpb24oLypEb21Ob2RlKi8gbm9kZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgd2hlbiBub2RlIGlzIGZvY3VzZWRcblxuXHRcdFx0aWYoIW5vZGUpe1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKG5vZGUubm9kZVR5cGUgPT0gOSl7XG5cdFx0XHRcdC8vIElnbm9yZSBmb2N1cyBldmVudHMgb24gdGhlIGRvY3VtZW50IGl0c2VsZi4gIFRoaXMgaXMgaGVyZSBzbyB0aGF0XG5cdFx0XHRcdC8vIChmb3IgZXhhbXBsZSkgY2xpY2tpbmcgdGhlIHVwL2Rvd24gYXJyb3dzIG9mIGEgc3Bpbm5lclxuXHRcdFx0XHQvLyAod2hpY2ggZG9uJ3QgZ2V0IGZvY3VzKSB3b24ndCBjYXVzZSB0aGF0IHdpZGdldCB0byBibHVyLiAoRkYgaXNzdWUpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB0aW1lIG9mIGxhc3QgZm9jdXNpbiBldmVudC5cblx0XHRcdGxhc3RGb2N1c2luID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0Ly8gVGhlcmUgd2FzIHByb2JhYmx5IGEgYmx1ciBldmVudCByaWdodCBiZWZvcmUgdGhpcyBldmVudCwgYnV0IHNpbmNlIHdlIGhhdmUgYSBuZXcgZm9jdXMsXG5cdFx0XHQvLyBmb3JnZXQgYWJvdXQgdGhlIGJsdXJcblx0XHRcdGlmKHRoaXMuX2NsZWFyRm9jdXNUaW1lcil7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9jbGVhckZvY3VzVGltZXIpO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fY2xlYXJGb2N1c1RpbWVyO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9vblRvdWNoTm9kZShub2RlKTtcblxuXHRcdFx0aWYobm9kZSA9PSB0aGlzLmN1ck5vZGUpeyByZXR1cm47IH1cblx0XHRcdHRoaXMuc2V0KFwicHJldk5vZGVcIiwgdGhpcy5jdXJOb2RlKTtcblx0XHRcdHRoaXMuc2V0KFwiY3VyTm9kZVwiLCBub2RlKTtcblx0XHR9LFxuXG5cdFx0X3NldFN0YWNrOiBmdW5jdGlvbigvKlN0cmluZ1tdKi8gbmV3U3RhY2ssIC8qU3RyaW5nKi8gYnkpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRoZSBzdGFjayBvZiBhY3RpdmUgd2lkZ2V0cyBoYXMgY2hhbmdlZC4gIFNlbmQgb3V0IGFwcHJvcHJpYXRlIGV2ZW50cyBhbmQgcmVjb3JkcyBuZXcgc3RhY2suXG5cdFx0XHQvLyBuZXdTdGFjazpcblx0XHRcdC8vXHRcdGFycmF5IG9mIHdpZGdldCBpZCdzLCBzdGFydGluZyBmcm9tIHRoZSB0b3AgKG91dGVybW9zdCkgd2lkZ2V0XG5cdFx0XHQvLyBieTpcblx0XHRcdC8vXHRcdFwibW91c2VcIiBpZiB0aGUgZm9jdXMvdG91Y2ggd2FzIGNhdXNlZCBieSBhIG1vdXNlIGRvd24gZXZlbnRcblxuXHRcdFx0dmFyIG9sZFN0YWNrID0gdGhpcy5hY3RpdmVTdGFjaywgbGFzdE9sZElkeCA9IG9sZFN0YWNrLmxlbmd0aCAtIDEsIGxhc3ROZXdJZHggPSBuZXdTdGFjay5sZW5ndGggLSAxO1xuXG5cdFx0XHRpZihuZXdTdGFja1tsYXN0TmV3SWR4XSA9PSBvbGRTdGFja1tsYXN0T2xkSWR4XSl7XG5cdFx0XHRcdC8vIG5vIGNoYW5nZXMsIHJldHVybiBub3cgdG8gYXZvaWQgc3B1cmlvdXMgbm90aWZpY2F0aW9ucyBhYm91dCBjaGFuZ2VzIHRvIGFjdGl2ZVN0YWNrXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXQoXCJhY3RpdmVTdGFja1wiLCBuZXdTdGFjayk7XG5cblx0XHRcdHZhciB3aWRnZXQsIGk7XG5cblx0XHRcdC8vIGZvciBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIGdvbmUgb3V0IG9mIGZvY3VzLCBzZXQgZm9jdXNlZD1mYWxzZVxuXHRcdFx0Zm9yKGkgPSBsYXN0T2xkSWR4OyBpID49IDAgJiYgb2xkU3RhY2tbaV0gIT0gbmV3U3RhY2tbaV07IGktLSl7XG5cdFx0XHRcdHdpZGdldCA9IHJlZ2lzdHJ5LmJ5SWQob2xkU3RhY2tbaV0pO1xuXHRcdFx0XHRpZih3aWRnZXQpe1xuXHRcdFx0XHRcdHdpZGdldC5faGFzQmVlbkJsdXJyZWQgPSB0cnVlO1x0XHQvLyBUT0RPOiB1c2VkIGJ5IGZvcm0gd2lkZ2V0cywgc2hvdWxkIGJlIG1vdmVkIHRoZXJlXG5cdFx0XHRcdFx0d2lkZ2V0LnNldChcImZvY3VzZWRcIiwgZmFsc2UpO1xuXHRcdFx0XHRcdGlmKHdpZGdldC5fZm9jdXNNYW5hZ2VyID09IHRoaXMpe1xuXHRcdFx0XHRcdFx0d2lkZ2V0Ll9vbkJsdXIoYnkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmVtaXQoXCJ3aWRnZXQtYmx1clwiLCB3aWRnZXQsIGJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBmb3IgYWxsIGVsZW1lbnQgdGhhdCBoYXZlIGNvbWUgaW50byBmb2N1cywgc2V0IGZvY3VzZWQ9dHJ1ZVxuXHRcdFx0Zm9yKGkrKzsgaSA8PSBsYXN0TmV3SWR4OyBpKyspe1xuXHRcdFx0XHR3aWRnZXQgPSByZWdpc3RyeS5ieUlkKG5ld1N0YWNrW2ldKTtcblx0XHRcdFx0aWYod2lkZ2V0KXtcblx0XHRcdFx0XHR3aWRnZXQuc2V0KFwiZm9jdXNlZFwiLCB0cnVlKTtcblx0XHRcdFx0XHRpZih3aWRnZXQuX2ZvY3VzTWFuYWdlciA9PSB0aGlzKXtcblx0XHRcdFx0XHRcdHdpZGdldC5fb25Gb2N1cyhieSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuZW1pdChcIndpZGdldC1mb2N1c1wiLCB3aWRnZXQsIGJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRmb2N1czogZnVuY3Rpb24obm9kZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Rm9jdXMgdGhlIHNwZWNpZmllZCBub2RlLCBzdXBwcmVzc2luZyBlcnJvcnMgaWYgdGhleSBvY2N1clxuXHRcdFx0aWYobm9kZSl7XG5cdFx0XHRcdHRyeXsgbm9kZS5mb2N1cygpOyB9Y2F0Y2goZSl7LypxdWlldCovfVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0dmFyIHNpbmdsZXRvbiA9IG5ldyBGb2N1c01hbmFnZXIoKTtcblxuXHQvLyByZWdpc3RlciB0b3Agd2luZG93IGFuZCBhbGwgdGhlIGlmcmFtZXMgaXQgY29udGFpbnNcblx0ZG9tUmVhZHkoZnVuY3Rpb24oKXtcblx0XHR2YXIgaGFuZGxlID0gc2luZ2xldG9uLnJlZ2lzdGVyV2luKHdpblV0aWxzLmdldChkb2N1bWVudCkpO1xuXHRcdGlmKGhhcyhcImllXCIpKXtcblx0XHRcdG9uKHdpbmRvdywgXCJ1bmxvYWRcIiwgZnVuY3Rpb24oKXtcblx0XHRcdFx0aWYoaGFuZGxlKXtcdC8vIGJlY2F1c2UgdGhpcyBnZXRzIGNhbGxlZCB0d2ljZSB3aGVuIGRvaC5yb2JvdCBpcyBydW5uaW5nXG5cdFx0XHRcdFx0aGFuZGxlLnJlbW92ZSgpO1xuXHRcdFx0XHRcdGhhbmRsZSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gU2V0dXAgZGlqaXQuZm9jdXMgYXMgYSBwb2ludGVyIHRvIHRoZSBzaW5nbGV0b24gYnV0IGFsc28gKGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcblx0Ly8gYXMgYSBmdW5jdGlvbiB0byBzZXQgZm9jdXMuICAgUmVtb3ZlIGZvciAyLjAuXG5cdGRpaml0LmZvY3VzID0gZnVuY3Rpb24obm9kZSl7XG5cdFx0c2luZ2xldG9uLmZvY3VzKG5vZGUpO1x0Ly8gaW5kaXJlY3Rpb24gaGVyZSBhbGxvd3MgZGlqaXQvX2Jhc2UvZm9jdXMuanMgdG8gb3ZlcnJpZGUgYmVoYXZpb3Jcblx0fTtcblx0Zm9yKHZhciBhdHRyIGluIHNpbmdsZXRvbil7XG5cdFx0aWYoIS9eXy8udGVzdChhdHRyKSl7XG5cdFx0XHRkaWppdC5mb2N1c1thdHRyXSA9IHR5cGVvZiBzaW5nbGV0b25bYXR0cl0gPT0gXCJmdW5jdGlvblwiID8gbGFuZy5oaXRjaChzaW5nbGV0b24sIGF0dHIpIDogc2luZ2xldG9uW2F0dHJdO1xuXHRcdH1cblx0fVxuXHRzaW5nbGV0b24ud2F0Y2goZnVuY3Rpb24oYXR0ciwgb2xkVmFsLCBuZXdWYWwpe1xuXHRcdGRpaml0LmZvY3VzW2F0dHJdID0gbmV3VmFsO1xuXHR9KTtcblxuXHRyZXR1cm4gc2luZ2xldG9uO1xufSk7XG4iLCJkZWZpbmUoW1xuXHRcImRvam8vX2Jhc2UvZGVjbGFyZVwiLCAvLyBkZWNsYXJlXG5cdFwiZG9qby9kb20tYXR0clwiLCAvLyBkb21BdHRyLnNldFxuXHRcImRvam8vX2Jhc2Uva2VybmVsXCIsIC8vIGtlcm5lbC5kZXByZWNhdGVkXG5cdFwiZG9qby9zbmlmZlwiLCAvLyBoYXMoXCJpZVwiKVxuXHRcIi4uL19XaWRnZXRcIixcblx0XCIuLi9fVGVtcGxhdGVkTWl4aW5cIixcblx0XCIuL19Gb3JtTWl4aW5cIixcblx0XCIuLi9sYXlvdXQvX0NvbnRlbnRQYW5lUmVzaXplTWl4aW5cIlxuXSwgZnVuY3Rpb24oZGVjbGFyZSwgZG9tQXR0ciwga2VybmVsLCBoYXMsIF9XaWRnZXQsIF9UZW1wbGF0ZWRNaXhpbiwgX0Zvcm1NaXhpbiwgX0NvbnRlbnRQYW5lUmVzaXplTWl4aW4pe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvZm9ybS9Gb3JtXG5cblxuXHRyZXR1cm4gZGVjbGFyZShcImRpaml0LmZvcm0uRm9ybVwiLCBbX1dpZGdldCwgX1RlbXBsYXRlZE1peGluLCBfRm9ybU1peGluLCBfQ29udGVudFBhbmVSZXNpemVNaXhpbl0sIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFdpZGdldCBjb3JyZXNwb25kaW5nIHRvIEhUTUwgZm9ybSB0YWcsIGZvciB2YWxpZGF0aW9uIGFuZCBzZXJpYWxpemF0aW9uXG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHQ8Zm9ybSBkYXRhLWRvam8tdHlwZT1cImRpaml0L2Zvcm0vRm9ybVwiIGlkPVwibXlGb3JtXCI+XG5cdFx0Ly9cdHxcdFx0TmFtZTogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cIm5hbWVcIiAvPlxuXHRcdC8vXHR8XHQ8L2Zvcm0+XG5cdFx0Ly9cdHxcdC8vIEV4YW1wbGUgYXNzdW1lcyB5b3UgaGF2ZSByZXF1aXJlZCBkaWppdC9yZWdpc3RyeVxuXHRcdC8vXHR8XHRteU9iaiA9IHtuYW1lOiBcIkpvaG4gRG9lXCJ9O1xuXHRcdC8vXHR8XHRyZWdpc3RyeS5ieUlkKCdteUZvcm0nKS5zZXQoJ3ZhbHVlJywgbXlPYmopO1xuXHRcdC8vXHR8XG5cdFx0Ly9cdHxcdG15T2JqPXJlZ2lzdHJ5LmJ5SWQoJ215Rm9ybScpLmdldCgndmFsdWUnKTtcblxuXHRcdC8vIEhUTUwgPEZPUk0+IGF0dHJpYnV0ZXNcblxuXHRcdC8vIG5hbWU6IFN0cmluZz9cblx0XHQvL1x0XHROYW1lIG9mIGZvcm0gZm9yIHNjcmlwdGluZy5cblx0XHRuYW1lOiBcIlwiLFxuXG5cdFx0Ly8gYWN0aW9uOiBTdHJpbmc/XG5cdFx0Ly9cdFx0U2VydmVyLXNpZGUgZm9ybSBoYW5kbGVyLlxuXHRcdGFjdGlvbjogXCJcIixcblxuXHRcdC8vIG1ldGhvZDogU3RyaW5nP1xuXHRcdC8vXHRcdEhUVFAgbWV0aG9kIHVzZWQgdG8gc3VibWl0IHRoZSBmb3JtLCBlaXRoZXIgXCJHRVRcIiBvciBcIlBPU1RcIi5cblx0XHRtZXRob2Q6IFwiXCIsXG5cblx0XHQvLyBlbmNUeXBlOiBTdHJpbmc/XG5cdFx0Ly9cdFx0RW5jb2RpbmcgdHlwZSBmb3IgdGhlIGZvcm0sIGV4OiBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQuXG5cdFx0ZW5jVHlwZTogXCJcIixcblxuXHRcdC8vIGFjY2VwdC1jaGFyc2V0OiBTdHJpbmc/XG5cdFx0Ly9cdFx0TGlzdCBvZiBzdXBwb3J0ZWQgY2hhcnNldHMuXG5cdFx0XCJhY2NlcHQtY2hhcnNldFwiOiBcIlwiLFxuXG5cdFx0Ly8gYWNjZXB0OiBTdHJpbmc/XG5cdFx0Ly9cdFx0TGlzdCBvZiBNSU1FIHR5cGVzIGZvciBmaWxlIHVwbG9hZC5cblx0XHRhY2NlcHQ6IFwiXCIsXG5cblx0XHQvLyB0YXJnZXQ6IFN0cmluZz9cblx0XHQvL1x0XHRUYXJnZXQgZnJhbWUgZm9yIHRoZSBkb2N1bWVudCB0byBiZSBvcGVuZWQgaW4uXG5cdFx0dGFyZ2V0OiBcIlwiLFxuXG5cdFx0dGVtcGxhdGVTdHJpbmc6IFwiPGZvcm0gZGF0YS1kb2pvLWF0dGFjaC1wb2ludD0nY29udGFpbmVyTm9kZScgZGF0YS1kb2pvLWF0dGFjaC1ldmVudD0nb25yZXNldDpfb25SZXNldCxvbnN1Ym1pdDpfb25TdWJtaXQnICR7IW5hbWVBdHRyU2V0dGluZ30+PC9mb3JtPlwiLFxuXG5cdFx0cG9zdE1peEluUHJvcGVydGllczogZnVuY3Rpb24oKXtcblx0XHRcdC8vIFNldHVwIG5hbWU9Zm9vIHN0cmluZyB0byBiZSByZWZlcmVuY2VkIGZyb20gdGhlIHRlbXBsYXRlIChidXQgb25seSBpZiBhIG5hbWUgaGFzIGJlZW4gc3BlY2lmaWVkKVxuXHRcdFx0Ly8gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndCB1c2UgX3NldE5hbWVBdHRyIHRvIHNldCB0aGUgbmFtZSBkdWUgdG8gSUUgbGltaXRhdGlvbnMsIHNlZSAjODY2MFxuXHRcdFx0dGhpcy5uYW1lQXR0clNldHRpbmcgPSB0aGlzLm5hbWUgPyAoXCJuYW1lPSdcIiArIHRoaXMubmFtZSArIFwiJ1wiKSA6IFwiXCI7XG5cdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRleGVjdXRlOiBmdW5jdGlvbigvKk9iamVjdCovIC8qPT09PT0gZm9ybUNvbnRlbnRzID09PT09Ki8pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERlcHJlY2F0ZWQ6IHVzZSBzdWJtaXQoKVxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdGRlcHJlY2F0ZWRcblx0XHR9LFxuXG5cdFx0b25FeGVjdXRlOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERlcHJlY2F0ZWQ6IHVzZSBvblN1Ym1pdCgpXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0ZGVwcmVjYXRlZFxuXHRcdH0sXG5cblx0XHRfc2V0RW5jVHlwZUF0dHI6IGZ1bmN0aW9uKC8qU3RyaW5nKi8gdmFsdWUpe1xuXHRcdFx0ZG9tQXR0ci5zZXQodGhpcy5kb21Ob2RlLCBcImVuY1R5cGVcIiwgdmFsdWUpO1xuXHRcdFx0aWYoaGFzKFwiaWVcIikpe1xuXHRcdFx0XHR0aGlzLmRvbU5vZGUuZW5jb2RpbmcgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NldChcImVuY1R5cGVcIiwgdmFsdWUpO1xuXHRcdH0sXG5cblx0XHRyZXNldDogZnVuY3Rpb24oLypFdmVudD8qLyBlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRyZXN0b3JlcyBhbGwgd2lkZ2V0IHZhbHVlcyBiYWNrIHRvIHRoZWlyIGluaXQgdmFsdWVzLFxuXHRcdFx0Ly9cdFx0Y2FsbHMgb25SZXNldCgpIHdoaWNoIGNhbiBjYW5jZWwgdGhlIHJlc2V0IGJ5IHJldHVybmluZyBmYWxzZVxuXG5cdFx0XHQvLyBjcmVhdGUgZmFrZSBldmVudCBzbyB3ZSBjYW4ga25vdyBpZiBwcmV2ZW50RGVmYXVsdCgpIGlzIGNhbGxlZFxuXHRcdFx0dmFyIGZhdXggPSB7XG5cdFx0XHRcdHJldHVyblZhbHVlOiB0cnVlLCAvLyB0aGUgSUUgd2F5XG5cdFx0XHRcdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpeyAvLyBub3QgSUVcblx0XHRcdFx0XHR0aGlzLnJldHVyblZhbHVlID0gZmFsc2U7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKXtcblx0XHRcdFx0fSxcblx0XHRcdFx0Y3VycmVudFRhcmdldDogZSA/IGUudGFyZ2V0IDogdGhpcy5kb21Ob2RlLFxuXHRcdFx0XHR0YXJnZXQ6IGUgPyBlLnRhcmdldCA6IHRoaXMuZG9tTm9kZVxuXHRcdFx0fTtcblx0XHRcdC8vIGlmIHJldHVybiB2YWx1ZSBpcyBub3QgZXhhY3RseSBmYWxzZSwgYW5kIGhhdmVuJ3QgY2FsbGVkIHByZXZlbnREZWZhdWx0KCksIHRoZW4gcmVzZXRcblx0XHRcdGlmKCEodGhpcy5vblJlc2V0KGZhdXgpID09PSBmYWxzZSkgJiYgZmF1eC5yZXR1cm5WYWx1ZSl7XG5cdFx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cywgW10pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvblJlc2V0OiBmdW5jdGlvbigvKkV2ZW50PyovIC8qPT09PT0gZSA9PT09PSovKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYWxsYmFjayB3aGVuIHVzZXIgcmVzZXRzIHRoZSBmb3JtLiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZFxuXHRcdFx0Ly9cdFx0dG8gYmUgb3Zlci1yaWRkZW4uIFdoZW4gdGhlIGByZXNldGAgbWV0aG9kIGlzIGNhbGxlZFxuXHRcdFx0Ly9cdFx0cHJvZ3JhbW1hdGljYWxseSwgdGhlIHJldHVybiB2YWx1ZSBmcm9tIGBvblJlc2V0YCBpcyB1c2VkXG5cdFx0XHQvL1x0XHR0byBjb21wdXRlIHdoZXRoZXIgb3Igbm90IHJlc2V0dGluZyBzaG91bGQgcHJvY2VlZFxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdGNhbGxiYWNrXG5cdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gQm9vbGVhblxuXHRcdH0sXG5cblx0XHRfb25SZXNldDogZnVuY3Rpb24oZSl7XG5cdFx0XHR0aGlzLnJlc2V0KGUpO1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0X29uU3VibWl0OiBmdW5jdGlvbihlKXtcblx0XHRcdHZhciBmcCA9IHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlO1xuXHRcdFx0Ly8gVE9ETzogcmVtb3ZlIHRoaXMgaWYgc3RhdGVtZW50IGJlZ2lubmluZyB3aXRoIDIuMFxuXHRcdFx0aWYodGhpcy5leGVjdXRlICE9IGZwLmV4ZWN1dGUgfHwgdGhpcy5vbkV4ZWN1dGUgIT0gZnAub25FeGVjdXRlKXtcblx0XHRcdFx0a2VybmVsLmRlcHJlY2F0ZWQoXCJkaWppdC5mb3JtLkZvcm06ZXhlY3V0ZSgpL29uRXhlY3V0ZSgpIGFyZSBkZXByZWNhdGVkLiBVc2Ugb25TdWJtaXQoKSBpbnN0ZWFkLlwiLCBcIlwiLCBcIjIuMFwiKTtcblx0XHRcdFx0dGhpcy5vbkV4ZWN1dGUoKTtcblx0XHRcdFx0dGhpcy5leGVjdXRlKHRoaXMuZ2V0VmFsdWVzKCkpO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5vblN1Ym1pdChlKSA9PT0gZmFsc2UpeyAvLyBvbmx5IGV4YWN0bHkgZmFsc2Ugc3RvcHMgc3VibWl0XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25TdWJtaXQ6IGZ1bmN0aW9uKC8qRXZlbnQ/Ki8gLyo9PT09PSBlID09PT09Ki8pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbGxiYWNrIHdoZW4gdXNlciBzdWJtaXRzIHRoZSBmb3JtLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCB0byBiZSBvdmVyLXJpZGRlbiwgYnV0IGJ5IGRlZmF1bHQgaXQgY2hlY2tzIGFuZFxuXHRcdFx0Ly9cdFx0cmV0dXJucyB0aGUgdmFsaWRpdHkgb2YgZm9ybSBlbGVtZW50cy4gV2hlbiB0aGUgYHN1Ym1pdGBcblx0XHRcdC8vXHRcdG1ldGhvZCBpcyBjYWxsZWQgcHJvZ3JhbW1hdGljYWxseSwgdGhlIHJldHVybiB2YWx1ZSBmcm9tXG5cdFx0XHQvL1x0XHRgb25TdWJtaXRgIGlzIHVzZWQgdG8gY29tcHV0ZSB3aGV0aGVyIG9yIG5vdCBzdWJtaXNzaW9uXG5cdFx0XHQvL1x0XHRzaG91bGQgcHJvY2VlZFxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdGV4dGVuc2lvblxuXG5cdFx0XHRyZXR1cm4gdGhpcy5pc1ZhbGlkKCk7IC8vIEJvb2xlYW5cblx0XHR9LFxuXG5cdFx0c3VibWl0OiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdHByb2dyYW1tYXRpY2FsbHkgc3VibWl0IGZvcm0gaWYgYW5kIG9ubHkgaWYgdGhlIGBvblN1Ym1pdGAgcmV0dXJucyB0cnVlXG5cdFx0XHRpZighKHRoaXMub25TdWJtaXQoKSA9PT0gZmFsc2UpKXtcblx0XHRcdFx0dGhpcy5jb250YWluZXJOb2RlLnN1Ym1pdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KTtcbiIsImRlZmluZShbXG5cdFwiZG9qby9fYmFzZS9kZWNsYXJlXCIsIC8vIGRlY2xhcmVcblx0XCJkb2pvL2RvbS1jb25zdHJ1Y3RcIiwgLy8gZG9tQ29uc3RydWN0LmNyZWF0ZVxuXHRcImRvam8vZG9tLXN0eWxlXCIsIC8vIGRvbVN0eWxlLmdldENvbXB1dGVkU3R5bGVcblx0XCJkb2pvL19iYXNlL2tlcm5lbFwiLCAvLyBrZXJuZWwuZGVwcmVjYXRlZFxuXHRcImRvam8vX2Jhc2UvbGFuZ1wiLCAvLyBsYW5nLmhpdGNoXG5cdFwiZG9qby9vblwiLFxuXHRcImRvam8vc25pZmZcIiwgLy8gaGFzKFwiaWVcIikgaGFzKFwibW96aWxsYVwiKVxuXHRcIi4vX0Zvcm1WYWx1ZVdpZGdldFwiLFxuXHRcIi4vX1RleHRCb3hNaXhpblwiLFxuXHRcImRvam8vdGV4dCEuL3RlbXBsYXRlcy9UZXh0Qm94Lmh0bWxcIixcblx0XCIuLi9tYWluXCJcdC8vIHRvIGV4cG9ydCBkaWppdC5fc2V0U2VsZWN0aW9uUmFuZ2UsIHJlbW92ZSBpbiAyLjBcbl0sIGZ1bmN0aW9uKGRlY2xhcmUsIGRvbUNvbnN0cnVjdCwgZG9tU3R5bGUsIGtlcm5lbCwgbGFuZywgb24sIGhhcyxcblx0XHRcdF9Gb3JtVmFsdWVXaWRnZXQsIF9UZXh0Qm94TWl4aW4sIHRlbXBsYXRlLCBkaWppdCl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9mb3JtL1RleHRCb3hcblxuXHR2YXIgVGV4dEJveCA9IGRlY2xhcmUoXCJkaWppdC5mb3JtLlRleHRCb3hcIiArIChoYXMoXCJkb2pvLWJpZGlcIikgPyBcIl9Ob0JpZGlcIiA6IFwiXCIpLCBbX0Zvcm1WYWx1ZVdpZGdldCwgX1RleHRCb3hNaXhpbl0sIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEEgYmFzZSBjbGFzcyBmb3IgdGV4dGJveCBmb3JtIGlucHV0c1xuXG5cdFx0dGVtcGxhdGVTdHJpbmc6IHRlbXBsYXRlLFxuXHRcdF9zaW5nbGVOb2RlVGVtcGxhdGU6ICc8aW5wdXQgY2xhc3M9XCJkaWppdCBkaWppdFJlc2V0IGRpaml0TGVmdCBkaWppdElucHV0RmllbGRcIiBkYXRhLWRvam8tYXR0YWNoLXBvaW50PVwidGV4dGJveCxmb2N1c05vZGVcIiBhdXRvY29tcGxldGU9XCJvZmZcIiB0eXBlPVwiJHt0eXBlfVwiICR7IW5hbWVBdHRyU2V0dGluZ30gLz4nLFxuXG5cdFx0X2J1dHRvbklucHV0RGlzYWJsZWQ6IGhhcyhcImllXCIpID8gXCJkaXNhYmxlZFwiIDogXCJcIiwgLy8gYWxsb3dzIElFIHRvIGRpc2FsbG93IGZvY3VzLCBidXQgRmlyZWZveCBjYW5ub3QgYmUgZGlzYWJsZWQgZm9yIG1vdXNlZG93biBldmVudHNcblxuXHRcdGJhc2VDbGFzczogXCJkaWppdFRleHRCb3hcIixcblxuXHRcdHBvc3RNaXhJblByb3BlcnRpZXM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYodGhpcy50ZW1wbGF0ZVN0cmluZyAmJiB0aGlzLnRlbXBsYXRlU3RyaW5nLnRvTG93ZXJDYXNlKCkgPT0gXCJpbnB1dFwiIHx8ICgodHlwZSA9PSBcImhpZGRlblwiIHx8IHR5cGUgPT0gXCJmaWxlXCIpICYmIHRoaXMudGVtcGxhdGVTdHJpbmcgPT0gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudGVtcGxhdGVTdHJpbmcpKXtcblx0XHRcdFx0dGhpcy50ZW1wbGF0ZVN0cmluZyA9IHRoaXMuX3NpbmdsZU5vZGVUZW1wbGF0ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdHBvc3RDcmVhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMpO1xuXG5cdFx0XHRpZihoYXMoXCJpZVwiKSA8IDkpe1xuXHRcdFx0XHQvLyBJRSBJTlBVVCB0YWcgZm9udEZhbWlseSBoYXMgdG8gYmUgc2V0IGRpcmVjdGx5IHVzaW5nIFNUWUxFXG5cdFx0XHRcdC8vIHRoZSBkZWZlciBnaXZlcyBJRSBhIGNoYW5jZSB0byByZW5kZXIgdGhlIFRleHRCb3ggYW5kIHRvIGRlYWwgd2l0aCBmb250IGluaGVyaXRhbmNlXG5cdFx0XHRcdHRoaXMuZGVmZXIoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHR2YXIgcyA9IGRvbVN0eWxlLmdldENvbXB1dGVkU3R5bGUodGhpcy5kb21Ob2RlKTsgLy8gY2FuIHRocm93IGFuIGV4Y2VwdGlvbiBpZiB3aWRnZXQgaXMgaW1tZWRpYXRlbHkgZGVzdHJveWVkXG5cdFx0XHRcdFx0XHRpZihzKXtcblx0XHRcdFx0XHRcdFx0dmFyIGZmID0gcy5mb250RmFtaWx5O1xuXHRcdFx0XHRcdFx0XHRpZihmZil7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGlucHV0cyA9IHRoaXMuZG9tTm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIklOUFVUXCIpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGlucHV0cyl7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IodmFyIGk9MDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlucHV0c1tpXS5zdHlsZS5mb250RmFtaWx5ID0gZmY7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fWNhdGNoKGUpey8qd2hlbiB1c2VkIGluIGEgRGlhbG9nLCBhbmQgdGhpcyBpcyBjYWxsZWQgYmVmb3JlIHRoZSBkaWFsb2cgaXNcblx0XHRcdFx0XHQgc2hvd24sIHMuZm9udEZhbWlseSB3b3VsZCB0cmlnZ2VyIFwiSW52YWxpZCBBcmd1bWVudFwiIGVycm9yLiovfVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3NldFBsYWNlSG9sZGVyQXR0cjogZnVuY3Rpb24odil7XG5cdFx0XHR0aGlzLl9zZXQoXCJwbGFjZUhvbGRlclwiLCB2KTtcblx0XHRcdGlmKCF0aGlzLl9waHNwYW4pe1xuXHRcdFx0XHR0aGlzLl9hdHRhY2hQb2ludHMucHVzaCgnX3Boc3BhbicpO1xuXHRcdFx0XHR0aGlzLl9waHNwYW4gPSBkb21Db25zdHJ1Y3QuY3JlYXRlKCdzcGFuJywge1xuXHRcdFx0XHRcdC8vIGRpaml0SW5wdXRGaWVsZCBjbGFzcyBnaXZlcyBwbGFjZUhvbGRlciBzYW1lIHBhZGRpbmcgYXMgdGhlIGlucHV0IGZpZWxkXG5cdFx0XHRcdFx0Ly8gcGFyZW50IG5vZGUgYWxyZWFkeSBoYXMgZGlqaXRJbnB1dEZpZWxkIGNsYXNzIGJ1dCBpdCBkb2Vzbid0IGFmZmVjdCB0aGlzIDxzcGFuPlxuXHRcdFx0XHRcdC8vIHNpbmNlIGl0J3MgcG9zaXRpb246IGFic29sdXRlLlxuXHRcdFx0XHRcdGNsYXNzTmFtZTogJ2Rpaml0UGxhY2VIb2xkZXIgZGlqaXRJbnB1dEZpZWxkJ1xuXHRcdFx0XHR9LCB0aGlzLnRleHRib3gsICdhZnRlcicpO1xuXHRcdFx0XHR0aGlzLm93bihcblx0XHRcdFx0XHRvbih0aGlzLl9waHNwYW4sIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKGV2dCl7IGV2dC5wcmV2ZW50RGVmYXVsdCgpOyB9KSxcblx0XHRcdFx0XHRvbih0aGlzLl9waHNwYW4sIFwidG91Y2hlbmQsIHBvaW50ZXJ1cCwgTVNQb2ludGVyVXBcIiwgbGFuZy5oaXRjaCh0aGlzLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHVzZXIgY2xpY2tzIHBsYWNlaG9sZGVyIHJhdGhlciB0aGFuIHRoZSA8aW5wdXQ+LCBuZWVkIHByb2dyYW1tYXRpYyBmb2N1cy4gIE5vcm1hbGx5IHRoaXNcblx0XHRcdFx0XHRcdC8vIGlzIGRvbmUgaW4gX0Zvcm1XaWRnZXRNaXhpbi5fb25Gb2N1cygpIGJ1dCBhZnRlciBbMzA2NjNdIGl0J3MgZG9uZSBvbiBhIGRlbGF5LCB3aGljaCBpcyBpbmVmZmVjdGl2ZS5cblx0XHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHR9KSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3Boc3Bhbi5pbm5lckhUTUw9XCJcIjtcblx0XHRcdHRoaXMuX3Boc3Bhbi5hcHBlbmRDaGlsZCh0aGlzLl9waHNwYW4ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2KSk7XG5cdFx0XHR0aGlzLl91cGRhdGVQbGFjZUhvbGRlcigpO1xuXHRcdH0sXG5cblx0XHRfb25JbnB1dDogZnVuY3Rpb24oLypFdmVudCovIGV2dCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2FsbGVkIEFGVEVSIHRoZSBpbnB1dCBldmVudCBoYXMgaGFwcGVuZWRcblx0XHRcdC8vXHRcdFNlZSBpZiB0aGUgcGxhY2VIb2xkZXIgdGV4dCBzaG91bGQgYmUgcmVtb3ZlZCBvciBhZGRlZCB3aGlsZSBlZGl0aW5nLlxuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVBsYWNlSG9sZGVyKCk7XG5cdFx0fSxcblxuXHRcdF91cGRhdGVQbGFjZUhvbGRlcjogZnVuY3Rpb24oKXtcblx0XHRcdGlmKHRoaXMuX3Boc3Bhbil7XG5cdFx0XHRcdHRoaXMuX3Boc3Bhbi5zdHlsZS5kaXNwbGF5ID0gKHRoaXMucGxhY2VIb2xkZXIgJiYgIXRoaXMudGV4dGJveC52YWx1ZSkgPyBcIlwiIDogXCJub25lXCI7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zZXRWYWx1ZUF0dHI6IGZ1bmN0aW9uKHZhbHVlLCAvKkJvb2xlYW4/Ki8gcHJpb3JpdHlDaGFuZ2UsIC8qU3RyaW5nPyovIGZvcm1hdHRlZFZhbHVlKXtcblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLl91cGRhdGVQbGFjZUhvbGRlcigpO1xuXHRcdH0sXG5cblx0XHRnZXREaXNwbGF5ZWRWYWx1ZTogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXByZWNhdGVkLiAgVXNlIGdldCgnZGlzcGxheWVkVmFsdWUnKSBpbnN0ZWFkLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdGRlcHJlY2F0ZWRcblx0XHRcdGtlcm5lbC5kZXByZWNhdGVkKHRoaXMuZGVjbGFyZWRDbGFzcytcIjo6Z2V0RGlzcGxheWVkVmFsdWUoKSBpcyBkZXByZWNhdGVkLiBVc2UgZ2V0KCdkaXNwbGF5ZWRWYWx1ZScpIGluc3RlYWQuXCIsIFwiXCIsIFwiMi4wXCIpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCdkaXNwbGF5ZWRWYWx1ZScpO1xuXHRcdH0sXG5cblx0XHRzZXREaXNwbGF5ZWRWYWx1ZTogZnVuY3Rpb24oLypTdHJpbmcqLyB2YWx1ZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RGVwcmVjYXRlZC4gIFVzZSBzZXQoJ2Rpc3BsYXllZFZhbHVlJywgLi4uKSBpbnN0ZWFkLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdGRlcHJlY2F0ZWRcblx0XHRcdGtlcm5lbC5kZXByZWNhdGVkKHRoaXMuZGVjbGFyZWRDbGFzcytcIjo6c2V0RGlzcGxheWVkVmFsdWUoKSBpcyBkZXByZWNhdGVkLiBVc2Ugc2V0KCdkaXNwbGF5ZWRWYWx1ZScsIC4uLikgaW5zdGVhZC5cIiwgXCJcIiwgXCIyLjBcIik7XG5cdFx0XHR0aGlzLnNldCgnZGlzcGxheWVkVmFsdWUnLCB2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdF9vbkJsdXI6IGZ1bmN0aW9uKGUpe1xuXHRcdFx0aWYodGhpcy5kaXNhYmxlZCl7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVBsYWNlSG9sZGVyKCk7XG5cblx0XHRcdGlmKGhhcyhcIm1vemlsbGFcIikpe1xuXHRcdFx0XHRpZih0aGlzLnNlbGVjdE9uQ2xpY2spe1xuXHRcdFx0XHRcdC8vIGNsZWFyIHNlbGVjdGlvbiBzbyB0aGF0IHRoZSBuZXh0IG1vdXNlIGNsaWNrIGRvZXNuJ3QgcmVzZWxlY3Rcblx0XHRcdFx0XHR0aGlzLnRleHRib3guc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnRleHRib3guc2VsZWN0aW9uRW5kID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9vbkZvY3VzOiBmdW5jdGlvbigvKlN0cmluZyovIGJ5KXtcblx0XHRcdGlmKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkT25seSl7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVBsYWNlSG9sZGVyKCk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZihoYXMoXCJpZVwiKSA8IDkpe1xuXHRcdFRleHRCb3gucHJvdG90eXBlLl9pc1RleHRTZWxlY3RlZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgcmFuZ2UgPSB0aGlzLm93bmVyRG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG5cdFx0XHR2YXIgcGFyZW50ID0gcmFuZ2UucGFyZW50RWxlbWVudCgpO1xuXHRcdFx0cmV0dXJuIHBhcmVudCA9PSB0aGlzLnRleHRib3ggJiYgcmFuZ2UudGV4dC5sZW5ndGggPiAwO1xuXHRcdH07XG5cblx0XHQvLyBPdmVycmlkZXMgZGVmaW5pdGlvbiBvZiBfc2V0U2VsZWN0aW9uUmFuZ2UgZnJvbSBfVGV4dEJveE1peGluIChUT0RPOiBtb3ZlIHRvIF9UZXh0Qm94TWl4aW4uanM/KVxuXHRcdGRpaml0Ll9zZXRTZWxlY3Rpb25SYW5nZSA9IF9UZXh0Qm94TWl4aW4uX3NldFNlbGVjdGlvblJhbmdlID0gZnVuY3Rpb24oLypEb21Ob2RlKi8gZWxlbWVudCwgLypOdW1iZXI/Ki8gc3RhcnQsIC8qTnVtYmVyPyovIHN0b3Ape1xuXHRcdFx0aWYoZWxlbWVudC5jcmVhdGVUZXh0UmFuZ2Upe1xuXHRcdFx0XHR2YXIgciA9IGVsZW1lbnQuY3JlYXRlVGV4dFJhbmdlKCk7XG5cdFx0XHRcdHIuY29sbGFwc2UodHJ1ZSk7XG5cdFx0XHRcdHIubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIC05OTk5OSk7IC8vIG1vdmUgdG8gMFxuXHRcdFx0XHRyLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCBzdGFydCk7IC8vIGRlbHRhIGZyb20gMCBpcyB0aGUgY29ycmVjdCBwb3NpdGlvblxuXHRcdFx0XHRyLm1vdmVFbmQoXCJjaGFyYWN0ZXJcIiwgc3RvcC1zdGFydCk7XG5cdFx0XHRcdHIuc2VsZWN0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYoaGFzKFwiZG9qby1iaWRpXCIpKXtcblx0XHRUZXh0Qm94ID0gZGVjbGFyZShcImRpaml0LmZvcm0uVGV4dEJveFwiLCBUZXh0Qm94LCB7XG5cdFx0XHRfc2V0UGxhY2VIb2xkZXJBdHRyOiBmdW5jdGlvbih2KXtcblx0XHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy5hcHBseVRleHREaXIodGhpcy5fcGhzcGFuKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiBUZXh0Qm94O1xufSk7XG4iLCJkZWZpbmUoW1xuXHRcImRvam8vX2Jhc2UvZGVjbGFyZVwiLCAvLyBkZWNsYXJlXG5cdFwiZG9qby9fYmFzZS9rZXJuZWxcIiwgLy8ga2VybmVsLmRlcHJlY2F0ZWRcblx0XCJkb2pvL19iYXNlL2xhbmdcIixcblx0XCJkb2pvL2kxOG5cIiwgLy8gaTE4bi5nZXRMb2NhbGl6YXRpb25cblx0XCIuL1RleHRCb3hcIixcblx0XCIuLi9Ub29sdGlwXCIsXG5cdFwiZG9qby90ZXh0IS4vdGVtcGxhdGVzL1ZhbGlkYXRpb25UZXh0Qm94Lmh0bWxcIixcblx0XCJkb2pvL2kxOG4hLi9ubHMvdmFsaWRhdGVcIlxuXSwgZnVuY3Rpb24oZGVjbGFyZSwga2VybmVsLCBsYW5nLCBpMThuLCBUZXh0Qm94LCBUb29sdGlwLCB0ZW1wbGF0ZSl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9mb3JtL1ZhbGlkYXRpb25UZXh0Qm94XG5cblxuXHR2YXIgVmFsaWRhdGlvblRleHRCb3ggPSBkZWNsYXJlKFwiZGlqaXQuZm9ybS5WYWxpZGF0aW9uVGV4dEJveFwiLCBUZXh0Qm94LCB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRCYXNlIGNsYXNzIGZvciB0ZXh0Ym94IHdpZGdldHMgd2l0aCB0aGUgYWJpbGl0eSB0byB2YWxpZGF0ZSBjb250ZW50IG9mIHZhcmlvdXMgdHlwZXMgYW5kIHByb3ZpZGUgdXNlciBmZWVkYmFjay5cblxuXHRcdHRlbXBsYXRlU3RyaW5nOiB0ZW1wbGF0ZSxcblxuXHRcdC8vIHJlcXVpcmVkOiBCb29sZWFuXG5cdFx0Ly9cdFx0VXNlciBpcyByZXF1aXJlZCB0byBlbnRlciBkYXRhIGludG8gdGhpcyBmaWVsZC5cblx0XHRyZXF1aXJlZDogZmFsc2UsXG5cblx0XHQvLyBwcm9tcHRNZXNzYWdlOiBTdHJpbmdcblx0XHQvL1x0XHRJZiBkZWZpbmVkLCBkaXNwbGF5IHRoaXMgaGludCBzdHJpbmcgaW1tZWRpYXRlbHkgb24gZm9jdXMgdG8gdGhlIHRleHRib3gsIGlmIGVtcHR5LlxuXHRcdC8vXHRcdEFsc28gZGlzcGxheXMgaWYgdGhlIHRleHRib3ggdmFsdWUgaXMgSW5jb21wbGV0ZSAobm90IHlldCB2YWxpZCBidXQgd2lsbCBiZSB3aXRoIGFkZGl0aW9uYWwgaW5wdXQpLlxuXHRcdC8vXHRcdFRoaW5rIG9mIHRoaXMgbGlrZSBhIHRvb2x0aXAgdGhhdCB0ZWxscyB0aGUgdXNlciB3aGF0IHRvIGRvLCBub3QgYW4gZXJyb3IgbWVzc2FnZVxuXHRcdC8vXHRcdHRoYXQgdGVsbHMgdGhlIHVzZXIgd2hhdCB0aGV5J3ZlIGRvbmUgd3JvbmcuXG5cdFx0Ly9cblx0XHQvL1x0XHRNZXNzYWdlIGRpc2FwcGVhcnMgd2hlbiB1c2VyIHN0YXJ0cyB0eXBpbmcuXG5cdFx0cHJvbXB0TWVzc2FnZTogXCJcIixcblxuXHRcdC8vIGludmFsaWRNZXNzYWdlOiBTdHJpbmdcblx0XHQvL1x0XHRUaGUgbWVzc2FnZSB0byBkaXNwbGF5IGlmIHZhbHVlIGlzIGludmFsaWQuXG5cdFx0Ly9cdFx0VGhlIHRyYW5zbGF0ZWQgc3RyaW5nIHZhbHVlIGlzIHJlYWQgZnJvbSB0aGUgbWVzc2FnZSBmaWxlIGJ5IGRlZmF1bHQuXG5cdFx0Ly9cdFx0U2V0IHRvIFwiXCIgdG8gdXNlIHRoZSBwcm9tcHRNZXNzYWdlIGluc3RlYWQuXG5cdFx0aW52YWxpZE1lc3NhZ2U6IFwiJF91bnNldF8kXCIsXG5cblx0XHQvLyBtaXNzaW5nTWVzc2FnZTogU3RyaW5nXG5cdFx0Ly9cdFx0VGhlIG1lc3NhZ2UgdG8gZGlzcGxheSBpZiB2YWx1ZSBpcyBlbXB0eSBhbmQgdGhlIGZpZWxkIGlzIHJlcXVpcmVkLlxuXHRcdC8vXHRcdFRoZSB0cmFuc2xhdGVkIHN0cmluZyB2YWx1ZSBpcyByZWFkIGZyb20gdGhlIG1lc3NhZ2UgZmlsZSBieSBkZWZhdWx0LlxuXHRcdC8vXHRcdFNldCB0byBcIlwiIHRvIHVzZSB0aGUgaW52YWxpZE1lc3NhZ2UgaW5zdGVhZC5cblx0XHRtaXNzaW5nTWVzc2FnZTogXCIkX3Vuc2V0XyRcIixcblxuXHRcdC8vIG1lc3NhZ2U6IFN0cmluZ1xuXHRcdC8vXHRcdEN1cnJlbnRseSBlcnJvci9wcm9tcHQgbWVzc2FnZS5cblx0XHQvL1x0XHRXaGVuIHVzaW5nIHRoZSBkZWZhdWx0IHRvb2x0aXAgaW1wbGVtZW50YXRpb24sIHRoaXMgd2lsbCBvbmx5IGJlXG5cdFx0Ly9cdFx0ZGlzcGxheWVkIHdoZW4gdGhlIGZpZWxkIGlzIGZvY3VzZWQuXG5cdFx0bWVzc2FnZTogXCJcIixcblxuXHRcdC8vIGNvbnN0cmFpbnRzOiBWYWxpZGF0aW9uVGV4dEJveC5fX0NvbnN0cmFpbnRzXG5cdFx0Ly9cdFx0RGVzcGl0ZSB0aGUgbmFtZSwgdGhpcyBwYXJhbWV0ZXIgc3BlY2lmaWVzIGJvdGggY29uc3RyYWludHMgb24gdGhlIGlucHV0IGFzIHdlbGwgYXNcblx0XHQvL1x0XHRmb3JtYXR0aW5nIG9wdGlvbnMuICBTZWUgYGRpaml0L2Zvcm0vVmFsaWRhdGlvblRleHRCb3guX19Db25zdHJhaW50c2AgZm9yIGRldGFpbHMuXG5cdFx0Y29uc3RyYWludHM6e30sXG5cblx0XHQvLyBwYXR0ZXJuOiBbZXh0ZW5zaW9uIHByb3RlY3RlZF0gU3RyaW5nfEZ1bmN0aW9uKGNvbnN0cmFpbnRzKSByZXR1cm5pbmcgYSBzdHJpbmcuXG5cdFx0Ly9cdFx0VGhpcyBkZWZpbmVzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2YWxpZGF0ZSB0aGUgaW5wdXQuXG5cdFx0Ly9cdFx0RG8gbm90IGFkZCBsZWFkaW5nIF4gb3IgJCBjaGFyYWN0ZXJzIHNpbmNlIHRoZSB3aWRnZXQgYWRkcyB0aGVzZS5cblx0XHQvL1x0XHRBIGZ1bmN0aW9uIG1heSBiZSB1c2VkIHRvIGdlbmVyYXRlIGEgdmFsaWQgcGF0dGVybiB3aGVuIGRlcGVuZGVudCBvbiBjb25zdHJhaW50cyBvciBvdGhlciBydW50aW1lIGZhY3RvcnMuXG5cdFx0Ly9cdFx0c2V0KCdwYXR0ZXJuJywgU3RyaW5nfEZ1bmN0aW9uKS5cblx0XHRwYXR0ZXJuOiBcIi4qXCIsXG5cblx0XHQvLyByZWdFeHA6IERlcHJlY2F0ZWQgW2V4dGVuc2lvbiBwcm90ZWN0ZWRdIFN0cmluZy4gIFVzZSBcInBhdHRlcm5cIiBpbnN0ZWFkLlxuXHRcdHJlZ0V4cDogXCJcIixcblxuXHRcdHJlZ0V4cEdlbjogZnVuY3Rpb24oLypfX0NvbnN0cmFpbnRzKi8gLyo9PT09PSBjb25zdHJhaW50cyA9PT09PSovKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXByZWNhdGVkLiAgVXNlIHNldCgncGF0dGVybicsIEZ1bmN0aW9uKSBpbnN0ZWFkLlxuXHRcdH0sXG5cblx0XHQvLyBzdGF0ZTogW3JlYWRvbmx5XSBTdHJpbmdcblx0XHQvL1x0XHRTaG93cyBjdXJyZW50IHN0YXRlIChpZSwgdmFsaWRhdGlvbiByZXN1bHQpIG9mIGlucHV0IChcIlwiPU5vcm1hbCwgSW5jb21wbGV0ZSwgb3IgRXJyb3IpXG5cdFx0c3RhdGU6IFwiXCIsXG5cblx0XHQvLyB0b29sdGlwUG9zaXRpb246IFN0cmluZ1tdXG5cdFx0Ly9cdFx0U2VlIGRlc2NyaXB0aW9uIG9mIGBkaWppdC9Ub29sdGlwLmRlZmF1bHRQb3NpdGlvbmAgZm9yIGRldGFpbHMgb24gdGhpcyBwYXJhbWV0ZXIuXG5cdFx0dG9vbHRpcFBvc2l0aW9uOiBbXSxcblxuXHRcdF9kZXByZWNhdGVSZWdFeHA6IGZ1bmN0aW9uKGF0dHIsIHZhbHVlKXtcblx0XHRcdGlmKHZhbHVlICE9IFZhbGlkYXRpb25UZXh0Qm94LnByb3RvdHlwZVthdHRyXSl7XG5cdFx0XHRcdGtlcm5lbC5kZXByZWNhdGVkKFwiVmFsaWRhdGlvblRleHRCb3ggaWQ9XCIrdGhpcy5pZCtcIiwgc2V0KCdcIiArIGF0dHIgKyBcIicsIC4uLikgaXMgZGVwcmVjYXRlZC4gIFVzZSBzZXQoJ3BhdHRlcm4nLCAuLi4pIGluc3RlYWQuXCIsIFwiXCIsIFwiMi4wXCIpO1xuXHRcdFx0XHR0aGlzLnNldCgncGF0dGVybicsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9zZXRSZWdFeHBHZW5BdHRyOiBmdW5jdGlvbigvKkZ1bmN0aW9uKi8gbmV3RmNuKXtcblx0XHRcdHRoaXMuX2RlcHJlY2F0ZVJlZ0V4cChcInJlZ0V4cEdlblwiLCBuZXdGY24pO1xuXHRcdFx0dGhpcy5fc2V0KFwicmVnRXhwR2VuXCIsIHRoaXMuX2NvbXB1dGVSZWdleHApOyAvLyBiYWNrd2FyZCBjb21wYXQgd2l0aCB0aGlzLnJlZ0V4cEdlbih0aGlzLmNvbnN0cmFpbnRzKVxuXHRcdH0sXG5cdFx0X3NldFJlZ0V4cEF0dHI6IGZ1bmN0aW9uKC8qU3RyaW5nKi8gdmFsdWUpe1xuXHRcdFx0dGhpcy5fZGVwcmVjYXRlUmVnRXhwKFwicmVnRXhwXCIsIHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0X3NldFZhbHVlQXR0cjogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRIb29rIHNvIHNldCgndmFsdWUnLCAuLi4pIHdvcmtzLlxuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX3JlZnJlc2hTdGF0ZSgpO1xuXHRcdH0sXG5cblx0XHR2YWxpZGF0b3I6IGZ1bmN0aW9uKC8qYW55dGhpbmcqLyB2YWx1ZSwgLypfX0NvbnN0cmFpbnRzKi8gY29uc3RyYWludHMpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdE92ZXJyaWRhYmxlIGZ1bmN0aW9uIHVzZWQgdG8gdmFsaWRhdGUgdGhlIHRleHQgaW5wdXQgYWdhaW5zdCB0aGUgcmVndWxhciBleHByZXNzaW9uLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXHRcdFx0cmV0dXJuIChuZXcgUmVnRXhwKFwiXig/OlwiICsgdGhpcy5fY29tcHV0ZVJlZ2V4cChjb25zdHJhaW50cykgKyBcIilcIisodGhpcy5yZXF1aXJlZD9cIlwiOlwiP1wiKStcIiRcIikpLnRlc3QodmFsdWUpICYmXG5cdFx0XHRcdCghdGhpcy5yZXF1aXJlZCB8fCAhdGhpcy5faXNFbXB0eSh2YWx1ZSkpICYmXG5cdFx0XHRcdCh0aGlzLl9pc0VtcHR5KHZhbHVlKSB8fCB0aGlzLnBhcnNlKHZhbHVlLCBjb25zdHJhaW50cykgIT09IHVuZGVmaW5lZCk7IC8vIEJvb2xlYW5cblx0XHR9LFxuXG5cdFx0X2lzVmFsaWRTdWJzZXQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBlaXRoZXIgYWxyZWFkeSB2YWxpZCBvciBjb3VsZCBiZSBtYWRlIHZhbGlkIGJ5IGFwcGVuZGluZyBjaGFyYWN0ZXJzLlxuXHRcdFx0Ly9cdFx0VGhpcyBpcyB1c2VkIGZvciB2YWxpZGF0aW9uIHdoaWxlIHRoZSB1c2VyIFttYXkgYmVdIHN0aWxsIHR5cGluZy5cblx0XHRcdHJldHVybiB0aGlzLnRleHRib3gudmFsdWUuc2VhcmNoKHRoaXMuX3BhcnRpYWxyZSkgPT0gMDtcblx0XHR9LFxuXG5cdFx0aXNWYWxpZDogZnVuY3Rpb24oLypCb29sZWFuKi8gLyo9PT09PSBpc0ZvY3VzZWQgPT09PT0qLyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0VGVzdHMgaWYgdmFsdWUgaXMgdmFsaWQuXG5cdFx0XHQvL1x0XHRDYW4gb3ZlcnJpZGUgd2l0aCB5b3VyIG93biByb3V0aW5lIGluIGEgc3ViY2xhc3MuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cdFx0XHRyZXR1cm4gdGhpcy52YWxpZGF0b3IodGhpcy50ZXh0Ym94LnZhbHVlLCB0aGlzLmdldCgnY29uc3RyYWludHMnKSk7XG5cdFx0fSxcblxuXHRcdF9pc0VtcHR5OiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIGZvciB3aGl0ZXNwYWNlXG5cdFx0XHRyZXR1cm4gKHRoaXMudHJpbSA/IC9eXFxzKiQvIDogL14kLykudGVzdCh2YWx1ZSk7IC8vIEJvb2xlYW5cblx0XHR9LFxuXG5cdFx0Z2V0RXJyb3JNZXNzYWdlOiBmdW5jdGlvbigvKkJvb2xlYW4qLyAvKj09PT09IGlzRm9jdXNlZCA9PT09PSovKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm4gYW4gZXJyb3IgbWVzc2FnZSB0byBzaG93IGlmIGFwcHJvcHJpYXRlXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cdFx0XHR2YXIgaW52YWxpZCA9IHRoaXMuaW52YWxpZE1lc3NhZ2UgPT0gXCIkX3Vuc2V0XyRcIiA/IHRoaXMubWVzc2FnZXMuaW52YWxpZE1lc3NhZ2UgOlxuXHRcdFx0XHQhdGhpcy5pbnZhbGlkTWVzc2FnZSA/IHRoaXMucHJvbXB0TWVzc2FnZSA6IHRoaXMuaW52YWxpZE1lc3NhZ2U7XG5cdFx0XHR2YXIgbWlzc2luZyA9IHRoaXMubWlzc2luZ01lc3NhZ2UgPT0gXCIkX3Vuc2V0XyRcIiA/IHRoaXMubWVzc2FnZXMubWlzc2luZ01lc3NhZ2UgOlxuXHRcdFx0XHQhdGhpcy5taXNzaW5nTWVzc2FnZSA/IGludmFsaWQgOiB0aGlzLm1pc3NpbmdNZXNzYWdlO1xuXHRcdFx0cmV0dXJuICh0aGlzLnJlcXVpcmVkICYmIHRoaXMuX2lzRW1wdHkodGhpcy50ZXh0Ym94LnZhbHVlKSkgPyBtaXNzaW5nIDogaW52YWxpZDsgLy8gU3RyaW5nXG5cdFx0fSxcblxuXHRcdGdldFByb21wdE1lc3NhZ2U6IGZ1bmN0aW9uKC8qQm9vbGVhbiovIC8qPT09PT0gaXNGb2N1c2VkID09PT09Ki8pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybiBhIGhpbnQgbWVzc2FnZSB0byBzaG93IHdoZW4gd2lkZ2V0IGlzIGZpcnN0IGZvY3VzZWRcblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblx0XHRcdHJldHVybiB0aGlzLnByb21wdE1lc3NhZ2U7IC8vIFN0cmluZ1xuXHRcdH0sXG5cblx0XHRfbWFza1ZhbGlkU3Vic2V0RXJyb3I6IHRydWUsXG5cdFx0dmFsaWRhdGU6IGZ1bmN0aW9uKC8qQm9vbGVhbiovIGlzRm9jdXNlZCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2FsbGVkIGJ5IG9uaW5pdCwgb25ibHVyLCBhbmQgb25rZXlwcmVzcy5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0U2hvdyBtaXNzaW5nIG9yIGludmFsaWQgbWVzc2FnZXMgaWYgYXBwcm9wcmlhdGUsIGFuZCBoaWdobGlnaHQgdGV4dGJveCBmaWVsZC5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblx0XHRcdHZhciBtZXNzYWdlID0gXCJcIjtcblx0XHRcdHZhciBpc1ZhbGlkID0gdGhpcy5kaXNhYmxlZCB8fCB0aGlzLmlzVmFsaWQoaXNGb2N1c2VkKTtcblx0XHRcdGlmKGlzVmFsaWQpeyB0aGlzLl9tYXNrVmFsaWRTdWJzZXRFcnJvciA9IHRydWU7IH1cblx0XHRcdHZhciBpc0VtcHR5ID0gdGhpcy5faXNFbXB0eSh0aGlzLnRleHRib3gudmFsdWUpO1xuXHRcdFx0dmFyIGlzVmFsaWRTdWJzZXQgPSAhaXNWYWxpZCAmJiBpc0ZvY3VzZWQgJiYgdGhpcy5faXNWYWxpZFN1YnNldCgpO1xuXHRcdFx0dGhpcy5fc2V0KFwic3RhdGVcIiwgaXNWYWxpZCA/IFwiXCIgOiAoKCgoKCF0aGlzLl9oYXNCZWVuQmx1cnJlZCB8fCBpc0ZvY3VzZWQpICYmIGlzRW1wdHkpIHx8IGlzVmFsaWRTdWJzZXQpICYmICh0aGlzLl9tYXNrVmFsaWRTdWJzZXRFcnJvciB8fCAoaXNWYWxpZFN1YnNldCAmJiAhdGhpcy5faGFzQmVlbkJsdXJyZWQgJiYgaXNGb2N1c2VkKSkpID8gXCJJbmNvbXBsZXRlXCIgOiBcIkVycm9yXCIpKTtcblx0XHRcdHRoaXMuZm9jdXNOb2RlLnNldEF0dHJpYnV0ZShcImFyaWEtaW52YWxpZFwiLCB0aGlzLnN0YXRlID09IFwiRXJyb3JcIiA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKTtcblxuXHRcdFx0aWYodGhpcy5zdGF0ZSA9PSBcIkVycm9yXCIpe1xuXHRcdFx0XHR0aGlzLl9tYXNrVmFsaWRTdWJzZXRFcnJvciA9IGlzRm9jdXNlZCAmJiBpc1ZhbGlkU3Vic2V0OyAvLyB3ZSB3YW50IHRoZSBlcnJvciB0byBzaG93IHVwIGFmdGVyIGEgYmx1ciBhbmQgcmVmb2N1c1xuXHRcdFx0XHRtZXNzYWdlID0gdGhpcy5nZXRFcnJvck1lc3NhZ2UoaXNGb2N1c2VkKTtcblx0XHRcdH1lbHNlIGlmKHRoaXMuc3RhdGUgPT0gXCJJbmNvbXBsZXRlXCIpe1xuXHRcdFx0XHRtZXNzYWdlID0gdGhpcy5nZXRQcm9tcHRNZXNzYWdlKGlzRm9jdXNlZCk7IC8vIHNob3cgdGhlIHByb21wdCB3aGVuZXZlciB0aGUgdmFsdWUgaXMgbm90IHlldCBjb21wbGV0ZVxuXHRcdFx0XHR0aGlzLl9tYXNrVmFsaWRTdWJzZXRFcnJvciA9ICF0aGlzLl9oYXNCZWVuQmx1cnJlZCB8fCBpc0ZvY3VzZWQ7IC8vIG5vIEluY29tcGxldGUgd2FybmluZ3Mgd2hpbGUgZm9jdXNlZFxuXHRcdFx0fWVsc2UgaWYoaXNFbXB0eSl7XG5cdFx0XHRcdG1lc3NhZ2UgPSB0aGlzLmdldFByb21wdE1lc3NhZ2UoaXNGb2N1c2VkKTsgLy8gc2hvdyB0aGUgcHJvbXB0IHdoZW5ldmVyIHRoZXJlJ3Mgbm8gZXJyb3IgYW5kIG5vIHRleHRcblx0XHRcdH1cblx0XHRcdHRoaXMuc2V0KFwibWVzc2FnZVwiLCBtZXNzYWdlKTtcblxuXHRcdFx0cmV0dXJuIGlzVmFsaWQ7XG5cdFx0fSxcblxuXHRcdGRpc3BsYXlNZXNzYWdlOiBmdW5jdGlvbigvKlN0cmluZyovIG1lc3NhZ2Upe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdE92ZXJyaWRhYmxlIG1ldGhvZCB0byBkaXNwbGF5IHZhbGlkYXRpb24gZXJyb3JzL2hpbnRzLlxuXHRcdFx0Ly9cdFx0QnkgZGVmYXVsdCB1c2VzIGEgdG9vbHRpcC5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRleHRlbnNpb25cblx0XHRcdGlmKG1lc3NhZ2UgJiYgdGhpcy5mb2N1c2VkKXtcblx0XHRcdFx0VG9vbHRpcC5zaG93KG1lc3NhZ2UsIHRoaXMuZG9tTm9kZSwgdGhpcy50b29sdGlwUG9zaXRpb24sICF0aGlzLmlzTGVmdFRvUmlnaHQoKSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0VG9vbHRpcC5oaWRlKHRoaXMuZG9tTm9kZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9yZWZyZXNoU3RhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBPdmVycmlkZXMgVGV4dEJveC5fcmVmcmVzaFN0YXRlKClcblx0XHRcdGlmKHRoaXMuX2NyZWF0ZWQpeyAvLyBzaG91bGQgaW5zdGVhZCBiZSB0aGlzLl9zdGFydGVkIGJ1dCB0aGF0IHdvdWxkIHJlcXVpcmUgYWxsIHByb2dyYW1tYXRpYyBWYWxpZGF0aW9uVGV4dEJveCBpbnN0YW50aWF0aW9ucyB0byBjYWxsIHN0YXJ0dXAoKVxuXHRcdFx0XHR0aGlzLnZhbGlkYXRlKHRoaXMuZm9jdXNlZCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHQvLy8vLy8vLy8vLy8gSU5JVElBTElaQVRJT04gTUVUSE9EUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHRcdGNvbnN0cnVjdG9yOiBmdW5jdGlvbihwYXJhbXMgLyo9PT09PSAsIHNyY05vZGVSZWYgPT09PT0qLyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q3JlYXRlIHRoZSB3aWRnZXQuXG5cdFx0XHQvLyBwYXJhbXM6IE9iamVjdHxudWxsXG5cdFx0XHQvL1x0XHRIYXNoIG9mIGluaXRpYWxpemF0aW9uIHBhcmFtZXRlcnMgZm9yIHdpZGdldCwgaW5jbHVkaW5nIHNjYWxhciB2YWx1ZXMgKGxpa2UgdGl0bGUsIGR1cmF0aW9uIGV0Yy4pXG5cdFx0XHQvL1x0XHRhbmQgZnVuY3Rpb25zLCB0eXBpY2FsbHkgY2FsbGJhY2tzIGxpa2Ugb25DbGljay5cblx0XHRcdC8vXHRcdFRoZSBoYXNoIGNhbiBjb250YWluIGFueSBvZiB0aGUgd2lkZ2V0J3MgcHJvcGVydGllcywgZXhjbHVkaW5nIHJlYWQtb25seSBwcm9wZXJ0aWVzLlxuXHRcdFx0Ly8gc3JjTm9kZVJlZjogRE9NTm9kZXxTdHJpbmc/XG5cdFx0XHQvL1x0XHRJZiBhIHNyY05vZGVSZWYgKERPTSBub2RlKSBpcyBzcGVjaWZpZWQsIHJlcGxhY2Ugc3JjTm9kZVJlZiB3aXRoIG15IGdlbmVyYXRlZCBET00gdHJlZS5cblxuXHRcdFx0dGhpcy5jb25zdHJhaW50cyA9IGxhbmcuY2xvbmUodGhpcy5jb25zdHJhaW50cyk7XG5cdFx0XHR0aGlzLmJhc2VDbGFzcyArPSAnIGRpaml0VmFsaWRhdGlvblRleHRCb3gnO1xuXHRcdH0sXG5cblx0XHRzdGFydHVwOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX3JlZnJlc2hTdGF0ZSgpOyAvLyBhZnRlciBhbGwgX3NldCogbWV0aG9kcyBoYXZlIHJ1blxuXHRcdH0sXG5cblx0XHRfc2V0Q29uc3RyYWludHNBdHRyOiBmdW5jdGlvbigvKl9fQ29uc3RyYWludHMqLyBjb25zdHJhaW50cyl7XG5cdFx0XHRpZighY29uc3RyYWludHMubG9jYWxlICYmIHRoaXMubGFuZyl7XG5cdFx0XHRcdGNvbnN0cmFpbnRzLmxvY2FsZSA9IHRoaXMubGFuZztcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NldChcImNvbnN0cmFpbnRzXCIsIGNvbnN0cmFpbnRzKTtcblx0XHRcdHRoaXMuX3JlZnJlc2hTdGF0ZSgpO1xuXHRcdH0sXG5cblx0XHRfc2V0UGF0dGVybkF0dHI6IGZ1bmN0aW9uKC8qU3RyaW5nfEZ1bmN0aW9uKi8gcGF0dGVybil7XG5cdFx0XHR0aGlzLl9zZXQoXCJwYXR0ZXJuXCIsIHBhdHRlcm4pOyAvLyBkb24ndCBzZXQgb24gSU5QVVQgdG8gYXZvaWQgbmF0aXZlIEhUTUw1IHZhbGlkYXRpb25cblx0XHRcdHRoaXMuX3JlZnJlc2hTdGF0ZSgpO1xuXHRcdH0sXG5cblx0XHRfY29tcHV0ZVJlZ2V4cDogZnVuY3Rpb24oLypfX0NvbnN0cmFpbnRzKi8gY29uc3RyYWludHMpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEhvb2sgdG8gZ2V0IHRoZSBjdXJyZW50IHJlZ0V4cCBhbmQgdG8gY29tcHV0ZSB0aGUgcGFydGlhbCB2YWxpZGF0aW9uIFJFLlxuXG5cdFx0XHR2YXIgcCA9IHRoaXMucGF0dGVybjtcblx0XHRcdGlmKHR5cGVvZiBwID09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRcdHAgPSBwLmNhbGwodGhpcywgY29uc3RyYWludHMpO1xuXHRcdFx0fVxuXHRcdFx0aWYocCAhPSB0aGlzLl9sYXN0UmVnRXhwKXtcblx0XHRcdFx0dmFyIHBhcnRpYWxyZSA9IFwiXCI7XG5cdFx0XHRcdHRoaXMuX2xhc3RSZWdFeHAgPSBwO1xuXHRcdFx0XHQvLyBwYXJzZSB0aGUgcmVnZXhwIGFuZCBwcm9kdWNlIGEgbmV3IHJlZ2V4cCB0aGF0IG1hdGNoZXMgdmFsaWQgc3Vic2V0c1xuXHRcdFx0XHQvLyBpZiB0aGUgcmVnZXhwIGlzIC4qIHRoZW4gdGhlcmUncyBubyB1c2UgaW4gbWF0Y2hpbmcgc3Vic2V0cyBzaW5jZSBldmVyeXRoaW5nIGlzIHZhbGlkXG5cdFx0XHRcdGlmKHAgIT0gXCIuKlwiKXtcblx0XHRcdFx0XHRwLnJlcGxhY2UoL1xcXFwufFxcW1xcXXxcXFsuKj9bXlxcXFxdezF9XFxdfFxcey4qP1xcfXxcXChcXD9bPTohXXwuL2csXG5cdFx0XHRcdFx0ZnVuY3Rpb24ocmUpe1xuXHRcdFx0XHRcdFx0c3dpdGNoKHJlLmNoYXJBdCgwKSl7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3snOlxuXHRcdFx0XHRcdFx0XHRjYXNlICcrJzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAnPyc6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJyonOlxuXHRcdFx0XHRcdFx0XHRjYXNlICdeJzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAnJCc6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3wnOlxuXHRcdFx0XHRcdFx0XHRjYXNlICcoJzpcblx0XHRcdFx0XHRcdFx0XHRwYXJ0aWFscmUgKz0gcmU7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgXCIpXCI6XG5cdFx0XHRcdFx0XHRcdFx0cGFydGlhbHJlICs9IFwifCQpXCI7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdCBkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdHBhcnRpYWxyZSArPSBcIig/OlwiK3JlK1wifCQpXCI7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJ5eyAvLyB0aGlzIGlzIG5lZWRlZCBmb3Igbm93IHNpbmNlIHRoZSBhYm92ZSByZWdleHAgcGFyc2luZyBuZWVkcyBtb3JlIHRlc3QgdmVyaWZpY2F0aW9uXG5cdFx0XHRcdFx0XCJcIi5zZWFyY2gocGFydGlhbHJlKTtcblx0XHRcdFx0fWNhdGNoKGUpeyAvLyBzaG91bGQgbmV2ZXIgYmUgaGVyZSB1bmxlc3MgdGhlIG9yaWdpbmFsIFJFIGlzIGJhZCBvciB0aGUgcGFyc2luZyBpcyBiYWRcblx0XHRcdFx0XHRwYXJ0aWFscmUgPSB0aGlzLnBhdHRlcm47XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdSZWdFeHAgZXJyb3IgaW4gJyArIHRoaXMuZGVjbGFyZWRDbGFzcyArICc6ICcgKyB0aGlzLnBhdHRlcm4pO1xuXHRcdFx0XHR9IC8vIHNob3VsZCBuZXZlciBiZSBoZXJlIHVubGVzcyB0aGUgb3JpZ2luYWwgUkUgaXMgYmFkIG9yIHRoZSBwYXJzaW5nIGlzIGJhZFxuXHRcdFx0XHR0aGlzLl9wYXJ0aWFscmUgPSBcIl4oPzpcIiArIHBhcnRpYWxyZSArIFwiKSRcIjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwO1xuXHRcdH0sXG5cblx0XHRwb3N0TWl4SW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMubWVzc2FnZXMgPSBpMThuLmdldExvY2FsaXphdGlvbihcImRpaml0LmZvcm1cIiwgXCJ2YWxpZGF0ZVwiLCB0aGlzLmxhbmcpO1xuXHRcdFx0dGhpcy5fc2V0Q29uc3RyYWludHNBdHRyKHRoaXMuY29uc3RyYWludHMpOyAvLyB0aGlzIG5lZWRzIHRvIGhhcHBlbiBub3cgKGFuZCBsYXRlcikgZHVlIHRvIGNvZGVwZW5kZW5jeSBvbiBfc2V0KkF0dHIgY2FsbHMgYXR0YWNoUG9pbnRzXG5cdFx0fSxcblxuXHRcdF9zZXREaXNhYmxlZEF0dHI6IGZ1bmN0aW9uKC8qQm9vbGVhbiovIHZhbHVlKXtcblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XHQvLyBjYWxsIEZvcm1WYWx1ZVdpZGdldC5fc2V0RGlzYWJsZWRBdHRyKClcblx0XHRcdHRoaXMuX3JlZnJlc2hTdGF0ZSgpO1xuXHRcdH0sXG5cblx0XHRfc2V0UmVxdWlyZWRBdHRyOiBmdW5jdGlvbigvKkJvb2xlYW4qLyB2YWx1ZSl7XG5cdFx0XHR0aGlzLl9zZXQoXCJyZXF1aXJlZFwiLCB2YWx1ZSk7XG5cdFx0XHR0aGlzLmZvY3VzTm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlcXVpcmVkXCIsIHZhbHVlKTtcblx0XHRcdHRoaXMuX3JlZnJlc2hTdGF0ZSgpO1xuXHRcdH0sXG5cblx0XHRfc2V0TWVzc2FnZUF0dHI6IGZ1bmN0aW9uKC8qU3RyaW5nKi8gbWVzc2FnZSl7XG5cdFx0XHR0aGlzLl9zZXQoXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuXHRcdFx0dGhpcy5kaXNwbGF5TWVzc2FnZShtZXNzYWdlKTtcblx0XHR9LFxuXG5cdFx0cmVzZXQ6ZnVuY3Rpb24oKXtcblx0XHRcdC8vIE92ZXJyaWRlcyBkaWppdC9mb3JtL1RleHRCb3gucmVzZXQoKSBieSBhbHNvXG5cdFx0XHQvLyBoaWRpbmcgZXJyb3JzIGFib3V0IHBhcnRpYWwgbWF0Y2hlc1xuXHRcdFx0dGhpcy5fbWFza1ZhbGlkU3Vic2V0RXJyb3IgPSB0cnVlO1xuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0X29uQmx1cjogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHRoZSBtZXNzYWdlIHN0aWxsIGV4aXN0cyBidXQgZm9yIGJhY2stY29tcGF0LCBhbmQgdG8gZXJhc2UgdGhlIHRvb2x0aXBcblx0XHRcdC8vIChpZiB0aGUgbWVzc2FnZSBpcyBiZWluZyBkaXNwbGF5ZWQgYXMgYSB0b29sdGlwKSwgY2FsbCBkaXNwbGF5TWVzc2FnZSgnJylcblx0XHRcdHRoaXMuZGlzcGxheU1lc3NhZ2UoJycpO1xuXG5cdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRkZXN0cm95OiBmdW5jdGlvbigpe1xuXHRcdFx0VG9vbHRpcC5oaWRlKHRoaXMuZG9tTm9kZSk7XHQvLyBpbiBjYXNlIHRvb2x0aXAgc2hvdyB3aGVuIFZhbGlkYXRpb25UZXh0Qm94IChvciBlbmNsb3NpbmcgRGlhbG9nKSBkZXN0cm95ZWRcblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKj09PT09XG5cdCBWYWxpZGF0aW9uVGV4dEJveC5fX0NvbnN0cmFpbnRzID0ge1xuXHRcdCAvLyBsb2NhbGU6IFN0cmluZ1xuXHRcdCAvL1x0XHRsb2NhbGUgdXNlZCBmb3IgdmFsaWRhdGlvbiwgcGlja3MgdXAgdmFsdWUgZnJvbSB0aGlzIHdpZGdldCdzIGxhbmcgYXR0cmlidXRlXG5cdFx0IC8vIF9mbGFnc186IGFueXRoaW5nXG5cdFx0IC8vXHRcdHZhcmlvdXMgZmxhZ3MgcGFzc2VkIHRvIHBhdHRlcm4gZnVuY3Rpb25cblx0IH07XG5cdCA9PT09PSovXG5cblx0cmV0dXJuIFZhbGlkYXRpb25UZXh0Qm94O1xufSk7XG4iLCJkZWZpbmUoW1xuXHRcImRvam8vX2Jhc2UvYXJyYXlcIiwgLy8gYXJyYXkuZXZlcnkgYXJyYXkuZmlsdGVyIGFycmF5LmZvckVhY2ggYXJyYXkuaW5kZXhPZiBhcnJheS5tYXBcblx0XCJkb2pvL19iYXNlL2RlY2xhcmVcIiwgLy8gZGVjbGFyZVxuXHRcImRvam8vX2Jhc2Uva2VybmVsXCIsIC8vIGtlcm5lbC5kZXByZWNhdGVkXG5cdFwiZG9qby9fYmFzZS9sYW5nXCIsIC8vIGxhbmcuaGl0Y2ggbGFuZy5pc0FycmF5XG5cdFwiZG9qby9vblwiLFxuXHRcImRvam8vd2luZG93XCIgLy8gd2luVXRpbHMuc2Nyb2xsSW50b1ZpZXdcbl0sIGZ1bmN0aW9uKGFycmF5LCBkZWNsYXJlLCBrZXJuZWwsIGxhbmcsIG9uLCB3aW5VdGlscyl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9mb3JtL19Gb3JtTWl4aW5cblxuXHRyZXR1cm4gZGVjbGFyZShcImRpaml0LmZvcm0uX0Zvcm1NaXhpblwiLCBudWxsLCB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRNaXhpbiBmb3IgY29udGFpbmVycyBvZiBmb3JtIHdpZGdldHMgKGkuZS4gd2lkZ2V0cyB0aGF0IHJlcHJlc2VudCBhIHNpbmdsZSB2YWx1ZVxuXHRcdC8vXHRcdGFuZCBjYW4gYmUgY2hpbGRyZW4gb2YgYSBgPGZvcm0+YCBub2RlIG9yIGBkaWppdC9mb3JtL0Zvcm1gIHdpZGdldClcblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRDYW4gZXh0cmFjdCBhbGwgdGhlIGZvcm0gd2lkZ2V0c1xuXHRcdC8vXHRcdHZhbHVlcyBhbmQgY29tYmluZSB0aGVtIGludG8gYSBzaW5nbGUgamF2YXNjcmlwdCBvYmplY3QsIG9yIGFsdGVybmF0ZWx5XG5cdFx0Ly9cdFx0dGFrZSBzdWNoIGFuIG9iamVjdCBhbmQgc2V0IHRoZSB2YWx1ZXMgZm9yIGFsbCB0aGUgY29udGFpbmVkXG5cdFx0Ly9cdFx0Zm9ybSB3aWRnZXRzXG5cblx0Lyo9PT09PVxuXHRcdC8vIHZhbHVlOiBPYmplY3Rcblx0XHQvL1x0XHROYW1lL3ZhbHVlIGhhc2ggZm9yIGVhY2ggY2hpbGQgd2lkZ2V0IHdpdGggYSBuYW1lIGFuZCB2YWx1ZS5cblx0XHQvL1x0XHRDaGlsZCB3aWRnZXRzIHdpdGhvdXQgbmFtZXMgYXJlIG5vdCBwYXJ0IG9mIHRoZSBoYXNoLlxuXHRcdC8vXG5cdFx0Ly9cdFx0SWYgdGhlcmUgYXJlIG11bHRpcGxlIGNoaWxkIHdpZGdldHMgdy90aGUgc2FtZSBuYW1lLCB2YWx1ZSBpcyBhbiBhcnJheSxcblx0XHQvL1x0XHR1bmxlc3MgdGhleSBhcmUgcmFkaW8gYnV0dG9ucyBpbiB3aGljaCBjYXNlIHZhbHVlIGlzIGEgc2NhbGFyIChzaW5jZSBvbmx5XG5cdFx0Ly9cdFx0b25lIHJhZGlvIGJ1dHRvbiBjYW4gYmUgY2hlY2tlZCBhdCBhIHRpbWUpLlxuXHRcdC8vXG5cdFx0Ly9cdFx0SWYgYSBjaGlsZCB3aWRnZXQncyBuYW1lIGlzIGEgZG90IHNlcGFyYXRlZCBsaXN0IChsaWtlIGEuYi5jLmQpLCBpdCdzIGEgbmVzdGVkIHN0cnVjdHVyZS5cblx0XHQvL1xuXHRcdC8vXHRcdEV4YW1wbGU6XG5cdFx0Ly9cdHxcdHsgbmFtZTogXCJKb2huIFNtaXRoXCIsIGludGVyZXN0czogW1wic3BvcnRzXCIsIFwibW92aWVzXCJdIH1cblx0PT09PT0qL1xuXG5cdFx0Ly8gc3RhdGU6IFtyZWFkb25seV0gU3RyaW5nXG5cdFx0Ly9cdFx0V2lsbCBiZSBcIkVycm9yXCIgaWYgb25lIG9yIG1vcmUgb2YgdGhlIGNoaWxkIHdpZGdldHMgaGFzIGFuIGludmFsaWQgdmFsdWUsXG5cdFx0Ly9cdFx0XCJJbmNvbXBsZXRlXCIgaWYgbm90IGFsbCBvZiB0aGUgcmVxdWlyZWQgY2hpbGQgd2lkZ2V0cyBhcmUgZmlsbGVkIGluLiAgT3RoZXJ3aXNlLCBcIlwiLFxuXHRcdC8vXHRcdHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZSBmb3JtIGlzIHJlYWR5IHRvIGJlIHN1Ym1pdHRlZC5cblx0XHRzdGF0ZTogXCJcIixcblxuXHRcdC8vIFRPRE86XG5cdFx0Ly9cdCogUmVwZWF0ZXJcblx0XHQvL1x0KiBiZXR0ZXIgaGFuZGxpbmcgZm9yIGFycmF5cy4gIE9mdGVuIGZvcm0gZWxlbWVudHMgaGF2ZSBuYW1lcyB3aXRoIFtdIGxpa2Vcblx0XHQvL1x0KiBwZW9wbGVbM10uc2V4IChmb3IgYSBsaXN0IG9mIHBlb3BsZSBbe25hbWU6IEJpbGwsIHNleDogTX0sIC4uLl0pXG5cblxuXHRcdF9nZXREZXNjZW5kYW50Rm9ybVdpZGdldHM6IGZ1bmN0aW9uKC8qZGlqaXQvX1dpZGdldEJhc2VbXT8qLyBjaGlsZHJlbil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhbGwgZm9ybSB3aWRnZXQgZGVzY2VuZGFudHMsIHNlYXJjaGluZyB0aHJvdWdoIG5vbi1mb3JtIGNoaWxkIHdpZGdldHMgbGlrZSBCb3JkZXJDb250YWluZXJcblx0XHRcdHZhciByZXMgPSBbXTtcblx0XHRcdGFycmF5LmZvckVhY2goY2hpbGRyZW4gfHwgdGhpcy5nZXRDaGlsZHJlbigpLCBmdW5jdGlvbihjaGlsZCl7XG5cdFx0XHRcdGlmKFwidmFsdWVcIiBpbiBjaGlsZCl7XG5cdFx0XHRcdFx0cmVzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRyZXMgPSByZXMuY29uY2F0KHRoaXMuX2dldERlc2NlbmRhbnRGb3JtV2lkZ2V0cyhjaGlsZC5nZXRDaGlsZHJlbigpKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHRhcnJheS5mb3JFYWNoKHRoaXMuX2dldERlc2NlbmRhbnRGb3JtV2lkZ2V0cygpLCBmdW5jdGlvbih3aWRnZXQpe1xuXHRcdFx0XHRpZih3aWRnZXQucmVzZXQpe1xuXHRcdFx0XHRcdHdpZGdldC5yZXNldCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0dmFsaWRhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0cmV0dXJucyBpZiB0aGUgZm9ybSBpcyB2YWxpZCAtIHNhbWUgYXMgaXNWYWxpZCAtIGJ1dFxuXHRcdFx0Ly9cdFx0cHJvdmlkZXMgYSBmZXcgYWRkaXRpb25hbCAodWktc3BlY2lmaWMpIGZlYXR1cmVzOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdDEuIGl0IHdpbGwgaGlnaGxpZ2h0IGFueSBzdWItd2lkZ2V0cyB0aGF0IGFyZSBub3QgdmFsaWRcblx0XHRcdC8vXHRcdDIuIGl0IHdpbGwgY2FsbCBmb2N1cygpIG9uIHRoZSBmaXJzdCBpbnZhbGlkIHN1Yi13aWRnZXRcblx0XHRcdHZhciBkaWRGb2N1cyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIGFycmF5LmV2ZXJ5KGFycmF5Lm1hcCh0aGlzLl9nZXREZXNjZW5kYW50Rm9ybVdpZGdldHMoKSwgZnVuY3Rpb24od2lkZ2V0KXtcblx0XHRcdFx0Ly8gTmVlZCB0byBzZXQgdGhpcyBzbyB0aGF0IFwicmVxdWlyZWRcIiB3aWRnZXRzIGdldCB0aGVpclxuXHRcdFx0XHQvLyBzdGF0ZSBzZXQuXG5cdFx0XHRcdHdpZGdldC5faGFzQmVlbkJsdXJyZWQgPSB0cnVlO1xuXHRcdFx0XHR2YXIgdmFsaWQgPSB3aWRnZXQuZGlzYWJsZWQgfHwgIXdpZGdldC52YWxpZGF0ZSB8fCB3aWRnZXQudmFsaWRhdGUoKTtcblx0XHRcdFx0aWYoIXZhbGlkICYmICFkaWRGb2N1cyl7XG5cdFx0XHRcdFx0Ly8gU2V0IGZvY3VzIG9mIHRoZSBmaXJzdCBub24tdmFsaWQgd2lkZ2V0XG5cdFx0XHRcdFx0d2luVXRpbHMuc2Nyb2xsSW50b1ZpZXcod2lkZ2V0LmNvbnRhaW5lck5vZGUgfHwgd2lkZ2V0LmRvbU5vZGUpO1xuXHRcdFx0XHRcdHdpZGdldC5mb2N1cygpO1xuXHRcdFx0XHRcdGRpZEZvY3VzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsaWQ7XG5cdFx0XHR9KSwgZnVuY3Rpb24oaXRlbSl7IHJldHVybiBpdGVtOyB9KTtcblx0XHR9LFxuXG5cdFx0c2V0VmFsdWVzOiBmdW5jdGlvbih2YWwpe1xuXHRcdFx0a2VybmVsLmRlcHJlY2F0ZWQodGhpcy5kZWNsYXJlZENsYXNzK1wiOjpzZXRWYWx1ZXMoKSBpcyBkZXByZWNhdGVkLiBVc2Ugc2V0KCd2YWx1ZScsIHZhbCkgaW5zdGVhZC5cIiwgXCJcIiwgXCIyLjBcIik7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXQoJ3ZhbHVlJywgdmFsKTtcblx0XHR9LFxuXHRcdF9zZXRWYWx1ZUF0dHI6IGZ1bmN0aW9uKC8qT2JqZWN0Ki8gb2JqKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRGaWxsIGluIGZvcm0gdmFsdWVzIGZyb20gYWNjb3JkaW5nIHRvIGFuIE9iamVjdCAoaW4gdGhlIGZvcm1hdCByZXR1cm5lZCBieSBnZXQoJ3ZhbHVlJykpXG5cblx0XHRcdC8vIGdlbmVyYXRlIG1hcCBmcm9tIG5hbWUgLS0+IFtsaXN0IG9mIHdpZGdldHMgd2l0aCB0aGF0IG5hbWVdXG5cdFx0XHR2YXIgbWFwID0geyB9O1xuXHRcdFx0YXJyYXkuZm9yRWFjaCh0aGlzLl9nZXREZXNjZW5kYW50Rm9ybVdpZGdldHMoKSwgZnVuY3Rpb24od2lkZ2V0KXtcblx0XHRcdFx0aWYoIXdpZGdldC5uYW1lKXsgcmV0dXJuOyB9XG5cdFx0XHRcdHZhciBlbnRyeSA9IG1hcFt3aWRnZXQubmFtZV0gfHwgKG1hcFt3aWRnZXQubmFtZV0gPSBbXSApO1xuXHRcdFx0XHRlbnRyeS5wdXNoKHdpZGdldCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Zm9yKHZhciBuYW1lIGluIG1hcCl7XG5cdFx0XHRcdGlmKCFtYXAuaGFzT3duUHJvcGVydHkobmFtZSkpe1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB3aWRnZXRzID0gbWFwW25hbWVdLFx0XHRcdFx0XHRcdC8vIGFycmF5IG9mIHdpZGdldHMgdy90aGlzIG5hbWVcblx0XHRcdFx0XHR2YWx1ZXMgPSBsYW5nLmdldE9iamVjdChuYW1lLCBmYWxzZSwgb2JqKTtcdC8vIGxpc3Qgb2YgdmFsdWVzIGZvciB0aG9zZSB3aWRnZXRzXG5cblx0XHRcdFx0aWYodmFsdWVzID09PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlcyA9IFtdLmNvbmNhdCh2YWx1ZXMpO1xuXHRcdFx0XHRpZih0eXBlb2Ygd2lkZ2V0c1swXS5jaGVja2VkID09ICdib29sZWFuJyl7XG5cdFx0XHRcdFx0Ly8gZm9yIGNoZWNrYm94L3JhZGlvLCB2YWx1ZXMgaXMgYSBsaXN0IG9mIHdoaWNoIHdpZGdldHMgc2hvdWxkIGJlIGNoZWNrZWRcblx0XHRcdFx0XHRhcnJheS5mb3JFYWNoKHdpZGdldHMsIGZ1bmN0aW9uKHcpe1xuXHRcdFx0XHRcdFx0dy5zZXQoJ3ZhbHVlJywgYXJyYXkuaW5kZXhPZih2YWx1ZXMsIHcuX2dldCgndmFsdWUnKSkgIT0gLTEpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9ZWxzZSBpZih3aWRnZXRzWzBdLm11bHRpcGxlKXtcblx0XHRcdFx0XHQvLyBpdCB0YWtlcyBhbiBhcnJheSAoZS5nLiBtdWx0aS1zZWxlY3QpXG5cdFx0XHRcdFx0d2lkZ2V0c1swXS5zZXQoJ3ZhbHVlJywgdmFsdWVzKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlLCB2YWx1ZXMgaXMgYSBsaXN0IG9mIHZhbHVlcyB0byBiZSBhc3NpZ25lZCBzZXF1ZW50aWFsbHkgdG8gZWFjaCB3aWRnZXRcblx0XHRcdFx0XHRhcnJheS5mb3JFYWNoKHdpZGdldHMsIGZ1bmN0aW9uKHcsIGkpe1xuXHRcdFx0XHRcdFx0dy5zZXQoJ3ZhbHVlJywgdmFsdWVzW2ldKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKioqXG5cdFx0XHQgKlx0VE9ETzogY29kZSBmb3IgcGxhaW4gaW5wdXQgYm94ZXMgKHRoaXMgc2hvdWxkbid0IHJ1biBmb3IgaW5wdXRzIHRoYXQgYXJlIHBhcnQgb2Ygd2lkZ2V0cylcblxuXHRcdFx0YXJyYXkuZm9yRWFjaCh0aGlzLmNvbnRhaW5lck5vZGUuZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpe1xuXHRcdFx0XHRpZihlbGVtZW50Lm5hbWUgPT0gJycpe3JldHVybn07XHQvLyBsaWtlIFwiY29udGludWVcIlxuXHRcdFx0XHR2YXIgbmFtZVBhdGggPSBlbGVtZW50Lm5hbWUuc3BsaXQoXCIuXCIpO1xuXHRcdFx0XHR2YXIgbXlPYmo9b2JqO1xuXHRcdFx0XHR2YXIgbmFtZT1uYW1lUGF0aFtuYW1lUGF0aC5sZW5ndGgtMV07XG5cdFx0XHRcdGZvcih2YXIgaj0xLGxlbjI9bmFtZVBhdGgubGVuZ3RoO2o8bGVuMjsrK2ope1xuXHRcdFx0XHRcdHZhciBwPW5hbWVQYXRoW2ogLSAxXTtcblx0XHRcdFx0XHQvLyByZXBlYXRlciBzdXBwb3J0IGJsb2NrXG5cdFx0XHRcdFx0dmFyIG5hbWVBPXAuc3BsaXQoXCJbXCIpO1xuXHRcdFx0XHRcdGlmKG5hbWVBLmxlbmd0aCA+IDEpe1xuXHRcdFx0XHRcdFx0aWYodHlwZW9mKG15T2JqW25hbWVBWzBdXSkgPT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0XHRcdFx0XHRcdG15T2JqW25hbWVBWzBdXT1bIF07XG5cdFx0XHRcdFx0XHR9IC8vIGlmXG5cblx0XHRcdFx0XHRcdG5hbWVJbmRleD1wYXJzZUludChuYW1lQVsxXSk7XG5cdFx0XHRcdFx0XHRpZih0eXBlb2YobXlPYmpbbmFtZUFbMF1dW25hbWVJbmRleF0pID09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdFx0XHRteU9ialtuYW1lQVswXV1bbmFtZUluZGV4XSA9IHsgfTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG15T2JqPW15T2JqW25hbWVBWzBdXVtuYW1lSW5kZXhdO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fSAvLyByZXBlYXRlciBzdXBwb3J0IGVuZHNcblxuXHRcdFx0XHRcdGlmKHR5cGVvZihteU9ialtwXSkgPT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0XHRcdFx0XHRteU9iaj11bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdG15T2JqPW15T2JqW3BdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYodHlwZW9mKG15T2JqKSA9PSBcInVuZGVmaW5lZFwiKXtcblx0XHRcdFx0XHRyZXR1cm47XHRcdC8vIGxpa2UgXCJjb250aW51ZVwiXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodHlwZW9mKG15T2JqW25hbWVdKSA9PSBcInVuZGVmaW5lZFwiICYmIHRoaXMuaWdub3JlTnVsbFZhbHVlcyl7XG5cdFx0XHRcdFx0cmV0dXJuO1x0XHQvLyBsaWtlIFwiY29udGludWVcIlxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVE9ETzogd2lkZ2V0IHZhbHVlcyAoanVzdCBjYWxsIHNldCgndmFsdWUnLCAuLi4pIG9uIHRoZSB3aWRnZXQpXG5cblx0XHRcdFx0Ly8gVE9ETzogbWF5YmUgc2hvdWxkIGNhbGwgZG9qby5nZXROb2RlUHJvcCgpIGluc3RlYWRcblx0XHRcdFx0c3dpdGNoKGVsZW1lbnQudHlwZSl7XG5cdFx0XHRcdFx0Y2FzZSBcImNoZWNrYm94XCI6XG5cdFx0XHRcdFx0XHRlbGVtZW50LmNoZWNrZWQgPSAobmFtZSBpbiBteU9iaikgJiZcblx0XHRcdFx0XHRcdFx0YXJyYXkuc29tZShteU9ialtuYW1lXSwgZnVuY3Rpb24odmFsKXsgcmV0dXJuIHZhbCA9PSBlbGVtZW50LnZhbHVlOyB9KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJyYWRpb1wiOlxuXHRcdFx0XHRcdFx0ZWxlbWVudC5jaGVja2VkID0gKG5hbWUgaW4gbXlPYmopICYmIG15T2JqW25hbWVdID09IGVsZW1lbnQudmFsdWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwic2VsZWN0LW11bHRpcGxlXCI6XG5cdFx0XHRcdFx0XHRlbGVtZW50LnNlbGVjdGVkSW5kZXg9LTE7XG5cdFx0XHRcdFx0XHRhcnJheS5mb3JFYWNoKGVsZW1lbnQub3B0aW9ucywgZnVuY3Rpb24ob3B0aW9uKXtcblx0XHRcdFx0XHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gYXJyYXkuc29tZShteU9ialtuYW1lXSwgZnVuY3Rpb24odmFsKXsgcmV0dXJuIG9wdGlvbi52YWx1ZSA9PSB2YWw7IH0pO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwic2VsZWN0LW9uZVwiOlxuXHRcdFx0XHRcdFx0ZWxlbWVudC5zZWxlY3RlZEluZGV4PVwiMFwiO1xuXHRcdFx0XHRcdFx0YXJyYXkuZm9yRWFjaChlbGVtZW50Lm9wdGlvbnMsIGZ1bmN0aW9uKG9wdGlvbil7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IG9wdGlvbi52YWx1ZSA9PSBteU9ialtuYW1lXTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImhpZGRlblwiOlxuXHRcdFx0XHRcdGNhc2UgXCJ0ZXh0XCI6XG5cdFx0XHRcdFx0Y2FzZSBcInRleHRhcmVhXCI6XG5cdFx0XHRcdFx0Y2FzZSBcInBhc3N3b3JkXCI6XG5cdFx0XHRcdFx0XHRlbGVtZW50LnZhbHVlID0gbXlPYmpbbmFtZV0gfHwgXCJcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdCovXG5cblx0XHRcdC8vIE5vdGU6IG5vIG5lZWQgdG8gY2FsbCB0aGlzLl9zZXQoXCJ2YWx1ZVwiLCAuLi4pIGFzIHRoZSBjaGlsZCB1cGRhdGVzIHdpbGwgdHJpZ2dlciBvbkNoYW5nZSBldmVudHNcblx0XHRcdC8vIHdoaWNoIEkgYW0gbW9uaXRvcmluZy5cblx0XHR9LFxuXG5cdFx0Z2V0VmFsdWVzOiBmdW5jdGlvbigpe1xuXHRcdFx0a2VybmVsLmRlcHJlY2F0ZWQodGhpcy5kZWNsYXJlZENsYXNzK1wiOjpnZXRWYWx1ZXMoKSBpcyBkZXByZWNhdGVkLiBVc2UgZ2V0KCd2YWx1ZScpIGluc3RlYWQuXCIsIFwiXCIsIFwiMi4wXCIpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCd2YWx1ZScpO1xuXHRcdH0sXG5cdFx0X2dldFZhbHVlQXR0cjogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIE9iamVjdCByZXByZXNlbnRpbmcgZm9ybSB2YWx1ZXMuICAgU2VlIGRlc2NyaXB0aW9uIG9mIGB2YWx1ZWAgZm9yIGRldGFpbHMuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblxuXHRcdFx0Ly8gVGhlIHZhbHVlIGlzIHVwZGF0ZWQgaW50byB0aGlzLnZhbHVlIGV2ZXJ5IHRpbWUgYSBjaGlsZCBoYXMgYW4gb25DaGFuZ2UgZXZlbnQsXG5cdFx0XHQvLyBzbyBpbiB0aGUgY29tbW9uIGNhc2UgdGhpcyBmdW5jdGlvbiBjb3VsZCBqdXN0IHJldHVybiB0aGlzLnZhbHVlLiAgIEhvd2V2ZXIsXG5cdFx0XHQvLyB0aGF0IHdvdWxkbid0IHdvcmsgd2hlbjpcblx0XHRcdC8vXG5cdFx0XHQvLyAxLiBVc2VyIHByZXNzZXMgcmV0dXJuIGtleSB0byBzdWJtaXQgYSBmb3JtLiAgVGhhdCBkb2Vzbid0IGZpcmUgYW4gb25jaGFuZ2UgZXZlbnQsXG5cdFx0XHQvLyBhbmQgZXZlbiBpZiBpdCBkaWQgaXQgd291bGQgY29tZSB0b28gbGF0ZSBkdWUgdG8gdGhlIGRlZmVyKC4uLikgaW4gX2hhbmRsZU9uQ2hhbmdlKClcblx0XHRcdC8vXG5cdFx0XHQvLyAyLiBhcHAgZm9yIHNvbWUgcmVhc29uIGNhbGxzIHRoaXMuZ2V0KFwidmFsdWVcIikgd2hpbGUgdGhlIHVzZXIgaXMgdHlwaW5nIGludG8gYVxuXHRcdFx0Ly8gZm9ybSBmaWVsZC4gICBOb3Qgc3VyZSBpZiB0aGF0IGNhc2UgbmVlZHMgdG8gYmUgc3VwcG9ydGVkIG9yIG5vdC5cblxuXHRcdFx0Ly8gZ2V0IHdpZGdldCB2YWx1ZXNcblx0XHRcdHZhciBvYmogPSB7IH07XG5cdFx0XHRhcnJheS5mb3JFYWNoKHRoaXMuX2dldERlc2NlbmRhbnRGb3JtV2lkZ2V0cygpLCBmdW5jdGlvbih3aWRnZXQpe1xuXHRcdFx0XHR2YXIgbmFtZSA9IHdpZGdldC5uYW1lO1xuXHRcdFx0XHRpZighbmFtZSB8fCB3aWRnZXQuZGlzYWJsZWQpeyByZXR1cm47IH1cblxuXHRcdFx0XHQvLyBTaW5nbGUgdmFsdWUgd2lkZ2V0IChjaGVja2JveCwgcmFkaW8sIG9yIHBsYWluIDxpbnB1dD4gdHlwZSB3aWRnZXQpXG5cdFx0XHRcdHZhciB2YWx1ZSA9IHdpZGdldC5nZXQoJ3ZhbHVlJyk7XG5cblx0XHRcdFx0Ly8gU3RvcmUgd2lkZ2V0J3MgdmFsdWUocykgYXMgYSBzY2FsYXIsIGV4Y2VwdCBmb3IgY2hlY2tib3hlcyB3aGljaCBhcmUgYXV0b21hdGljYWxseSBhcnJheXNcblx0XHRcdFx0aWYodHlwZW9mIHdpZGdldC5jaGVja2VkID09ICdib29sZWFuJyl7XG5cdFx0XHRcdFx0aWYoL1JhZGlvLy50ZXN0KHdpZGdldC5kZWNsYXJlZENsYXNzKSl7XG5cdFx0XHRcdFx0XHQvLyByYWRpbyBidXR0b25cblx0XHRcdFx0XHRcdGlmKHZhbHVlICE9PSBmYWxzZSl7XG5cdFx0XHRcdFx0XHRcdGxhbmcuc2V0T2JqZWN0KG5hbWUsIHZhbHVlLCBvYmopO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdC8vIGdpdmUgcmFkaW8gd2lkZ2V0cyBhIGRlZmF1bHQgb2YgbnVsbFxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGxhbmcuZ2V0T2JqZWN0KG5hbWUsIGZhbHNlLCBvYmopO1xuXHRcdFx0XHRcdFx0XHRpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0XHRcdFx0XHRsYW5nLnNldE9iamVjdChuYW1lLCBudWxsLCBvYmopO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHQvLyBjaGVja2JveC90b2dnbGUgYnV0dG9uXG5cdFx0XHRcdFx0XHR2YXIgYXJ5PWxhbmcuZ2V0T2JqZWN0KG5hbWUsIGZhbHNlLCBvYmopO1xuXHRcdFx0XHRcdFx0aWYoIWFyeSl7XG5cdFx0XHRcdFx0XHRcdGFyeT1bXTtcblx0XHRcdFx0XHRcdFx0bGFuZy5zZXRPYmplY3QobmFtZSwgYXJ5LCBvYmopO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYodmFsdWUgIT09IGZhbHNlKXtcblx0XHRcdFx0XHRcdFx0YXJ5LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0dmFyIHByZXY9bGFuZy5nZXRPYmplY3QobmFtZSwgZmFsc2UsIG9iaik7XG5cdFx0XHRcdFx0aWYodHlwZW9mIHByZXYgIT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0XHRcdFx0XHRpZihsYW5nLmlzQXJyYXkocHJldikpe1xuXHRcdFx0XHRcdFx0XHRwcmV2LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdGxhbmcuc2V0T2JqZWN0KG5hbWUsIFtwcmV2LCB2YWx1ZV0sIG9iaik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHQvLyB1bmlxdWUgbmFtZVxuXHRcdFx0XHRcdFx0bGFuZy5zZXRPYmplY3QobmFtZSwgdmFsdWUsIG9iaik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0LyoqKlxuXHRcdFx0ICogY29kZSBmb3IgcGxhaW4gaW5wdXQgYm94ZXMgKHNlZSBhbHNvIGRvbUZvcm0uZm9ybVRvT2JqZWN0LCBjYW4gd2UgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGlzIGNvZGU/XG5cdFx0XHQgKiBidXQgaXQgZG9lc24ndCB1bmRlcnN0YW5kIFtdIG5vdGF0aW9uLCBwcmVzdW1hYmx5KVxuXHRcdFx0dmFyIG9iaiA9IHsgfTtcblx0XHRcdGFycmF5LmZvckVhY2godGhpcy5jb250YWluZXJOb2RlLmVsZW1lbnRzLCBmdW5jdGlvbihlbG0pe1xuXHRcdFx0XHRpZighZWxtLm5hbWUpXHR7XG5cdFx0XHRcdFx0cmV0dXJuO1x0XHQvLyBsaWtlIFwiY29udGludWVcIlxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBuYW1lUGF0aCA9IGVsbS5uYW1lLnNwbGl0KFwiLlwiKTtcblx0XHRcdFx0dmFyIG15T2JqPW9iajtcblx0XHRcdFx0dmFyIG5hbWU9bmFtZVBhdGhbbmFtZVBhdGgubGVuZ3RoLTFdO1xuXHRcdFx0XHRmb3IodmFyIGo9MSxsZW4yPW5hbWVQYXRoLmxlbmd0aDtqPGxlbjI7KytqKXtcblx0XHRcdFx0XHR2YXIgbmFtZUluZGV4ID0gbnVsbDtcblx0XHRcdFx0XHR2YXIgcD1uYW1lUGF0aFtqIC0gMV07XG5cdFx0XHRcdFx0dmFyIG5hbWVBPXAuc3BsaXQoXCJbXCIpO1xuXHRcdFx0XHRcdGlmKG5hbWVBLmxlbmd0aCA+IDEpe1xuXHRcdFx0XHRcdFx0aWYodHlwZW9mKG15T2JqW25hbWVBWzBdXSkgPT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0XHRcdFx0XHRcdG15T2JqW25hbWVBWzBdXT1bIF07XG5cdFx0XHRcdFx0XHR9IC8vIGlmXG5cdFx0XHRcdFx0XHRuYW1lSW5kZXg9cGFyc2VJbnQobmFtZUFbMV0pO1xuXHRcdFx0XHRcdFx0aWYodHlwZW9mKG15T2JqW25hbWVBWzBdXVtuYW1lSW5kZXhdKSA9PSBcInVuZGVmaW5lZFwiKXtcblx0XHRcdFx0XHRcdFx0bXlPYmpbbmFtZUFbMF1dW25hbWVJbmRleF0gPSB7IH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fWVsc2UgaWYodHlwZW9mKG15T2JqW25hbWVBWzBdXSkgPT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0XHRcdFx0XHRteU9ialtuYW1lQVswXV0gPSB7IH1cblx0XHRcdFx0XHR9IC8vIGlmXG5cblx0XHRcdFx0XHRpZihuYW1lQS5sZW5ndGggPT0gMSl7XG5cdFx0XHRcdFx0XHRteU9iaj1teU9ialtuYW1lQVswXV07XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRteU9iaj1teU9ialtuYW1lQVswXV1bbmFtZUluZGV4XTtcblx0XHRcdFx0XHR9IC8vIGlmXG5cdFx0XHRcdH0gLy8gZm9yXG5cblx0XHRcdFx0aWYoKGVsbS50eXBlICE9IFwic2VsZWN0LW11bHRpcGxlXCIgJiYgZWxtLnR5cGUgIT0gXCJjaGVja2JveFwiICYmIGVsbS50eXBlICE9IFwicmFkaW9cIikgfHwgKGVsbS50eXBlID09IFwicmFkaW9cIiAmJiBlbG0uY2hlY2tlZCkpe1xuXHRcdFx0XHRcdGlmKG5hbWUgPT0gbmFtZS5zcGxpdChcIltcIilbMF0pe1xuXHRcdFx0XHRcdFx0bXlPYmpbbmFtZV09ZWxtLnZhbHVlO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0Ly8gY2FuIG5vdCBzZXQgdmFsdWUgd2hlbiB0aGVyZSBpcyBubyBuYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ZWxzZSBpZihlbG0udHlwZSA9PSBcImNoZWNrYm94XCIgJiYgZWxtLmNoZWNrZWQpe1xuXHRcdFx0XHRcdGlmKHR5cGVvZihteU9ialtuYW1lXSkgPT0gJ3VuZGVmaW5lZCcpe1xuXHRcdFx0XHRcdFx0bXlPYmpbbmFtZV09WyBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRteU9ialtuYW1lXS5wdXNoKGVsbS52YWx1ZSk7XG5cdFx0XHRcdH1lbHNlIGlmKGVsbS50eXBlID09IFwic2VsZWN0LW11bHRpcGxlXCIpe1xuXHRcdFx0XHRcdGlmKHR5cGVvZihteU9ialtuYW1lXSkgPT0gJ3VuZGVmaW5lZCcpe1xuXHRcdFx0XHRcdFx0bXlPYmpbbmFtZV09WyBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3IodmFyIGpkeD0wLGxlbjM9ZWxtLm9wdGlvbnMubGVuZ3RoOyBqZHg8bGVuMzsgKytqZHgpe1xuXHRcdFx0XHRcdFx0aWYoZWxtLm9wdGlvbnNbamR4XS5zZWxlY3RlZCl7XG5cdFx0XHRcdFx0XHRcdG15T2JqW25hbWVdLnB1c2goZWxtLm9wdGlvbnNbamR4XS52YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIGlmXG5cdFx0XHRcdG5hbWU9dW5kZWZpbmVkO1xuXHRcdFx0fSk7IC8vIGZvckVhY2hcblx0XHRcdCoqKi9cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdGlzVmFsaWQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0cnVlIGlmIGFsbCBvZiB0aGUgd2lkZ2V0cyBhcmUgdmFsaWQuXG5cdFx0XHQvL1x0XHREZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gMi4wLiAgVXNlIGdldChcInN0YXRlXCIpIGluc3RlYWQuXG5cblx0XHRcdHJldHVybiB0aGlzLnN0YXRlID09IFwiXCI7XG5cdFx0fSxcblxuXHRcdG9uVmFsaWRTdGF0ZUNoYW5nZTogZnVuY3Rpb24oLypCb29sZWFuKi8gLyo9PT09PSBpc1ZhbGlkID09PT09Ki8pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFN0dWIgZnVuY3Rpb24gdG8gY29ubmVjdCB0byBpZiB5b3Ugd2FudCB0byBkbyBzb21ldGhpbmdcblx0XHRcdC8vXHRcdChsaWtlIGRpc2FibGUvZW5hYmxlIGEgc3VibWl0IGJ1dHRvbikgd2hlbiB0aGUgdmFsaWRcblx0XHRcdC8vXHRcdHN0YXRlIGNoYW5nZXMgb24gdGhlIGZvcm0gYXMgYSB3aG9sZS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHREZXByZWNhdGVkLiAgV2lsbCBiZSByZW1vdmVkIGluIDIuMC4gIFVzZSB3YXRjaChcInN0YXRlXCIsIC4uLikgaW5zdGVhZC5cblx0XHR9LFxuXG5cdFx0X2dldFN0YXRlOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENvbXB1dGUgd2hhdCB0aGlzLnN0YXRlIHNob3VsZCBiZSBiYXNlZCBvbiBzdGF0ZSBvZiBjaGlsZHJlblxuXHRcdFx0dmFyIHN0YXRlcyA9IGFycmF5Lm1hcCh0aGlzLl9kZXNjZW5kYW50cywgZnVuY3Rpb24odyl7XG5cdFx0XHRcdHJldHVybiB3LmdldChcInN0YXRlXCIpIHx8IFwiXCI7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGFycmF5LmluZGV4T2Yoc3RhdGVzLCBcIkVycm9yXCIpID49IDAgPyBcIkVycm9yXCIgOlxuXHRcdFx0XHRhcnJheS5pbmRleE9mKHN0YXRlcywgXCJJbmNvbXBsZXRlXCIpID49IDAgPyBcIkluY29tcGxldGVcIiA6IFwiXCI7XG5cdFx0fSxcblxuXHRcdGRpc2Nvbm5lY3RDaGlsZHJlbjogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXByZWNhdGVkIG1ldGhvZC4gICBBcHBsaWNhdGlvbnMgbm8gbG9uZ2VyIG5lZWQgdG8gY2FsbCB0aGlzLiAgIFJlbW92ZSBmb3IgMi4wLlxuXHRcdH0sXG5cblx0XHRjb25uZWN0Q2hpbGRyZW46IGZ1bmN0aW9uKC8qQm9vbGVhbiovIGluU3RhcnR1cCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0WW91IGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24gZGlyZWN0bHksIGV4LiBpbiB0aGUgZXZlbnQgdGhhdCB5b3Vcblx0XHRcdC8vXHRcdHByb2dyYW1tYXRpY2FsbHkgYWRkIGEgd2lkZ2V0IHRvIHRoZSBmb3JtICphZnRlciogdGhlIGZvcm0gaGFzIGJlZW5cblx0XHRcdC8vXHRcdGluaXRpYWxpemVkLlxuXG5cdFx0XHQvLyBUT0RPOiByZW5hbWUgZm9yIDIuMFxuXG5cdFx0XHR0aGlzLl9kZXNjZW5kYW50cyA9IHRoaXMuX2dldERlc2NlbmRhbnRGb3JtV2lkZ2V0cygpO1xuXG5cdFx0XHQvLyBUbyBnZXQgbm90aWZpY2F0aW9ucyBmcm9tIGNoaWxkcmVuIHRoZXkgbmVlZCB0byBiZSBzdGFydGVkLiAgIENoaWxkcmVuIGRpZG4ndCB1c2VkIHRvIG5lZWQgdG8gYmUgc3RhcnRlZCxcblx0XHRcdC8vIHNvIGZvciBiYWNrLWNvbXBhdCwgc3RhcnQgdGhlbSBoZXJlXG5cdFx0XHRhcnJheS5mb3JFYWNoKHRoaXMuX2Rlc2NlbmRhbnRzLCBmdW5jdGlvbihjaGlsZCl7XG5cdFx0XHRcdGlmKCFjaGlsZC5fc3RhcnRlZCl7IGNoaWxkLnN0YXJ0dXAoKTsgfVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmKCFpblN0YXJ0dXApe1xuXHRcdFx0XHR0aGlzLl9vbkNoaWxkQ2hhbmdlKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9vbkNoaWxkQ2hhbmdlOiBmdW5jdGlvbigvKlN0cmluZyovIGF0dHIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbGxlZCB3aGVuIGNoaWxkJ3MgdmFsdWUgb3IgZGlzYWJsZWQgc3RhdGUgY2hhbmdlc1xuXG5cdFx0XHQvLyBUaGUgdW5pdCB0ZXN0cyBleHBlY3Qgc3RhdGUgdXBkYXRlIHRvIGJlIHN5bmNocm9ub3VzLCBzbyB1cGRhdGUgaXQgaW1tZWRpYXRlbHkuXG5cdFx0XHRpZighYXR0ciB8fCBhdHRyID09IFwic3RhdGVcIiB8fCBhdHRyID09IFwiZGlzYWJsZWRcIil7XG5cdFx0XHRcdHRoaXMuX3NldChcInN0YXRlXCIsIHRoaXMuX2dldFN0YXRlKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgZGVmZXIoKSB0byBjb2xsYXBzZSB2YWx1ZSBjaGFuZ2VzIGluIG11bHRpcGxlIGNoaWxkcmVuIGludG8gYSBzaW5nbGVcblx0XHRcdC8vIHVwZGF0ZSB0byBteSB2YWx1ZS4gICBNdWx0aXBsZSB1cGRhdGVzIHdpbGwgb2NjdXIgb246XG5cdFx0XHQvL1x0MS4gRm9ybS5zZXQoKVxuXHRcdFx0Ly9cdDIuIEZvcm0ucmVzZXQoKVxuXHRcdFx0Ly9cdDMuIHVzZXIgc2VsZWN0aW5nIGEgcmFkaW8gYnV0dG9uICh3aGljaCB3aWxsIGRlLXNlbGVjdCBhbm90aGVyIHJhZGlvIGJ1dHRvbixcblx0XHRcdC8vXHRcdCBjYXVzaW5nIHR3byBvbkNoYW5nZSBldmVudHMpXG5cdFx0XHRpZighYXR0ciB8fCBhdHRyID09IFwidmFsdWVcIiB8fCBhdHRyID09IFwiZGlzYWJsZWRcIiB8fCBhdHRyID09IFwiY2hlY2tlZFwiKXtcblx0XHRcdFx0aWYodGhpcy5fb25DaGFuZ2VEZWxheVRpbWVyKXtcblx0XHRcdFx0XHR0aGlzLl9vbkNoYW5nZURlbGF5VGltZXIucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fb25DaGFuZ2VEZWxheVRpbWVyID0gdGhpcy5kZWZlcihmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9vbkNoYW5nZURlbGF5VGltZXI7XG5cdFx0XHRcdFx0dGhpcy5fc2V0KFwidmFsdWVcIiwgdGhpcy5nZXQoXCJ2YWx1ZVwiKSk7XG5cdFx0XHRcdH0sIDEwKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c3RhcnR1cDogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cblx0XHRcdC8vIFNldCBpbml0aWFsIHRoaXMudmFsdWUgYW5kIHRoaXMuc3RhdGUuICAgRG9uJ3QgZW1pdCB3YXRjaCgpIG5vdGlmaWNhdGlvbnMuXG5cdFx0XHR0aGlzLl9kZXNjZW5kYW50cyA9IHRoaXMuX2dldERlc2NlbmRhbnRGb3JtV2lkZ2V0cygpO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZ2V0KFwidmFsdWVcIik7XG5cdFx0XHR0aGlzLnN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoKTtcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSB2YWx1ZSBhbmQgdmFsaWQvaW52YWxpZCBzdGF0ZSB0cmFja2luZy5cblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHRoaXMub3duKFxuXHRcdFx0XHRvbihcblx0XHRcdFx0XHR0aGlzLmNvbnRhaW5lck5vZGUsXG5cdFx0XHRcdFx0XCJhdHRybW9kaWZpZWQtc3RhdGUsIGF0dHJtb2RpZmllZC1kaXNhYmxlZCwgYXR0cm1vZGlmaWVkLXZhbHVlLCBhdHRybW9kaWZpZWQtY2hlY2tlZFwiLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHRcdFx0XHRpZihldnQudGFyZ2V0ID09IHNlbGYuZG9tTm9kZSl7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcdC8vIGlnbm9yZSBldmVudHMgdGhhdCBJIGZpcmUgb24gbXlzZWxmIGJlY2F1c2UgbXkgY2hpbGRyZW4gY2hhbmdlZFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2VsZi5fb25DaGlsZENoYW5nZShldnQudHlwZS5yZXBsYWNlKFwiYXR0cm1vZGlmaWVkLVwiLCBcIlwiKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBNYWtlIHN0YXRlIGNoYW5nZSBjYWxsIG9uVmFsaWRTdGF0ZUNoYW5nZSgpLCB3aWxsIGJlIHJlbW92ZWQgaW4gMi4wXG5cdFx0XHR0aGlzLndhdGNoKFwic3RhdGVcIiwgZnVuY3Rpb24oYXR0ciwgb2xkVmFsLCBuZXdWYWwpeyB0aGlzLm9uVmFsaWRTdGF0ZUNoYW5nZShuZXdWYWwgPT0gXCJcIik7IH0pO1xuXHRcdH0sXG5cblx0XHRkZXN0cm95OiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHR9XG5cblx0fSk7XG59KTtcbiIsImRlZmluZShbXG5cdFwiZG9qby9fYmFzZS9kZWNsYXJlXCIsIC8vIGRlY2xhcmVcblx0XCJkb2pvL2RvbS1hdHRyXCIsIC8vIGRvbUF0dHIuc2V0XG5cdFwiZG9qby9rZXlzXCIsIC8vIGtleXMuRVNDQVBFXG5cdFwiZG9qby9fYmFzZS9sYW5nXCIsXG5cdFwiZG9qby9vblwiLFxuXHRcImRvam8vc25pZmZcIiwgLy8gaGFzKFwid2Via2l0XCIpXG5cdFwiLi9fRm9ybVdpZGdldE1peGluXCJcbl0sIGZ1bmN0aW9uKGRlY2xhcmUsIGRvbUF0dHIsIGtleXMsIGxhbmcsIG9uLCBoYXMsIF9Gb3JtV2lkZ2V0TWl4aW4pe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvZm9ybS9fRm9ybVZhbHVlTWl4aW5cblxuXHRyZXR1cm4gZGVjbGFyZShcImRpaml0LmZvcm0uX0Zvcm1WYWx1ZU1peGluXCIsIF9Gb3JtV2lkZ2V0TWl4aW4sIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdE1peGluIGZvciB3aWRnZXRzIGNvcnJlc3BvbmRpbmcgdG8gbmF0aXZlIEhUTUwgZWxlbWVudHMgc3VjaCBhcyBgPGlucHV0PmAgb3IgYDxzZWxlY3Q+YFxuXHRcdC8vXHRcdHRoYXQgaGF2ZSB1c2VyIGNoYW5nZWFibGUgdmFsdWVzLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEVhY2ggX0Zvcm1WYWx1ZU1peGluIHJlcHJlc2VudHMgYSBzaW5nbGUgaW5wdXQgdmFsdWUsIGFuZCBoYXMgYSAocG9zc2libHkgaGlkZGVuKSBgPGlucHV0PmAgZWxlbWVudCxcblx0XHQvL1x0XHR0byB3aGljaCBpdCBzZXJpYWxpemVzIGl0J3MgaW5wdXQgdmFsdWUsIHNvIHRoYXQgZm9ybSBzdWJtaXNzaW9uIChlaXRoZXIgbm9ybWFsIHN1Ym1pc3Npb24gb3IgdmlhIEZvcm1CaW5kPylcblx0XHQvL1x0XHR3b3JrcyBhcyBleHBlY3RlZC5cblxuXHRcdC8vIHJlYWRPbmx5OiBCb29sZWFuXG5cdFx0Ly9cdFx0U2hvdWxkIHRoaXMgd2lkZ2V0IHJlc3BvbmQgdG8gdXNlciBpbnB1dD9cblx0XHQvL1x0XHRJbiBtYXJrdXAsIHRoaXMgaXMgc3BlY2lmaWVkIGFzIFwicmVhZE9ubHlcIi5cblx0XHQvL1x0XHRTaW1pbGFyIHRvIGRpc2FibGVkIGV4Y2VwdCByZWFkT25seSBmb3JtIHZhbHVlcyBhcmUgc3VibWl0dGVkLlxuXHRcdHJlYWRPbmx5OiBmYWxzZSxcblxuXHRcdF9zZXRSZWFkT25seUF0dHI6IGZ1bmN0aW9uKC8qQm9vbGVhbiovIHZhbHVlKXtcblx0XHRcdC8vIElFIGhhcyBhIENhcmV0IEJyb3dzaW5nIG1vZGUgKGhpdCBGNyB0byBhY3RpdmF0ZSkgd2hlcmUgZGlzYWJsZWQgdGV4dGJveGVzIGNhbiBiZSBtb2RpZmllZFxuXHRcdFx0Ly8gZm9jdXNOb2RlIGVuZm9yY2VkIHJlYWRvbmx5IGlmIGN1cnJlbnRseSBkaXNhYmxlZCB0byBhdm9pZCB0aGlzIGlzc3VlLlxuXHRcdFx0aWYgKGhhcygndHJpZGVudCcpICYmICdkaXNhYmxlZCcgaW4gdGhpcykge1xuXHRcdFx0XHRkb21BdHRyLnNldCh0aGlzLmZvY3VzTm9kZSwgJ3JlYWRPbmx5JywgdmFsdWUgfHwgdGhpcy5kaXNhYmxlZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb21BdHRyLnNldCh0aGlzLmZvY3VzTm9kZSwgJ3JlYWRPbmx5JywgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2V0KFwicmVhZE9ubHlcIiwgdmFsdWUpO1xuXHRcdH0sXG5cblx0XHRwb3N0Q3JlYXRlOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblxuXHRcdFx0Ly8gVXBkYXRlIG91ciByZXNldCB2YWx1ZSBpZiBpdCBoYXNuJ3QgeWV0IGJlZW4gc2V0IChiZWNhdXNlIHRoaXMuc2V0KClcblx0XHRcdC8vIGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlcmUgKmlzKiBhIHZhbHVlKVxuXHRcdFx0aWYodGhpcy5fcmVzZXRWYWx1ZSA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0dGhpcy5fbGFzdFZhbHVlUmVwb3J0ZWQgPSB0aGlzLl9yZXNldFZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3NldFZhbHVlQXR0cjogZnVuY3Rpb24oLyphbnl0aGluZyovIG5ld1ZhbHVlLCAvKkJvb2xlYW4/Ki8gcHJpb3JpdHlDaGFuZ2Upe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEhvb2sgc28gc2V0KCd2YWx1ZScsIHZhbHVlKSB3b3Jrcy5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0U2V0cyB0aGUgdmFsdWUgb2YgdGhlIHdpZGdldC5cblx0XHRcdC8vXHRcdElmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCwgdGhlbiBmaXJlIG9uQ2hhbmdlIGV2ZW50LCB1bmxlc3MgcHJpb3JpdHlDaGFuZ2Vcblx0XHRcdC8vXHRcdGlzIHNwZWNpZmllZCBhcyBudWxsIChvciBmYWxzZT8pXG5cdFx0XHR0aGlzLl9oYW5kbGVPbkNoYW5nZShuZXdWYWx1ZSwgcHJpb3JpdHlDaGFuZ2UpO1xuXHRcdH0sXG5cblx0XHRfaGFuZGxlT25DaGFuZ2U6IGZ1bmN0aW9uKC8qYW55dGhpbmcqLyBuZXdWYWx1ZSwgLypCb29sZWFuPyovIHByaW9yaXR5Q2hhbmdlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYWxsZWQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIHdpZGdldCBoYXMgY2hhbmdlZC4gIFNhdmVzIHRoZSBuZXcgdmFsdWUgaW4gdGhpcy52YWx1ZSxcblx0XHRcdC8vXHRcdGFuZCBjYWxscyBvbkNoYW5nZSgpIGlmIGFwcHJvcHJpYXRlLiAgIFNlZSBfRm9ybVdpZGdldC5faGFuZGxlT25DaGFuZ2UoKSBmb3IgZGV0YWlscy5cblx0XHRcdHRoaXMuX3NldChcInZhbHVlXCIsIG5ld1ZhbHVlKTtcblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdHVuZG86IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVzdG9yZSB0aGUgdmFsdWUgdG8gdGhlIGxhc3QgdmFsdWUgcGFzc2VkIHRvIG9uQ2hhbmdlXG5cdFx0XHR0aGlzLl9zZXRWYWx1ZUF0dHIodGhpcy5fbGFzdFZhbHVlUmVwb3J0ZWQsIGZhbHNlKTtcblx0XHR9LFxuXG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVzZXQgdGhlIHdpZGdldCdzIHZhbHVlIHRvIHdoYXQgaXQgd2FzIGF0IGluaXRpYWxpemF0aW9uIHRpbWVcblx0XHRcdHRoaXMuX2hhc0JlZW5CbHVycmVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9zZXRWYWx1ZUF0dHIodGhpcy5fcmVzZXRWYWx1ZSwgdHJ1ZSk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCJkb2pvL19iYXNlL2RlY2xhcmVcIiwgLy8gZGVjbGFyZVxuXHRcImRvam8vc25pZmZcIiwgLy8gaGFzKFwiaWVcIilcblx0XCIuL19Gb3JtV2lkZ2V0XCIsXG5cdFwiLi9fRm9ybVZhbHVlTWl4aW5cIlxuXSwgZnVuY3Rpb24oZGVjbGFyZSwgaGFzLCBfRm9ybVdpZGdldCwgX0Zvcm1WYWx1ZU1peGluKXtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRpaml0L2Zvcm0vX0Zvcm1WYWx1ZVdpZGdldFxuXG5cdHJldHVybiBkZWNsYXJlKFwiZGlqaXQuZm9ybS5fRm9ybVZhbHVlV2lkZ2V0XCIsIFtfRm9ybVdpZGdldCwgX0Zvcm1WYWx1ZU1peGluXSwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0QmFzZSBjbGFzcyBmb3Igd2lkZ2V0cyBjb3JyZXNwb25kaW5nIHRvIG5hdGl2ZSBIVE1MIGVsZW1lbnRzIHN1Y2ggYXMgYDxpbnB1dD5gIG9yIGA8c2VsZWN0PmBcblx0XHQvL1x0XHR0aGF0IGhhdmUgdXNlciBjaGFuZ2VhYmxlIHZhbHVlcy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRFYWNoIF9Gb3JtVmFsdWVXaWRnZXQgcmVwcmVzZW50cyBhIHNpbmdsZSBpbnB1dCB2YWx1ZSwgYW5kIGhhcyBhIChwb3NzaWJseSBoaWRkZW4pIGA8aW5wdXQ+YCBlbGVtZW50LFxuXHRcdC8vXHRcdHRvIHdoaWNoIGl0IHNlcmlhbGl6ZXMgaXQncyBpbnB1dCB2YWx1ZSwgc28gdGhhdCBmb3JtIHN1Ym1pc3Npb24gKGVpdGhlciBub3JtYWwgc3VibWlzc2lvbiBvciB2aWEgRm9ybUJpbmQ/KVxuXHRcdC8vXHRcdHdvcmtzIGFzIGV4cGVjdGVkLlxuXG5cdFx0Ly8gRG9uJ3QgYXR0ZW1wdCB0byBtaXhpbiB0aGUgJ3R5cGUnLCAnbmFtZScgYXR0cmlidXRlcyBoZXJlIHByb2dyYW1hdGljYWxseSAtLSB0aGV5IG11c3QgYmUgZGVjbGFyZWRcblx0XHQvLyBkaXJlY3RseSBpbiB0aGUgdGVtcGxhdGUgYXMgcmVhZCBieSB0aGUgcGFyc2VyIGluIG9yZGVyIHRvIGZ1bmN0aW9uLiBJRSBpcyBrbm93biB0byBzcGVjaWZpY2FsbHlcblx0XHQvLyByZXF1aXJlIHRoZSAnbmFtZScgYXR0cmlidXRlIGF0IGVsZW1lbnQgY3JlYXRpb24gdGltZS4gIFNlZSAjODQ4NCwgIzg2NjAuXG5cblx0XHRfbGF5b3V0SGFja0lFNzogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRXb3JrIGFyb3VuZCB0YWJsZSBzaXppbmcgYnVncyBvbiBJRTcgYnkgZm9yY2luZyByZWRyYXdcblxuXHRcdFx0aWYoaGFzKFwiaWVcIikgPT0gNyl7IC8vIGZpeCBJRTcgbGF5b3V0IGJ1ZyB3aGVuIHRoZSB3aWRnZXQgaXMgc2Nyb2xsZWQgb3V0IG9mIHNpZ2h0XG5cdFx0XHRcdHZhciBkb21Ob2RlID0gdGhpcy5kb21Ob2RlO1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuXHRcdFx0XHR2YXIgcGluZ05vZGUgPSBkb21Ob2RlLmZpcnN0Q2hpbGQgfHwgZG9tTm9kZTsgLy8gdGFyZ2V0IG5vZGUgbW9zdCB1bmxpa2VseSB0byBoYXZlIGEgY3VzdG9tIGZpbHRlclxuXHRcdFx0XHR2YXIgb3JpZ0ZpbHRlciA9IHBpbmdOb2RlLnN0eWxlLmZpbHRlcjsgLy8gc2F2ZSBjdXN0b20gZmlsdGVyLCBtb3N0IGxpa2VseSBub3RoaW5nXG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdHdoaWxlKHBhcmVudCAmJiBwYXJlbnQuY2xpZW50SGVpZ2h0ID09IDApeyAvLyBzZWFyY2ggZm9yIHBhcmVudHMgdGhhdCBoYXZlbid0IHJlbmRlcmVkIHlldFxuXHRcdFx0XHRcdChmdW5jdGlvbiBwaW5nKCl7XG5cdFx0XHRcdFx0XHR2YXIgZGlzY29ubmVjdEhhbmRsZSA9IF90aGlzLmNvbm5lY3QocGFyZW50LCBcIm9uc2Nyb2xsXCIsXG5cdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0X3RoaXMuZGlzY29ubmVjdChkaXNjb25uZWN0SGFuZGxlKTsgLy8gb25seSBjYWxsIG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRwaW5nTm9kZS5zdHlsZS5maWx0ZXIgPSAobmV3IERhdGUoKSkuZ2V0TWlsbGlzZWNvbmRzKCk7IC8vIHNldCB0byBhbnl0aGluZyB0aGF0J3MgdW5pcXVlXG5cdFx0XHRcdFx0XHRcdFx0X3RoaXMuZGVmZXIoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0XHRcdHBpbmdOb2RlLnN0eWxlLmZpbHRlciA9IG9yaWdGaWx0ZXI7XG5cdFx0XHRcdFx0XHRcdFx0fSk7IC8vIHJlc3RvcmUgY3VzdG9tIGZpbHRlciwgaWYgYW55XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSkoKTtcblx0XHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KTtcbiIsImRlZmluZShbXG5cdFwiZG9qby9fYmFzZS9kZWNsYXJlXCIsIC8vIGRlY2xhcmVcblx0XCJkb2pvL3NuaWZmXCIsIC8vIGhhcyhcImRpaml0LWxlZ2FjeS1yZXF1aXJlc1wiKSwgaGFzKFwibXNhcHBcIilcblx0XCJkb2pvL19iYXNlL2tlcm5lbFwiLCAvLyBrZXJuZWwuZGVwcmVjYXRlZFxuXHRcImRvam8vcmVhZHlcIixcblx0XCIuLi9fV2lkZ2V0XCIsXG5cdFwiLi4vX0Nzc1N0YXRlTWl4aW5cIixcblx0XCIuLi9fVGVtcGxhdGVkTWl4aW5cIixcblx0XCIuL19Gb3JtV2lkZ2V0TWl4aW5cIlxuXSwgZnVuY3Rpb24oZGVjbGFyZSwgaGFzLCBrZXJuZWwsIHJlYWR5LCBfV2lkZ2V0LCBfQ3NzU3RhdGVNaXhpbiwgX1RlbXBsYXRlZE1peGluLCBfRm9ybVdpZGdldE1peGluKXtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRpaml0L2Zvcm0vX0Zvcm1XaWRnZXRcblxuXHQvLyBCYWNrIGNvbXBhdCB3LzEuNiwgcmVtb3ZlIGZvciAyLjBcblx0aWYoaGFzKFwiZGlqaXQtbGVnYWN5LXJlcXVpcmVzXCIpKXtcblx0XHRyZWFkeSgwLCBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHJlcXVpcmVzID0gW1wiZGlqaXQvZm9ybS9fRm9ybVZhbHVlV2lkZ2V0XCJdO1xuXHRcdFx0cmVxdWlyZShyZXF1aXJlcyk7XHQvLyB1c2UgaW5kaXJlY3Rpb24gc28gbW9kdWxlcyBub3Qgcm9sbGVkIGludG8gYSBidWlsZFxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIGRlY2xhcmUoXCJkaWppdC5mb3JtLl9Gb3JtV2lkZ2V0XCIsIFtfV2lkZ2V0LCBfVGVtcGxhdGVkTWl4aW4sIF9Dc3NTdGF0ZU1peGluLCBfRm9ybVdpZGdldE1peGluXSwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0QmFzZSBjbGFzcyBmb3Igd2lkZ2V0cyBjb3JyZXNwb25kaW5nIHRvIG5hdGl2ZSBIVE1MIGVsZW1lbnRzIHN1Y2ggYXMgYDxjaGVja2JveD5gIG9yIGA8YnV0dG9uPmAsXG5cdFx0Ly9cdFx0d2hpY2ggY2FuIGJlIGNoaWxkcmVuIG9mIGEgYDxmb3JtPmAgbm9kZSBvciBhIGBkaWppdC9mb3JtL0Zvcm1gIHdpZGdldC5cblx0XHQvL1xuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdFJlcHJlc2VudHMgYSBzaW5nbGUgSFRNTCBlbGVtZW50LlxuXHRcdC8vXHRcdEFsbCB0aGVzZSB3aWRnZXRzIHNob3VsZCBoYXZlIHRoZXNlIGF0dHJpYnV0ZXMganVzdCBsaWtlIG5hdGl2ZSBIVE1MIGlucHV0IGVsZW1lbnRzLlxuXHRcdC8vXHRcdFlvdSBjYW4gc2V0IHRoZW0gZHVyaW5nIHdpZGdldCBjb25zdHJ1Y3Rpb24gb3IgYWZ0ZXJ3YXJkcywgdmlhIGBkaWppdC9fV2lkZ2V0QmFzZS5zZXQoKWAuXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGV5IGFsc28gc2hhcmUgc29tZSBjb21tb24gbWV0aG9kcy5cblxuXHRcdHNldERpc2FibGVkOiBmdW5jdGlvbigvKkJvb2xlYW4qLyBkaXNhYmxlZCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RGVwcmVjYXRlZC4gIFVzZSBzZXQoJ2Rpc2FibGVkJywgLi4uKSBpbnN0ZWFkLlxuXHRcdFx0a2VybmVsLmRlcHJlY2F0ZWQoXCJzZXREaXNhYmxlZChcIiArIGRpc2FibGVkICsgXCIpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoJ2Rpc2FibGVkJyxcIiArIGRpc2FibGVkICsgXCIpIGluc3RlYWQuXCIsIFwiXCIsIFwiMi4wXCIpO1xuXHRcdFx0dGhpcy5zZXQoJ2Rpc2FibGVkJywgZGlzYWJsZWQpO1xuXHRcdH0sXG5cblx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oLypTdHJpbmcqLyB2YWx1ZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RGVwcmVjYXRlZC4gIFVzZSBzZXQoJ3ZhbHVlJywgLi4uKSBpbnN0ZWFkLlxuXHRcdFx0a2VybmVsLmRlcHJlY2F0ZWQoXCJkaWppdC5mb3JtLl9Gb3JtV2lkZ2V0OnNldFZhbHVlKFwiICsgdmFsdWUgKyBcIikgaXMgZGVwcmVjYXRlZC4gIFVzZSBzZXQoJ3ZhbHVlJyxcIiArIHZhbHVlICsgXCIpIGluc3RlYWQuXCIsIFwiXCIsIFwiMi4wXCIpO1xuXHRcdFx0dGhpcy5zZXQoJ3ZhbHVlJywgdmFsdWUpO1xuXHRcdH0sXG5cblx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXByZWNhdGVkLiAgVXNlIGdldCgndmFsdWUnKSBpbnN0ZWFkLlxuXHRcdFx0a2VybmVsLmRlcHJlY2F0ZWQodGhpcy5kZWNsYXJlZENsYXNzICsgXCI6OmdldFZhbHVlKCkgaXMgZGVwcmVjYXRlZC4gVXNlIGdldCgndmFsdWUnKSBpbnN0ZWFkLlwiLCBcIlwiLCBcIjIuMFwiKTtcblx0XHRcdHJldHVybiB0aGlzLmdldCgndmFsdWUnKTtcblx0XHR9LFxuXG5cdFx0cG9zdE1peEluUHJvcGVydGllczogZnVuY3Rpb24oKXtcblx0XHRcdC8vIFNldHVwIG5hbWU9Zm9vIHN0cmluZyB0byBiZSByZWZlcmVuY2VkIGZyb20gdGhlIHRlbXBsYXRlIChidXQgb25seSBpZiBhIG5hbWUgaGFzIGJlZW4gc3BlY2lmaWVkKS5cblx0XHRcdC8vIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3QgdXNlIF9zZXROYW1lQXR0ciB0byBzZXQgdGhlIG5hbWUgaW4gSUUgZHVlIHRvIElFIGxpbWl0YXRpb25zLCBzZWUgIzg0ODQsICM4NjYwLlxuXHRcdFx0Ly8gQnV0IHdoZW4gSUU2IGFuZCBJRTcgYXJlIGRlc3VwcG9ydGVkLCB0aGVuIHdlIHByb2JhYmx5IGRvbid0IG5lZWQgdGhpcyBhbnltb3JlLCBzbyBzaG91bGQgcmVtb3ZlIGl0IGluIDIuMC5cblx0XHRcdC8vIEFsc28sIGRvbid0IGRvIHRoaXMgZm9yIFdpbmRvd3MgOCBTdG9yZSBBcHBzIGJlY2F1c2UgaXQgY2F1c2VzIGEgc2VjdXJpdHkgZXhjZXB0aW9uIChzZWUgIzE2NDUyKS5cblx0XHRcdC8vIFJlZ2FyZGluZyBlc2NhcGluZywgc2VlIGhlYWRpbmcgXCJBdHRyaWJ1dGUgdmFsdWVzXCIgaW5cblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy1odG1sNDAvYXBwZW5kaXgvbm90ZXMuaHRtbCNoLUIuMy4yXG5cdFx0XHR0aGlzLm5hbWVBdHRyU2V0dGluZyA9ICh0aGlzLm5hbWUgJiYgIWhhcyhcIm1zYXBwXCIpKSA/ICgnbmFtZT1cIicgKyB0aGlzLm5hbWUucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikgKyAnXCInKSA6ICcnO1xuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHR9XG5cdH0pO1xufSk7XG4iLCJkZWZpbmUoW1xuXHRcImRvam8vX2Jhc2UvYXJyYXlcIiwgLy8gYXJyYXkuZm9yRWFjaFxuXHRcImRvam8vX2Jhc2UvZGVjbGFyZVwiLCAvLyBkZWNsYXJlXG5cdFwiZG9qby9kb20tYXR0clwiLCAvLyBkb21BdHRyLnNldFxuXHRcImRvam8vZG9tLXN0eWxlXCIsIC8vIGRvbVN0eWxlLmdldFxuXHRcImRvam8vX2Jhc2UvbGFuZ1wiLCAvLyBsYW5nLmhpdGNoIGxhbmcuaXNBcnJheVxuXHRcImRvam8vbW91c2VcIiwgLy8gbW91c2UuaXNMZWZ0XG5cdFwiZG9qby9vblwiLFxuXHRcImRvam8vc25pZmZcIiwgLy8gaGFzKFwid2Via2l0XCIpXG5cdFwiZG9qby93aW5kb3dcIiwgLy8gd2luVXRpbHMuc2Nyb2xsSW50b1ZpZXdcblx0XCIuLi9hMTF5XCIgICAgLy8gYTExeS5oYXNEZWZhdWx0VGFiU3RvcFxuXSwgZnVuY3Rpb24oYXJyYXksIGRlY2xhcmUsIGRvbUF0dHIsIGRvbVN0eWxlLCBsYW5nLCBtb3VzZSwgb24sIGhhcywgd2luVXRpbHMsIGExMXkpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvZm9ybS9fRm9ybVdpZGdldE1peGluXG5cblx0cmV0dXJuIGRlY2xhcmUoXCJkaWppdC5mb3JtLl9Gb3JtV2lkZ2V0TWl4aW5cIiwgbnVsbCwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0TWl4aW4gZm9yIHdpZGdldHMgY29ycmVzcG9uZGluZyB0byBuYXRpdmUgSFRNTCBlbGVtZW50cyBzdWNoIGFzIGA8Y2hlY2tib3g+YCBvciBgPGJ1dHRvbj5gLFxuXHRcdC8vXHRcdHdoaWNoIGNhbiBiZSBjaGlsZHJlbiBvZiBhIGA8Zm9ybT5gIG5vZGUgb3IgYSBgZGlqaXQvZm9ybS9Gb3JtYCB3aWRnZXQuXG5cdFx0Ly9cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRSZXByZXNlbnRzIGEgc2luZ2xlIEhUTUwgZWxlbWVudC5cblx0XHQvL1x0XHRBbGwgdGhlc2Ugd2lkZ2V0cyBzaG91bGQgaGF2ZSB0aGVzZSBhdHRyaWJ1dGVzIGp1c3QgbGlrZSBuYXRpdmUgSFRNTCBpbnB1dCBlbGVtZW50cy5cblx0XHQvL1x0XHRZb3UgY2FuIHNldCB0aGVtIGR1cmluZyB3aWRnZXQgY29uc3RydWN0aW9uIG9yIGFmdGVyd2FyZHMsIHZpYSBgZGlqaXQvX1dpZGdldEJhc2Uuc2V0KClgLlxuXHRcdC8vXG5cdFx0Ly9cdFx0VGhleSBhbHNvIHNoYXJlIHNvbWUgY29tbW9uIG1ldGhvZHMuXG5cblx0XHQvLyBuYW1lOiBbY29uc3RdIFN0cmluZ1xuXHRcdC8vXHRcdE5hbWUgdXNlZCB3aGVuIHN1Ym1pdHRpbmcgZm9ybTsgc2FtZSBhcyBcIm5hbWVcIiBhdHRyaWJ1dGUgb3IgcGxhaW4gSFRNTCBlbGVtZW50c1xuXHRcdG5hbWU6IFwiXCIsXG5cblx0XHQvLyBhbHQ6IFN0cmluZ1xuXHRcdC8vXHRcdENvcnJlc3BvbmRzIHRvIHRoZSBuYXRpdmUgSFRNTCBgPGlucHV0PmAgZWxlbWVudCdzIGF0dHJpYnV0ZS5cblx0XHRhbHQ6IFwiXCIsXG5cblx0XHQvLyB2YWx1ZTogU3RyaW5nXG5cdFx0Ly9cdFx0Q29ycmVzcG9uZHMgdG8gdGhlIG5hdGl2ZSBIVE1MIGA8aW5wdXQ+YCBlbGVtZW50J3MgYXR0cmlidXRlLlxuXHRcdHZhbHVlOiBcIlwiLFxuXG5cdFx0Ly8gdHlwZTogW2NvbnN0XSBTdHJpbmdcblx0XHQvL1x0XHRDb3JyZXNwb25kcyB0byB0aGUgbmF0aXZlIEhUTUwgYDxpbnB1dD5gIGVsZW1lbnQncyBhdHRyaWJ1dGUuXG5cdFx0dHlwZTogXCJ0ZXh0XCIsXG5cblx0XHQvLyB0eXBlOiBTdHJpbmdcblx0XHQvL1x0XHRBcHBseSBhcmlhLWxhYmVsIGluIG1hcmt1cCB0byB0aGUgd2lkZ2V0J3MgZm9jdXNOb2RlXG5cdFx0XCJhcmlhLWxhYmVsXCI6IFwiZm9jdXNOb2RlXCIsXG5cblx0XHQvLyB0YWJJbmRleDogU3RyaW5nXG5cdFx0Ly9cdFx0T3JkZXIgZmllbGRzIGFyZSB0cmF2ZXJzZWQgd2hlbiB1c2VyIGhpdHMgdGhlIHRhYiBrZXlcblx0XHR0YWJJbmRleDogXCIwXCIsXG5cdFx0X3NldFRhYkluZGV4QXR0cjogXCJmb2N1c05vZGVcIiwgLy8gZm9yY2UgY29weSBldmVuIHdoZW4gdGFiSW5kZXggZGVmYXVsdCB2YWx1ZSwgbmVlZGVkIHNpbmNlIEJ1dHRvbiBpcyA8c3Bhbj5cblxuXHRcdC8vIGRpc2FibGVkOiBCb29sZWFuXG5cdFx0Ly9cdFx0U2hvdWxkIHRoaXMgd2lkZ2V0IHJlc3BvbmQgdG8gdXNlciBpbnB1dD9cblx0XHQvL1x0XHRJbiBtYXJrdXAsIHRoaXMgaXMgc3BlY2lmaWVkIGFzIFwiZGlzYWJsZWQ9J2Rpc2FibGVkJ1wiLCBvciBqdXN0IFwiZGlzYWJsZWRcIi5cblx0XHRkaXNhYmxlZDogZmFsc2UsXG5cblx0XHQvLyBpbnRlcm1lZGlhdGVDaGFuZ2VzOiBCb29sZWFuXG5cdFx0Ly9cdFx0RmlyZXMgb25DaGFuZ2UgZm9yIGVhY2ggdmFsdWUgY2hhbmdlIG9yIG9ubHkgb24gZGVtYW5kXG5cdFx0aW50ZXJtZWRpYXRlQ2hhbmdlczogZmFsc2UsXG5cblx0XHQvLyBzY3JvbGxPbkZvY3VzOiBCb29sZWFuXG5cdFx0Ly9cdFx0T24gZm9jdXMsIHNob3VsZCB0aGlzIHdpZGdldCBzY3JvbGwgaW50byB2aWV3P1xuXHRcdHNjcm9sbE9uRm9jdXM6IHRydWUsXG5cblx0XHQvLyBPdmVycmlkZSBfV2lkZ2V0QmFzZSBtYXBwaW5nIGlkIHRvIHRoaXMuZG9tTm9kZSwgbmVlZHMgdG8gYmUgb24gZm9jdXNOb2RlIHNvIDxsYWJlbD4gZXRjLlxuXHRcdC8vIHdvcmtzIHdpdGggc2NyZWVuIHJlYWRlclxuXHRcdF9zZXRJZEF0dHI6IFwiZm9jdXNOb2RlXCIsXG5cblx0XHRfc2V0RGlzYWJsZWRBdHRyOiBmdW5jdGlvbigvKkJvb2xlYW4qLyB2YWx1ZSl7XG5cdFx0XHR0aGlzLl9zZXQoXCJkaXNhYmxlZFwiLCB2YWx1ZSk7XG5cblx0XHRcdC8vIFNldCBkaXNhYmxlZCBwcm9wZXJ0eSBpZiBmb2N1c05vZGUgaXMgYW4gPGlucHV0PiwgYnV0IGFyaWEtZGlzYWJsZWQgYXR0cmlidXRlIGlmIGZvY3VzTm9kZSBpcyBhIDxzcGFuPi5cblx0XHRcdC8vIENhbid0IHVzZSBcImRpc2FibGVkXCIgaW4gdGhpcy5mb2N1c05vZGUgYXMgYSB0ZXN0IGJlY2F1c2Ugb24gSUUsIHRoYXQncyB0cnVlIGZvciBhbGwgbm9kZXMuXG5cdFx0XHRpZigvXihidXR0b258aW5wdXR8c2VsZWN0fHRleHRhcmVhfG9wdGdyb3VwfG9wdGlvbnxmaWVsZHNldCkkL2kudGVzdCh0aGlzLmZvY3VzTm9kZS50YWdOYW1lKSl7XG5cdFx0XHRcdGRvbUF0dHIuc2V0KHRoaXMuZm9jdXNOb2RlLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG5cdFx0XHRcdC8vIElFIGhhcyBhIENhcmV0IEJyb3dzaW5nIG1vZGUgKGhpdCBGNyB0byBhY3RpdmF0ZSkgd2hlcmUgZGlzYWJsZWQgdGV4dGJveGVzIGNhbiBiZSBtb2RpZmllZFxuXHRcdFx0XHQvLyB0ZXh0Ym94ZXMgbWFya2VkIHJlYWRvbmx5IGlmIGRpc2FibGVkIHRvIGF2b2lkIHRoaXMgaXNzdWUuXG5cdFx0XHRcdGlmIChoYXMoJ3RyaWRlbnQnKSAmJiAncmVhZE9ubHknIGluIHRoaXMpIHtcblx0XHRcdFx0XHRkb21BdHRyLnNldCh0aGlzLmZvY3VzTm9kZSwgJ3JlYWRvbmx5JywgdmFsdWUgfHwgdGhpcy5yZWFkT25seSk7XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNle1xuXHRcdFx0XHR0aGlzLmZvY3VzTm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsIHZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbmQgYWxzbyBzZXQgZGlzYWJsZWQgb24gdGhlIGhpZGRlbiA8aW5wdXQ+IG5vZGVcblx0XHRcdGlmKHRoaXMudmFsdWVOb2RlKXtcblx0XHRcdFx0ZG9tQXR0ci5zZXQodGhpcy52YWx1ZU5vZGUsICdkaXNhYmxlZCcsIHZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYodmFsdWUpe1xuXHRcdFx0XHQvLyByZXNldCB0aGVzZSwgYmVjYXVzZSBhZnRlciB0aGUgZG9tTm9kZSBpcyBkaXNhYmxlZCwgd2UgY2FuIG5vIGxvbmdlciByZWNlaXZlXG5cdFx0XHRcdC8vIG1vdXNlIHJlbGF0ZWQgZXZlbnRzLCBzZWUgIzQyMDBcblx0XHRcdFx0dGhpcy5fc2V0KFwiaG92ZXJpbmdcIiwgZmFsc2UpO1xuXHRcdFx0XHR0aGlzLl9zZXQoXCJhY3RpdmVcIiwgZmFsc2UpO1xuXG5cdFx0XHRcdC8vIGNsZWFyIHRhYiBzdG9wKHMpIG9uIHRoaXMgd2lkZ2V0J3MgZm9jdXNhYmxlIG5vZGUocykgIChDb21ib0JveCBoYXMgdHdvIGZvY3VzYWJsZSBub2Rlcylcblx0XHRcdFx0dmFyIGF0dGFjaFBvaW50TmFtZXMgPSBcInRhYkluZGV4XCIgaW4gdGhpcy5hdHRyaWJ1dGVNYXAgPyB0aGlzLmF0dHJpYnV0ZU1hcC50YWJJbmRleCA6XG5cdFx0XHRcdFx0KFwiX3NldFRhYkluZGV4QXR0clwiIGluIHRoaXMpID8gdGhpcy5fc2V0VGFiSW5kZXhBdHRyIDogXCJmb2N1c05vZGVcIjtcblx0XHRcdFx0YXJyYXkuZm9yRWFjaChsYW5nLmlzQXJyYXkoYXR0YWNoUG9pbnROYW1lcykgPyBhdHRhY2hQb2ludE5hbWVzIDogW2F0dGFjaFBvaW50TmFtZXNdLCBmdW5jdGlvbihhdHRhY2hQb2ludE5hbWUpe1xuXHRcdFx0XHRcdHZhciBub2RlID0gdGhpc1thdHRhY2hQb2ludE5hbWVdO1xuXHRcdFx0XHRcdC8vIGNvbXBsZXggY29kZSBiZWNhdXNlIHRhYkluZGV4PS0xIG9uIGEgPGRpdj4gZG9lc24ndCB3b3JrIG9uIEZGXG5cdFx0XHRcdFx0aWYoaGFzKFwid2Via2l0XCIpIHx8IGExMXkuaGFzRGVmYXVsdFRhYlN0b3Aobm9kZSkpeyAgICAvLyBzZWUgIzExMDY0IGFib3V0IHdlYmtpdCBidWdcblx0XHRcdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIFwiLTFcIik7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGlmKHRoaXMudGFiSW5kZXggIT0gXCJcIil7XG5cdFx0XHRcdFx0dGhpcy5zZXQoJ3RhYkluZGV4JywgdGhpcy50YWJJbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X29uRm9jdXM6IGZ1bmN0aW9uKC8qU3RyaW5nKi8gYnkpe1xuXHRcdFx0Ly8gSWYgdXNlciBjbGlja3Mgb24gdGhlIHdpZGdldCwgZXZlbiBpZiB0aGUgbW91c2UgaXMgcmVsZWFzZWQgb3V0c2lkZSBvZiBpdCxcblx0XHRcdC8vIHRoaXMgd2lkZ2V0J3MgZm9jdXNOb2RlIHNob3VsZCBnZXQgZm9jdXMgKHRvIG1pbWljIG5hdGl2ZSBicm93c2VyIGJlaGF2aW9yKS5cblx0XHRcdC8vIEJyb3dzZXJzIG9mdGVuIG5lZWQgaGVscCB0byBtYWtlIHN1cmUgdGhlIGZvY3VzIHZpYSBtb3VzZSBhY3R1YWxseSBnZXRzIHRvIHRoZSBmb2N1c05vZGUuXG5cdFx0XHQvLyBUT0RPOiBjb25zaWRlciByZW1vdmluZyBhbGwgb2YgdGhpcyBmb3IgMi4wIG9yIHNvb25lciwgc2VlICMxNjYyMiBldGMuXG5cdFx0XHRpZihieSA9PSBcIm1vdXNlXCIgJiYgdGhpcy5pc0ZvY3VzYWJsZSgpKXtcblx0XHRcdFx0Ly8gSUUgZXhoaWJpdHMgc3RyYW5nZSBzY3JvbGxpbmcgYmVoYXZpb3Igd2hlbiByZWZvY3VzaW5nIGEgbm9kZSBzbyBvbmx5IGRvIGl0IHdoZW4gIWZvY3VzZWQuXG5cdFx0XHRcdHZhciBmb2N1c0hhbmRsZSA9IHRoaXMub3duKG9uKHRoaXMuZm9jdXNOb2RlLCBcImZvY3VzXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0bW91c2VVcEhhbmRsZS5yZW1vdmUoKTtcblx0XHRcdFx0XHRmb2N1c0hhbmRsZS5yZW1vdmUoKTtcblx0XHRcdFx0fSkpWzBdO1xuXHRcdFx0XHQvLyBTZXQgYSBnbG9iYWwgZXZlbnQgdG8gaGFuZGxlIG1vdXNldXAsIHNvIGl0IGZpcmVzIHByb3Blcmx5XG5cdFx0XHRcdC8vIGV2ZW4gaWYgdGhlIGN1cnNvciBsZWF2ZXMgdGhpcy5kb21Ob2RlIGJlZm9yZSB0aGUgbW91c2UgdXAgZXZlbnQuXG5cdFx0XHRcdHZhciBldmVudCA9IGhhcyhcInBvaW50ZXItZXZlbnRzXCIpID8gXCJwb2ludGVydXBcIiA6IGhhcyhcIk1TUG9pbnRlclwiKSA/IFwiTVNQb2ludGVyVXBcIiA6XG5cdFx0XHRcdFx0aGFzKFwidG91Y2gtZXZlbnRzXCIpID8gXCJ0b3VjaGVuZCwgbW91c2V1cFwiIDpcdFx0Ly8gc2VlbXMgbGlrZSBvdmVya2lsbCBidXQgc2VlICMxNjYyMiwgIzE2NzI1XG5cdFx0XHRcdFx0XCJtb3VzZXVwXCI7XG5cdFx0XHRcdHZhciBtb3VzZVVwSGFuZGxlID0gdGhpcy5vd24ob24odGhpcy5vd25lckRvY3VtZW50Qm9keSwgZXZlbnQsIGxhbmcuaGl0Y2godGhpcywgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0XHRtb3VzZVVwSGFuZGxlLnJlbW92ZSgpO1xuXHRcdFx0XHRcdGZvY3VzSGFuZGxlLnJlbW92ZSgpO1xuXHRcdFx0XHRcdC8vIGlmIGhlcmUsIHRoZW4gdGhlIG1vdXNlZG93biBkaWQgbm90IGZvY3VzIHRoZSBmb2N1c05vZGUgYXMgdGhlIGRlZmF1bHQgYWN0aW9uXG5cdFx0XHRcdFx0aWYodGhpcy5mb2N1c2VkKXtcblx0XHRcdFx0XHRcdGlmKGV2dC50eXBlID09IFwidG91Y2hlbmRcIil7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVmZXIoXCJmb2N1c1wiKTsgLy8gbmF0aXZlIGZvY3VzIGhhc24ndCBvY2N1cnJlZCB5ZXRcblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7IC8vIG5hdGl2ZSBmb2N1cyBhbHJlYWR5IG9jY3VycmVkIG9uIG1vdXNlZG93blxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpKVswXTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuc2Nyb2xsT25Gb2N1cyl7XG5cdFx0XHRcdHRoaXMuZGVmZXIoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR3aW5VdGlscy5zY3JvbGxJbnRvVmlldyh0aGlzLmRvbU5vZGUpO1xuXHRcdFx0XHR9KTsgLy8gd2l0aG91dCBkZWZlciwgdGhlIGlucHV0IGNhcmV0IHBvc2l0aW9uIGNhbiBjaGFuZ2Ugb24gbW91c2UgY2xpY2tcblx0XHRcdH1cblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdGlzRm9jdXNhYmxlOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRlbGxzIGlmIHRoaXMgd2lkZ2V0IGlzIGZvY3VzYWJsZSBvciBub3QuICBVc2VkIGludGVybmFsbHkgYnkgZGlqaXQuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cdFx0XHRyZXR1cm4gIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5mb2N1c05vZGUgJiYgKGRvbVN0eWxlLmdldCh0aGlzLmRvbU5vZGUsIFwiZGlzcGxheVwiKSAhPSBcIm5vbmVcIik7XG5cdFx0fSxcblxuXHRcdGZvY3VzOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFB1dCBmb2N1cyBvbiB0aGlzIHdpZGdldFxuXHRcdFx0aWYoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5mb2N1c05vZGUuZm9jdXMpe1xuXHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0dGhpcy5mb2N1c05vZGUuZm9jdXMoKTtcblx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qc3F1ZWxjaCBlcnJvcnMgZnJvbSBoaWRkZW4gbm9kZXMqL1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjb21wYXJlOiBmdW5jdGlvbigvKmFueXRoaW5nKi8gdmFsMSwgLyphbnl0aGluZyovIHZhbDIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENvbXBhcmUgMiB2YWx1ZXMgKGFzIHJldHVybmVkIGJ5IGdldCgndmFsdWUnKSBmb3IgdGhpcyB3aWRnZXQpLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXHRcdFx0aWYodHlwZW9mIHZhbDEgPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdmFsMiA9PSBcIm51bWJlclwiKXtcblx0XHRcdFx0cmV0dXJuIChpc05hTih2YWwxKSAmJiBpc05hTih2YWwyKSkgPyAwIDogdmFsMSAtIHZhbDI7XG5cdFx0XHR9ZWxzZSBpZih2YWwxID4gdmFsMil7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fWVsc2UgaWYodmFsMSA8IHZhbDIpe1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uQ2hhbmdlOiBmdW5jdGlvbigvKj09PT09IG5ld1ZhbHVlID09PT09Ki8pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbGxiYWNrIHdoZW4gdGhpcyB3aWRnZXQncyB2YWx1ZSBpcyBjaGFuZ2VkLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdGNhbGxiYWNrXG5cdFx0fSxcblxuXHRcdC8vIF9vbkNoYW5nZUFjdGl2ZTogW3ByaXZhdGVdIEJvb2xlYW5cblx0XHQvL1x0XHRJbmRpY2F0ZXMgdGhhdCBjaGFuZ2VzIHRvIHRoZSB2YWx1ZSBzaG91bGQgY2FsbCBvbkNoYW5nZSgpIGNhbGxiYWNrLlxuXHRcdC8vXHRcdFRoaXMgaXMgZmFsc2UgZHVyaW5nIHdpZGdldCBpbml0aWFsaXphdGlvbiwgdG8gYXZvaWQgY2FsbGluZyBvbkNoYW5nZSgpXG5cdFx0Ly9cdFx0d2hlbiB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBzZXQuXG5cdFx0X29uQ2hhbmdlQWN0aXZlOiBmYWxzZSxcblxuXHRcdF9oYW5kbGVPbkNoYW5nZTogZnVuY3Rpb24oLyphbnl0aGluZyovIG5ld1ZhbHVlLCAvKkJvb2xlYW4/Ki8gcHJpb3JpdHlDaGFuZ2Upe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbGxlZCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgd2lkZ2V0IGlzIHNldC4gIENhbGxzIG9uQ2hhbmdlKCkgaWYgYXBwcm9wcmlhdGVcblx0XHRcdC8vIG5ld1ZhbHVlOlxuXHRcdFx0Ly9cdFx0dGhlIG5ldyB2YWx1ZVxuXHRcdFx0Ly8gcHJpb3JpdHlDaGFuZ2U6XG5cdFx0XHQvL1x0XHRGb3IgYSBzbGlkZXIsIGZvciBleGFtcGxlLCBkcmFnZ2luZyB0aGUgc2xpZGVyIGlzIHByaW9yaXR5Q2hhbmdlPT1mYWxzZSxcblx0XHRcdC8vXHRcdGJ1dCBvbiBtb3VzZSB1cCwgaXQncyBwcmlvcml0eUNoYW5nZT09dHJ1ZS4gIElmIGludGVybWVkaWF0ZUNoYW5nZXM9PWZhbHNlLFxuXHRcdFx0Ly9cdFx0b25DaGFuZ2UgaXMgb25seSBjYWxsZWQgZm9ybSBwcmlvcml0eUNoYW5nZT10cnVlIGV2ZW50cy5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcml2YXRlXG5cdFx0XHRpZih0aGlzLl9sYXN0VmFsdWVSZXBvcnRlZCA9PSB1bmRlZmluZWQgJiYgKHByaW9yaXR5Q2hhbmdlID09PSBudWxsIHx8ICF0aGlzLl9vbkNoYW5nZUFjdGl2ZSkpe1xuXHRcdFx0XHQvLyB0aGlzIGJsb2NrIGV4ZWN1dGVzIG5vdCBmb3IgYSBjaGFuZ2UsIGJ1dCBkdXJpbmcgaW5pdGlhbGl6YXRpb24sXG5cdFx0XHRcdC8vIGFuZCBpcyB1c2VkIHRvIHN0b3JlIGF3YXkgdGhlIG9yaWdpbmFsIHZhbHVlIChvciBmb3IgVG9nZ2xlQnV0dG9uLCB0aGUgb3JpZ2luYWwgY2hlY2tlZCBzdGF0ZSlcblx0XHRcdFx0dGhpcy5fcmVzZXRWYWx1ZSA9IHRoaXMuX2xhc3RWYWx1ZVJlcG9ydGVkID0gbmV3VmFsdWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9wZW5kaW5nT25DaGFuZ2UgPSB0aGlzLl9wZW5kaW5nT25DaGFuZ2Vcblx0XHRcdFx0fHwgKHR5cGVvZiBuZXdWYWx1ZSAhPSB0eXBlb2YgdGhpcy5fbGFzdFZhbHVlUmVwb3J0ZWQpXG5cdFx0XHRcdHx8ICh0aGlzLmNvbXBhcmUobmV3VmFsdWUsIHRoaXMuX2xhc3RWYWx1ZVJlcG9ydGVkKSAhPSAwKTtcblx0XHRcdGlmKCh0aGlzLmludGVybWVkaWF0ZUNoYW5nZXMgfHwgcHJpb3JpdHlDaGFuZ2UgfHwgcHJpb3JpdHlDaGFuZ2UgPT09IHVuZGVmaW5lZCkgJiYgdGhpcy5fcGVuZGluZ09uQ2hhbmdlKXtcblx0XHRcdFx0dGhpcy5fbGFzdFZhbHVlUmVwb3J0ZWQgPSBuZXdWYWx1ZTtcblx0XHRcdFx0dGhpcy5fcGVuZGluZ09uQ2hhbmdlID0gZmFsc2U7XG5cdFx0XHRcdGlmKHRoaXMuX29uQ2hhbmdlQWN0aXZlKXtcblx0XHRcdFx0XHRpZih0aGlzLl9vbkNoYW5nZUhhbmRsZSl7XG5cdFx0XHRcdFx0XHR0aGlzLl9vbkNoYW5nZUhhbmRsZS5yZW1vdmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZGVmZXIgYWxsb3dzIGhpZGRlbiB2YWx1ZSBwcm9jZXNzaW5nIHRvIHJ1biBhbmRcblx0XHRcdFx0XHQvLyBhbHNvIHRoZSBvbkNoYW5nZSBoYW5kbGVyIGNhbiBzYWZlbHkgYWRqdXN0IGZvY3VzLCBldGNcblx0XHRcdFx0XHR0aGlzLl9vbkNoYW5nZUhhbmRsZSA9IHRoaXMuZGVmZXIoXG5cdFx0XHRcdFx0XHRmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9vbkNoYW5nZUhhbmRsZSA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHRoaXMub25DaGFuZ2UobmV3VmFsdWUpO1xuXHRcdFx0XHRcdFx0fSk7IC8vIHRyeSB0byBjb2xsYXBzZSBtdWx0aXBsZSBvbkNoYW5nZSdzIGZpcmVkIGZhc3RlciB0aGFuIGNhbiBiZSBwcm9jZXNzZWRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBPdmVycmlkZXMgX1dpZGdldC5jcmVhdGUoKVxuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQWN0aXZlID0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKXtcblx0XHRcdGlmKHRoaXMuX29uQ2hhbmdlSGFuZGxlKXsgLy8gZGVzdHJveSBjYWxsZWQgYmVmb3JlIGxhc3Qgb25DaGFuZ2UgaGFzIGZpcmVkXG5cdFx0XHRcdHRoaXMuX29uQ2hhbmdlSGFuZGxlLnJlbW92ZSgpO1xuXHRcdFx0XHR0aGlzLm9uQ2hhbmdlKHRoaXMuX2xhc3RWYWx1ZVJlcG9ydGVkKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCJkb2pvL19iYXNlL2FycmF5XCIsIC8vIGFycmF5LmZvckVhY2hcblx0XCJkb2pvL19iYXNlL2RlY2xhcmVcIiwgLy8gZGVjbGFyZVxuXHRcImRvam8vZG9tXCIsIC8vIGRvbS5ieUlkXG5cdFwiZG9qby9zbmlmZlwiLFx0Ly8gaGFzKFwiaWVcIiksIGhhcyhcImRvam8tYmlkaVwiKVxuXHRcImRvam8va2V5c1wiLCAvLyBrZXlzLkFMVCBrZXlzLkNBUFNfTE9DSyBrZXlzLkNUUkwga2V5cy5NRVRBIGtleXMuU0hJRlRcblx0XCJkb2pvL19iYXNlL2xhbmdcIiwgLy8gbGFuZy5taXhpblxuXHRcImRvam8vb25cIiwgLy8gb25cblx0XCIuLi9tYWluXCIgICAgLy8gZm9yIGV4cG9ydGluZyBkaWppdC5fc2V0U2VsZWN0aW9uUmFuZ2UsIGRpaml0LnNlbGVjdElucHV0VGV4dFxuXSwgZnVuY3Rpb24oYXJyYXksIGRlY2xhcmUsIGRvbSwgaGFzLCBrZXlzLCBsYW5nLCBvbiwgZGlqaXQpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvZm9ybS9fVGV4dEJveE1peGluXG5cblx0dmFyIF9UZXh0Qm94TWl4aW4gPSBkZWNsYXJlKFwiZGlqaXQuZm9ybS5fVGV4dEJveE1peGluXCIgKyAoaGFzKFwiZG9qby1iaWRpXCIpID8gXCJfTm9CaWRpXCIgOiBcIlwiKSwgbnVsbCwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0QSBtaXhpbiBmb3IgdGV4dGJveCBmb3JtIGlucHV0IHdpZGdldHNcblxuXHRcdC8vIHRyaW06IEJvb2xlYW5cblx0XHQvL1x0XHRSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgaWYgdHJ1ZS4gIERlZmF1bHQgaXMgZmFsc2UuXG5cdFx0dHJpbTogZmFsc2UsXG5cblx0XHQvLyB1cHBlcmNhc2U6IEJvb2xlYW5cblx0XHQvL1x0XHRDb252ZXJ0cyBhbGwgY2hhcmFjdGVycyB0byB1cHBlcmNhc2UgaWYgdHJ1ZS4gIERlZmF1bHQgaXMgZmFsc2UuXG5cdFx0dXBwZXJjYXNlOiBmYWxzZSxcblxuXHRcdC8vIGxvd2VyY2FzZTogQm9vbGVhblxuXHRcdC8vXHRcdENvbnZlcnRzIGFsbCBjaGFyYWN0ZXJzIHRvIGxvd2VyY2FzZSBpZiB0cnVlLiAgRGVmYXVsdCBpcyBmYWxzZS5cblx0XHRsb3dlcmNhc2U6IGZhbHNlLFxuXG5cdFx0Ly8gcHJvcGVyY2FzZTogQm9vbGVhblxuXHRcdC8vXHRcdENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgZWFjaCB3b3JkIHRvIHVwcGVyY2FzZSBpZiB0cnVlLlxuXHRcdHByb3BlcmNhc2U6IGZhbHNlLFxuXG5cdFx0Ly8gbWF4TGVuZ3RoOiBTdHJpbmdcblx0XHQvL1x0XHRIVE1MIElOUFVUIHRhZyBtYXhMZW5ndGggZGVjbGFyYXRpb24uXG5cdFx0bWF4TGVuZ3RoOiBcIlwiLFxuXG5cdFx0Ly8gc2VsZWN0T25DbGljazogW2NvbnN0XSBCb29sZWFuXG5cdFx0Ly9cdFx0SWYgdHJ1ZSwgYWxsIHRleHQgd2lsbCBiZSBzZWxlY3RlZCB3aGVuIGZvY3VzZWQgd2l0aCBtb3VzZVxuXHRcdHNlbGVjdE9uQ2xpY2s6IGZhbHNlLFxuXG5cdFx0Ly8gcGxhY2VIb2xkZXI6IFN0cmluZ1xuXHRcdC8vXHRcdERlZmluZXMgYSBoaW50IHRvIGhlbHAgdXNlcnMgZmlsbCBvdXQgdGhlIGlucHV0IGZpZWxkIChhcyBkZWZpbmVkIGluIEhUTUwgNSkuXG5cdFx0Ly9cdFx0VGhpcyBzaG91bGQgb25seSBjb250YWluIHBsYWluIHRleHQgKG5vIGh0bWwgbWFya3VwKS5cblx0XHRwbGFjZUhvbGRlcjogXCJcIixcblxuXHRcdF9nZXRWYWx1ZUF0dHI6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0SG9vayBzbyBnZXQoJ3ZhbHVlJykgd29ya3MgYXMgd2UgbGlrZS5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0Rm9yIGBkaWppdC9mb3JtL1RleHRCb3hgIHRoaXMgYmFzaWNhbGx5IHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBgPGlucHV0PmAuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Rm9yIGBkaWppdC9mb3JtL01hcHBlZFRleHRCb3hgIHN1YmNsYXNzZXMsIHdoaWNoIGhhdmUgYm90aFxuXHRcdFx0Ly9cdFx0YSBcImRpc3BsYXllZCB2YWx1ZVwiIGFuZCBhIHNlcGFyYXRlIFwic3VibWl0IHZhbHVlXCIsXG5cdFx0XHQvL1x0XHRUaGlzIHRyZWF0cyB0aGUgXCJkaXNwbGF5ZWQgdmFsdWVcIiBhcyB0aGUgbWFzdGVyIHZhbHVlLCBjb21wdXRpbmcgdGhlXG5cdFx0XHQvL1x0XHRzdWJtaXQgdmFsdWUgZnJvbSBpdCB2aWEgdGhpcy5wYXJzZSgpLlxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2UodGhpcy5nZXQoJ2Rpc3BsYXllZFZhbHVlJyksIHRoaXMuY29uc3RyYWludHMpO1xuXHRcdH0sXG5cblx0XHRfc2V0VmFsdWVBdHRyOiBmdW5jdGlvbih2YWx1ZSwgLypCb29sZWFuPyovIHByaW9yaXR5Q2hhbmdlLCAvKlN0cmluZz8qLyBmb3JtYXR0ZWRWYWx1ZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0SG9vayBzbyBzZXQoJ3ZhbHVlJywgLi4uKSB3b3Jrcy5cblx0XHRcdC8vXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFNldHMgdGhlIHZhbHVlIG9mIHRoZSB3aWRnZXQgdG8gXCJ2YWx1ZVwiIHdoaWNoIGNhbiBiZSBvZlxuXHRcdFx0Ly9cdFx0YW55IHR5cGUgYXMgZGV0ZXJtaW5lZCBieSB0aGUgd2lkZ2V0LlxuXHRcdFx0Ly9cblx0XHRcdC8vIHZhbHVlOlxuXHRcdFx0Ly9cdFx0VGhlIHZpc3VhbCBlbGVtZW50IHZhbHVlIGlzIGFsc28gc2V0IHRvIGEgY29ycmVzcG9uZGluZyxcblx0XHRcdC8vXHRcdGJ1dCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUsIHZhbHVlLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGZvcm1hdHRlZFZhbHVlOlxuXHRcdFx0Ly9cdFx0SWYgc3BlY2lmaWVkLCB1c2VkIHRvIHNldCB0aGUgdmlzdWFsIGVsZW1lbnQgdmFsdWUsXG5cdFx0XHQvL1x0XHRvdGhlcndpc2UgYSBjb21wdXRlZCB2aXN1YWwgdmFsdWUgaXMgdXNlZC5cblx0XHRcdC8vXG5cdFx0XHQvLyBwcmlvcml0eUNoYW5nZTpcblx0XHRcdC8vXHRcdElmIHRydWUsIGFuIG9uQ2hhbmdlIGV2ZW50IGlzIGZpcmVkIGltbWVkaWF0ZWx5IGluc3RlYWQgb2Zcblx0XHRcdC8vXHRcdHdhaXRpbmcgZm9yIHRoZSBuZXh0IGJsdXIgZXZlbnQuXG5cblx0XHRcdHZhciBmaWx0ZXJlZFZhbHVlO1xuXHRcdFx0aWYodmFsdWUgIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdC8vIFRPRE86IHRoaXMgaXMgY2FsbGluZyBmaWx0ZXIoKSBvbiBib3RoIHRoZSBkaXNwbGF5IHZhbHVlIGFuZCB0aGUgYWN0dWFsIHZhbHVlLlxuXHRcdFx0XHQvLyBJIGFkZGVkIGEgY29tbWVudCB0byB0aGUgZmlsdGVyKCkgZGVmaW5pdGlvbiBhYm91dCB0aGlzLCBidXQgaXQgc2hvdWxkIGJlIGNoYW5nZWQuXG5cdFx0XHRcdGZpbHRlcmVkVmFsdWUgPSB0aGlzLmZpbHRlcih2YWx1ZSk7XG5cdFx0XHRcdGlmKHR5cGVvZiBmb3JtYXR0ZWRWYWx1ZSAhPSBcInN0cmluZ1wiKXtcblx0XHRcdFx0XHRpZihmaWx0ZXJlZFZhbHVlICE9PSBudWxsICYmICgodHlwZW9mIGZpbHRlcmVkVmFsdWUgIT0gXCJudW1iZXJcIikgfHwgIWlzTmFOKGZpbHRlcmVkVmFsdWUpKSl7XG5cdFx0XHRcdFx0XHRmb3JtYXR0ZWRWYWx1ZSA9IHRoaXMuZmlsdGVyKHRoaXMuZm9ybWF0KGZpbHRlcmVkVmFsdWUsIHRoaXMuY29uc3RyYWludHMpKTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdGZvcm1hdHRlZFZhbHVlID0gJyc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEVuc3VyZSB0aGUgZmlsdGVyZWQgdmFsdWUgZG9lcyBub3QgY2hhbmdlIGFmdGVyIGJlaW5nIGZvcm1hdHRlZC4gU2VlIHRyYWNrICMxNzk1NS5cblx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdC8vIFRoaXMgY2hlY2sgaXMgb25seSBhcHBsaWVkIHdoZW4gdGhlIGZvcm1hdHRlZCB2YWx1ZSBpcyBub3Qgc3BlY2lmaWVkIGJ5IHRoZSBjYWxsZXIgaW4gb3JkZXIgdG8gYWxsb3cgdGhlIFxuXHRcdFx0XHRcdC8vIGJlaGF2aW9yIHRvIGJlIG92ZXJyaWRlbi4gVGhpcyBpcyBuZWVkZWQgd2hlbmV2ZXIgdmFsdWUgc3lub255bXMgY2Fubm90IGJlIGRldGVybWluZWQgdXNpbmcgcGFyc2UvY29tcGFyZS4gRm9yXG5cdFx0XHRcdFx0Ly8gZXhhbXBsZSwgZGlqaXQvZm9ybS9GaWx0ZXJpbmdTZWxlY3QgZGV0ZXJtaW5lcyB0aGUgZm9ybWF0dGVkIHZhbHVlIGFzeW5jaHJvbm91c2x5IGFuZCBhcHBsaWVzIGl0IHVzaW5nIGEgXG5cdFx0XHRcdFx0Ly8gY2FsbGJhY2sgdG8gdGhpcyBtZXRob2QuXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBUT0RPOiBTaG91bGQgZGV2ZWxvcGVycyBiZSB3YXJuZWQgdGhhdCB0aGV5IGJyb2tlIHRoZSByb3VuZCB0cmlwIG9uIGZvcm1hdD9cblx0XHRcdFx0XHRpZiAodGhpcy5jb21wYXJlKGZpbHRlcmVkVmFsdWUsIHRoaXMuZmlsdGVyKHRoaXMucGFyc2UoZm9ybWF0dGVkVmFsdWUsIHRoaXMuY29uc3RyYWludHMpKSkgIT0gMCl7XG5cdFx0XHRcdFx0XHRmb3JtYXR0ZWRWYWx1ZSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihmb3JtYXR0ZWRWYWx1ZSAhPSBudWxsIC8qIGFuZCAhdW5kZWZpbmVkICovICYmICgodHlwZW9mIGZvcm1hdHRlZFZhbHVlKSAhPSBcIm51bWJlclwiIHx8ICFpc05hTihmb3JtYXR0ZWRWYWx1ZSkpICYmIHRoaXMudGV4dGJveC52YWx1ZSAhPSBmb3JtYXR0ZWRWYWx1ZSl7XG5cdFx0XHRcdHRoaXMudGV4dGJveC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuXHRcdFx0XHR0aGlzLl9zZXQoXCJkaXNwbGF5ZWRWYWx1ZVwiLCB0aGlzLmdldChcImRpc3BsYXllZFZhbHVlXCIpKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzLCBbZmlsdGVyZWRWYWx1ZSwgcHJpb3JpdHlDaGFuZ2VdKTtcblx0XHR9LFxuXG5cdFx0Ly8gZGlzcGxheWVkVmFsdWU6IFN0cmluZ1xuXHRcdC8vXHRcdEZvciBzdWJjbGFzc2VzIGxpa2UgQ29tYm9Cb3ggd2hlcmUgdGhlIGRpc3BsYXllZCB2YWx1ZVxuXHRcdC8vXHRcdChleDogS2VudHVja3kpIGFuZCB0aGUgc2VyaWFsaXplZCB2YWx1ZSAoZXg6IEtZKSBhcmUgZGlmZmVyZW50LFxuXHRcdC8vXHRcdHRoaXMgcmVwcmVzZW50cyB0aGUgZGlzcGxheWVkIHZhbHVlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0U2V0dGluZyAnZGlzcGxheWVkVmFsdWUnIHRocm91Z2ggc2V0KCdkaXNwbGF5ZWRWYWx1ZScsIC4uLilcblx0XHQvL1x0XHR1cGRhdGVzICd2YWx1ZScsIGFuZCB2aWNlLXZlcnNhLiAgT3RoZXJ3aXNlICd2YWx1ZScgaXMgdXBkYXRlZFxuXHRcdC8vXHRcdGZyb20gJ2Rpc3BsYXllZFZhbHVlJyBwZXJpb2RpY2FsbHksIGxpa2Ugb25CbHVyIGV0Yy5cblx0XHQvL1xuXHRcdC8vXHRcdFRPRE86IG1vdmUgZGVjbGFyYXRpb24gdG8gTWFwcGVkVGV4dEJveD9cblx0XHQvL1x0XHRQcm9ibGVtIGlzIHRoYXQgQ29tYm9Cb3ggcmVmZXJlbmNlcyBkaXNwbGF5ZWRWYWx1ZSxcblx0XHQvL1x0XHRmb3IgYmVuZWZpdCBvZiBGaWx0ZXJpbmdTZWxlY3QuXG5cdFx0ZGlzcGxheWVkVmFsdWU6IFwiXCIsXG5cblx0XHRfZ2V0RGlzcGxheWVkVmFsdWVBdHRyOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEhvb2sgc28gZ2V0KCdkaXNwbGF5ZWRWYWx1ZScpIHdvcmtzLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRoZSBkaXNwbGF5ZWQgdmFsdWUgKHdoYXQgdGhlIHVzZXIgc2VlcyBvbiB0aGUgc2NyZWVuKSxcblx0XHRcdC8vXHRcdGFmdGVyIGZpbHRlcmluZyAoaWUsIHRyaW1taW5nIHNwYWNlcyBldGMuKS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRGb3Igc29tZSBzdWJjbGFzc2VzIG9mIFRleHRCb3ggKGxpa2UgQ29tYm9Cb3gpLCB0aGUgZGlzcGxheWVkIHZhbHVlXG5cdFx0XHQvL1x0XHRpcyBkaWZmZXJlbnQgZnJvbSB0aGUgc2VyaWFsaXplZCB2YWx1ZSB0aGF0J3MgYWN0dWFsbHlcblx0XHRcdC8vXHRcdHNlbnQgdG8gdGhlIHNlcnZlciAoc2VlIGBkaWppdC9mb3JtL1ZhbGlkYXRpb25UZXh0Qm94LnNlcmlhbGl6ZSgpYClcblxuXHRcdFx0Ly8gVE9ETzogbWF5YmUgd2Ugc2hvdWxkIHVwZGF0ZSB0aGlzLmRpc3BsYXllZFZhbHVlIG9uIGV2ZXJ5IGtleXN0cm9rZSBzbyB0aGF0IHdlIGRvbid0IG5lZWRcblx0XHRcdC8vIHRoaXMgbWV0aG9kXG5cdFx0XHQvLyBUT0RPOiB0aGlzIGlzbid0IHJlYWxseSB0aGUgZGlzcGxheWVkIHZhbHVlIHdoZW4gdGhlIHVzZXIgaXMgdHlwaW5nXG5cdFx0XHRyZXR1cm4gdGhpcy5maWx0ZXIodGhpcy50ZXh0Ym94LnZhbHVlKTtcblx0XHR9LFxuXG5cdFx0X3NldERpc3BsYXllZFZhbHVlQXR0cjogZnVuY3Rpb24oLypTdHJpbmcqLyB2YWx1ZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0SG9vayBzbyBzZXQoJ2Rpc3BsYXllZFZhbHVlJywgLi4uKSB3b3Jrcy5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0U2V0cyB0aGUgdmFsdWUgb2YgdGhlIHZpc3VhbCBlbGVtZW50IHRvIHRoZSBzdHJpbmcgXCJ2YWx1ZVwiLlxuXHRcdFx0Ly9cdFx0VGhlIHdpZGdldCB2YWx1ZSBpcyBhbHNvIHNldCB0byBhIGNvcnJlc3BvbmRpbmcsXG5cdFx0XHQvL1x0XHRidXQgbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lLCB2YWx1ZS5cblxuXHRcdFx0aWYodmFsdWUgPT0gbnVsbCAvKiBvciB1bmRlZmluZWQgKi8pe1xuXHRcdFx0XHR2YWx1ZSA9ICcnXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKXtcblx0XHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUpXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudGV4dGJveC52YWx1ZSA9IHZhbHVlO1xuXG5cdFx0XHQvLyBzZXRzIHRoZSBzZXJpYWxpemVkIHZhbHVlIHRvIHNvbWV0aGluZyBjb3JyZXNwb25kaW5nIHRvIHNwZWNpZmllZCBkaXNwbGF5ZWRWYWx1ZVxuXHRcdFx0Ly8gKGlmIHBvc3NpYmxlKSwgYW5kIGFsc28gdXBkYXRlcyB0aGUgdGV4dGJveC52YWx1ZSwgZm9yIGV4YW1wbGUgY29udmVydGluZyBcIjEyM1wiXG5cdFx0XHQvLyB0byBcIjEyMy4wMFwiXG5cdFx0XHR0aGlzLl9zZXRWYWx1ZUF0dHIodGhpcy5nZXQoJ3ZhbHVlJyksIHVuZGVmaW5lZCk7XG5cblx0XHRcdHRoaXMuX3NldChcImRpc3BsYXllZFZhbHVlXCIsIHRoaXMuZ2V0KCdkaXNwbGF5ZWRWYWx1ZScpKTtcblx0XHR9LFxuXG5cdFx0Zm9ybWF0OiBmdW5jdGlvbih2YWx1ZSAvKj09PT09LCBjb25zdHJhaW50cyA9PT09PSovKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXBsYWNlYWJsZSBmdW5jdGlvbiB0byBjb252ZXJ0IGEgdmFsdWUgdG8gYSBwcm9wZXJseSBmb3JtYXR0ZWQgc3RyaW5nLlxuXHRcdFx0Ly8gdmFsdWU6IFN0cmluZ1xuXHRcdFx0Ly8gY29uc3RyYWludHM6IE9iamVjdFxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZCBleHRlbnNpb25cblx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsIC8qIG9yIHVuZGVmaW5lZCAqLyA/IFwiXCIgOiAodmFsdWUudG9TdHJpbmcgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWUpO1xuXHRcdH0sXG5cblx0XHRwYXJzZTogZnVuY3Rpb24odmFsdWUgLyo9PT09PSwgY29uc3RyYWludHMgPT09PT0qLyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVwbGFjZWFibGUgZnVuY3Rpb24gdG8gY29udmVydCBhIGZvcm1hdHRlZCBzdHJpbmcgdG8gYSB2YWx1ZVxuXHRcdFx0Ly8gdmFsdWU6IFN0cmluZ1xuXHRcdFx0Ly8gY29uc3RyYWludHM6IE9iamVjdFxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZCBleHRlbnNpb25cblxuXHRcdFx0cmV0dXJuIHZhbHVlO1x0Ly8gU3RyaW5nXG5cdFx0fSxcblxuXHRcdF9yZWZyZXNoU3RhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0QWZ0ZXIgdGhlIHVzZXIgdHlwZXMgc29tZSBjaGFyYWN0ZXJzLCBldGMuLCB0aGlzIG1ldGhvZCBpc1xuXHRcdFx0Ly9cdFx0Y2FsbGVkIHRvIGNoZWNrIHRoZSBmaWVsZCBmb3IgdmFsaWRpdHkgZXRjLiAgVGhlIGJhc2UgbWV0aG9kXG5cdFx0XHQvL1x0XHRpbiBgZGlqaXQvZm9ybS9UZXh0Qm94YCBkb2VzIG5vdGhpbmcsIGJ1dCBzdWJjbGFzc2VzIG92ZXJyaWRlLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXHRcdH0sXG5cblx0XHQgb25JbnB1dDogZnVuY3Rpb24oLypFdmVudCovIC8qPT09PT0gZXZ0ID09PT09Ki8pe1xuXHRcdFx0IC8vIHN1bW1hcnk6XG5cdFx0XHQgLy9cdFx0Q29ubmVjdCB0byB0aGlzIGZ1bmN0aW9uIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB2YXJpb3VzIHVzZXIgZGF0YS1pbnB1dCBldmVudHMuXG5cdFx0XHQgLy9cdFx0UmV0dXJuIGZhbHNlIHRvIGNhbmNlbCB0aGUgZXZlbnQgYW5kIHByZXZlbnQgaXQgZnJvbSBiZWluZyBwcm9jZXNzZWQuXG5cdFx0XHQgLy9cdFx0Tm90ZSB0aGF0IGFsdGhvdWdoIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGBvbklucHV0KClgLCBpdCBkb2Vzbid0XG5cdFx0XHQgLy9cdFx0Y29ycmVzcG9uZCB0byB0aGUgc3RhbmRhcmQgRE9NIFwiaW5wdXRcIiBldmVudCwgYmVjYXVzZSBpdCBvY2N1cnMgYmVmb3JlIHRoZSBpbnB1dCBoYXMgYmVlbiBwcm9jZXNzZWQuXG5cdFx0XHQgLy8gZXZlbnQ6XG5cdFx0XHQgLy9cdFx0a2V5ZG93biB8IGtleXByZXNzIHwgY3V0IHwgcGFzdGUgfCBjb21wb3NpdGlvbmVuZFxuXHRcdFx0IC8vIHRhZ3M6XG5cdFx0XHQgLy9cdFx0Y2FsbGJhY2tcblx0XHQgfSxcblxuXHRcdF9vbklucHV0OiBmdW5jdGlvbigvKkV2ZW50Ki8gZXZ0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYWxsZWQgQUZURVIgdGhlIGlucHV0IGV2ZW50IGhhcyBoYXBwZW5lZCBhbmQgdGhpcy50ZXh0Ym94LnZhbHVlIGhhcyBuZXcgdmFsdWUuXG5cblx0XHRcdHRoaXMuX2xhc3RJbnB1dEV2ZW50VmFsdWUgPSB0aGlzLnRleHRib3gudmFsdWU7XG5cblx0XHRcdC8vIEZvciBDb21ib2JveCwgdGhpcyBuZWVkcyB0byBiZSBjYWxsZWQgdy90aGUga2V5ZG93bi9rZXlwcmVzcyBldmVudCB0aGF0IHdhcyBwYXNzZWQgdG8gb25JbnB1dCgpLlxuXHRcdFx0Ly8gQXMgYSBiYWNrdXAsIHVzZSB0aGUgXCJpbnB1dFwiIGV2ZW50IGl0c2VsZi5cblx0XHRcdHRoaXMuX3Byb2Nlc3NJbnB1dCh0aGlzLl9sYXN0SW5wdXRQcm9kdWNpbmdFdmVudCB8fCBldnQpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xhc3RJbnB1dFByb2R1Y2luZ0V2ZW50O1xuXG5cdFx0XHRpZih0aGlzLmludGVybWVkaWF0ZUNoYW5nZXMpe1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVPbkNoYW5nZSh0aGlzLmdldCgndmFsdWUnKSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfcHJvY2Vzc0lucHV0OiBmdW5jdGlvbigvKkV2ZW50Ki8gLyo9PT09PSBldnQgPT09PT0qLyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RGVmYXVsdCBhY3Rpb24gaGFuZGxlciBmb3IgdXNlciBpbnB1dCBldmVudHMuXG5cdFx0XHQvL1x0XHRDYWxsZWQgYWZ0ZXIgdGhlIFwiaW5wdXRcIiBldmVudCAoaS5lLiBhZnRlciB0aGlzLnRleHRib3gudmFsdWUgaGFzIGJlZW4gdXBkYXRlZCksXG5cdFx0XHQvL1x0XHRidXQgYGV2dGAgaXMgdGhlIGtleWRvd24va2V5cHJlc3MvZXRjLiBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgXCJpbnB1dFwiIGV2ZW50LlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXG5cdFx0XHR0aGlzLl9yZWZyZXNoU3RhdGUoKTtcblxuXHRcdFx0Ly8gSW4gY2FzZSBzb21lb25lIGlzIHdhdGNoKCknaW5nIGZvciBjaGFuZ2VzIHRvIGRpc3BsYXllZFZhbHVlXG5cdFx0XHR0aGlzLl9zZXQoXCJkaXNwbGF5ZWRWYWx1ZVwiLCB0aGlzLmdldChcImRpc3BsYXllZFZhbHVlXCIpKTtcblx0XHR9LFxuXG5cdFx0cG9zdENyZWF0ZTogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHNldHRpbmcgdGhlIHZhbHVlIGhlcmUgaXMgbmVlZGVkIHNpbmNlIHZhbHVlPVwiXCIgaW4gdGhlIHRlbXBsYXRlIGNhdXNlcyBcInVuZGVmaW5lZFwiXG5cdFx0XHQvLyBhbmQgc2V0dGluZyBpbiB0aGUgRE9NIChpbnN0ZWFkIG9mIHRoZSBKUyBvYmplY3QpIGhlbHBzIHdpdGggZm9ybSByZXNldCBhY3Rpb25zXG5cdFx0XHR0aGlzLnRleHRib3guc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgdGhpcy50ZXh0Ym94LnZhbHVlKTsgLy8gRE9NIGFuZCBKUyB2YWx1ZXMgc2hvdWxkIGJlIHRoZSBzYW1lXG5cblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cblx0XHRcdC8vIG5vcm1hbGl6ZSBpbnB1dCBldmVudHMgdG8gcmVkdWNlIHNwdXJpb3VzIGV2ZW50IHByb2Nlc3Npbmdcblx0XHRcdC8vXHRrZXlkb3duOiBkbyBub3QgZm9yd2FyZCBtb2RpZmllciBrZXlzXG5cdFx0XHQvL1x0XHQgICAgICAgc2V0IGNoYXJPckNvZGUgdG8gbnVtZXJpYyBrZXljb2RlXG5cdFx0XHQvL1x0a2V5cHJlc3M6IGRvIG5vdCBmb3J3YXJkIG51bWVyaWMgY2hhck9yQ29kZSBrZXlzIChhbHJlYWR5IHNlbnQgdGhyb3VnaCBvbmtleWRvd24pXG5cdFx0XHQvL1x0cGFzdGUsIGN1dCwgY29tcG9zaXRpb25lbmQ6IHNldCBjaGFyT3JDb2RlIHRvIDIyOSAoSU1FKVxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlRXZlbnQoZSl7XG5cdFx0XHRcdHZhciBjaGFyT3JDb2RlO1xuXG5cdFx0XHRcdC8vIEZpbHRlciBvdXQga2V5ZG93biBldmVudHMgdGhhdCB3aWxsIGJlIGZvbGxvd2VkIGJ5IGtleXByZXNzIGV2ZW50cy4gIE5vdGUgdGhhdCBjaHJvbWUvYW5kcm9pZFxuXHRcdFx0XHQvLyB3L3dvcmQgc3VnZ2VzdGlvbiBoYXMga2V5ZG93bi8yMjkgZXZlbnRzIG9uIHR5cGluZyB3aXRoIG5vIGNvcnJlc3BvbmRpbmcga2V5cHJlc3MgZXZlbnRzLlxuXHRcdFx0XHRpZihlLnR5cGUgPT0gXCJrZXlkb3duXCIgJiYgZS5rZXlDb2RlICE9IDIyOSl7XG5cdFx0XHRcdFx0Y2hhck9yQ29kZSA9IGUua2V5Q29kZTtcblx0XHRcdFx0XHRzd2l0Y2goY2hhck9yQ29kZSl7IC8vIGlnbm9yZSBzdGF0ZSBrZXlzXG5cdFx0XHRcdFx0XHRjYXNlIGtleXMuU0hJRlQ6XG5cdFx0XHRcdFx0XHRjYXNlIGtleXMuQUxUOlxuXHRcdFx0XHRcdFx0Y2FzZSBrZXlzLkNUUkw6XG5cdFx0XHRcdFx0XHRjYXNlIGtleXMuTUVUQTpcblx0XHRcdFx0XHRcdGNhc2Uga2V5cy5DQVBTX0xPQ0s6XG5cdFx0XHRcdFx0XHRjYXNlIGtleXMuTlVNX0xPQ0s6XG5cdFx0XHRcdFx0XHRjYXNlIGtleXMuU0NST0xMX0xPQ0s6XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoIWUuY3RybEtleSAmJiAhZS5tZXRhS2V5ICYmICFlLmFsdEtleSl7IC8vIG5vIG1vZGlmaWVyc1xuXHRcdFx0XHRcdFx0c3dpdGNoKGNoYXJPckNvZGUpeyAvLyBpZ25vcmUgbG9jYXRpb24ga2V5c1xuXHRcdFx0XHRcdFx0XHRjYXNlIGtleXMuTlVNUEFEXzA6XG5cdFx0XHRcdFx0XHRcdGNhc2Uga2V5cy5OVU1QQURfMTpcblx0XHRcdFx0XHRcdFx0Y2FzZSBrZXlzLk5VTVBBRF8yOlxuXHRcdFx0XHRcdFx0XHRjYXNlIGtleXMuTlVNUEFEXzM6XG5cdFx0XHRcdFx0XHRcdGNhc2Uga2V5cy5OVU1QQURfNDpcblx0XHRcdFx0XHRcdFx0Y2FzZSBrZXlzLk5VTVBBRF81OlxuXHRcdFx0XHRcdFx0XHRjYXNlIGtleXMuTlVNUEFEXzY6XG5cdFx0XHRcdFx0XHRcdGNhc2Uga2V5cy5OVU1QQURfNzpcblx0XHRcdFx0XHRcdFx0Y2FzZSBrZXlzLk5VTVBBRF84OlxuXHRcdFx0XHRcdFx0XHRjYXNlIGtleXMuTlVNUEFEXzk6XG5cdFx0XHRcdFx0XHRcdGNhc2Uga2V5cy5OVU1QQURfTVVMVElQTFk6XG5cdFx0XHRcdFx0XHRcdGNhc2Uga2V5cy5OVU1QQURfUExVUzpcblx0XHRcdFx0XHRcdFx0Y2FzZSBrZXlzLk5VTVBBRF9FTlRFUjpcblx0XHRcdFx0XHRcdFx0Y2FzZSBrZXlzLk5VTVBBRF9NSU5VUzpcblx0XHRcdFx0XHRcdFx0Y2FzZSBrZXlzLk5VTVBBRF9QRVJJT0Q6XG5cdFx0XHRcdFx0XHRcdGNhc2Uga2V5cy5OVU1QQURfRElWSURFOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKChjaGFyT3JDb2RlID49IDY1ICYmIGNoYXJPckNvZGUgPD0gOTApIHx8IChjaGFyT3JDb2RlID49IDQ4ICYmIGNoYXJPckNvZGUgPD0gNTcpIHx8IGNoYXJPckNvZGUgPT0ga2V5cy5TUEFDRSl7XG5cdFx0XHRcdFx0XHRcdHJldHVybjsgLy8ga2V5cHJlc3Mgd2lsbCBoYW5kbGUgc2ltcGxlIG5vbi1tb2RpZmllZCBwcmludGFibGUga2V5c1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIG5hbWVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRmb3IodmFyIGkgaW4ga2V5cyl7XG5cdFx0XHRcdFx0XHRcdGlmKGtleXNbaV0gPT09IGUua2V5Q29kZSl7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZighbmFtZWQpe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9IC8vIG9ubHkgYWxsb3cgbmFtZWQgb25lcyB0aHJvdWdoXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2hhck9yQ29kZSA9IGUuY2hhckNvZGUgPj0gMzIgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGUuY2hhckNvZGUpIDogZS5jaGFyQ29kZTtcblx0XHRcdFx0aWYoIWNoYXJPckNvZGUpe1xuXHRcdFx0XHRcdGNoYXJPckNvZGUgPSAoZS5rZXlDb2RlID49IDY1ICYmIGUua2V5Q29kZSA8PSA5MCkgfHwgKGUua2V5Q29kZSA+PSA0OCAmJiBlLmtleUNvZGUgPD0gNTcpIHx8IGUua2V5Q29kZSA9PSBrZXlzLlNQQUNFID8gU3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUpIDogZS5rZXlDb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFjaGFyT3JDb2RlKXtcblx0XHRcdFx0XHRjaGFyT3JDb2RlID0gMjI5OyAvLyBJTUVcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihlLnR5cGUgPT0gXCJrZXlwcmVzc1wiKXtcblx0XHRcdFx0XHRpZih0eXBlb2YgY2hhck9yQ29kZSAhPSBcInN0cmluZ1wiKXtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoKGNoYXJPckNvZGUgPj0gJ2EnICYmIGNoYXJPckNvZGUgPD0gJ3onKSB8fCAoY2hhck9yQ29kZSA+PSAnQScgJiYgY2hhck9yQ29kZSA8PSAnWicpIHx8IChjaGFyT3JDb2RlID49ICcwJyAmJiBjaGFyT3JDb2RlIDw9ICc5JykgfHwgKGNoYXJPckNvZGUgPT09ICcgJykpe1xuXHRcdFx0XHRcdFx0aWYoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLmFsdEtleSl7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH0gLy8gY2FuIG9ubHkgYmUgc3RvcHBlZCByZWxpYWJseSBpbiBrZXlkb3duXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGZha2UgZXZlbnQgdG8gc2V0IGNoYXJPckNvZGUgYW5kIHRvIGtub3cgaWYgcHJldmVudERlZmF1bHQoKSB3YXMgY2FsbGVkXG5cdFx0XHRcdHZhciBmYXV4ID0geyBmYXV4OiB0cnVlIH0sIGF0dHI7XG5cdFx0XHRcdGZvcihhdHRyIGluIGUpe1xuXHRcdFx0XHRcdGlmKCEvXihsYXllcltYWV18cmV0dXJuVmFsdWV8a2V5TG9jYXRpb24pJC8udGVzdChhdHRyKSl7IC8vIHByZXZlbnQgV2ViS2l0IHdhcm5pbmdzXG5cdFx0XHRcdFx0XHR2YXIgdiA9IGVbYXR0cl07XG5cdFx0XHRcdFx0XHRpZih0eXBlb2YgdiAhPSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYgIT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0XHRcdFx0XHRcdGZhdXhbYXR0cl0gPSB2O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsYW5nLm1peGluKGZhdXgsIHtcblx0XHRcdFx0XHRjaGFyT3JDb2RlOiBjaGFyT3JDb2RlLFxuXHRcdFx0XHRcdF93YXNDb25zdW1lZDogZmFsc2UsXG5cdFx0XHRcdFx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRmYXV4Ll93YXNDb25zdW1lZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dGhpcy5fbGFzdElucHV0UHJvZHVjaW5nRXZlbnQgPSBmYXV4O1xuXG5cdFx0XHRcdC8vIEdpdmUgd2ViIHBhZ2UgYXV0aG9yIGEgY2hhbmNlIHRvIGNvbnN1bWUgdGhlIGV2ZW50LiAgTm90ZSB0aGF0IG9uSW5wdXQoKSBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG5cdFx0XHRcdC8vIGZvciBzYW1lIGtleXN0cm9rZTogb25jZSBmb3Iga2V5cHJlc3MgZXZlbnQgYW5kIG9uY2UgZm9yIGlucHV0IGV2ZW50LlxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKGZhdXgudHlwZSArICcsIGNoYXJPckNvZGUgPSAoJyArICh0eXBlb2YgY2hhck9yQ29kZSkgKyAnKSAnICsgY2hhck9yQ29kZSArICcsIGN0cmwgJyArICEhZmF1eC5jdHJsS2V5ICsgJywgYWx0ICcgKyAhIWZhdXguYWx0S2V5ICsgJywgbWV0YSAnICsgISFmYXV4Lm1ldGFLZXkgKyAnLCBzaGlmdCAnICsgISFmYXV4LnNoaWZ0S2V5KTtcblx0XHRcdFx0aWYodGhpcy5vbklucHV0KGZhdXgpID09PSBmYWxzZSl7IC8vIHJldHVybiBmYWxzZSBtZWFucyBzdG9wXG5cdFx0XHRcdFx0ZmF1eC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdGZhdXguc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZmF1eC5fd2FzQ29uc3VtZWQpe1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSAvLyBpZiBwcmV2ZW50RGVmYXVsdCB3YXMgY2FsbGVkXG5cblx0XHRcdFx0Ly8gSUU4IGRvZXNuJ3QgZW1pdCB0aGUgXCJpbnB1dFwiIGV2ZW50IGF0IGFsbCwgYW5kIElFOSBkb2Vzbid0IGVtaXQgaXQgZm9yIGJhY2tzcGFjZSwgZGVsZXRlLCBjdXQsIGV0Yy5cblx0XHRcdFx0Ly8gU2luY2UgdGhlIGNvZGUgYmVsb3cgKGFuZCBwZXJoYXBzIHVzZXIgY29kZSkgZGVwZW5kcyBvbiB0aGF0IGV2ZW50LCBlbWl0IGl0IHN5bnRoZXRpY2FsbHkuXG5cdFx0XHRcdC8vIFNlZSBodHRwOi8vYmVuYWxwZXJ0LmNvbS8yMDEzLzA2LzE4L2EtbmVhci1wZXJmZWN0LW9uaW5wdXQtc2hpbS1mb3ItaWUtOC1hbmQtOS5odG1sLlxuXHRcdFx0XHRpZihoYXMoXCJpZVwiKSA8PSA5KXtcblx0XHRcdFx0XHRzd2l0Y2goZS5rZXlDb2RlKXtcblx0XHRcdFx0XHRjYXNlIGtleXMuVEFCOlxuXHRcdFx0XHRcdGNhc2Uga2V5cy5FU0NBUEU6XG5cdFx0XHRcdFx0Y2FzZSBrZXlzLkRPV05fQVJST1c6XG5cdFx0XHRcdFx0Y2FzZSBrZXlzLlVQX0FSUk9XOlxuXHRcdFx0XHRcdGNhc2Uga2V5cy5MRUZUX0FSUk9XOlxuXHRcdFx0XHRcdGNhc2Uga2V5cy5SSUdIVF9BUlJPVzpcblx0XHRcdFx0XHRcdC8vIFRoZXNlIGtleXMgbWF5IGFsdGVyIHRoZSA8aW5wdXQ+J3MgdmFsdWUgaW5kaXJlY3RseSwgYnV0IHdlIGRvbid0IHdhbnQgdG8gZW1pdCBhbiBcImlucHV0XCJcblx0XHRcdFx0XHRcdC8vIGV2ZW50LiAgRm9yIGV4YW1wbGUsIHRoZSB1cC9kb3duIGFycm93cyBpbiBUaW1lVGV4dEJveCBvciBDb21ib0JveCB3aWxsIGNhdXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0XHQvLyBkcm9wZG93biBpdGVtJ3MgdmFsdWUgdG8gYmUgY29waWVkIHRvIHRoZSA8aW5wdXQ+LlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGlmKGUua2V5Q29kZSA9PSBrZXlzLkVOVEVSICYmIHRoaXMudGV4dGJveC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT0gXCJ0ZXh0YXJlYVwiKXtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmRlZmVyKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMudGV4dGJveC52YWx1ZSAhPT0gdGhpcy5fbGFzdElucHV0RXZlbnRWYWx1ZSl7XG5cdFx0XHRcdFx0XHRcdFx0b24uZW1pdCh0aGlzLnRleHRib3gsIFwiaW5wdXRcIiwge2J1YmJsZXM6IHRydWV9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm93bihcblx0XHRcdFx0b24odGhpcy50ZXh0Ym94LCBcImtleWRvd24sIGtleXByZXNzLCBwYXN0ZSwgY3V0LCBjb21wb3NpdGlvbmVuZFwiLCBsYW5nLmhpdGNoKHRoaXMsIGhhbmRsZUV2ZW50KSksXG5cdFx0XHRcdG9uKHRoaXMudGV4dGJveCwgXCJpbnB1dFwiLCBsYW5nLmhpdGNoKHRoaXMsIFwiX29uSW5wdXRcIikpLFxuXG5cdFx0XHRcdC8vIEFsbG93IGtleXByZXNzIHRvIGJ1YmJsZSB0byB0aGlzLmRvbU5vZGUsIHNvIHRoYXQgVGV4dEJveC5vbihcImtleXByZXNzXCIsIC4uLikgd29ya3MsXG5cdFx0XHRcdC8vIGJ1dCBwcmV2ZW50IGl0IGZyb20gZnVydGhlciBwcm9wYWdhdGluZywgc28gdGhhdCB0eXBpbmcgaW50byBhIFRleHRCb3ggaW5zaWRlIGEgVG9vbGJhciBkb2Vzbid0XG5cdFx0XHRcdC8vIHRyaWdnZXIgdGhlIFRvb2xiYXIncyBsZXR0ZXIga2V5IG5hdmlnYXRpb24uXG5cdFx0XHRcdG9uKHRoaXMuZG9tTm9kZSwgXCJrZXlwcmVzc1wiLCBmdW5jdGlvbihlKXsgZS5zdG9wUHJvcGFnYXRpb24oKTsgfSlcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdF9ibGFua1ZhbHVlOiAnJywgLy8gaWYgdGhlIHRleHRib3ggaXMgYmxhbmssIHdoYXQgdmFsdWUgc2hvdWxkIGJlIHJlcG9ydGVkXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbih2YWwpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEF1dG8tY29ycmVjdGlvbnMgKHN1Y2ggYXMgdHJpbW1pbmcpIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGV4dGJveFxuXHRcdFx0Ly9cdFx0dmFsdWUgb24gYmx1ciBvciBmb3JtIHN1Ym1pdC5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0Rm9yIE1hcHBlZFRleHRCb3ggc3ViY2xhc3NlcywgdGhpcyBpcyBjYWxsZWQgdHdpY2Vcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHQtIG9uY2Ugd2l0aCB0aGUgZGlzcGxheSB2YWx1ZVxuXHRcdFx0Ly9cdFx0LSBvbmNlIHRoZSB2YWx1ZSBhcyBzZXQvcmV0dXJuZWQgYnkgc2V0KCd2YWx1ZScsIC4uLilcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRhbmQgZ2V0KCd2YWx1ZScpLCBleDogYSBOdW1iZXIgZm9yIE51bWJlclRleHRCb3guXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0SW4gdGhlIGxhdHRlciBjYXNlIGl0IGRvZXMgY29ycmVjdGlvbnMgbGlrZSBjb252ZXJ0aW5nIG51bGwgdG8gTmFOLiAgSW5cblx0XHRcdC8vXHRcdHRoZSBmb3JtZXIgY2FzZSB0aGUgTnVtYmVyVGV4dEJveC5maWx0ZXIoKSBtZXRob2QgY2FsbHMgdGhpcy5pbmhlcml0ZWQoKVxuXHRcdFx0Ly9cdFx0dG8gZXhlY3V0ZSBzdGFuZGFyZCB0cmltbWluZyBjb2RlIGluIFRleHRCb3guZmlsdGVyKCkuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VE9ETzogYnJlYWsgdGhpcyBpbnRvIHR3byBtZXRob2RzIGluIDIuMFxuXHRcdFx0Ly9cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWQgZXh0ZW5zaW9uXG5cdFx0XHRpZih2YWwgPT09IG51bGwpe1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fYmxhbmtWYWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmKHR5cGVvZiB2YWwgIT0gXCJzdHJpbmdcIil7XG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLnRyaW0pe1xuXHRcdFx0XHR2YWwgPSBsYW5nLnRyaW0odmFsKTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMudXBwZXJjYXNlKXtcblx0XHRcdFx0dmFsID0gdmFsLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLmxvd2VyY2FzZSl7XG5cdFx0XHRcdHZhbCA9IHZhbC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5wcm9wZXJjYXNlKXtcblx0XHRcdFx0dmFsID0gdmFsLnJlcGxhY2UoL1teXFxzXSsvZywgZnVuY3Rpb24od29yZCl7XG5cdFx0XHRcdFx0cmV0dXJuIHdvcmQuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnN1YnN0cmluZygxKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH0sXG5cblx0XHRfc2V0Qmx1clZhbHVlOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gRm9ybWF0IHRoZSBkaXNwbGF5ZWQgdmFsdWUsIGZvciBleGFtcGxlIChmb3IgTnVtYmVyVGV4dEJveCkgY29udmVydCAxLjQgdG8gMS40MDAsXG5cdFx0XHQvLyBvciAoZm9yIEN1cnJlbmN5VGV4dEJveCkgMi41MCB0byAkMi41MFxuXG5cdFx0XHR0aGlzLl9zZXRWYWx1ZUF0dHIodGhpcy5nZXQoJ3ZhbHVlJyksIHRydWUpO1xuXHRcdH0sXG5cblx0XHRfb25CbHVyOiBmdW5jdGlvbihlKXtcblx0XHRcdGlmKHRoaXMuZGlzYWJsZWQpe1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zZXRCbHVyVmFsdWUoKTtcblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdF9pc1RleHRTZWxlY3RlZDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLnRleHRib3guc2VsZWN0aW9uU3RhcnQgIT0gdGhpcy50ZXh0Ym94LnNlbGVjdGlvbkVuZDtcblx0XHR9LFxuXG5cdFx0X29uRm9jdXM6IGZ1bmN0aW9uKC8qU3RyaW5nKi8gYnkpe1xuXHRcdFx0aWYodGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRPbmx5KXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWxlY3QgYWxsIHRleHQgb24gZm9jdXMgdmlhIGNsaWNrIGlmIG5vdGhpbmcgYWxyZWFkeSBzZWxlY3RlZC5cblx0XHRcdC8vIFNpbmNlIG1vdXNlLXVwIHdpbGwgY2xlYXIgdGhlIHNlbGVjdGlvbiwgbmVlZCB0byBkZWZlciBzZWxlY3Rpb24gdW50aWwgYWZ0ZXIgbW91c2UtdXAuXG5cdFx0XHQvLyBEb24ndCBkbyBhbnl0aGluZyBvbiBmb2N1cyBieSB0YWJiaW5nIGludG8gdGhlIHdpZGdldCBzaW5jZSB0aGVyZSdzIG5vIGFzc29jaWF0ZWQgbW91c2UtdXAgZXZlbnQuXG5cdFx0XHRpZih0aGlzLnNlbGVjdE9uQ2xpY2sgJiYgYnkgPT0gXCJtb3VzZVwiKXtcblx0XHRcdFx0Ly8gVXNlIG9uLm9uY2UoKSB0byBvbmx5IHNlbGVjdCBhbGwgdGV4dCBvbiBmaXJzdCBjbGljayBvbmx5OyBvdGhlcndpc2UgdXNlcnMgd291bGQgaGF2ZSBubyB3YXkgdG8gY2xlYXJcblx0XHRcdFx0Ly8gdGhlIHNlbGVjdGlvbi5cblx0XHRcdFx0dGhpcy5fc2VsZWN0T25DbGlja0hhbmRsZSA9IG9uLm9uY2UodGhpcy5kb21Ob2RlLCBcIm1vdXNldXAsIHRvdWNoZW5kXCIsIGxhbmcuaGl0Y2godGhpcywgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0XHQvLyBDaGVjayBpZiB0aGUgdXNlciBzZWxlY3RlZCBzb21lIHRleHQgbWFudWFsbHkgKG1vdXNlLWRvd24sIG1vdXNlLW1vdmUsIG1vdXNlLXVwKVxuXHRcdFx0XHRcdC8vIGFuZCBpZiBub3QsIHRoZW4gc2VsZWN0IGFsbCB0aGUgdGV4dFxuXHRcdFx0XHRcdGlmKCF0aGlzLl9pc1RleHRTZWxlY3RlZCgpKXtcblx0XHRcdFx0XHRcdF9UZXh0Qm94TWl4aW4uc2VsZWN0SW5wdXRUZXh0KHRoaXMudGV4dGJveCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSk7XG5cdFx0XHRcdHRoaXMub3duKHRoaXMuX3NlbGVjdE9uQ2xpY2tIYW5kbGUpO1xuXG5cdFx0XHRcdC8vIGluIGNhc2UgdGhlIG1vdXNldXAgbmV2ZXIgY29tZXNcblx0XHRcdFx0dGhpcy5kZWZlcihmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmKHRoaXMuX3NlbGVjdE9uQ2xpY2tIYW5kbGUpe1xuXHRcdFx0XHRcdFx0dGhpcy5fc2VsZWN0T25DbGlja0hhbmRsZS5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdHRoaXMuX3NlbGVjdE9uQ2xpY2tIYW5kbGUgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgNTAwKTsgLy8gaWYgbW91c2V1cCBub3QgcmVjZWl2ZWQgc29vbiwgdGhlbiB0cmVhdCBpdCBhcyBzb21lIGdlc3R1cmVcblx0XHRcdH1cblx0XHRcdC8vIGNhbGwgdGhpcy5pbmhlcml0ZWQoKSBiZWZvcmUgcmVmcmVzaFN0YXRlKCksIHNpbmNlIHRoaXMuaW5oZXJpdGVkKCkgd2lsbCBwb3NzaWJseSBzY3JvbGwgdGhlIHZpZXdwb3J0XG5cdFx0XHQvLyAodG8gc2Nyb2xsIHRoZSBUZXh0Qm94IGludG8gdmlldyksIHdoaWNoIHdpbGwgYWZmZWN0IGhvdyBfcmVmcmVzaFN0YXRlKCkgcG9zaXRpb25zIHRoZSB0b29sdGlwXG5cdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMpO1xuXG5cdFx0XHR0aGlzLl9yZWZyZXNoU3RhdGUoKTtcblx0XHR9LFxuXG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBPdmVycmlkZXMgYGRpaml0L19Gb3JtV2lkZ2V0L3Jlc2V0KClgLlxuXHRcdFx0Ly8gQWRkaXRpb25hbGx5IHJlc2V0cyB0aGUgZGlzcGxheWVkIHRleHRib3ggdmFsdWUgdG8gJydcblx0XHRcdHRoaXMudGV4dGJveC52YWx1ZSA9ICcnO1xuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmKGhhcyhcImRvam8tYmlkaVwiKSl7XG5cdFx0X1RleHRCb3hNaXhpbiA9IGRlY2xhcmUoXCJkaWppdC5mb3JtLl9UZXh0Qm94TWl4aW5cIiwgX1RleHRCb3hNaXhpbiwge1xuXHRcdFx0X3NldFZhbHVlQXR0cjogZnVuY3Rpb24oKXtcblx0XHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy5hcHBseVRleHREaXIodGhpcy5mb2N1c05vZGUpO1xuXHRcdFx0fSxcblx0XHRcdF9zZXREaXNwbGF5ZWRWYWx1ZUF0dHI6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHRoaXMuYXBwbHlUZXh0RGlyKHRoaXMuZm9jdXNOb2RlKTtcblx0XHRcdH0sXG5cdFx0XHRfb25JbnB1dDogZnVuY3Rpb24oKXtcblx0XHRcdFx0dGhpcy5hcHBseVRleHREaXIodGhpcy5mb2N1c05vZGUpO1xuXHRcdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0X1RleHRCb3hNaXhpbi5fc2V0U2VsZWN0aW9uUmFuZ2UgPSBkaWppdC5fc2V0U2VsZWN0aW9uUmFuZ2UgPSBmdW5jdGlvbigvKkRvbU5vZGUqLyBlbGVtZW50LCAvKk51bWJlcj8qLyBzdGFydCwgLypOdW1iZXI/Ki8gc3RvcCl7XG5cdFx0aWYoZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSl7XG5cdFx0XHRlbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBzdG9wKTtcblx0XHR9XG5cdH07XG5cblx0X1RleHRCb3hNaXhpbi5zZWxlY3RJbnB1dFRleHQgPSBkaWppdC5zZWxlY3RJbnB1dFRleHQgPSBmdW5jdGlvbigvKkRvbU5vZGUqLyBlbGVtZW50LCAvKk51bWJlcj8qLyBzdGFydCwgLypOdW1iZXI/Ki8gc3RvcCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZWxlY3QgdGV4dCBpbiB0aGUgaW5wdXQgZWxlbWVudCBhcmd1bWVudCwgZnJvbSBzdGFydCAoZGVmYXVsdCAwKSwgdG8gc3RvcCAoZGVmYXVsdCBlbmQpLlxuXG5cdFx0Ly8gVE9ETzogdXNlIGZ1bmN0aW9ucyBpbiBfZWRpdG9yL3NlbGVjdGlvbi5qcz9cblx0XHRlbGVtZW50ID0gZG9tLmJ5SWQoZWxlbWVudCk7XG5cdFx0aWYoaXNOYU4oc3RhcnQpKXtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHR9XG5cdFx0aWYoaXNOYU4oc3RvcCkpe1xuXHRcdFx0c3RvcCA9IGVsZW1lbnQudmFsdWUgPyBlbGVtZW50LnZhbHVlLmxlbmd0aCA6IDA7XG5cdFx0fVxuXHRcdHRyeXtcblx0XHRcdGVsZW1lbnQuZm9jdXMoKTtcblx0XHRcdF9UZXh0Qm94TWl4aW4uX3NldFNlbGVjdGlvblJhbmdlKGVsZW1lbnQsIHN0YXJ0LCBzdG9wKTtcblx0XHR9Y2F0Y2goZSl7IC8qIHNxdWVsY2ggcmFuZG9tIGVycm9ycyAoZXNwLiBvbiBJRSkgZnJvbSB1bmV4cGVjdGVkIGZvY3VzIGNoYW5nZXMgb3IgRE9NIG5vZGVzIGJlaW5nIGhpZGRlbiAqL1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gX1RleHRCb3hNaXhpbjtcbn0pO1xuIiwiZGVmaW5lKFxuKHtcblx0aW52YWxpZE1lc3NhZ2U6IFwiRWwgdmFsb3IgZXNwZWNpZmljYWRvIG5vIGVzIHbDoWxpZG8uXCIsXG5cdG1pc3NpbmdNZXNzYWdlOiBcIkVzdGUgdmFsb3IgZXMgbmVjZXNhcmlvLlwiLFxuXHRyYW5nZU1lc3NhZ2U6IFwiRXN0ZSB2YWxvciBlc3TDoSBmdWVyYSBkZWwgaW50ZXJ2YWxvLlwiXG59KVxuKTtcbiIsImRlZmluZShcbih7XG5cdGludmFsaWRNZXNzYWdlOiBcIkxhIHZhbGV1ciBpbmRpcXXDqWUgbidlc3QgcGFzIGNvcnJlY3RlLlwiLFxuXHRtaXNzaW5nTWVzc2FnZTogXCJDZXR0ZSB2YWxldXIgZXN0IHJlcXVpc2UuXCIsXG5cdHJhbmdlTWVzc2FnZTogXCJDZXR0ZSB2YWxldXIgbidlc3QgcGFzIGNvbXByaXNlIGRhbnMgbGEgcGxhZ2UgYXV0b3Jpc8OpZS5cIlxufSlcbik7XG4iLCIvKlxuICogVGhpcyBtb2R1bGUgd2FzIG1vZGlmaWVkIGJ5IGRvam8td2VicGFjay1wbHVnaW4gdG8gZGlzYWJsZSBzb21lIGxvY2FsZXNcbiAqIHRoYXQgd2VyZSBleGNsdWRlZCBieSB0aGUgcGx1Z2luJ3MgJ2xvY2FsZXMnIG9wdGlvblxuICovXG5kZWZpbmUoKHsncm9vdCc6KHsnaW52YWxpZE1lc3NhZ2UnOidUaGUgdmFsdWUgZW50ZXJlZCBpcyBub3QgdmFsaWQuJywnbWlzc2luZ01lc3NhZ2UnOidUaGlzIHZhbHVlIGlzIHJlcXVpcmVkLicsJ3JhbmdlTWVzc2FnZSc6J1RoaXMgdmFsdWUgaXMgb3V0IG9mIHJhbmdlLid9KSwnYnMnOmZhbHNlLCdtayc6ZmFsc2UsJ3NyJzpmYWxzZSwnemgnOmZhbHNlLCd6aC10dyc6ZmFsc2UsJ3VrJzpmYWxzZSwndHInOmZhbHNlLCd0aCc6ZmFsc2UsJ3N2JzpmYWxzZSwnc2wnOmZhbHNlLCdzayc6ZmFsc2UsJ3J1JzpmYWxzZSwncm8nOmZhbHNlLCdwdCc6ZmFsc2UsJ3B0LXB0JzpmYWxzZSwncGwnOmZhbHNlLCdubCc6ZmFsc2UsJ25iJzpmYWxzZSwna28nOmZhbHNlLCdrayc6ZmFsc2UsJ2phJzpmYWxzZSwnaXQnOmZhbHNlLCdpZCc6ZmFsc2UsJ2h1JzpmYWxzZSwnaHInOmZhbHNlLCdoZSc6ZmFsc2UsJ2ZyJzp0cnVlLCdmaSc6ZmFsc2UsJ2V1JzpmYWxzZSwnZXMnOnRydWUsJ2VsJzpmYWxzZSwnZGUnOmZhbHNlLCdkYSc6ZmFsc2UsJ2NzJzpmYWxzZSwnY2EnOmZhbHNlLCdiZyc6ZmFsc2UsJ2F6JzpmYWxzZSwnYXInOmZhbHNlLCdhbCc6ZmFsc2V9KSkiLCJkZWZpbmUoW1wiZG9qby9kb20tY2xhc3NcIiwgXCJkb2pvL2hjY3NzXCIsIFwiZG9qby9kb21SZWFkeVwiLCBcImRvam8vX2Jhc2Uvd2luZG93XCJdLCBmdW5jdGlvbihkb21DbGFzcywgaGFzLCBkb21SZWFkeSwgd2luKXtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRpaml0L2hjY3NzXG5cblx0Lyo9PT09PVxuXHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRlc3QgaWYgY29tcHV0ZXIgaXMgaW4gaGlnaCBjb250cmFzdCBtb2RlLCBhbmQgc2V0cyBgZGlqaXRfYTExeWAgZmxhZyBvbiBgPGJvZHk+YCBpZiBpdCBpcy5cblx0XHQvL1x0XHREZXByZWNhdGVkLCB1c2UgYGBkb2pvL2hjY3NzYGAgaW5zdGVhZC5cblx0fTtcblx0PT09PT0qL1xuXG5cdGRvbVJlYWR5KGZ1bmN0aW9uKCl7XG5cdFx0aWYoaGFzKFwiaGlnaGNvbnRyYXN0XCIpKXtcblx0XHRcdGRvbUNsYXNzLmFkZCh3aW4uYm9keSgpLCBcImRpaml0X2ExMXlcIik7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gaGFzO1xufSk7XG4iLCJkZWZpbmUoW1xuXHRcImRvam8vX2Jhc2UvYXJyYXlcIiwgLy8gYXJyYXkuZmlsdGVyIGFycmF5LmZvckVhY2hcblx0XCJkb2pvL19iYXNlL2RlY2xhcmVcIiwgLy8gZGVjbGFyZVxuXHRcImRvam8vZG9tLWNsYXNzXCIsIC8vIGRvbUNsYXNzLmNvbnRhaW5zIGRvbUNsYXNzLnRvZ2dsZVxuXHRcImRvam8vZG9tLWdlb21ldHJ5XCIsIC8vIGRvbUdlb21ldHJ5LmNvbnRlbnRCb3ggZG9tR2VvbWV0cnkubWFyZ2luQm94XG5cdFwiZG9qby9kb20tc3R5bGVcIixcblx0XCJkb2pvL19iYXNlL2xhbmdcIiwgLy8gbGFuZy5taXhpblxuXHRcImRvam8vcXVlcnlcIiwgLy8gcXVlcnlcblx0XCIuLi9yZWdpc3RyeVwiLCAvLyByZWdpc3RyeS5ieUlkXG5cdFwiLi4vVmlld3BvcnRcIixcblx0XCIuL3V0aWxzXCIgLy8gbWFyZ2luQm94MmNvbnRleHRCb3hcbl0sIGZ1bmN0aW9uKGFycmF5LCBkZWNsYXJlLCBkb21DbGFzcywgZG9tR2VvbWV0cnksIGRvbVN0eWxlLCBsYW5nLCBxdWVyeSxcblx0XHRcdHJlZ2lzdHJ5LCBWaWV3cG9ydCwgbGF5b3V0VXRpbHMpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvbGF5b3V0L19Db250ZW50UGFuZVJlc2l6ZU1peGluXG5cblx0cmV0dXJuIGRlY2xhcmUoXCJkaWppdC5sYXlvdXQuX0NvbnRlbnRQYW5lUmVzaXplTWl4aW5cIiwgbnVsbCwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmVzaXplKCkgZnVuY3Rpb25hbGl0eSBvZiBDb250ZW50UGFuZS4gICBJZiB0aGVyZSdzIGEgc2luZ2xlIGxheW91dCB3aWRnZXRcblx0XHQvL1x0XHRjaGlsZCB0aGVuIGl0IHdpbGwgY2FsbCByZXNpemUoKSB3aXRoIHRoZSBzYW1lIGRpbWVuc2lvbnMgYXMgdGhlIENvbnRlbnRQYW5lLlxuXHRcdC8vXHRcdE90aGVyd2lzZSBqdXN0IGNhbGxzIHJlc2l6ZSBvbiBlYWNoIGNoaWxkLlxuXHRcdC8vXG5cdFx0Ly9cdFx0QWxzbyBpbXBsZW1lbnRzIGJhc2ljIHN0YXJ0dXAoKSBmdW5jdGlvbmFsaXR5LCB3aGVyZSBzdGFydGluZyB0aGUgcGFyZW50XG5cdFx0Ly9cdFx0d2lsbCBzdGFydCB0aGUgY2hpbGRyZW5cblxuXHRcdC8vIGRvTGF5b3V0OiBCb29sZWFuXG5cdFx0Ly9cdFx0LSBmYWxzZSAtIGRvbid0IGFkanVzdCBzaXplIG9mIGNoaWxkcmVuXG5cdFx0Ly9cdFx0LSB0cnVlIC0gaWYgdGhlcmUgaXMgYSBzaW5nbGUgdmlzaWJsZSBjaGlsZCB3aWRnZXQsIHNldCBpdCdzIHNpemUgdG8gaG93ZXZlciBiaWcgdGhlIENvbnRlbnRQYW5lIGlzXG5cdFx0ZG9MYXlvdXQ6IHRydWUsXG5cblx0XHQvLyBpc0xheW91dENvbnRhaW5lcjogW3Byb3RlY3RlZF0gQm9vbGVhblxuXHRcdC8vXHRcdEluZGljYXRlcyB0aGF0IHRoaXMgd2lkZ2V0IHdpbGwgY2FsbCByZXNpemUoKSBvbiBpdCdzIGNoaWxkIHdpZGdldHNcblx0XHQvL1x0XHR3aGVuIHRoZXkgYmVjb21lIHZpc2libGUuXG5cdFx0aXNMYXlvdXRDb250YWluZXI6IHRydWUsXG5cblx0XHRzdGFydHVwOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFNlZSBgZGlqaXQvbGF5b3V0L19MYXlvdXRXaWRnZXQuc3RhcnR1cCgpYCBmb3IgZGVzY3JpcHRpb24uXG5cdFx0XHQvL1x0XHRBbHRob3VnaCBDb250ZW50UGFuZSBkb2Vzbid0IGV4dGVuZCBfTGF5b3V0V2lkZ2V0LCBpdCBkb2VzIGltcGxlbWVudFxuXHRcdFx0Ly9cdFx0dGhlIHNhbWUgQVBJLlxuXG5cdFx0XHRpZih0aGlzLl9zdGFydGVkKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcblx0XHRcdHRoaXMuX2NoaWxkT2ZMYXlvdXRXaWRnZXQgPSBwYXJlbnQgJiYgcGFyZW50LmlzTGF5b3V0Q29udGFpbmVyO1xuXG5cdFx0XHQvLyBJIG5lZWQgdG8gY2FsbCByZXNpemUoKSBvbiBteSBjaGlsZC9jaGlsZHJlbiAod2hlbiBJIGJlY29tZSB2aXNpYmxlKSwgdW5sZXNzXG5cdFx0XHQvLyBJJ20gdGhlIGNoaWxkIG9mIGEgbGF5b3V0IHdpZGdldCBpbiB3aGljaCBjYXNlIG15IHBhcmVudCB3aWxsIGNhbGwgcmVzaXplKCkgb24gbWUgYW5kIEknbGwgZG8gaXQgdGhlbi5cblx0XHRcdHRoaXMuX25lZWRMYXlvdXQgPSAhdGhpcy5fY2hpbGRPZkxheW91dFdpZGdldDtcblxuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblxuXHRcdFx0aWYodGhpcy5faXNTaG93bigpKXtcblx0XHRcdFx0dGhpcy5fb25TaG93KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCF0aGlzLl9jaGlsZE9mTGF5b3V0V2lkZ2V0KXtcblx0XHRcdFx0Ly8gU2luY2UgbXkgcGFyZW50IGlzbid0IGEgbGF5b3V0IGNvbnRhaW5lciwgYW5kIG15IHN0eWxlICptYXkgYmUqIHdpZHRoPWhlaWdodD0xMDAlXG5cdFx0XHRcdC8vIG9yIHNvbWV0aGluZyBzaW1pbGFyIChlaXRoZXIgc2V0IGRpcmVjdGx5IG9yIHZpYSBhIENTUyBjbGFzcyksXG5cdFx0XHRcdC8vIG1vbml0b3Igd2hlbiB2aWV3cG9ydCBzaXplIGNoYW5nZXMgc28gdGhhdCBJIGNhbiByZS1sYXlvdXQuXG5cdFx0XHRcdC8vIFRoaXMgaXMgbW9yZSBmb3Igc3ViY2xhc3NlcyBvZiBDb250ZW50UGFuZSB0aGFuIENvbnRlbnRQYW5lIGl0c2VsZiwgYWx0aG91Z2ggaXRcblx0XHRcdFx0Ly8gY291bGQgYmUgdXNlZnVsIGZvciBhIENvbnRlbnRQYW5lIGlmIGl0IGhhcyBhIHNpbmdsZSBjaGlsZCB3aWRnZXQgaW5oZXJpdGluZyBDb250ZW50UGFuZSdzIHNpemUuXG5cdFx0XHRcdHRoaXMub3duKFZpZXdwb3J0Lm9uKFwicmVzaXplXCIsIGxhbmcuaGl0Y2godGhpcywgXCJyZXNpemVcIikpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2NoZWNrSWZTaW5nbGVDaGlsZDogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRUZXN0IGlmIHdlIGhhdmUgZXhhY3RseSBvbmUgdmlzaWJsZSB3aWRnZXQgYXMgYSBjaGlsZCxcblx0XHRcdC8vXHRcdGFuZCBpZiBzbyBhc3N1bWUgdGhhdCB3ZSBhcmUgYSBjb250YWluZXIgZm9yIHRoYXQgd2lkZ2V0LFxuXHRcdFx0Ly9cdFx0YW5kIHNob3VsZCBwcm9wYWdhdGUgc3RhcnR1cCgpIGFuZCByZXNpemUoKSBjYWxscyB0byBpdC5cblx0XHRcdC8vXHRcdFNraXBzIG92ZXIgdGhpbmdzIGxpa2UgZGF0YSBzdG9yZXMgc2luY2UgdGhleSBhcmVuJ3QgdmlzaWJsZS5cblxuXHRcdFx0aWYoIXRoaXMuZG9MYXlvdXQpeyByZXR1cm47IH1cblxuXHRcdFx0dmFyIGNhbmRpZGF0ZVdpZGdldHMgPSBbXSxcblx0XHRcdFx0b3RoZXJWaXNpYmxlTm9kZXMgPSBmYWxzZTtcblxuXHRcdFx0cXVlcnkoXCI+ICpcIiwgdGhpcy5jb250YWluZXJOb2RlKS5zb21lKGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0XHR2YXIgd2lkZ2V0ID0gcmVnaXN0cnkuYnlOb2RlKG5vZGUpO1xuXHRcdFx0XHRpZih3aWRnZXQgJiYgd2lkZ2V0LnJlc2l6ZSl7XG5cdFx0XHRcdFx0Y2FuZGlkYXRlV2lkZ2V0cy5wdXNoKHdpZGdldCk7XG5cdFx0XHRcdH1lbHNlIGlmKCEvc2NyaXB0fGxpbmt8c3R5bGUvaS50ZXN0KG5vZGUubm9kZU5hbWUpICYmIG5vZGUub2Zmc2V0SGVpZ2h0KXtcblx0XHRcdFx0XHRvdGhlclZpc2libGVOb2RlcyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLl9zaW5nbGVDaGlsZCA9IGNhbmRpZGF0ZVdpZGdldHMubGVuZ3RoID09IDEgJiYgIW90aGVyVmlzaWJsZU5vZGVzID9cblx0XHRcdFx0Y2FuZGlkYXRlV2lkZ2V0c1swXSA6IG51bGw7XG5cblx0XHRcdC8vIFNvIHdlIGNhbiBzZXQgb3ZlcmZsb3c6IGhpZGRlbiB0byBhdm9pZCBhIHNhZmFyaSBidWcgdy9zY3JvbGxiYXJzIHNob3dpbmcgdXAgKCM5NDQ5KVxuXHRcdFx0ZG9tQ2xhc3MudG9nZ2xlKHRoaXMuY29udGFpbmVyTm9kZSwgdGhpcy5iYXNlQ2xhc3MgKyBcIlNpbmdsZUNoaWxkXCIsICEhdGhpcy5fc2luZ2xlQ2hpbGQpO1xuXHRcdH0sXG5cblx0XHRyZXNpemU6IGZ1bmN0aW9uKGNoYW5nZVNpemUsIHJlc3VsdFNpemUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFNlZSBgZGlqaXQvbGF5b3V0L19MYXlvdXRXaWRnZXQucmVzaXplKClgIGZvciBkZXNjcmlwdGlvbi5cblx0XHRcdC8vXHRcdEFsdGhvdWdoIENvbnRlbnRQYW5lIGRvZXNuJ3QgZXh0ZW5kIF9MYXlvdXRXaWRnZXQsIGl0IGRvZXMgaW1wbGVtZW50XG5cdFx0XHQvL1x0XHR0aGUgc2FtZSBBUEkuXG5cblx0XHRcdHRoaXMuX3Jlc2l6ZUNhbGxlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX3NjaGVkdWxlTGF5b3V0KGNoYW5nZVNpemUsIHJlc3VsdFNpemUpO1xuXHRcdH0sXG5cblx0XHRfc2NoZWR1bGVMYXlvdXQ6IGZ1bmN0aW9uKGNoYW5nZVNpemUsIHJlc3VsdFNpemUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlc2l6ZSBteXNlbGYsIGFuZCBjYWxsIHJlc2l6ZSgpIG9uIGVhY2ggb2YgbXkgY2hpbGQgbGF5b3V0IHdpZGdldHMsIGVpdGhlciBub3dcblx0XHRcdC8vXHRcdChpZiBJJ20gY3VycmVudGx5IHZpc2libGUpIG9yIHdoZW4gSSBiZWNvbWUgdmlzaWJsZVxuXHRcdFx0aWYodGhpcy5faXNTaG93bigpKXtcblx0XHRcdFx0dGhpcy5fbGF5b3V0KGNoYW5nZVNpemUsIHJlc3VsdFNpemUpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHRoaXMuX25lZWRMYXlvdXQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VTaXplID0gY2hhbmdlU2l6ZTtcblx0XHRcdFx0dGhpcy5fcmVzdWx0U2l6ZSA9IHJlc3VsdFNpemU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9sYXlvdXQ6IGZ1bmN0aW9uKGNoYW5nZVNpemUsIHJlc3VsdFNpemUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlc2l6ZSBteXNlbGYgYWNjb3JkaW5nIHRvIG9wdGlvbmFsIGNoYW5nZVNpemUvcmVzdWx0U2l6ZSBwYXJhbWV0ZXJzLCBsaWtlIGEgbGF5b3V0IHdpZGdldC5cblx0XHRcdC8vXHRcdEFsc28sIHNpbmNlIEkgYW0gYW4gaXNMYXlvdXRDb250YWluZXIgd2lkZ2V0LCBlYWNoIG9mIG15IGNoaWxkcmVuIGV4cGVjdHMgbWUgdG9cblx0XHRcdC8vXHRcdGNhbGwgcmVzaXplKCkgb3IgbGF5b3V0KCkgb24gaXQuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0U2hvdWxkIGJlIGNhbGxlZCBvbiBpbml0aWFsaXphdGlvbiBhbmQgYWxzbyB3aGVuZXZlciB3ZSBnZXQgbmV3IGNvbnRlbnRcblx0XHRcdC8vXHRcdChmcm9tIGFuIGhyZWYsIG9yIGZyb20gc2V0KCdjb250ZW50JywgLi4uKSkuLi4gYnV0IGRlZmVycmVkIHVudGlsXG5cdFx0XHQvL1x0XHR0aGUgQ29udGVudFBhbmUgaXMgdmlzaWJsZVxuXG5cdFx0XHRkZWxldGUgdGhpcy5fbmVlZExheW91dDtcblxuXHRcdFx0Ly8gRm9yIHRoZSBUYWJDb250YWluZXIgLS0+IEJvcmRlckNvbnRhaW5lciAtLT4gQ29udGVudFBhbmUgY2FzZSwgX29uU2hvdygpIGlzXG5cdFx0XHQvLyBuZXZlciBjYWxsZWQgZGlyZWN0bHksIHNvIHJlc2l6ZSgpIGlzIG91ciB0cmlnZ2VyIHRvIGRvIHRoZSBpbml0aWFsIGhyZWYgZG93bmxvYWQgKHNlZSBbMjAwOTldKS5cblx0XHRcdC8vIEhvd2V2ZXIsIGRvbid0IGxvYWQgaHJlZiBmb3IgY2xvc2VkIFRpdGxlUGFuZXMuXG5cdFx0XHRpZighdGhpcy5fd2FzU2hvd24gJiYgdGhpcy5vcGVuICE9PSBmYWxzZSl7XG5cdFx0XHRcdHRoaXMuX29uU2hvdygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgbWFyZ2luIGJveCBzaXplLCB1bmxlc3MgaXQgd2Fzbid0IHNwZWNpZmllZCwgaW4gd2hpY2ggY2FzZSB1c2UgY3VycmVudCBzaXplLlxuXHRcdFx0aWYoY2hhbmdlU2l6ZSl7XG5cdFx0XHRcdGRvbUdlb21ldHJ5LnNldE1hcmdpbkJveCh0aGlzLmRvbU5vZGUsIGNoYW5nZVNpemUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wdXRlIGNvbnRlbnQgYm94IHNpemUgb2YgY29udGFpbmVyTm9kZSBpbiBjYXNlIHdlIFtsYXRlcl0gbmVlZCB0byBzaXplIG91ciBzaW5nbGUgY2hpbGQuXG5cdFx0XHR2YXIgY24gPSB0aGlzLmNvbnRhaW5lck5vZGU7XG5cdFx0XHRpZihjbiA9PT0gdGhpcy5kb21Ob2RlKXtcblx0XHRcdFx0Ly8gSWYgY2hhbmdlU2l6ZSBvciByZXN1bHRTaXplIHdhcyBwYXNzZWQgdG8gdGhpcyBtZXRob2QgYW5kIHRoaXMuY29udGFpbmVyTm9kZSA9PVxuXHRcdFx0XHQvLyB0aGlzLmRvbU5vZGUgdGhlbiB3ZSBjYW4gY29tcHV0ZSB0aGUgY29udGVudC1ib3ggc2l6ZSB3aXRob3V0IHF1ZXJ5aW5nIHRoZSBub2RlLFxuXHRcdFx0XHQvLyB3aGljaCBpcyBtb3JlIHJlbGlhYmxlIChzaW1pbGFyIHRvIExheW91dFdpZGdldC5yZXNpemUpIChzZWUgZm9yIGV4YW1wbGUgIzk0NDkpLlxuXHRcdFx0XHR2YXIgbWIgPSByZXN1bHRTaXplIHx8IHt9O1xuXHRcdFx0XHRsYW5nLm1peGluKG1iLCBjaGFuZ2VTaXplIHx8IHt9KTsgLy8gY2hhbmdlU2l6ZSBvdmVycmlkZXMgcmVzdWx0U2l6ZVxuXHRcdFx0XHRpZighKFwiaFwiIGluIG1iKSB8fCAhKFwid1wiIGluIG1iKSl7XG5cdFx0XHRcdFx0bWIgPSBsYW5nLm1peGluKGRvbUdlb21ldHJ5LmdldE1hcmdpbkJveChjbiksIG1iKTsgLy8ganVzdCB1c2UgZG9tR2VvbWV0cnkuc2V0TWFyZ2luQm94KCkgdG8gZmlsbCBpbiBtaXNzaW5nIHZhbHVlc1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NvbnRlbnRCb3ggPSBsYXlvdXRVdGlscy5tYXJnaW5Cb3gyY29udGVudEJveChjbiwgbWIpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHRoaXMuX2NvbnRlbnRCb3ggPSBkb21HZW9tZXRyeS5nZXRDb250ZW50Qm94KGNuKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGF5b3V0Q2hpbGRyZW4oKTtcblx0XHR9LFxuXG5cdFx0X2xheW91dENoaWxkcmVuOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQ2FsbCBfY2hlY2tJZlNpbmdsZUNoaWxkKCkgYWdhaW4gaW4gY2FzZSBhcHAgaGFzIG1hbnVhbGx5IG11Y2tlZCB3L3RoZSBjb250ZW50XG5cdFx0XHQvLyBvZiB0aGUgQ29udGVudFBhbmUgKHJhdGhlciB0aGFuIGNoYW5naW5nIGl0IHRocm91Z2ggdGhlIHNldChcImNvbnRlbnRcIiwgLi4uKSBBUEkuXG5cdFx0XHR0aGlzLl9jaGVja0lmU2luZ2xlQ2hpbGQoKTtcblxuXHRcdFx0aWYodGhpcy5fc2luZ2xlQ2hpbGQgJiYgdGhpcy5fc2luZ2xlQ2hpbGQucmVzaXplKXtcblx0XHRcdFx0dmFyIGNiID0gdGhpcy5fY29udGVudEJveCB8fCBkb21HZW9tZXRyeS5nZXRDb250ZW50Qm94KHRoaXMuY29udGFpbmVyTm9kZSk7XG5cblx0XHRcdFx0Ly8gbm90ZTogaWYgd2lkZ2V0IGhhcyBwYWRkaW5nIHRoaXMuX2NvbnRlbnRCb3ggd2lsbCBoYXZlIGwgYW5kIHQgc2V0LFxuXHRcdFx0XHQvLyBidXQgZG9uJ3QgcGFzcyB0aGVtIHRvIHJlc2l6ZSgpIG9yIGl0IHdpbGwgZG91Ymx5LW9mZnNldCB0aGUgY2hpbGRcblx0XHRcdFx0dGhpcy5fc2luZ2xlQ2hpbGQucmVzaXplKHt3OiBjYi53LCBoOiBjYi5ofSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Ly8gQWxsIG15IGNoaWxkIHdpZGdldHMgYXJlIGluZGVwZW5kZW50bHkgc2l6ZWQgKHJhdGhlciB0aGFuIG1hdGNoaW5nIG15IHNpemUpLFxuXHRcdFx0XHQvLyBidXQgSSBzdGlsbCBuZWVkIHRvIGNhbGwgcmVzaXplKCkgb24gZWFjaCBjaGlsZCB0byBtYWtlIGl0IGxheW91dC5cblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpLFxuXHRcdFx0XHRcdHdpZGdldCxcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0d2hpbGUod2lkZ2V0ID0gY2hpbGRyZW5baSsrXSl7XG5cdFx0XHRcdFx0aWYod2lkZ2V0LnJlc2l6ZSl7XG5cdFx0XHRcdFx0XHR3aWRnZXQucmVzaXplKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9pc1Nob3duOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udGVudCBpcyBjdXJyZW50bHkgc2hvd24uXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdElmIEkgYW0gYSBjaGlsZCBvZiBhIGxheW91dCB3aWRnZXQgdGhlbiBpdCBhY3R1YWxseSByZXR1cm5zIHRydWUgaWYgSSd2ZSBldmVyIGJlZW4gdmlzaWJsZSxcblx0XHRcdC8vXHRcdG5vdCB3aGV0aGVyIEknbSBjdXJyZW50bHkgdmlzaWJsZSwgc2luY2UgdGhhdCdzIG11Y2ggZmFzdGVyIHRoYW4gdHJhY2luZyB1cCB0aGUgRE9NL3dpZGdldFxuXHRcdFx0Ly9cdFx0dHJlZSBldmVyeSBjYWxsLCBhbmQgYXQgbGVhc3Qgc29sdmVzIHRoZSBwZXJmb3JtYW5jZSBwcm9ibGVtIG9uIHBhZ2UgbG9hZCBieSBkZWZlcnJpbmcgbG9hZGluZ1xuXHRcdFx0Ly9cdFx0aGlkZGVuIENvbnRlbnRQYW5lcyB1bnRpbCB0aGV5IGFyZSBmaXJzdCBzaG93blxuXG5cdFx0XHRpZih0aGlzLl9jaGlsZE9mTGF5b3V0V2lkZ2V0KXtcblx0XHRcdFx0Ly8gSWYgd2UgYXJlIFRpdGxlUGFuZSwgZXRjIC0gd2UgcmV0dXJuIHRoYXQgb25seSAqSUYqIHdlJ3ZlIGJlZW4gcmVzaXplZFxuXHRcdFx0XHRpZih0aGlzLl9yZXNpemVDYWxsZWQgJiYgXCJvcGVuXCIgaW4gdGhpcyl7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3Blbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVzaXplQ2FsbGVkO1xuXHRcdFx0fWVsc2UgaWYoXCJvcGVuXCIgaW4gdGhpcyl7XG5cdFx0XHRcdHJldHVybiB0aGlzLm9wZW47XHRcdC8vIGZvciBUaXRsZVBhbmUsIGV0Yy5cblx0XHRcdH1lbHNle1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZG9tTm9kZSwgcGFyZW50ID0gdGhpcy5kb21Ob2RlLnBhcmVudE5vZGU7XG5cdFx0XHRcdHJldHVybiAobm9kZS5zdHlsZS5kaXNwbGF5ICE9ICdub25lJykgJiYgKG5vZGUuc3R5bGUudmlzaWJpbGl0eSAhPSAnaGlkZGVuJykgJiYgIWRvbUNsYXNzLmNvbnRhaW5zKG5vZGUsIFwiZGlqaXRIaWRkZW5cIikgJiZcblx0XHRcdFx0XHRwYXJlbnQgJiYgcGFyZW50LnN0eWxlICYmIChwYXJlbnQuc3R5bGUuZGlzcGxheSAhPSAnbm9uZScpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfb25TaG93OiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbGxlZCB3aGVuIHRoZSBDb250ZW50UGFuZSBpcyBtYWRlIHZpc2libGVcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0Rm9yIGEgcGxhaW4gQ29udGVudFBhbmUsIHRoaXMgaXMgY2FsbGVkIG9uIGluaXRpYWxpemF0aW9uLCBmcm9tIHN0YXJ0dXAoKS5cblx0XHRcdC8vXHRcdElmIHRoZSBDb250ZW50UGFuZSBpcyBhIGhpZGRlbiBwYW5lIG9mIGEgVGFiQ29udGFpbmVyIGV0Yy4sIHRoZW4gaXQnc1xuXHRcdFx0Ly9cdFx0Y2FsbGVkIHdoZW5ldmVyIHRoZSBwYW5lIGlzIG1hZGUgdmlzaWJsZS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHREb2VzIGxheW91dC9yZXNpemUgb2YgY2hpbGQgd2lkZ2V0KHMpXG5cblx0XHRcdC8vIE5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIENvbnRlbnRQYW5lIGhhcyBiZWVuIHNob3duICh3aGljaCBpcyBkaWZmZXJlbnQgdGhhblxuXHRcdFx0Ly8gd2hldGhlciBvciBub3QgaXQncyBjdXJyZW50bHkgdmlzaWJsZSkuXG5cdFx0XHR0aGlzLl93YXNTaG93biA9IHRydWU7XG5cblx0XHRcdGlmKHRoaXMuX25lZWRMYXlvdXQpe1xuXHRcdFx0XHQvLyBJZiBhIGxheW91dCBoYXMgYmVlbiBzY2hlZHVsZWQgZm9yIHdoZW4gd2UgYmVjb21lIHZpc2libGUsIGRvIGl0IG5vd1xuXHRcdFx0XHR0aGlzLl9sYXlvdXQodGhpcy5fY2hhbmdlU2l6ZSwgdGhpcy5fcmVzdWx0U2l6ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCJkb2pvL19iYXNlL2FycmF5XCIsIC8vIGFycmF5LmZpbHRlciBhcnJheS5mb3JFYWNoXG5cdFwiZG9qby9kb20tY2xhc3NcIiwgLy8gZG9tQ2xhc3MuYWRkIGRvbUNsYXNzLnJlbW92ZVxuXHRcImRvam8vZG9tLWdlb21ldHJ5XCIsIC8vIGRvbUdlb21ldHJ5Lm1hcmdpbkJveFxuXHRcImRvam8vZG9tLXN0eWxlXCIsIC8vIGRvbVN0eWxlLmdldENvbXB1dGVkU3R5bGVcblx0XCJkb2pvL19iYXNlL2xhbmdcIiAvLyBsYW5nLm1peGluLCBsYW5nLnNldE9iamVjdFxuXSwgZnVuY3Rpb24oYXJyYXksIGRvbUNsYXNzLCBkb21HZW9tZXRyeSwgZG9tU3R5bGUsIGxhbmcpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvbGF5b3V0L3V0aWxzXG5cblx0ZnVuY3Rpb24gY2FwaXRhbGl6ZSh3b3JkKXtcblx0XHRyZXR1cm4gd29yZC5zdWJzdHJpbmcoMCwxKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zdWJzdHJpbmcoMSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzaXplKHdpZGdldCwgZGltKXtcblx0XHQvLyBzaXplIHRoZSBjaGlsZFxuXHRcdHZhciBuZXdTaXplID0gd2lkZ2V0LnJlc2l6ZSA/IHdpZGdldC5yZXNpemUoZGltKSA6IGRvbUdlb21ldHJ5LnNldE1hcmdpbkJveCh3aWRnZXQuZG9tTm9kZSwgZGltKTtcblxuXHRcdC8vIHJlY29yZCBjaGlsZCdzIHNpemVcblx0XHRpZihuZXdTaXplKXtcblx0XHRcdC8vIGlmIHRoZSBjaGlsZCByZXR1cm5lZCBpdCdzIG5ldyBzaXplIHRoZW4gdXNlIHRoYXRcblx0XHRcdGxhbmcubWl4aW4od2lkZ2V0LCBuZXdTaXplKTtcblx0XHR9ZWxzZXtcblx0XHRcdC8vIG90aGVyd2lzZSwgY2FsbCBnZXRNYXJnaW5Cb3goKSwgYnV0IGZhdm9yIG91ciBvd24gbnVtYmVycyB3aGVuIHdlIGhhdmUgdGhlbS5cblx0XHRcdC8vIHRoZSBicm93c2VyIGxpZXMgc29tZXRpbWVzXG5cdFx0XHRsYW5nLm1peGluKHdpZGdldCwgZG9tR2VvbWV0cnkuZ2V0TWFyZ2luQm94KHdpZGdldC5kb21Ob2RlKSk7XG5cdFx0XHRsYW5nLm1peGluKHdpZGdldCwgZGltKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgdXRpbHMgPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZG9pbmcgbGF5b3V0XG5cblx0XHRtYXJnaW5Cb3gyY29udGVudEJveDogZnVuY3Rpb24oLypEb21Ob2RlKi8gbm9kZSwgLypPYmplY3QqLyBtYil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0R2l2ZW4gdGhlIG1hcmdpbi1ib3ggc2l6ZSBvZiBhIG5vZGUsIHJldHVybiBpdHMgY29udGVudCBib3ggc2l6ZS5cblx0XHRcdC8vXHRcdEZ1bmN0aW9ucyBsaWtlIGRvbUdlb21ldHJ5LmNvbnRlbnRCb3goKSBidXQgaXMgbW9yZSByZWxpYWJsZSBzaW5jZSBpdCBkb2Vzbid0IGhhdmVcblx0XHRcdC8vXHRcdHRvIHdhaXQgZm9yIHRoZSBicm93c2VyIHRvIGNvbXB1dGUgc2l6ZXMuXG5cdFx0XHR2YXIgY3MgPSBkb21TdHlsZS5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRcdFx0dmFyIG1lID0gZG9tR2VvbWV0cnkuZ2V0TWFyZ2luRXh0ZW50cyhub2RlLCBjcyk7XG5cdFx0XHR2YXIgcGIgPSBkb21HZW9tZXRyeS5nZXRQYWRCb3JkZXJFeHRlbnRzKG5vZGUsIGNzKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGw6IGRvbVN0eWxlLnRvUGl4ZWxWYWx1ZShub2RlLCBjcy5wYWRkaW5nTGVmdCksXG5cdFx0XHRcdHQ6IGRvbVN0eWxlLnRvUGl4ZWxWYWx1ZShub2RlLCBjcy5wYWRkaW5nVG9wKSxcblx0XHRcdFx0dzogbWIudyAtIChtZS53ICsgcGIudyksXG5cdFx0XHRcdGg6IG1iLmggLSAobWUuaCArIHBiLmgpXG5cdFx0XHR9O1xuXHRcdH0sXG5cblxuXHRcdGxheW91dENoaWxkcmVuOiBmdW5jdGlvbigvKkRvbU5vZGUqLyBjb250YWluZXIsIC8qT2JqZWN0Ki8gZGltLCAvKldpZGdldFtdKi8gY2hpbGRyZW4sXG5cdFx0XHRcdC8qU3RyaW5nPyovIGNoYW5nZWRSZWdpb25JZCwgLypOdW1iZXI/Ki8gY2hhbmdlZFJlZ2lvblNpemUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdExheW91dCBhIGJ1bmNoIG9mIGNoaWxkIGRvbSBub2RlcyB3aXRoaW4gYSBwYXJlbnQgZG9tIG5vZGVcblx0XHRcdC8vIGNvbnRhaW5lcjpcblx0XHRcdC8vXHRcdHBhcmVudCBub2RlXG5cdFx0XHQvLyBkaW06XG5cdFx0XHQvL1x0XHR7bCwgdCwgdywgaH0gb2JqZWN0IHNwZWNpZnlpbmcgZGltZW5zaW9ucyBvZiBjb250YWluZXIgaW50byB3aGljaCB0byBwbGFjZSBjaGlsZHJlblxuXHRcdFx0Ly8gY2hpbGRyZW46XG5cdFx0XHQvL1x0XHRBbiBhcnJheSBvZiBXaWRnZXRzIG9yIGF0IGxlYXN0IG9iamVjdHMgY29udGFpbmluZzpcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHQtIGRvbU5vZGU6IHBvaW50ZXIgdG8gRE9NIG5vZGUgdG8gcG9zaXRpb25cblx0XHRcdC8vXHRcdC0gcmVnaW9uIG9yIGxheW91dEFsaWduOiBwb3NpdGlvbiB0byBwbGFjZSBET00gbm9kZVxuXHRcdFx0Ly9cdFx0LSByZXNpemUoKTogKG9wdGlvbmFsKSBtZXRob2QgdG8gc2V0IHNpemUgb2Ygbm9kZVxuXHRcdFx0Ly9cdFx0LSBpZDogKG9wdGlvbmFsKSBJZCBvZiB3aWRnZXRzLCByZWZlcmVuY2VkIGZyb20gcmVzaXplIG9iamVjdCwgYmVsb3cuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VGhlIHdpZGdldHMgaW4gdGhpcyBhcnJheSBzaG91bGQgYmUgb3JkZXJlZCBhY2NvcmRpbmcgdG8gaG93IHRoZXkgc2hvdWxkIGJlIGxhaWQgb3V0XG5cdFx0XHQvL1x0XHQoZWFjaCBlbGVtZW50IHdpbGwgYmUgcHJvY2Vzc2VkIGluIG9yZGVyLCBhbmQgdGFrZSB1cCBhcyBtdWNoIHJlbWFpbmluZyBzcGFjZSBhcyBuZWVkZWQpLFxuXHRcdFx0Ly9cdFx0d2l0aCB0aGUgY2VudGVyIHdpZGdldCBsYXN0LlxuXHRcdFx0Ly8gY2hhbmdlZFJlZ2lvbklkOlxuXHRcdFx0Ly9cdFx0SWYgc3BlY2lmaWVkLCB0aGUgc2xpZGVyIGZvciB0aGUgcmVnaW9uIHdpdGggdGhlIHNwZWNpZmllZCBpZCBoYXMgYmVlbiBkcmFnZ2VkLCBhbmQgdGh1c1xuXHRcdFx0Ly9cdFx0dGhlIHJlZ2lvbidzIGhlaWdodCBvciB3aWR0aCBzaG91bGQgYmUgYWRqdXN0ZWQgYWNjb3JkaW5nIHRvIGNoYW5nZWRSZWdpb25TaXplXG5cdFx0XHQvLyBjaGFuZ2VkUmVnaW9uU2l6ZTpcblx0XHRcdC8vXHRcdFNlZSBjaGFuZ2VkUmVnaW9uSWQuXG5cblx0XHRcdC8vIGNvcHkgZGltIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIG1vZGlmeSBpdFxuXHRcdFx0ZGltID0gbGFuZy5taXhpbih7fSwgZGltKTtcblxuXHRcdFx0ZG9tQ2xhc3MuYWRkKGNvbnRhaW5lciwgXCJkaWppdExheW91dENvbnRhaW5lclwiKTtcblxuXHRcdFx0Ly8gTW92ZSBcImNsaWVudFwiIGVsZW1lbnRzIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IGZvciBsYXlvdXQuICBhMTF5IGRpY3RhdGVzIHRoYXQgdGhlIGF1dGhvclxuXHRcdFx0Ly8gbmVlZHMgdG8gYmUgYWJsZSB0byBwdXQgdGhlbSBpbiB0aGUgZG9jdW1lbnQgaW4gdGFiLW9yZGVyLCBidXQgdGhpcyBhbGdvcml0aG0gcmVxdWlyZXMgdGhhdFxuXHRcdFx0Ly8gY2xpZW50IGJlIGxhc3QuICAgIFRPRE86IHJlbW92ZSBmb3IgMi4wLCBhbGwgZGlqaXQgY2xpZW50IGNvZGUgYWxyZWFkeSBzZW5kcyBjaGlsZHJlbiBhcyBsYXN0IGl0ZW0uXG5cdFx0XHRjaGlsZHJlbiA9IGFycmF5LmZpbHRlcihjaGlsZHJlbiwgZnVuY3Rpb24oaXRlbSl7IHJldHVybiBpdGVtLnJlZ2lvbiAhPSBcImNlbnRlclwiICYmIGl0ZW0ubGF5b3V0QWxpZ24gIT0gXCJjbGllbnRcIjsgfSlcblx0XHRcdFx0LmNvbmNhdChhcnJheS5maWx0ZXIoY2hpbGRyZW4sIGZ1bmN0aW9uKGl0ZW0peyByZXR1cm4gaXRlbS5yZWdpb24gPT0gXCJjZW50ZXJcIiB8fCBpdGVtLmxheW91dEFsaWduID09IFwiY2xpZW50XCI7IH0pKTtcblxuXHRcdFx0Ly8gc2V0IHBvc2l0aW9ucy9zaXplc1xuXHRcdFx0YXJyYXkuZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpe1xuXHRcdFx0XHR2YXIgZWxtID0gY2hpbGQuZG9tTm9kZSxcblx0XHRcdFx0XHRwb3MgPSAoY2hpbGQucmVnaW9uIHx8IGNoaWxkLmxheW91dEFsaWduKTtcblx0XHRcdFx0aWYoIXBvcyl7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTm8gcmVnaW9uIHNldHRpbmcgZm9yIFwiICsgY2hpbGQuaWQpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzZXQgZWxlbSB0byB1cHBlciBsZWZ0IGNvcm5lciBvZiB1bnVzZWQgc3BhY2U7IG1heSBtb3ZlIGl0IGxhdGVyXG5cdFx0XHRcdHZhciBlbG1TdHlsZSA9IGVsbS5zdHlsZTtcblx0XHRcdFx0ZWxtU3R5bGUubGVmdCA9IGRpbS5sK1wicHhcIjtcblx0XHRcdFx0ZWxtU3R5bGUudG9wID0gZGltLnQrXCJweFwiO1xuXHRcdFx0XHRlbG1TdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblxuXHRcdFx0XHRkb21DbGFzcy5hZGQoZWxtLCBcImRpaml0QWxpZ25cIiArIGNhcGl0YWxpemUocG9zKSk7XG5cblx0XHRcdFx0Ly8gU2l6ZSBhZGp1c3RtZW50cyB0byBtYWtlIHRvIHRoaXMgY2hpbGQgd2lkZ2V0XG5cdFx0XHRcdHZhciBzaXplU2V0dGluZyA9IHt9O1xuXG5cdFx0XHRcdC8vIENoZWNrIGZvciBvcHRpb25hbCBzaXplIGFkanVzdG1lbnQgZHVlIHRvIHNwbGl0dGVyIGRyYWcgKGhlaWdodCBhZGp1c3RtZW50IGZvciB0b3AvYm90dG9tIGFsaWduXG5cdFx0XHRcdC8vIHBhbmVzIGFuZCB3aWR0aCBhZGp1c3RtZW50IGZvciBsZWZ0L3JpZ2h0IGFsaWduIHBhbmVzLlxuXHRcdFx0XHRpZihjaGFuZ2VkUmVnaW9uSWQgJiYgY2hhbmdlZFJlZ2lvbklkID09IGNoaWxkLmlkKXtcblx0XHRcdFx0XHRzaXplU2V0dGluZ1tjaGlsZC5yZWdpb24gPT0gXCJ0b3BcIiB8fCBjaGlsZC5yZWdpb24gPT0gXCJib3R0b21cIiA/IFwiaFwiIDogXCJ3XCJdID0gY2hhbmdlZFJlZ2lvblNpemU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihwb3MgPT0gXCJsZWFkaW5nXCIpe1xuXHRcdFx0XHRcdHBvcyA9IGNoaWxkLmlzTGVmdFRvUmlnaHQoKSA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHBvcyA9PSBcInRyYWlsaW5nXCIpe1xuXHRcdFx0XHRcdHBvcyA9IGNoaWxkLmlzTGVmdFRvUmlnaHQoKSA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2V0IHNpemUgJiYgYWRqdXN0IHJlY29yZCBvZiByZW1haW5pbmcgc3BhY2UuXG5cdFx0XHRcdC8vIG5vdGUgdGhhdCBzZXR0aW5nIHRoZSB3aWR0aCBvZiBhIDxkaXY+IG1heSBhZmZlY3QgaXRzIGhlaWdodC5cblx0XHRcdFx0aWYocG9zID09IFwidG9wXCIgfHwgcG9zID09IFwiYm90dG9tXCIpe1xuXHRcdFx0XHRcdHNpemVTZXR0aW5nLncgPSBkaW0udztcblx0XHRcdFx0XHRzaXplKGNoaWxkLCBzaXplU2V0dGluZyk7XG5cdFx0XHRcdFx0ZGltLmggLT0gY2hpbGQuaDtcblx0XHRcdFx0XHRpZihwb3MgPT0gXCJ0b3BcIil7XG5cdFx0XHRcdFx0XHRkaW0udCArPSBjaGlsZC5oO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0ZWxtU3R5bGUudG9wID0gZGltLnQgKyBkaW0uaCArIFwicHhcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1lbHNlIGlmKHBvcyA9PSBcImxlZnRcIiB8fCBwb3MgPT0gXCJyaWdodFwiKXtcblx0XHRcdFx0XHRzaXplU2V0dGluZy5oID0gZGltLmg7XG5cdFx0XHRcdFx0c2l6ZShjaGlsZCwgc2l6ZVNldHRpbmcpO1xuXHRcdFx0XHRcdGRpbS53IC09IGNoaWxkLnc7XG5cdFx0XHRcdFx0aWYocG9zID09IFwibGVmdFwiKXtcblx0XHRcdFx0XHRcdGRpbS5sICs9IGNoaWxkLnc7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRlbG1TdHlsZS5sZWZ0ID0gZGltLmwgKyBkaW0udyArIFwicHhcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1lbHNlIGlmKHBvcyA9PSBcImNsaWVudFwiIHx8IHBvcyA9PSBcImNlbnRlclwiKXtcblx0XHRcdFx0XHRzaXplKGNoaWxkLCBkaW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0bGFuZy5zZXRPYmplY3QoXCJkaWppdC5sYXlvdXQudXRpbHNcIiwgdXRpbHMpO1x0Ly8gcmVtb3ZlIGZvciAyLjBcblxuXHRyZXR1cm4gdXRpbHM7XG59KTtcbiIsImRlZmluZShbXG5cdFwiZG9qby9fYmFzZS9rZXJuZWxcIlxuXSwgZnVuY3Rpb24oZG9qbyl7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvbWFpblxuXG4vKj09PT09XG5yZXR1cm4ge1xuXHQvLyBzdW1tYXJ5OlxuXHQvL1x0XHRUaGUgZGlqaXQgcGFja2FnZSBtYWluIG1vZHVsZS5cblx0Ly9cdFx0RGVwcmVjYXRlZC4gICBVc2VycyBzaG91bGQgYWNjZXNzIGluZGl2aWR1YWwgbW9kdWxlcyAoZXg6IGRpaml0L3JlZ2lzdHJ5KSBkaXJlY3RseS5cbn07XG49PT09PSovXG5cblx0cmV0dXJuIGRvam8uZGlqaXQ7XG59KTtcbiIsImRlZmluZShbXG5cdFwiZG9qby9fYmFzZS9hcnJheVwiLCAvLyBhcnJheS5mb3JFYWNoIGFycmF5Lm1hcCBhcnJheS5zb21lXG5cdFwiZG9qby9kb20tZ2VvbWV0cnlcIiwgLy8gZG9tR2VvbWV0cnkucG9zaXRpb25cblx0XCJkb2pvL2RvbS1zdHlsZVwiLCAvLyBkb21TdHlsZS5nZXRDb21wdXRlZFN0eWxlXG5cdFwiZG9qby9fYmFzZS9rZXJuZWxcIiwgLy8ga2VybmVsLmRlcHJlY2F0ZWRcblx0XCJkb2pvL19iYXNlL3dpbmRvd1wiLCAvLyB3aW4uYm9keVxuXHRcIi4vVmlld3BvcnRcIiwgLy8gZ2V0RWZmZWN0aXZlQm94XG5cdFwiLi9tYWluXCJcdC8vIGRpaml0IChkZWZpbmluZyBkaWppdC5wbGFjZSB0byBtYXRjaCBBUEkgZG9jKVxuXSwgZnVuY3Rpb24oYXJyYXksIGRvbUdlb21ldHJ5LCBkb21TdHlsZSwga2VybmVsLCB3aW4sIFZpZXdwb3J0LCBkaWppdCl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9wbGFjZVxuXG5cblx0ZnVuY3Rpb24gX3BsYWNlKC8qRG9tTm9kZSovIG5vZGUsIGNob2ljZXMsIGxheW91dE5vZGUsIGFyb3VuZE5vZGVDb29yZHMpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0R2l2ZW4gYSBsaXN0IG9mIHNwb3RzIHRvIHB1dCBub2RlLCBwdXQgaXQgYXQgdGhlIGZpcnN0IHNwb3Qgd2hlcmUgaXQgZml0cyxcblx0XHQvL1x0XHRvZiBpZiBpdCBkb2Vzbid0IGZpdCBhbnl3aGVyZSB0aGVuIHRoZSBwbGFjZSB3aXRoIHRoZSBsZWFzdCBvdmVyZmxvd1xuXHRcdC8vIGNob2ljZXM6IEFycmF5XG5cdFx0Ly9cdFx0QXJyYXkgb2YgZWxlbWVudHMgbGlrZToge2Nvcm5lcjogJ1RMJywgcG9zOiB7eDogMTAsIHk6IDIwfSB9XG5cdFx0Ly9cdFx0QWJvdmUgZXhhbXBsZSBzYXlzIHRvIHB1dCB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBub2RlIGF0ICgxMCwyMClcblx0XHQvLyBsYXlvdXROb2RlOiBGdW5jdGlvbihub2RlLCBhcm91bmROb2RlQ29ybmVyLCBub2RlQ29ybmVyLCBzaXplKVxuXHRcdC8vXHRcdGZvciB0aGluZ3MgbGlrZSB0b29sdGlwLCB0aGV5IGFyZSBkaXNwbGF5ZWQgZGlmZmVyZW50bHkgKGFuZCBoYXZlIGRpZmZlcmVudCBkaW1lbnNpb25zKVxuXHRcdC8vXHRcdGJhc2VkIG9uIHRoZWlyIG9yaWVudGF0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQuXHQgVGhpcyBhZGp1c3RzIHRoZSBwb3B1cCBiYXNlZCBvbiBvcmllbnRhdGlvbi5cblx0XHQvL1x0XHRJdCBhbHNvIHBhc3NlcyBpbiB0aGUgYXZhaWxhYmxlIHNpemUgZm9yIHRoZSBwb3B1cCwgd2hpY2ggaXMgdXNlZnVsIGZvciB0b29sdGlwcyB0b1xuXHRcdC8vXHRcdHRlbGwgdGhlbSB0aGF0IHRoZWlyIHdpZHRoIGlzIGxpbWl0ZWQgdG8gYSBjZXJ0YWluIGFtb3VudC5cdCBsYXlvdXROb2RlKCkgbWF5IHJldHVybiBhIHZhbHVlIGV4cHJlc3Npbmdcblx0XHQvL1x0XHRob3cgbXVjaCB0aGUgcG9wdXAgaGFkIHRvIGJlIG1vZGlmaWVkIHRvIGZpdCBpbnRvIHRoZSBhdmFpbGFibGUgc3BhY2UuXHQgVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZVxuXHRcdC8vXHRcdHdoYXQgdGhlIGJlc3QgcGxhY2VtZW50IGlzLlxuXHRcdC8vIGFyb3VuZE5vZGVDb29yZHM6IE9iamVjdFxuXHRcdC8vXHRcdFNpemUgb2YgYXJvdW5kTm9kZSwgZXg6IHt3OiAyMDAsIGg6IDUwfVxuXG5cdFx0Ly8gZ2V0IHt4OiAxMCwgeTogMTAsIHc6IDEwMCwgaDoxMDB9IHR5cGUgb2JqIHJlcHJlc2VudGluZyBwb3NpdGlvbiBvZlxuXHRcdC8vIHZpZXdwb3J0IG92ZXIgZG9jdW1lbnRcblx0XHR2YXIgdmlldyA9IFZpZXdwb3J0LmdldEVmZmVjdGl2ZUJveChub2RlLm93bmVyRG9jdW1lbnQpO1xuXG5cdFx0Ly8gVGhpcyB3b24ndCB3b3JrIGlmIHRoZSBub2RlIGlzIGluc2lkZSBhIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogcmVsYXRpdmVcIj4sXG5cdFx0Ly8gc28gcmVhdHRhY2ggaXQgdG8gPGJvZHk+Llx0IChPdGhlcndpc2UsIHRoZSBwb3NpdGlvbmluZyB3aWxsIGJlIHdyb25nXG5cdFx0Ly8gYW5kIGFsc28gaXQgbWlnaHQgZ2V0IGN1dG9mZi4pXG5cdFx0aWYoIW5vZGUucGFyZW50Tm9kZSB8fCBTdHJpbmcobm9kZS5wYXJlbnROb2RlLnRhZ05hbWUpLnRvTG93ZXJDYXNlKCkgIT0gXCJib2R5XCIpe1xuXHRcdFx0d2luLmJvZHkobm9kZS5vd25lckRvY3VtZW50KS5hcHBlbmRDaGlsZChub2RlKTtcblx0XHR9XG5cblx0XHR2YXIgYmVzdCA9IG51bGw7XG5cdFx0YXJyYXkuc29tZShjaG9pY2VzLCBmdW5jdGlvbihjaG9pY2Upe1xuXHRcdFx0dmFyIGNvcm5lciA9IGNob2ljZS5jb3JuZXI7XG5cdFx0XHR2YXIgcG9zID0gY2hvaWNlLnBvcztcblx0XHRcdHZhciBvdmVyZmxvdyA9IDA7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSBhbW91bnQgb2Ygc3BhY2UgYXZhaWxhYmxlIGdpdmVuIHNwZWNpZmllZCBwb3NpdGlvbiBvZiBub2RlXG5cdFx0XHR2YXIgc3BhY2VBdmFpbGFibGUgPSB7XG5cdFx0XHRcdHc6IHtcblx0XHRcdFx0XHQnTCc6IHZpZXcubCArIHZpZXcudyAtIHBvcy54LFxuXHRcdFx0XHRcdCdSJzogcG9zLnggLSB2aWV3LmwsXG5cdFx0XHRcdFx0J00nOiB2aWV3Lndcblx0XHRcdFx0fVtjb3JuZXIuY2hhckF0KDEpXSxcblx0XHRcdFx0aDoge1xuXHRcdFx0XHRcdCdUJzogdmlldy50ICsgdmlldy5oIC0gcG9zLnksXG5cdFx0XHRcdFx0J0InOiBwb3MueSAtIHZpZXcudCxcblx0XHRcdFx0XHQnTSc6IHZpZXcuaFxuXHRcdFx0XHR9W2Nvcm5lci5jaGFyQXQoMCldXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBDbGVhciBsZWZ0L3JpZ2h0IHBvc2l0aW9uIHNldHRpbmdzIHNldCBlYXJsaWVyIHNvIHRoZXkgZG9uJ3QgaW50ZXJmZXJlIHdpdGggY2FsY3VsYXRpb25zLFxuXHRcdFx0Ly8gc3BlY2lmaWNhbGx5IHdoZW4gbGF5b3V0Tm9kZSgpIChhLmsuYS4gVG9vbHRpcC5vcmllbnQoKSkgbWVhc3VyZXMgbmF0dXJhbCB3aWR0aCBvZiBUb29sdGlwXG5cdFx0XHR2YXIgcyA9IG5vZGUuc3R5bGU7XG5cdFx0XHRzLmxlZnQgPSBzLnJpZ2h0ID0gXCJhdXRvXCI7XG5cblx0XHRcdC8vIGNvbmZpZ3VyZSBub2RlIHRvIGJlIGRpc3BsYXllZCBpbiBnaXZlbiBwb3NpdGlvbiByZWxhdGl2ZSB0byBidXR0b25cblx0XHRcdC8vIChuZWVkIHRvIGRvIHRoaXMgaW4gb3JkZXIgdG8gZ2V0IGFuIGFjY3VyYXRlIHNpemUgZm9yIHRoZSBub2RlLCBiZWNhdXNlXG5cdFx0XHQvLyBhIHRvb2x0aXAncyBzaXplIGNoYW5nZXMgYmFzZWQgb24gcG9zaXRpb24sIGR1ZSB0byB0cmlhbmdsZSlcblx0XHRcdGlmKGxheW91dE5vZGUpe1xuXHRcdFx0XHR2YXIgcmVzID0gbGF5b3V0Tm9kZShub2RlLCBjaG9pY2UuYXJvdW5kQ29ybmVyLCBjb3JuZXIsIHNwYWNlQXZhaWxhYmxlLCBhcm91bmROb2RlQ29vcmRzKTtcblx0XHRcdFx0b3ZlcmZsb3cgPSB0eXBlb2YgcmVzID09IFwidW5kZWZpbmVkXCIgPyAwIDogcmVzO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBnZXQgbm9kZSdzIHNpemVcblx0XHRcdHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG5cdFx0XHR2YXIgb2xkRGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHR2YXIgb2xkVmlzID0gc3R5bGUudmlzaWJpbGl0eTtcblx0XHRcdGlmKHN0eWxlLmRpc3BsYXkgPT0gXCJub25lXCIpe1xuXHRcdFx0XHRzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYmIgPSBkb21HZW9tZXRyeS5wb3NpdGlvbihub2RlKTtcblx0XHRcdHN0eWxlLmRpc3BsYXkgPSBvbGREaXNwbGF5O1xuXHRcdFx0c3R5bGUudmlzaWJpbGl0eSA9IG9sZFZpcztcblxuXHRcdFx0Ly8gY29vcmRpbmF0ZXMgYW5kIHNpemUgb2Ygbm9kZSB3aXRoIHNwZWNpZmllZCBjb3JuZXIgcGxhY2VkIGF0IHBvcyxcblx0XHRcdC8vIGFuZCBjbGlwcGVkIGJ5IHZpZXdwb3J0XG5cdFx0XHR2YXJcblx0XHRcdFx0c3RhcnRYcG9zID0ge1xuXHRcdFx0XHRcdCdMJzogcG9zLngsXG5cdFx0XHRcdFx0J1InOiBwb3MueCAtIGJiLncsXG5cdFx0XHRcdFx0J00nOiBNYXRoLm1heCh2aWV3LmwsIE1hdGgubWluKHZpZXcubCArIHZpZXcudywgcG9zLnggKyAoYmIudyA+PiAxKSkgLSBiYi53KSAvLyBNIG9yaWVudGF0aW9uIGlzIG1vcmUgZmxleGlibGVcblx0XHRcdFx0fVtjb3JuZXIuY2hhckF0KDEpXSxcblx0XHRcdFx0c3RhcnRZcG9zID0ge1xuXHRcdFx0XHRcdCdUJzogcG9zLnksXG5cdFx0XHRcdFx0J0InOiBwb3MueSAtIGJiLmgsXG5cdFx0XHRcdFx0J00nOiBNYXRoLm1heCh2aWV3LnQsIE1hdGgubWluKHZpZXcudCArIHZpZXcuaCwgcG9zLnkgKyAoYmIuaCA+PiAxKSkgLSBiYi5oKVxuXHRcdFx0XHR9W2Nvcm5lci5jaGFyQXQoMCldLFxuXHRcdFx0XHRzdGFydFggPSBNYXRoLm1heCh2aWV3LmwsIHN0YXJ0WHBvcyksXG5cdFx0XHRcdHN0YXJ0WSA9IE1hdGgubWF4KHZpZXcudCwgc3RhcnRZcG9zKSxcblx0XHRcdFx0ZW5kWCA9IE1hdGgubWluKHZpZXcubCArIHZpZXcudywgc3RhcnRYcG9zICsgYmIudyksXG5cdFx0XHRcdGVuZFkgPSBNYXRoLm1pbih2aWV3LnQgKyB2aWV3LmgsIHN0YXJ0WXBvcyArIGJiLmgpLFxuXHRcdFx0XHR3aWR0aCA9IGVuZFggLSBzdGFydFgsXG5cdFx0XHRcdGhlaWdodCA9IGVuZFkgLSBzdGFydFk7XG5cblx0XHRcdG92ZXJmbG93ICs9IChiYi53IC0gd2lkdGgpICsgKGJiLmggLSBoZWlnaHQpO1xuXG5cdFx0XHRpZihiZXN0ID09IG51bGwgfHwgb3ZlcmZsb3cgPCBiZXN0Lm92ZXJmbG93KXtcblx0XHRcdFx0YmVzdCA9IHtcblx0XHRcdFx0XHRjb3JuZXI6IGNvcm5lcixcblx0XHRcdFx0XHRhcm91bmRDb3JuZXI6IGNob2ljZS5hcm91bmRDb3JuZXIsXG5cdFx0XHRcdFx0eDogc3RhcnRYLFxuXHRcdFx0XHRcdHk6IHN0YXJ0WSxcblx0XHRcdFx0XHR3OiB3aWR0aCxcblx0XHRcdFx0XHRoOiBoZWlnaHQsXG5cdFx0XHRcdFx0b3ZlcmZsb3c6IG92ZXJmbG93LFxuXHRcdFx0XHRcdHNwYWNlQXZhaWxhYmxlOiBzcGFjZUF2YWlsYWJsZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gIW92ZXJmbG93O1xuXHRcdH0pO1xuXG5cdFx0Ly8gSW4gY2FzZSB0aGUgYmVzdCBwb3NpdGlvbiBpcyBub3QgdGhlIGxhc3Qgb25lIHdlIGNoZWNrZWQsIG5lZWQgdG8gY2FsbFxuXHRcdC8vIGxheW91dE5vZGUoKSBhZ2Fpbi5cblx0XHRpZihiZXN0Lm92ZXJmbG93ICYmIGxheW91dE5vZGUpe1xuXHRcdFx0bGF5b3V0Tm9kZShub2RlLCBiZXN0LmFyb3VuZENvcm5lciwgYmVzdC5jb3JuZXIsIGJlc3Quc3BhY2VBdmFpbGFibGUsIGFyb3VuZE5vZGVDb29yZHMpO1xuXHRcdH1cblxuXHRcdC8vIEFuZCB0aGVuIHBvc2l0aW9uIHRoZSBub2RlLiAgRG8gdGhpcyBsYXN0LCBhZnRlciB0aGUgbGF5b3V0Tm9kZSgpIGFib3ZlXG5cdFx0Ly8gaGFzIHNpemVkIHRoZSBub2RlLCBkdWUgdG8gYnJvd3NlciBxdWlya3Mgd2hlbiB0aGUgdmlld3BvcnQgaXMgc2Nyb2xsZWRcblx0XHQvLyAoc3BlY2lmaWNhbGx5IHRoYXQgYSBUb29sdGlwIHdpbGwgc2hyaW5rIHRvIGZpdCBhcyB0aG91Z2ggdGhlIHdpbmRvdyB3YXNcblx0XHQvLyBzY3JvbGxlZCB0byB0aGUgbGVmdCkuXG5cblx0XHR2YXIgdG9wID0gYmVzdC55LFxuXHRcdFx0c2lkZSA9IGJlc3QueCxcblx0XHRcdGJvZHkgPSB3aW4uYm9keShub2RlLm93bmVyRG9jdW1lbnQpO1xuXG5cdFx0aWYoL3JlbGF0aXZlfGFic29sdXRlLy50ZXN0KGRvbVN0eWxlLmdldChib2R5LCBcInBvc2l0aW9uXCIpKSl7XG5cdFx0XHQvLyBjb21wZW5zYXRlIGZvciBtYXJnaW4gb24gPGJvZHk+LCBzZWUgIzE2MTQ4XG5cdFx0XHR0b3AgLT0gZG9tU3R5bGUuZ2V0KGJvZHksIFwibWFyZ2luVG9wXCIpO1xuXHRcdFx0c2lkZSAtPSBkb21TdHlsZS5nZXQoYm9keSwgXCJtYXJnaW5MZWZ0XCIpO1xuXHRcdH1cblxuXHRcdHZhciBzID0gbm9kZS5zdHlsZTtcblx0XHRzLnRvcCA9IHRvcCArIFwicHhcIjtcblx0XHRzLmxlZnQgPSBzaWRlICsgXCJweFwiO1xuXHRcdHMucmlnaHQgPSBcImF1dG9cIjtcdC8vIG5lZWRlZCBmb3IgRkYgb3IgZWxzZSB0b29sdGlwIGdvZXMgdG8gZmFyIGxlZnRcblxuXHRcdHJldHVybiBiZXN0O1xuXHR9XG5cblx0dmFyIHJldmVyc2UgPSB7XG5cdFx0Ly8gTWFwIGZyb20gY29ybmVyIHRvIGtpdHR5LWNvcm5lclxuXHRcdFwiVExcIjogXCJCUlwiLFxuXHRcdFwiVFJcIjogXCJCTFwiLFxuXHRcdFwiQkxcIjogXCJUUlwiLFxuXHRcdFwiQlJcIjogXCJUTFwiXG5cdH07XG5cblx0dmFyIHBsYWNlID0ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0Q29kZSB0byBwbGFjZSBhIERPTU5vZGUgcmVsYXRpdmUgdG8gYW5vdGhlciBET01Ob2RlLlxuXHRcdC8vXHRcdExvYWQgdXNpbmcgcmVxdWlyZShbXCJkaWppdC9wbGFjZVwiXSwgZnVuY3Rpb24ocGxhY2UpeyAuLi4gfSkuXG5cblx0XHRhdDogZnVuY3Rpb24obm9kZSwgcG9zLCBjb3JuZXJzLCBwYWRkaW5nLCBsYXlvdXROb2RlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRQb3NpdGlvbnMgbm9kZSBraXR0eS1jb3JuZXIgdG8gdGhlIHJlY3RhbmdsZSBjZW50ZXJlZCBhdCAocG9zLngsIHBvcy55KSB3aXRoIHdpZHRoIGFuZCBoZWlnaHQgb2Zcblx0XHRcdC8vXHRcdHBhZGRpbmcueCAqIDIgYW5kIHBhZGRpbmcueSAqIDIsIG9yIHplcm8gaWYgcGFkZGluZyBub3Qgc3BlY2lmaWVkLiAgUGlja3MgZmlyc3QgY29ybmVyIGluIGNvcm5lcnNbXVxuXHRcdFx0Ly9cdFx0d2hlcmUgbm9kZSBpcyBmdWxseSB2aXNpYmxlLCBvciB0aGUgY29ybmVyIHdoZXJlIGl0J3MgbW9zdCB2aXNpYmxlLlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdE5vZGUgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZWx5IG9yIHJlbGF0aXZlbHkgcG9zaXRpb25lZC5cblx0XHRcdC8vIG5vZGU6IERPTU5vZGVcblx0XHRcdC8vXHRcdFRoZSBub2RlIHRvIHBvc2l0aW9uXG5cdFx0XHQvLyBwb3M6IGRpaml0L3BsYWNlLl9fUG9zaXRpb25cblx0XHRcdC8vXHRcdE9iamVjdCBsaWtlIHt4OiAxMCwgeTogMjB9XG5cdFx0XHQvLyBjb3JuZXJzOiBTdHJpbmdbXVxuXHRcdFx0Ly9cdFx0QXJyYXkgb2YgU3RyaW5ncyByZXByZXNlbnRpbmcgb3JkZXIgdG8gdHJ5IGNvcm5lcnMgb2YgdGhlIG5vZGUgaW4sIGxpa2UgW1wiVFJcIiwgXCJCTFwiXS5cblx0XHRcdC8vXHRcdFBvc3NpYmxlIHZhbHVlcyBhcmU6XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0LSBcIkJMXCIgLSBib3R0b20gbGVmdFxuXHRcdFx0Ly9cdFx0LSBcIkJSXCIgLSBib3R0b20gcmlnaHRcblx0XHRcdC8vXHRcdC0gXCJUTFwiIC0gdG9wIGxlZnRcblx0XHRcdC8vXHRcdC0gXCJUUlwiIC0gdG9wIHJpZ2h0XG5cdFx0XHQvLyBwYWRkaW5nOiBkaWppdC9wbGFjZS5fX1Bvc2l0aW9uP1xuXHRcdFx0Ly9cdFx0T3B0aW9uYWwgcGFyYW0gdG8gc2V0IHBhZGRpbmcsIHRvIHB1dCBzb21lIGJ1ZmZlciBhcm91bmQgdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcG9zaXRpb24uXG5cdFx0XHQvL1x0XHREZWZhdWx0cyB0byB6ZXJvLlxuXHRcdFx0Ly8gbGF5b3V0Tm9kZTogRnVuY3Rpb24obm9kZSwgYXJvdW5kTm9kZUNvcm5lciwgbm9kZUNvcm5lcilcblx0XHRcdC8vXHRcdEZvciB0aGluZ3MgbGlrZSB0b29sdGlwLCB0aGV5IGFyZSBkaXNwbGF5ZWQgZGlmZmVyZW50bHkgKGFuZCBoYXZlIGRpZmZlcmVudCBkaW1lbnNpb25zKVxuXHRcdFx0Ly9cdFx0YmFzZWQgb24gdGhlaXIgb3JpZW50YXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhcmVudC4gIFRoaXMgYWRqdXN0cyB0aGUgcG9wdXAgYmFzZWQgb24gb3JpZW50YXRpb24uXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0VHJ5IHRvIHBsYWNlIG5vZGUncyB0b3AgcmlnaHQgY29ybmVyIGF0ICgxMCwyMCkuXG5cdFx0XHQvL1x0XHRJZiB0aGF0IG1ha2VzIG5vZGUgZ28gKHBhcnRpYWxseSkgb2ZmIHNjcmVlbiwgdGhlbiB0cnkgcGxhY2luZ1xuXHRcdFx0Ly9cdFx0Ym90dG9tIGxlZnQgY29ybmVyIGF0ICgxMCwyMCkuXG5cdFx0XHQvL1x0fFx0cGxhY2Uobm9kZSwge3g6IDEwLCB5OiAyMH0sIFtcIlRSXCIsIFwiQkxcIl0pXG5cdFx0XHR2YXIgY2hvaWNlcyA9IGFycmF5Lm1hcChjb3JuZXJzLCBmdW5jdGlvbihjb3JuZXIpe1xuXHRcdFx0XHR2YXIgYyA9IHtcblx0XHRcdFx0XHRjb3JuZXI6IGNvcm5lcixcblx0XHRcdFx0XHRhcm91bmRDb3JuZXI6IHJldmVyc2VbY29ybmVyXSxcdC8vIHNvIFRvb2x0aXBEaWFsb2cub3JpZW50KCkgZ2V0cyBhcm91bmRDb3JuZXIgYXJndW1lbnQgc2V0XG5cdFx0XHRcdFx0cG9zOiB7eDogcG9zLngseTogcG9zLnl9XG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmKHBhZGRpbmcpe1xuXHRcdFx0XHRcdGMucG9zLnggKz0gY29ybmVyLmNoYXJBdCgxKSA9PSAnTCcgPyBwYWRkaW5nLnggOiAtcGFkZGluZy54O1xuXHRcdFx0XHRcdGMucG9zLnkgKz0gY29ybmVyLmNoYXJBdCgwKSA9PSAnVCcgPyBwYWRkaW5nLnkgOiAtcGFkZGluZy55O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBfcGxhY2Uobm9kZSwgY2hvaWNlcywgbGF5b3V0Tm9kZSk7XG5cdFx0fSxcblxuXHRcdGFyb3VuZDogZnVuY3Rpb24oXG5cdFx0XHQvKkRvbU5vZGUqL1x0XHRub2RlLFxuXHRcdFx0LypEb21Ob2RlfGRpaml0L3BsYWNlLl9fUmVjdGFuZ2xlKi8gYW5jaG9yLFxuXHRcdFx0LypTdHJpbmdbXSovXHRwb3NpdGlvbnMsXG5cdFx0XHQvKkJvb2xlYW4qL1x0XHRsZWZ0VG9SaWdodCxcblx0XHRcdC8qRnVuY3Rpb24/Ki9cdGxheW91dE5vZGUpe1xuXG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UG9zaXRpb24gbm9kZSBhZGphY2VudCBvciBraXR0eS1jb3JuZXIgdG8gYW5jaG9yXG5cdFx0XHQvL1x0XHRzdWNoIHRoYXQgaXQncyBmdWxseSB2aXNpYmxlIGluIHZpZXdwb3J0LlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRQbGFjZSBub2RlIHN1Y2ggdGhhdCBjb3JuZXIgb2Ygbm9kZSB0b3VjaGVzIGEgY29ybmVyIG9mXG5cdFx0XHQvL1x0XHRhcm91bmROb2RlLCBhbmQgdGhhdCBub2RlIGlzIGZ1bGx5IHZpc2libGUuXG5cdFx0XHQvLyBhbmNob3I6XG5cdFx0XHQvL1x0XHRFaXRoZXIgYSBET01Ob2RlIG9yIGEgcmVjdGFuZ2xlIChvYmplY3Qgd2l0aCB4LCB5LCB3aWR0aCwgaGVpZ2h0KS5cblx0XHRcdC8vIHBvc2l0aW9uczpcblx0XHRcdC8vXHRcdE9yZGVyZWQgbGlzdCBvZiBwb3NpdGlvbnMgdG8gdHJ5IG1hdGNoaW5nIHVwLlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdC0gYmVmb3JlOiBwbGFjZXMgZHJvcCBkb3duIHRvIHRoZSBsZWZ0IG9mIHRoZSBhbmNob3Igbm9kZS93aWRnZXQsIG9yIHRvIHRoZSByaWdodCBpbiB0aGUgY2FzZVxuXHRcdFx0Ly9cdFx0XHRvZiBSVEwgc2NyaXB0cyBsaWtlIEhlYnJldyBhbmQgQXJhYmljOyBhbGlnbnMgZWl0aGVyIHRoZSB0b3Agb2YgdGhlIGRyb3AgZG93blxuXHRcdFx0Ly9cdFx0XHR3aXRoIHRoZSB0b3Agb2YgdGhlIGFuY2hvciwgb3IgdGhlIGJvdHRvbSBvZiB0aGUgZHJvcCBkb3duIHdpdGggYm90dG9tIG9mIHRoZSBhbmNob3IuXG5cdFx0XHQvL1x0XHQtIGFmdGVyOiBwbGFjZXMgZHJvcCBkb3duIHRvIHRoZSByaWdodCBvZiB0aGUgYW5jaG9yIG5vZGUvd2lkZ2V0LCBvciB0byB0aGUgbGVmdCBpbiB0aGUgY2FzZVxuXHRcdFx0Ly9cdFx0XHRvZiBSVEwgc2NyaXB0cyBsaWtlIEhlYnJldyBhbmQgQXJhYmljOyBhbGlnbnMgZWl0aGVyIHRoZSB0b3Agb2YgdGhlIGRyb3AgZG93blxuXHRcdFx0Ly9cdFx0XHR3aXRoIHRoZSB0b3Agb2YgdGhlIGFuY2hvciwgb3IgdGhlIGJvdHRvbSBvZiB0aGUgZHJvcCBkb3duIHdpdGggYm90dG9tIG9mIHRoZSBhbmNob3IuXG5cdFx0XHQvL1x0XHQtIGJlZm9yZS1jZW50ZXJlZDogY2VudGVycyBkcm9wIGRvd24gdG8gdGhlIGxlZnQgb2YgdGhlIGFuY2hvciBub2RlL3dpZGdldCwgb3IgdG8gdGhlIHJpZ2h0XG5cdFx0XHQvL1x0XHRcdGluIHRoZSBjYXNlIG9mIFJUTCBzY3JpcHRzIGxpa2UgSGVicmV3IGFuZCBBcmFiaWNcblx0XHRcdC8vXHRcdC0gYWZ0ZXItY2VudGVyZWQ6IGNlbnRlcnMgZHJvcCBkb3duIHRvIHRoZSByaWdodCBvZiB0aGUgYW5jaG9yIG5vZGUvd2lkZ2V0LCBvciB0byB0aGUgbGVmdFxuXHRcdFx0Ly9cdFx0XHRpbiB0aGUgY2FzZSBvZiBSVEwgc2NyaXB0cyBsaWtlIEhlYnJldyBhbmQgQXJhYmljXG5cdFx0XHQvL1x0XHQtIGFib3ZlLWNlbnRlcmVkOiBkcm9wIGRvd24gaXMgY2VudGVyZWQgYWJvdmUgYW5jaG9yIG5vZGVcblx0XHRcdC8vXHRcdC0gYWJvdmU6IGRyb3AgZG93biBnb2VzIGFib3ZlIGFuY2hvciBub2RlLCBsZWZ0IHNpZGVzIGFsaWduZWRcblx0XHRcdC8vXHRcdC0gYWJvdmUtYWx0OiBkcm9wIGRvd24gZ29lcyBhYm92ZSBhbmNob3Igbm9kZSwgcmlnaHQgc2lkZXMgYWxpZ25lZFxuXHRcdFx0Ly9cdFx0LSBiZWxvdy1jZW50ZXJlZDogZHJvcCBkb3duIGlzIGNlbnRlcmVkIGFib3ZlIGFuY2hvciBub2RlXG5cdFx0XHQvL1x0XHQtIGJlbG93OiBkcm9wIGRvd24gZ29lcyBiZWxvdyBhbmNob3Igbm9kZVxuXHRcdFx0Ly9cdFx0LSBiZWxvdy1hbHQ6IGRyb3AgZG93biBnb2VzIGJlbG93IGFuY2hvciBub2RlLCByaWdodCBzaWRlcyBhbGlnbmVkXG5cdFx0XHQvLyBsYXlvdXROb2RlOiBGdW5jdGlvbihub2RlLCBhcm91bmROb2RlQ29ybmVyLCBub2RlQ29ybmVyKVxuXHRcdFx0Ly9cdFx0Rm9yIHRoaW5ncyBsaWtlIHRvb2x0aXAsIHRoZXkgYXJlIGRpc3BsYXllZCBkaWZmZXJlbnRseSAoYW5kIGhhdmUgZGlmZmVyZW50IGRpbWVuc2lvbnMpXG5cdFx0XHQvL1x0XHRiYXNlZCBvbiB0aGVpciBvcmllbnRhdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFyZW50Llx0IFRoaXMgYWRqdXN0cyB0aGUgcG9wdXAgYmFzZWQgb24gb3JpZW50YXRpb24uXG5cdFx0XHQvLyBsZWZ0VG9SaWdodDpcblx0XHRcdC8vXHRcdFRydWUgaWYgd2lkZ2V0IGlzIExUUiwgZmFsc2UgaWYgd2lkZ2V0IGlzIFJUTC4gICBBZmZlY3RzIHRoZSBiZWhhdmlvciBvZiBcImFib3ZlXCIgYW5kIFwiYmVsb3dcIlxuXHRcdFx0Ly9cdFx0cG9zaXRpb25zIHNsaWdodGx5LlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHRwbGFjZUFyb3VuZE5vZGUobm9kZSwgYXJvdW5kTm9kZSwgWydiZWxvdycsICdhYm92ZS1hbHQnXSk7XG5cdFx0XHQvL1x0XHRUaGlzIHdpbGwgdHJ5IHRvIHBvc2l0aW9uIG5vZGUgc3VjaCB0aGF0IG5vZGUncyB0b3AtbGVmdCBjb3JuZXIgaXMgYXQgdGhlIHNhbWUgcG9zaXRpb25cblx0XHRcdC8vXHRcdGFzIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIGFyb3VuZE5vZGUgKGllLCBwdXQgbm9kZSBiZWxvd1xuXHRcdFx0Ly9cdFx0YXJvdW5kTm9kZSwgd2l0aCBsZWZ0IGVkZ2VzIGFsaWduZWQpLlx0SWYgdGhhdCBmYWlscyBpdCB3aWxsIHRyeSB0byBwdXRcblx0XHRcdC8vXHRcdHRoZSBib3R0b20tcmlnaHQgY29ybmVyIG9mIG5vZGUgd2hlcmUgdGhlIHRvcCByaWdodCBjb3JuZXIgb2YgYXJvdW5kTm9kZSBpc1xuXHRcdFx0Ly9cdFx0KGllLCBwdXQgbm9kZSBhYm92ZSBhcm91bmROb2RlLCB3aXRoIHJpZ2h0IGVkZ2VzIGFsaWduZWQpXG5cdFx0XHQvL1xuXG5cdFx0XHQvLyBJZiBhcm91bmQgaXMgYSBET01Ob2RlIChvciBET01Ob2RlIGlkKSwgY29udmVydCB0byBjb29yZGluYXRlcy5cblx0XHRcdHZhciBhcm91bmROb2RlUG9zO1xuXHRcdFx0aWYodHlwZW9mIGFuY2hvciA9PSBcInN0cmluZ1wiIHx8IFwib2Zmc2V0V2lkdGhcIiBpbiBhbmNob3IgfHwgXCJvd25lclNWR0VsZW1lbnRcIiBpbiBhbmNob3Ipe1xuXHRcdFx0XHRhcm91bmROb2RlUG9zID0gZG9tR2VvbWV0cnkucG9zaXRpb24oYW5jaG9yLCB0cnVlKTtcblxuXHRcdFx0XHQvLyBGb3IgYWJvdmUgYW5kIGJlbG93IGRyb3Bkb3ducywgc3VidHJhY3Qgd2lkdGggb2YgYm9yZGVyIHNvIHRoYXQgcG9wdXAgYW5kIGFyb3VuZE5vZGUgYm9yZGVyc1xuXHRcdFx0XHQvLyBvdmVybGFwLCBwcmV2ZW50aW5nIGEgZG91YmxlLWJvcmRlciBlZmZlY3QuICBVbmZvcnR1bmF0ZWx5LCBkaWZmaWN1bHQgdG8gbWVhc3VyZSB0aGUgYm9yZGVyXG5cdFx0XHRcdC8vIHdpZHRoIG9mIGVpdGhlciBhbmNob3Igb3IgcG9wdXAgYmVjYXVzZSBpbiBib3RoIGNhc2VzIHRoZSBib3JkZXIgbWF5IGJlIG9uIGFuIGlubmVyIG5vZGUuXG5cdFx0XHRcdGlmKC9eKGFib3ZlfGJlbG93KS8udGVzdChwb3NpdGlvbnNbMF0pKXtcblx0XHRcdFx0XHR2YXIgYW5jaG9yQm9yZGVyID0gZG9tR2VvbWV0cnkuZ2V0Qm9yZGVyRXh0ZW50cyhhbmNob3IpLFxuXHRcdFx0XHRcdFx0YW5jaG9yQ2hpbGRCb3JkZXIgPSBhbmNob3IuZmlyc3RDaGlsZCA/IGRvbUdlb21ldHJ5LmdldEJvcmRlckV4dGVudHMoYW5jaG9yLmZpcnN0Q2hpbGQpIDoge3Q6MCxsOjAsYjowLHI6MH0sXG5cdFx0XHRcdFx0XHRub2RlQm9yZGVyID0gIGRvbUdlb21ldHJ5LmdldEJvcmRlckV4dGVudHMobm9kZSksXG5cdFx0XHRcdFx0XHRub2RlQ2hpbGRCb3JkZXIgPSBub2RlLmZpcnN0Q2hpbGQgPyBkb21HZW9tZXRyeS5nZXRCb3JkZXJFeHRlbnRzKG5vZGUuZmlyc3RDaGlsZCkgOiB7dDowLGw6MCxiOjAscjowfTtcblx0XHRcdFx0XHRhcm91bmROb2RlUG9zLnkgKz0gTWF0aC5taW4oYW5jaG9yQm9yZGVyLnQgKyBhbmNob3JDaGlsZEJvcmRlci50LCBub2RlQm9yZGVyLnQgKyBub2RlQ2hpbGRCb3JkZXIudCk7XG5cdFx0XHRcdFx0YXJvdW5kTm9kZVBvcy5oIC09ICBNYXRoLm1pbihhbmNob3JCb3JkZXIudCArIGFuY2hvckNoaWxkQm9yZGVyLnQsIG5vZGVCb3JkZXIudCsgbm9kZUNoaWxkQm9yZGVyLnQpICtcblx0XHRcdFx0XHRcdE1hdGgubWluKGFuY2hvckJvcmRlci5iICsgYW5jaG9yQ2hpbGRCb3JkZXIuYiwgbm9kZUJvcmRlci5iICsgbm9kZUNoaWxkQm9yZGVyLmIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0YXJvdW5kTm9kZVBvcyA9IGFuY2hvcjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcHV0ZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB2aXNpYmxlIHBhcnQgb2YgYW5jaG9yIChpdCBtYXkgYmUgcGFydGlhbGx5IGhpZGRlbiBieSBhbmNlc3RvciBub2RlcyB3L3Njcm9sbGJhcnMpXG5cdFx0XHRpZihhbmNob3IucGFyZW50Tm9kZSl7XG5cdFx0XHRcdC8vIGlnbm9yZSBub2RlcyBiZXR3ZWVuIHBvc2l0aW9uOnJlbGF0aXZlIGFuZCBwb3NpdGlvbjphYnNvbHV0ZVxuXHRcdFx0XHR2YXIgc2F3UG9zQWJzb2x1dGUgPSBkb21TdHlsZS5nZXRDb21wdXRlZFN0eWxlKGFuY2hvcikucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiO1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gYW5jaG9yLnBhcmVudE5vZGU7XG5cdFx0XHRcdHdoaWxlKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQubm9kZU5hbWUgIT0gXCJCT0RZXCIpeyAgLy9pZ25vcmluZyB0aGUgYm9keSB3aWxsIGhlbHAgcGVyZm9ybWFuY2Vcblx0XHRcdFx0XHR2YXIgcGFyZW50UG9zID0gZG9tR2VvbWV0cnkucG9zaXRpb24ocGFyZW50LCB0cnVlKSxcblx0XHRcdFx0XHRcdHBjcyA9IGRvbVN0eWxlLmdldENvbXB1dGVkU3R5bGUocGFyZW50KTtcblx0XHRcdFx0XHRpZigvcmVsYXRpdmV8YWJzb2x1dGUvLnRlc3QocGNzLnBvc2l0aW9uKSl7XG5cdFx0XHRcdFx0XHRzYXdQb3NBYnNvbHV0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZighc2F3UG9zQWJzb2x1dGUgJiYgL2hpZGRlbnxhdXRvfHNjcm9sbC8udGVzdChwY3Mub3ZlcmZsb3cpKXtcblx0XHRcdFx0XHRcdHZhciBib3R0b21ZQ29vcmQgPSBNYXRoLm1pbihhcm91bmROb2RlUG9zLnkgKyBhcm91bmROb2RlUG9zLmgsIHBhcmVudFBvcy55ICsgcGFyZW50UG9zLmgpO1xuXHRcdFx0XHRcdFx0dmFyIHJpZ2h0WENvb3JkID0gTWF0aC5taW4oYXJvdW5kTm9kZVBvcy54ICsgYXJvdW5kTm9kZVBvcy53LCBwYXJlbnRQb3MueCArIHBhcmVudFBvcy53KTtcblx0XHRcdFx0XHRcdGFyb3VuZE5vZGVQb3MueCA9IE1hdGgubWF4KGFyb3VuZE5vZGVQb3MueCwgcGFyZW50UG9zLngpO1xuXHRcdFx0XHRcdFx0YXJvdW5kTm9kZVBvcy55ID0gTWF0aC5tYXgoYXJvdW5kTm9kZVBvcy55LCBwYXJlbnRQb3MueSk7XG5cdFx0XHRcdFx0XHRhcm91bmROb2RlUG9zLmggPSBib3R0b21ZQ29vcmQgLSBhcm91bmROb2RlUG9zLnk7XG5cdFx0XHRcdFx0XHRhcm91bmROb2RlUG9zLncgPSByaWdodFhDb29yZCAtIGFyb3VuZE5vZGVQb3MueDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYocGNzLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIil7XG5cdFx0XHRcdFx0XHRzYXdQb3NBYnNvbHV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciB4ID0gYXJvdW5kTm9kZVBvcy54LFxuXHRcdFx0XHR5ID0gYXJvdW5kTm9kZVBvcy55LFxuXHRcdFx0XHR3aWR0aCA9IFwid1wiIGluIGFyb3VuZE5vZGVQb3MgPyBhcm91bmROb2RlUG9zLncgOiAoYXJvdW5kTm9kZVBvcy53ID0gYXJvdW5kTm9kZVBvcy53aWR0aCksXG5cdFx0XHRcdGhlaWdodCA9IFwiaFwiIGluIGFyb3VuZE5vZGVQb3MgPyBhcm91bmROb2RlUG9zLmggOiAoa2VybmVsLmRlcHJlY2F0ZWQoXCJwbGFjZS5hcm91bmQ6IGRpaml0L3BsYWNlLl9fUmVjdGFuZ2xlOiB7IHg6XCIreCtcIiwgeTpcIit5K1wiLCBoZWlnaHQ6XCIrYXJvdW5kTm9kZVBvcy5oZWlnaHQrXCIsIHdpZHRoOlwiK3dpZHRoK1wiIH0gaGFzIGJlZW4gZGVwcmVjYXRlZC4gIFBsZWFzZSB1c2UgeyB4OlwiK3grXCIsIHk6XCIreStcIiwgaDpcIithcm91bmROb2RlUG9zLmhlaWdodCtcIiwgdzpcIit3aWR0aCtcIiB9XCIsIFwiXCIsIFwiMi4wXCIpLCBhcm91bmROb2RlUG9zLmggPSBhcm91bmROb2RlUG9zLmhlaWdodCk7XG5cblx0XHRcdC8vIENvbnZlcnQgcG9zaXRpb25zIGFyZ3VtZW50cyBpbnRvIGNob2ljZXMgYXJndW1lbnQgZm9yIF9wbGFjZSgpXG5cdFx0XHR2YXIgY2hvaWNlcyA9IFtdO1xuXHRcdFx0ZnVuY3Rpb24gcHVzaChhcm91bmRDb3JuZXIsIGNvcm5lcil7XG5cdFx0XHRcdGNob2ljZXMucHVzaCh7XG5cdFx0XHRcdFx0YXJvdW5kQ29ybmVyOiBhcm91bmRDb3JuZXIsXG5cdFx0XHRcdFx0Y29ybmVyOiBjb3JuZXIsXG5cdFx0XHRcdFx0cG9zOiB7XG5cdFx0XHRcdFx0XHR4OiB7XG5cdFx0XHRcdFx0XHRcdCdMJzogeCxcblx0XHRcdFx0XHRcdFx0J1InOiB4ICsgd2lkdGgsXG5cdFx0XHRcdFx0XHRcdCdNJzogeCArICh3aWR0aCA+PiAxKVxuXHRcdFx0XHRcdFx0fVthcm91bmRDb3JuZXIuY2hhckF0KDEpXSxcblx0XHRcdFx0XHRcdHk6IHtcblx0XHRcdFx0XHRcdFx0J1QnOiB5LFxuXHRcdFx0XHRcdFx0XHQnQic6IHkgKyBoZWlnaHQsXG5cdFx0XHRcdFx0XHRcdCdNJzogeSArIChoZWlnaHQgPj4gMSlcblx0XHRcdFx0XHRcdH1bYXJvdW5kQ29ybmVyLmNoYXJBdCgwKV1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0XHRhcnJheS5mb3JFYWNoKHBvc2l0aW9ucywgZnVuY3Rpb24ocG9zKXtcblx0XHRcdFx0dmFyIGx0ciA9ICBsZWZ0VG9SaWdodDtcblx0XHRcdFx0c3dpdGNoKHBvcyl7XG5cdFx0XHRcdFx0Y2FzZSBcImFib3ZlLWNlbnRlcmVkXCI6XG5cdFx0XHRcdFx0XHRwdXNoKFwiVE1cIiwgXCJCTVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJiZWxvdy1jZW50ZXJlZFwiOlxuXHRcdFx0XHRcdFx0cHVzaChcIkJNXCIsIFwiVE1cIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiYWZ0ZXItY2VudGVyZWRcIjpcblx0XHRcdFx0XHRcdGx0ciA9ICFsdHI7XG5cdFx0XHRcdFx0XHQvLyBmYWxsIHRocm91Z2hcblx0XHRcdFx0XHRjYXNlIFwiYmVmb3JlLWNlbnRlcmVkXCI6XG5cdFx0XHRcdFx0XHRwdXNoKGx0ciA/IFwiTUxcIiA6IFwiTVJcIiwgbHRyID8gXCJNUlwiIDogXCJNTFwiKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJhZnRlclwiOlxuXHRcdFx0XHRcdFx0bHRyID0gIWx0cjtcblx0XHRcdFx0XHRcdC8vIGZhbGwgdGhyb3VnaFxuXHRcdFx0XHRcdGNhc2UgXCJiZWZvcmVcIjpcblx0XHRcdFx0XHRcdHB1c2gobHRyID8gXCJUTFwiIDogXCJUUlwiLCBsdHIgPyBcIlRSXCIgOiBcIlRMXCIpO1xuXHRcdFx0XHRcdFx0cHVzaChsdHIgPyBcIkJMXCIgOiBcIkJSXCIsIGx0ciA/IFwiQlJcIiA6IFwiQkxcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiYmVsb3ctYWx0XCI6XG5cdFx0XHRcdFx0XHRsdHIgPSAhbHRyO1xuXHRcdFx0XHRcdFx0Ly8gZmFsbCB0aHJvdWdoXG5cdFx0XHRcdFx0Y2FzZSBcImJlbG93XCI6XG5cdFx0XHRcdFx0XHQvLyBmaXJzdCB0cnkgdG8gYWxpZ24gbGVmdCBib3JkZXJzLCBuZXh0IHRyeSB0byBhbGlnbiByaWdodCBib3JkZXJzIChvciByZXZlcnNlIGZvciBSVEwgbW9kZSlcblx0XHRcdFx0XHRcdHB1c2gobHRyID8gXCJCTFwiIDogXCJCUlwiLCBsdHIgPyBcIlRMXCIgOiBcIlRSXCIpO1xuXHRcdFx0XHRcdFx0cHVzaChsdHIgPyBcIkJSXCIgOiBcIkJMXCIsIGx0ciA/IFwiVFJcIiA6IFwiVExcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiYWJvdmUtYWx0XCI6XG5cdFx0XHRcdFx0XHRsdHIgPSAhbHRyO1xuXHRcdFx0XHRcdFx0Ly8gZmFsbCB0aHJvdWdoXG5cdFx0XHRcdFx0Y2FzZSBcImFib3ZlXCI6XG5cdFx0XHRcdFx0XHQvLyBmaXJzdCB0cnkgdG8gYWxpZ24gbGVmdCBib3JkZXJzLCBuZXh0IHRyeSB0byBhbGlnbiByaWdodCBib3JkZXJzIChvciByZXZlcnNlIGZvciBSVEwgbW9kZSlcblx0XHRcdFx0XHRcdHB1c2gobHRyID8gXCJUTFwiIDogXCJUUlwiLCBsdHIgPyBcIkJMXCIgOiBcIkJSXCIpO1xuXHRcdFx0XHRcdFx0cHVzaChsdHIgPyBcIlRSXCIgOiBcIlRMXCIsIGx0ciA/IFwiQlJcIiA6IFwiQkxcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Ly8gVG8gYXNzaXN0IGRpaml0L19iYXNlL3BsYWNlLCBhY2NlcHQgYXJndW1lbnRzIG9mIHR5cGUge2Fyb3VuZENvcm5lcjogXCJCTFwiLCBjb3JuZXI6IFwiVExcIn0uXG5cdFx0XHRcdFx0XHQvLyBOb3QgbWVhbnQgdG8gYmUgdXNlZCBkaXJlY3RseS4gIFJlbW92ZSBmb3IgMi4wLlxuXHRcdFx0XHRcdFx0cHVzaChwb3MuYXJvdW5kQ29ybmVyLCBwb3MuY29ybmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHZhciBwb3NpdGlvbiA9IF9wbGFjZShub2RlLCBjaG9pY2VzLCBsYXlvdXROb2RlLCB7dzogd2lkdGgsIGg6IGhlaWdodH0pO1xuXHRcdFx0cG9zaXRpb24uYXJvdW5kTm9kZVBvcyA9IGFyb3VuZE5vZGVQb3M7XG5cblx0XHRcdHJldHVybiBwb3NpdGlvbjtcblx0XHR9XG5cdH07XG5cblx0Lyo9PT09PVxuXHRwbGFjZS5fX1Bvc2l0aW9uID0ge1xuXHRcdC8vIHg6IEludGVnZXJcblx0XHQvL1x0XHRob3Jpem9udGFsIGNvb3JkaW5hdGUgaW4gcGl4ZWxzLCByZWxhdGl2ZSB0byBkb2N1bWVudCBib2R5XG5cdFx0Ly8geTogSW50ZWdlclxuXHRcdC8vXHRcdHZlcnRpY2FsIGNvb3JkaW5hdGUgaW4gcGl4ZWxzLCByZWxhdGl2ZSB0byBkb2N1bWVudCBib2R5XG5cdH07XG5cdHBsYWNlLl9fUmVjdGFuZ2xlID0ge1xuXHRcdC8vIHg6IEludGVnZXJcblx0XHQvL1x0XHRob3Jpem9udGFsIG9mZnNldCBpbiBwaXhlbHMsIHJlbGF0aXZlIHRvIGRvY3VtZW50IGJvZHlcblx0XHQvLyB5OiBJbnRlZ2VyXG5cdFx0Ly9cdFx0dmVydGljYWwgb2Zmc2V0IGluIHBpeGVscywgcmVsYXRpdmUgdG8gZG9jdW1lbnQgYm9keVxuXHRcdC8vIHc6IEludGVnZXJcblx0XHQvL1x0XHR3aWR0aCBpbiBwaXhlbHMuICAgQ2FuIGFsc28gYmUgc3BlY2lmaWVkIGFzIFwid2lkdGhcIiBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkuXG5cdFx0Ly8gaDogSW50ZWdlclxuXHRcdC8vXHRcdGhlaWdodCBpbiBwaXhlbHMuICAgQ2FuIGFsc28gYmUgc3BlY2lmaWVkIGFzIFwiaGVpZ2h0XCIgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LlxuXHR9O1xuXHQ9PT09PSovXG5cblx0cmV0dXJuIGRpaml0LnBsYWNlID0gcGxhY2U7XHQvLyBzZXR0aW5nIGRpaml0LnBsYWNlIGZvciBiYWNrLWNvbXBhdCwgcmVtb3ZlIGZvciAyLjBcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCJkb2pvL19iYXNlL2FycmF5XCIsIC8vIGFycmF5LmZvckVhY2ggYXJyYXkubWFwXG5cdFwiZG9qby9fYmFzZS93aW5kb3dcIiwgLy8gd2luLmJvZHlcblx0XCIuL21haW5cIlx0Ly8gZGlqaXQuX3Njb3BlTmFtZVxuXSwgZnVuY3Rpb24oYXJyYXksIHdpbiwgZGlqaXQpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvcmVnaXN0cnlcblxuXHR2YXIgX3dpZGdldFR5cGVDdHIgPSB7fSwgaGFzaCA9IHt9O1xuXG5cdHZhciByZWdpc3RyeSA9ICB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRSZWdpc3RyeSBvZiBleGlzdGluZyB3aWRnZXQgb24gcGFnZSwgcGx1cyBzb21lIHV0aWxpdHkgbWV0aG9kcy5cblxuXHRcdC8vIGxlbmd0aDogTnVtYmVyXG5cdFx0Ly9cdFx0TnVtYmVyIG9mIHJlZ2lzdGVyZWQgd2lkZ2V0c1xuXHRcdGxlbmd0aDogMCxcblxuXHRcdGFkZDogZnVuY3Rpb24od2lkZ2V0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBZGQgYSB3aWRnZXQgdG8gdGhlIHJlZ2lzdHJ5LiBJZiBhIGR1cGxpY2F0ZSBJRCBpcyBkZXRlY3RlZCwgYSBlcnJvciBpcyB0aHJvd24uXG5cdFx0XHQvLyB3aWRnZXQ6IGRpaml0L19XaWRnZXRCYXNlXG5cdFx0XHQvL1x0XHRBbnkgZGlqaXQvX1dpZGdldEJhc2Ugc3ViY2xhc3MuXG5cdFx0XHRpZihoYXNoW3dpZGdldC5pZF0pe1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byByZWdpc3RlciB3aWRnZXQgd2l0aCBpZD09XCIgKyB3aWRnZXQuaWQgKyBcIiBidXQgdGhhdCBpZCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7XG5cdFx0XHR9XG5cdFx0XHRoYXNoW3dpZGdldC5pZF0gPSB3aWRnZXQ7XG5cdFx0XHR0aGlzLmxlbmd0aCsrO1xuXHRcdH0sXG5cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKC8qU3RyaW5nKi8gaWQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlbW92ZSBhIHdpZGdldCBmcm9tIHRoZSByZWdpc3RyeS4gRG9lcyBub3QgZGVzdHJveSB0aGUgd2lkZ2V0OyBzaW1wbHlcblx0XHRcdC8vXHRcdHJlbW92ZXMgdGhlIHJlZmVyZW5jZS5cblx0XHRcdGlmKGhhc2hbaWRdKXtcblx0XHRcdFx0ZGVsZXRlIGhhc2hbaWRdO1xuXHRcdFx0XHR0aGlzLmxlbmd0aC0tO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRieUlkOiBmdW5jdGlvbigvKlN0cmluZ3xXaWRnZXQqLyBpZCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RmluZCBhIHdpZGdldCBieSBpdCdzIGlkLlxuXHRcdFx0Ly9cdFx0SWYgcGFzc2VkIGEgd2lkZ2V0IHRoZW4ganVzdCByZXR1cm5zIHRoZSB3aWRnZXQuXG5cdFx0XHRyZXR1cm4gdHlwZW9mIGlkID09IFwic3RyaW5nXCIgPyBoYXNoW2lkXSA6IGlkO1x0Ly8gZGlqaXQvX1dpZGdldEJhc2Vcblx0XHR9LFxuXG5cdFx0YnlOb2RlOiBmdW5jdGlvbigvKkRPTU5vZGUqLyBub2RlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRoZSB3aWRnZXQgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gRE9NTm9kZVxuXHRcdFx0cmV0dXJuIGhhc2hbbm9kZS5nZXRBdHRyaWJ1dGUoXCJ3aWRnZXRJZFwiKV07IC8vIGRpaml0L19XaWRnZXRCYXNlXG5cdFx0fSxcblxuXHRcdHRvQXJyYXk6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q29udmVydCByZWdpc3RyeSBpbnRvIGEgdHJ1ZSBBcnJheVxuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRXb3JrIHdpdGggdGhlIHdpZGdldCAuZG9tTm9kZXMgaW4gYSByZWFsIEFycmF5XG5cdFx0XHQvL1x0XHR8XHRhcnJheS5tYXAocmVnaXN0cnkudG9BcnJheSgpLCBmdW5jdGlvbih3KXsgcmV0dXJuIHcuZG9tTm9kZTsgfSk7XG5cblx0XHRcdHZhciBhciA9IFtdO1xuXHRcdFx0Zm9yKHZhciBpZCBpbiBoYXNoKXtcblx0XHRcdFx0YXIucHVzaChoYXNoW2lkXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXI7XHQvLyBkaWppdC9fV2lkZ2V0QmFzZVtdXG5cdFx0fSxcblxuXHRcdGdldFVuaXF1ZUlkOiBmdW5jdGlvbigvKlN0cmluZyovd2lkZ2V0VHlwZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0R2VuZXJhdGVzIGEgdW5pcXVlIGlkIGZvciBhIGdpdmVuIHdpZGdldFR5cGVcblxuXHRcdFx0dmFyIGlkO1xuXHRcdFx0ZG97XG5cdFx0XHRcdGlkID0gd2lkZ2V0VHlwZSArIFwiX1wiICtcblx0XHRcdFx0XHQod2lkZ2V0VHlwZSBpbiBfd2lkZ2V0VHlwZUN0ciA/XG5cdFx0XHRcdFx0XHQrK193aWRnZXRUeXBlQ3RyW3dpZGdldFR5cGVdIDogX3dpZGdldFR5cGVDdHJbd2lkZ2V0VHlwZV0gPSAwKTtcblx0XHRcdH13aGlsZShoYXNoW2lkXSk7XG5cdFx0XHRyZXR1cm4gZGlqaXQuX3Njb3BlTmFtZSA9PSBcImRpaml0XCIgPyBpZCA6IGRpaml0Ll9zY29wZU5hbWUgKyBcIl9cIiArIGlkOyAvLyBTdHJpbmdcblx0XHR9LFxuXG5cdFx0ZmluZFdpZGdldHM6IGZ1bmN0aW9uKHJvb3QsIHNraXBOb2RlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRTZWFyY2ggc3VidHJlZSB1bmRlciByb290IHJldHVybmluZyB3aWRnZXRzIGZvdW5kLlxuXHRcdFx0Ly9cdFx0RG9lc24ndCBzZWFyY2ggZm9yIG5lc3RlZCB3aWRnZXRzIChpZSwgd2lkZ2V0cyBpbnNpZGUgb3RoZXIgd2lkZ2V0cykuXG5cdFx0XHQvLyByb290OiBET01Ob2RlXG5cdFx0XHQvL1x0XHROb2RlIHRvIHNlYXJjaCB1bmRlci5cblx0XHRcdC8vIHNraXBOb2RlOiBET01Ob2RlXG5cdFx0XHQvL1x0XHRJZiBzcGVjaWZpZWQsIGRvbid0IHNlYXJjaCBiZW5lYXRoIHRoaXMgbm9kZSAodXN1YWxseSBjb250YWluZXJOb2RlKS5cblxuXHRcdFx0dmFyIG91dEFyeSA9IFtdO1xuXG5cdFx0XHRmdW5jdGlvbiBnZXRDaGlsZHJlbkhlbHBlcihyb290KXtcblx0XHRcdFx0Zm9yKHZhciBub2RlID0gcm9vdC5maXJzdENoaWxkOyBub2RlOyBub2RlID0gbm9kZS5uZXh0U2libGluZyl7XG5cdFx0XHRcdFx0aWYobm9kZS5ub2RlVHlwZSA9PSAxKXtcblx0XHRcdFx0XHRcdHZhciB3aWRnZXRJZCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwid2lkZ2V0SWRcIik7XG5cdFx0XHRcdFx0XHRpZih3aWRnZXRJZCl7XG5cdFx0XHRcdFx0XHRcdHZhciB3aWRnZXQgPSBoYXNoW3dpZGdldElkXTtcblx0XHRcdFx0XHRcdFx0aWYod2lkZ2V0KXtcdC8vIG1heSBiZSBudWxsIG9uIHBhZ2Ugdy9tdWx0aXBsZSBkb2pvJ3MgbG9hZGVkXG5cdFx0XHRcdFx0XHRcdFx0b3V0QXJ5LnB1c2god2lkZ2V0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fWVsc2UgaWYobm9kZSAhPT0gc2tpcE5vZGUpe1xuXHRcdFx0XHRcdFx0XHRnZXRDaGlsZHJlbkhlbHBlcihub2RlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Z2V0Q2hpbGRyZW5IZWxwZXIocm9vdCk7XG5cdFx0XHRyZXR1cm4gb3V0QXJ5O1xuXHRcdH0sXG5cblx0XHRfZGVzdHJveUFsbDogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDb2RlIHRvIGRlc3Ryb3kgYWxsIHdpZGdldHMgYW5kIGRvIG90aGVyIGNsZWFudXAgb24gcGFnZSB1bmxvYWRcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgZm9jdXMgbWFuYWdlciBsaW5nZXJpbmcgcmVmZXJlbmNlcyB0byB3aWRnZXRzIGFuZCBub2Rlc1xuXHRcdFx0ZGlqaXQuX2N1ckZvY3VzID0gbnVsbDtcblx0XHRcdGRpaml0Ll9wcmV2Rm9jdXMgPSBudWxsO1xuXHRcdFx0ZGlqaXQuX2FjdGl2ZVN0YWNrID0gW107XG5cblx0XHRcdC8vIERlc3Ryb3kgYWxsIHRoZSB3aWRnZXRzLCB0b3AgZG93blxuXHRcdFx0YXJyYXkuZm9yRWFjaChyZWdpc3RyeS5maW5kV2lkZ2V0cyh3aW4uYm9keSgpKSwgZnVuY3Rpb24od2lkZ2V0KXtcblx0XHRcdFx0Ly8gQXZvaWQgZG91YmxlIGRlc3Ryb3kgb2Ygd2lkZ2V0cyBsaWtlIE1lbnUgdGhhdCBhcmUgYXR0YWNoZWQgdG8gPGJvZHk+XG5cdFx0XHRcdC8vIGV2ZW4gdGhvdWdoIHRoZXkgYXJlIGxvZ2ljYWxseSBjaGlsZHJlbiBvZiBvdGhlciB3aWRnZXRzLlxuXHRcdFx0XHRpZighd2lkZ2V0Ll9kZXN0cm95ZWQpe1xuXHRcdFx0XHRcdGlmKHdpZGdldC5kZXN0cm95UmVjdXJzaXZlKXtcblx0XHRcdFx0XHRcdHdpZGdldC5kZXN0cm95UmVjdXJzaXZlKCk7XG5cdFx0XHRcdFx0fWVsc2UgaWYod2lkZ2V0LmRlc3Ryb3kpe1xuXHRcdFx0XHRcdFx0d2lkZ2V0LmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRnZXRFbmNsb3NpbmdXaWRnZXQ6IGZ1bmN0aW9uKC8qRE9NTm9kZSovIG5vZGUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIHdpZGdldCB3aG9zZSBET00gdHJlZSBjb250YWlucyB0aGUgc3BlY2lmaWVkIERPTU5vZGUsIG9yIG51bGwgaWZcblx0XHRcdC8vXHRcdHRoZSBub2RlIGlzIG5vdCBjb250YWluZWQgd2l0aGluIHRoZSBET00gdHJlZSBvZiBhbnkgd2lkZ2V0XG5cdFx0XHR3aGlsZShub2RlKXtcblx0XHRcdFx0dmFyIGlkID0gbm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuZ2V0QXR0cmlidXRlKFwid2lkZ2V0SWRcIik7XG5cdFx0XHRcdGlmKGlkKXtcblx0XHRcdFx0XHRyZXR1cm4gaGFzaFtpZF07XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cblx0XHQvLyBJbiBjYXNlIHNvbWVvbmUgbmVlZHMgdG8gYWNjZXNzIGhhc2guXG5cdFx0Ly8gQWN0dWFsbHksIHRoaXMgaXMgYWNjZXNzZWQgZnJvbSBXaWRnZXRTZXQgYmFjay1jb21wYXRpYmlsaXR5IGNvZGVcblx0XHRfaGFzaDogaGFzaFxuXHR9O1xuXG5cdGRpaml0LnJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG5cblx0cmV0dXJuIHJlZ2lzdHJ5O1xufSk7XG4iLCIvKlxyXG4gKiAoQykgQ29weXJpZ2h0IElCTSBDb3JwLiAyMDEyLCAyMDE2IEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSB1bmRlZmluZWQ7XHJcbiIsImRlZmluZShbXCJkb2pvL2kxOG5cIiwgXCJFOi9kb2pvLXdlYnBhY2svbm9kZV9tb2R1bGVzL2Rvam8td2VicGFjay1wbHVnaW4vbG9hZGVycy9kb2pvL3J1bm5lci5qc1wiXG4sXCJFOi9kb2pvLXdlYnBhY2svbm9kZV9tb2R1bGVzL2Rpaml0L2Zvcm0vbmxzL2VzL3ZhbGlkYXRlLmpzP2Fic01pZD1kaWppdC9mb3JtL25scy9lcy92YWxpZGF0ZVwiXG4sXCJFOi9kb2pvLXdlYnBhY2svbm9kZV9tb2R1bGVzL2Rpaml0L2Zvcm0vbmxzL2ZyL3ZhbGlkYXRlLmpzP2Fic01pZD1kaWppdC9mb3JtL25scy9mci92YWxpZGF0ZVwiXG4sXCJFOi9kb2pvLXdlYnBhY2svbm9kZV9tb2R1bGVzL2Rpaml0L2Zvcm0vbmxzL3ZhbGlkYXRlLmpzP2Fic01pZD1kaWppdC9mb3JtL25scy92YWxpZGF0ZVwiXG5dLCBmdW5jdGlvbihsb2FkZXIsIHJ1bm5lcikge1xuICAgcmV0dXJuIHJ1bm5lcihsb2FkZXIsIFwiZGlqaXQvZm9ybS9ubHMvdmFsaWRhdGVcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5kai5jKCksIGZhbHNlKTtcbn0pOyIsIi8qXG4gKiAoQykgQ29weXJpZ2h0IEhDTCBUZWNobm9sb2dpZXMgTHRkLiAyMDE5XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5kZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gZnVuY3Rpb24obGRyLCBuYW1lLCByZXEsIGFzeW5jKSB7XG5cdFx0dmFyIHJlc29sdmVGbiwgcmVzdWx0LCByZXN1bHRTZXQ7XG5cdFx0bGRyLmxvYWQobmFtZSwgIHJlcSwgZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0cmVzdWx0ID0gZGF0YTtcblx0XHRcdHJlc3VsdFNldCA9IHRydWU7XG5cdFx0XHRpZiAocmVzb2x2ZUZuKSB7XG5cdFx0XHRcdHJlc29sdmVGbihkYXRhKTtcblx0XHRcdH1cblx0XHR9LCB7aXNCdWlsZDp0cnVlfSk7XG5cdFx0aWYgKHJlc3VsdFNldCkge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9IGVsc2UgaWYgKCFhc3luYykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKG5hbWUgKyAnIHVuYXZhaWxhYmxlJyk7XG5cdFx0fVxuXHRcdHJlc3VsdCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0XHRcdHJlc29sdmVGbiA9IHJlc29sdmU7XG5cdFx0fSk7XG5cdFx0cmVzdWx0Ll9fRE9KT19XRUJQQUNLX0RFRklORV9QUk9NSVNFX18gPSB0cnVlO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJkaWppdCBkaWppdFJlc2V0IGRpaml0SW5saW5lIGRpaml0TGVmdFxcXCIgaWQ9XFxcIndpZGdldF8ke2lkfVxcXCIgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIlxcblxcdD48ZGl2IGNsYXNzPVxcXCJkaWppdFJlc2V0IGRpaml0SW5wdXRGaWVsZCBkaWppdElucHV0Q29udGFpbmVyXFxcIlxcblxcdFxcdD48aW5wdXQgY2xhc3M9XFxcImRpaml0UmVzZXQgZGlqaXRJbnB1dElubmVyXFxcIiBkYXRhLWRvam8tYXR0YWNoLXBvaW50PSd0ZXh0Ym94LGZvY3VzTm9kZScgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiXFxuXFx0XFx0XFx0JHshbmFtZUF0dHJTZXR0aW5nfSB0eXBlPScke3R5cGV9J1xcblxcdC8+PC9kaXZcXG4+PC9kaXY+XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiZGlqaXQgZGlqaXRSZXNldCBkaWppdElubGluZSBkaWppdExlZnRcXFwiXFxuXFx0aWQ9XFxcIndpZGdldF8ke2lkfVxcXCIgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIlxcblxcdD48ZGl2IGNsYXNzPSdkaWppdFJlc2V0IGRpaml0VmFsaWRhdGlvbkNvbnRhaW5lcidcXG5cXHRcXHQ+PGlucHV0IGNsYXNzPVxcXCJkaWppdFJlc2V0IGRpaml0SW5wdXRGaWVsZCBkaWppdFZhbGlkYXRpb25JY29uIGRpaml0VmFsaWRhdGlvbklubmVyXFxcIiB2YWx1ZT1cXFwiJiM5MzU7IFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgdGFiSW5kZXg9XFxcIi0xXFxcIiByZWFkb25seT1cXFwicmVhZG9ubHlcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCJcXG5cXHQvPjwvZGl2XFxuXFx0PjxkaXYgY2xhc3M9XFxcImRpaml0UmVzZXQgZGlqaXRJbnB1dEZpZWxkIGRpaml0SW5wdXRDb250YWluZXJcXFwiXFxuXFx0XFx0PjxpbnB1dCBjbGFzcz1cXFwiZGlqaXRSZXNldCBkaWppdElucHV0SW5uZXJcXFwiIGRhdGEtZG9qby1hdHRhY2gtcG9pbnQ9J3RleHRib3gsZm9jdXNOb2RlJyBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCJcXG5cXHRcXHRcXHQkeyFuYW1lQXR0clNldHRpbmd9IHR5cGU9JyR7dHlwZX0nXFxuXFx0Lz48L2Rpdlxcbj48L2Rpdj5cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJkaWppdFRvb2x0aXAgZGlqaXRUb29sdGlwTGVmdFxcXCIgaWQ9XFxcImRvam9Ub29sdGlwXFxcIiBkYXRhLWRvam8tYXR0YWNoLWV2ZW50PVxcXCJtb3VzZWVudGVyOm9uTW91c2VFbnRlcixtb3VzZWxlYXZlOm9uTW91c2VMZWF2ZVxcXCJcXG5cXHQ+PGRpdiBjbGFzcz1cXFwiZGlqaXRUb29sdGlwQ29ubmVjdG9yXFxcIiBkYXRhLWRvam8tYXR0YWNoLXBvaW50PVxcXCJjb25uZWN0b3JOb2RlXFxcIj48L2RpdlxcblxcdD48ZGl2IGNsYXNzPVxcXCJkaWppdFRvb2x0aXBDb250YWluZXIgZGlqaXRUb29sdGlwQ29udGVudHNcXFwiIGRhdGEtZG9qby1hdHRhY2gtcG9pbnQ9XFxcImNvbnRhaW5lck5vZGVcXFwiIHJvbGU9J2FsZXJ0Jz48L2Rpdlxcbj48L2Rpdj5cXG5cIiIsImRlZmluZShbXG5cdFwiLi9oYXNcIixcblx0XCIuL19iYXNlL2xhbmdcIixcblx0XCIuL2Vycm9ycy9DYW5jZWxFcnJvclwiLFxuXHRcIi4vcHJvbWlzZS9Qcm9taXNlXCIsXG5cdFwiLi9oYXMhY29uZmlnLWRlZmVycmVkSW5zdHJ1bWVudGF0aW9uPy4vcHJvbWlzZS9pbnN0cnVtZW50YXRpb25cIlxuXSwgZnVuY3Rpb24oaGFzLCBsYW5nLCBDYW5jZWxFcnJvciwgUHJvbWlzZSwgaW5zdHJ1bWVudGF0aW9uKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL0RlZmVycmVkXG5cblx0dmFyIFBST0dSRVNTID0gMCxcblx0XHRcdFJFU09MVkVEID0gMSxcblx0XHRcdFJFSkVDVEVEID0gMjtcblx0dmFyIEZVTEZJTExFRF9FUlJPUl9NRVNTQUdFID0gXCJUaGlzIGRlZmVycmVkIGhhcyBhbHJlYWR5IGJlZW4gZnVsZmlsbGVkLlwiO1xuXG5cdHZhciBmcmVlemVPYmplY3QgPSBPYmplY3QuZnJlZXplIHx8IGZ1bmN0aW9uKCl7fTtcblxuXHR2YXIgc2lnbmFsV2FpdGluZyA9IGZ1bmN0aW9uKHdhaXRpbmcsIHR5cGUsIHJlc3VsdCwgcmVqZWN0aW9uLCBkZWZlcnJlZCl7XG5cdFx0aWYoaGFzKFwiY29uZmlnLWRlZmVycmVkSW5zdHJ1bWVudGF0aW9uXCIpKXtcblx0XHRcdGlmKHR5cGUgPT09IFJFSkVDVEVEICYmIERlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZCAmJiB3YWl0aW5nLmxlbmd0aCA9PT0gMCl7XG5cdFx0XHRcdERlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZChyZXN1bHQsIGZhbHNlLCByZWplY3Rpb24sIGRlZmVycmVkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgd2FpdGluZy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRzaWduYWxMaXN0ZW5lcih3YWl0aW5nW2ldLCB0eXBlLCByZXN1bHQsIHJlamVjdGlvbik7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBzaWduYWxMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyLCB0eXBlLCByZXN1bHQsIHJlamVjdGlvbil7XG5cdFx0dmFyIGZ1bmMgPSBsaXN0ZW5lclt0eXBlXTtcblx0XHR2YXIgZGVmZXJyZWQgPSBsaXN0ZW5lci5kZWZlcnJlZDtcblx0XHRpZihmdW5jKXtcblx0XHRcdHRyeXtcblx0XHRcdFx0dmFyIG5ld1Jlc3VsdCA9IGZ1bmMocmVzdWx0KTtcblx0XHRcdFx0aWYodHlwZSA9PT0gUFJPR1JFU1Mpe1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBuZXdSZXN1bHQgIT09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdFx0c2lnbmFsRGVmZXJyZWQoZGVmZXJyZWQsIHR5cGUsIG5ld1Jlc3VsdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRpZihuZXdSZXN1bHQgJiYgdHlwZW9mIG5ld1Jlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0XHRcdFx0bGlzdGVuZXIuY2FuY2VsID0gbmV3UmVzdWx0LmNhbmNlbDtcblx0XHRcdFx0XHRcdG5ld1Jlc3VsdC50aGVuKFxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbWFrZSByZXNvbHZlcnMgaWYgdGhleSdyZSBhY3R1YWxseSBnb2luZyB0byBiZSB1c2VkXG5cdFx0XHRcdFx0XHRcdFx0bWFrZURlZmVycmVkU2lnbmFsZXIoZGVmZXJyZWQsIFJFU09MVkVEKSxcblx0XHRcdFx0XHRcdFx0XHRtYWtlRGVmZXJyZWRTaWduYWxlcihkZWZlcnJlZCwgUkVKRUNURUQpLFxuXHRcdFx0XHRcdFx0XHRcdG1ha2VEZWZlcnJlZFNpZ25hbGVyKGRlZmVycmVkLCBQUk9HUkVTUykpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzaWduYWxEZWZlcnJlZChkZWZlcnJlZCwgUkVTT0xWRUQsIG5ld1Jlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1jYXRjaChlcnJvcil7XG5cdFx0XHRcdHNpZ25hbERlZmVycmVkKGRlZmVycmVkLCBSRUpFQ1RFRCwgZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH1lbHNle1xuXHRcdFx0c2lnbmFsRGVmZXJyZWQoZGVmZXJyZWQsIHR5cGUsIHJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0aWYoaGFzKFwiY29uZmlnLWRlZmVycmVkSW5zdHJ1bWVudGF0aW9uXCIpKXtcblx0XHRcdGlmKHR5cGUgPT09IFJFSkVDVEVEICYmIERlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZCl7XG5cdFx0XHRcdERlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZChyZXN1bHQsICEhZnVuYywgcmVqZWN0aW9uLCBkZWZlcnJlZC5wcm9taXNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0dmFyIG1ha2VEZWZlcnJlZFNpZ25hbGVyID0gZnVuY3Rpb24oZGVmZXJyZWQsIHR5cGUpe1xuXHRcdHJldHVybiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0XHRzaWduYWxEZWZlcnJlZChkZWZlcnJlZCwgdHlwZSwgdmFsdWUpO1xuXHRcdH07XG5cdH07XG5cblx0dmFyIHNpZ25hbERlZmVycmVkID0gZnVuY3Rpb24oZGVmZXJyZWQsIHR5cGUsIHJlc3VsdCl7XG5cdFx0aWYoIWRlZmVycmVkLmlzQ2FuY2VsZWQoKSl7XG5cdFx0XHRzd2l0Y2godHlwZSl7XG5cdFx0XHRcdGNhc2UgUFJPR1JFU1M6XG5cdFx0XHRcdFx0ZGVmZXJyZWQucHJvZ3Jlc3MocmVzdWx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBSRVNPTFZFRDpcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUkVKRUNURUQ6XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KHJlc3VsdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBEZWZlcnJlZCA9IGZ1bmN0aW9uKGNhbmNlbGVyKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENyZWF0ZXMgYSBuZXcgZGVmZXJyZWQuIFRoaXMgQVBJIGlzIHByZWZlcnJlZCBvdmVyXG5cdFx0Ly9cdFx0YGRvam8vX2Jhc2UvRGVmZXJyZWRgLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdENyZWF0ZXMgYSBuZXcgZGVmZXJyZWQsIGFzIGFuIGFic3RyYWN0aW9uIG92ZXIgKHByaW1hcmlseSlcblx0XHQvL1x0XHRhc3luY2hyb25vdXMgb3BlcmF0aW9ucy4gVGhlIGRlZmVycmVkIGlzIHRoZSBwcml2YXRlIGludGVyZmFjZVxuXHRcdC8vXHRcdHRoYXQgc2hvdWxkIG5vdCBiZSByZXR1cm5lZCB0byBjYWxsaW5nIGNvZGUuIFRoYXQncyB3aGF0IHRoZVxuXHRcdC8vXHRcdGBwcm9taXNlYCBpcyBmb3IuIFNlZSBgZG9qby9wcm9taXNlL1Byb21pc2VgLlxuXHRcdC8vIGNhbmNlbGVyOiBGdW5jdGlvbj9cblx0XHQvL1x0XHRXaWxsIGJlIGludm9rZWQgaWYgdGhlIGRlZmVycmVkIGlzIGNhbmNlbGVkLiBUaGUgY2FuY2VsZXJcblx0XHQvL1x0XHRyZWNlaXZlcyB0aGUgcmVhc29uIHRoZSBkZWZlcnJlZCB3YXMgY2FuY2VsZWQgYXMgaXRzIGFyZ3VtZW50LlxuXHRcdC8vXHRcdFRoZSBkZWZlcnJlZCBpcyByZWplY3RlZCB3aXRoIGl0cyByZXR1cm4gdmFsdWUsIG9yIGEgbmV3XG5cdFx0Ly9cdFx0YGRvam8vZXJyb3JzL0NhbmNlbEVycm9yYCBpbnN0YW5jZS5cblxuXHRcdC8vIHByb21pc2U6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdFx0Ly9cdFx0VGhlIHB1YmxpYyBwcm9taXNlIG9iamVjdCB0aGF0IGNsaWVudHMgY2FuIGFkZCBjYWxsYmFja3MgdG8uIFxuXHRcdHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKTtcblxuXHRcdHZhciBkZWZlcnJlZCA9IHRoaXM7XG5cdFx0dmFyIGZ1bGZpbGxlZCwgcmVzdWx0LCByZWplY3Rpb247XG5cdFx0dmFyIGNhbmNlbGVkID0gZmFsc2U7XG5cdFx0dmFyIHdhaXRpbmcgPSBbXTtcblxuXHRcdGlmKGhhcyhcImNvbmZpZy1kZWZlcnJlZEluc3RydW1lbnRhdGlvblwiKSAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSl7XG5cdFx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShkZWZlcnJlZCwgRGVmZXJyZWQpO1xuXHRcdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UocHJvbWlzZSwgRGVmZXJyZWQpO1xuXHRcdH1cblxuXHRcdHRoaXMuaXNSZXNvbHZlZCA9IHByb21pc2UuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIHdoZXRoZXIgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkLlxuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXG5cdFx0XHRyZXR1cm4gZnVsZmlsbGVkID09PSBSRVNPTFZFRDtcblx0XHR9O1xuXG5cdFx0dGhpcy5pc1JlamVjdGVkID0gcHJvbWlzZS5pc1JlamVjdGVkID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDaGVja3Mgd2hldGhlciB0aGUgZGVmZXJyZWQgaGFzIGJlZW4gcmVqZWN0ZWQuXG5cdFx0XHQvLyByZXR1cm5zOiBCb29sZWFuXG5cblx0XHRcdHJldHVybiBmdWxmaWxsZWQgPT09IFJFSkVDVEVEO1xuXHRcdH07XG5cblx0XHR0aGlzLmlzRnVsZmlsbGVkID0gcHJvbWlzZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIHdoZXRoZXIgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlxuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXG5cdFx0XHRyZXR1cm4gISFmdWxmaWxsZWQ7XG5cdFx0fTtcblxuXHRcdHRoaXMuaXNDYW5jZWxlZCA9IHByb21pc2UuaXNDYW5jZWxlZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIHdoZXRoZXIgdGhlIGRlZmVycmVkIGhhcyBiZWVuIGNhbmNlbGVkLlxuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXG5cdFx0XHRyZXR1cm4gY2FuY2VsZWQ7XG5cdFx0fTtcblxuXHRcdHRoaXMucHJvZ3Jlc3MgPSBmdW5jdGlvbih1cGRhdGUsIHN0cmljdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RW1pdCBhIHByb2dyZXNzIHVwZGF0ZSBvbiB0aGUgZGVmZXJyZWQuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEVtaXQgYSBwcm9ncmVzcyB1cGRhdGUgb24gdGhlIGRlZmVycmVkLiBQcm9ncmVzcyB1cGRhdGVzXG5cdFx0XHQvL1x0XHRjYW4gYmUgdXNlZCB0byBjb21tdW5pY2F0ZSB1cGRhdGVzIGFib3V0IHRoZSBhc3luY2hyb25vdXNcblx0XHRcdC8vXHRcdG9wZXJhdGlvbiBiZWZvcmUgaXQgaGFzIGZpbmlzaGVkLlxuXHRcdFx0Ly8gdXBkYXRlOiBhbnlcblx0XHRcdC8vXHRcdFRoZSBwcm9ncmVzcyB1cGRhdGUuIFBhc3NlZCB0byBwcm9nYmFja3MuXG5cdFx0XHQvLyBzdHJpY3Q6IEJvb2xlYW4/XG5cdFx0XHQvL1x0XHRJZiBzdHJpY3QsIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGRlZmVycmVkIGhhcyBhbHJlYWR5XG5cdFx0XHQvL1x0XHRiZWVuIGZ1bGZpbGxlZCBhbmQgY29uc2VxdWVudGx5IG5vIHByb2dyZXNzIGNhbiBiZSBlbWl0dGVkLlxuXHRcdFx0Ly8gcmV0dXJuczogZG9qby9wcm9taXNlL1Byb21pc2Vcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIG9yaWdpbmFsIHByb21pc2UgZm9yIHRoZSBkZWZlcnJlZC5cblxuXHRcdFx0aWYoIWZ1bGZpbGxlZCl7XG5cdFx0XHRcdHNpZ25hbFdhaXRpbmcod2FpdGluZywgUFJPR1JFU1MsIHVwZGF0ZSwgbnVsbCwgZGVmZXJyZWQpO1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH1lbHNlIGlmKHN0cmljdCA9PT0gdHJ1ZSl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihGVUxGSUxMRURfRVJST1JfTUVTU0FHRSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlc29sdmUgdGhlIGRlZmVycmVkLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRSZXNvbHZlIHRoZSBkZWZlcnJlZCwgcHV0dGluZyBpdCBpbiBhIHN1Y2Nlc3Mgc3RhdGUuXG5cdFx0XHQvLyB2YWx1ZTogYW55XG5cdFx0XHQvL1x0XHRUaGUgcmVzdWx0IG9mIHRoZSBkZWZlcnJlZC4gUGFzc2VkIHRvIGNhbGxiYWNrcy5cblx0XHRcdC8vIHN0cmljdDogQm9vbGVhbj9cblx0XHRcdC8vXHRcdElmIHN0cmljdCwgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZGVmZXJyZWQgaGFzIGFscmVhZHlcblx0XHRcdC8vXHRcdGJlZW4gZnVsZmlsbGVkIGFuZCBjb25zZXF1ZW50bHkgY2Fubm90IGJlIHJlc29sdmVkLlxuXHRcdFx0Ly8gcmV0dXJuczogZG9qby9wcm9taXNlL1Byb21pc2Vcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIG9yaWdpbmFsIHByb21pc2UgZm9yIHRoZSBkZWZlcnJlZC5cblxuXHRcdFx0aWYoIWZ1bGZpbGxlZCl7XG5cdFx0XHRcdC8vIFNldCBmdWxmaWxsZWQsIHN0b3JlIHZhbHVlLiBBZnRlciBzaWduYWxpbmcgd2FpdGluZyBsaXN0ZW5lcnMgdW5zZXRcblx0XHRcdFx0Ly8gd2FpdGluZy5cblx0XHRcdFx0c2lnbmFsV2FpdGluZyh3YWl0aW5nLCBmdWxmaWxsZWQgPSBSRVNPTFZFRCwgcmVzdWx0ID0gdmFsdWUsIG51bGwsIGRlZmVycmVkKTtcblx0XHRcdFx0d2FpdGluZyA9IG51bGw7XG5cdFx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdFx0fWVsc2UgaWYoc3RyaWN0ID09PSB0cnVlKXtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKEZVTEZJTExFRF9FUlJPUl9NRVNTQUdFKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIHJlamVjdCA9IHRoaXMucmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IsIHN0cmljdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVqZWN0IHRoZSBkZWZlcnJlZC5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0UmVqZWN0IHRoZSBkZWZlcnJlZCwgcHV0dGluZyBpdCBpbiBhbiBlcnJvciBzdGF0ZS5cblx0XHRcdC8vIGVycm9yOiBhbnlcblx0XHRcdC8vXHRcdFRoZSBlcnJvciByZXN1bHQgb2YgdGhlIGRlZmVycmVkLiBQYXNzZWQgdG8gZXJyYmFja3MuXG5cdFx0XHQvLyBzdHJpY3Q6IEJvb2xlYW4/XG5cdFx0XHQvL1x0XHRJZiBzdHJpY3QsIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGRlZmVycmVkIGhhcyBhbHJlYWR5XG5cdFx0XHQvL1x0XHRiZWVuIGZ1bGZpbGxlZCBhbmQgY29uc2VxdWVudGx5IGNhbm5vdCBiZSByZWplY3RlZC5cblx0XHRcdC8vIHJldHVybnM6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRoZSBvcmlnaW5hbCBwcm9taXNlIGZvciB0aGUgZGVmZXJyZWQuXG5cblx0XHRcdGlmKCFmdWxmaWxsZWQpe1xuXHRcdFx0XHRpZihoYXMoXCJjb25maWctZGVmZXJyZWRJbnN0cnVtZW50YXRpb25cIikgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Upe1xuXHRcdFx0XHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHJlamVjdGlvbiA9IHt9LCByZWplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNpZ25hbFdhaXRpbmcod2FpdGluZywgZnVsZmlsbGVkID0gUkVKRUNURUQsIHJlc3VsdCA9IGVycm9yLCByZWplY3Rpb24sIGRlZmVycmVkKTtcblx0XHRcdFx0d2FpdGluZyA9IG51bGw7XG5cdFx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdFx0fWVsc2UgaWYoc3RyaWN0ID09PSB0cnVlKXtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKEZVTEZJTExFRF9FUlJPUl9NRVNTQUdFKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy50aGVuID0gcHJvbWlzZS50aGVuID0gZnVuY3Rpb24oY2FsbGJhY2ssIGVycmJhY2ssIHByb2diYWNrKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBZGQgbmV3IGNhbGxiYWNrcyB0byB0aGUgZGVmZXJyZWQuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEFkZCBuZXcgY2FsbGJhY2tzIHRvIHRoZSBkZWZlcnJlZC4gQ2FsbGJhY2tzIGNhbiBiZSBhZGRlZFxuXHRcdFx0Ly9cdFx0YmVmb3JlIG9yIGFmdGVyIHRoZSBkZWZlcnJlZCBpcyBmdWxmaWxsZWQuXG5cdFx0XHQvLyBjYWxsYmFjazogRnVuY3Rpb24/XG5cdFx0XHQvL1x0XHRDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQuXG5cdFx0XHQvL1x0XHRSZWNlaXZlcyB0aGUgcmVzb2x1dGlvbiB2YWx1ZS5cblx0XHRcdC8vIGVycmJhY2s6IEZ1bmN0aW9uP1xuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuXHRcdFx0Ly9cdFx0UmVjZWl2ZXMgdGhlIHJlamVjdGlvbiBlcnJvci5cblx0XHRcdC8vIHByb2diYWNrOiBGdW5jdGlvbj9cblx0XHRcdC8vXHRcdENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgcHJvbWlzZSBlbWl0cyBhIHByb2dyZXNzXG5cdFx0XHQvL1x0XHR1cGRhdGUuIFJlY2VpdmVzIHRoZSBwcm9ncmVzcyB1cGRhdGUuXG5cdFx0XHQvLyByZXR1cm5zOiBkb2pvL3Byb21pc2UvUHJvbWlzZVxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIG5ldyBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjayhzKS5cblx0XHRcdC8vXHRcdFRoaXMgY2FuIGJlIHVzZWQgZm9yIGNoYWluaW5nIG1hbnkgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuXG5cblx0XHRcdHZhciBsaXN0ZW5lciA9IFtwcm9nYmFjaywgY2FsbGJhY2ssIGVycmJhY2tdO1xuXHRcdFx0Ly8gRW5zdXJlIHdlIGNhbmNlbCB0aGUgcHJvbWlzZSB3ZSdyZSB3YWl0aW5nIGZvciwgb3IgaWYgY2FsbGJhY2svZXJyYmFja1xuXHRcdFx0Ly8gaGF2ZSByZXR1cm5lZCBhIHByb21pc2UsIGNhbmNlbCB0aGF0IG9uZS5cblx0XHRcdGxpc3RlbmVyLmNhbmNlbCA9IHByb21pc2UuY2FuY2VsO1xuXHRcdFx0bGlzdGVuZXIuZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoZnVuY3Rpb24ocmVhc29uKXtcblx0XHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBjYW5jZWwgaXMgcmVhbGx5IGF2YWlsYWJsZSwgcmV0dXJuZWQgcHJvbWlzZXMgYXJlIG5vdFxuXHRcdFx0XHQvLyByZXF1aXJlZCB0byBleHBvc2UgYGNhbmNlbGBcblx0XHRcdFx0cmV0dXJuIGxpc3RlbmVyLmNhbmNlbCAmJiBsaXN0ZW5lci5jYW5jZWwocmVhc29uKTtcblx0XHRcdH0pO1xuXHRcdFx0aWYoZnVsZmlsbGVkICYmICF3YWl0aW5nKXtcblx0XHRcdFx0c2lnbmFsTGlzdGVuZXIobGlzdGVuZXIsIGZ1bGZpbGxlZCwgcmVzdWx0LCByZWplY3Rpb24pO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHdhaXRpbmcucHVzaChsaXN0ZW5lcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbGlzdGVuZXIuZGVmZXJyZWQucHJvbWlzZTtcblx0XHR9O1xuXG5cdFx0dGhpcy5jYW5jZWwgPSBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uKHJlYXNvbiwgc3RyaWN0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRJbmZvcm0gdGhlIGRlZmVycmVkIGl0IG1heSBjYW5jZWwgaXRzIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEluZm9ybSB0aGUgZGVmZXJyZWQgaXQgbWF5IGNhbmNlbCBpdHMgYXN5bmNocm9ub3VzIG9wZXJhdGlvbi5cblx0XHRcdC8vXHRcdFRoZSBkZWZlcnJlZCdzIChvcHRpb25hbCkgY2FuY2VsZXIgaXMgaW52b2tlZCBhbmQgdGhlXG5cdFx0XHQvL1x0XHRkZWZlcnJlZCB3aWxsIGJlIGxlZnQgaW4gYSByZWplY3RlZCBzdGF0ZS4gQ2FuIGFmZmVjdCBvdGhlclxuXHRcdFx0Ly9cdFx0cHJvbWlzZXMgdGhhdCBvcmlnaW5hdGUgd2l0aCB0aGUgc2FtZSBkZWZlcnJlZC5cblx0XHRcdC8vIHJlYXNvbjogYW55XG5cdFx0XHQvL1x0XHRBIG1lc3NhZ2UgdGhhdCBtYXkgYmUgc2VudCB0byB0aGUgZGVmZXJyZWQncyBjYW5jZWxlcixcblx0XHRcdC8vXHRcdGV4cGxhaW5pbmcgd2h5IGl0J3MgYmVpbmcgY2FuY2VsZWQuXG5cdFx0XHQvLyBzdHJpY3Q6IEJvb2xlYW4/XG5cdFx0XHQvL1x0XHRJZiBzdHJpY3QsIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGRlZmVycmVkIGhhcyBhbHJlYWR5XG5cdFx0XHQvL1x0XHRiZWVuIGZ1bGZpbGxlZCBhbmQgY29uc2VxdWVudGx5IGNhbm5vdCBiZSBjYW5jZWxlZC5cblx0XHRcdC8vIHJldHVybnM6IGFueVxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0aGUgcmVqZWN0aW9uIHJlYXNvbiBpZiB0aGUgZGVmZXJyZWQgd2FzIGNhbmNlbGVkXG5cdFx0XHQvL1x0XHRub3JtYWxseS5cblxuXHRcdFx0aWYoIWZ1bGZpbGxlZCl7XG5cdFx0XHRcdC8vIENhbmNlbCBjYW4gYmUgY2FsbGVkIGV2ZW4gYWZ0ZXIgdGhlIGRlZmVycmVkIGlzIGZ1bGZpbGxlZFxuXHRcdFx0XHRpZihjYW5jZWxlcil7XG5cdFx0XHRcdFx0dmFyIHJldHVybmVkUmVhc29uID0gY2FuY2VsZXIocmVhc29uKTtcblx0XHRcdFx0XHRyZWFzb24gPSB0eXBlb2YgcmV0dXJuZWRSZWFzb24gPT09IFwidW5kZWZpbmVkXCIgPyByZWFzb24gOiByZXR1cm5lZFJlYXNvbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYW5jZWxlZCA9IHRydWU7XG5cdFx0XHRcdGlmKCFmdWxmaWxsZWQpe1xuXHRcdFx0XHRcdC8vIEFsbG93IGNhbmNlbGVyIHRvIHByb3ZpZGUgaXRzIG93biByZWFzb24sIGJ1dCBmYWxsIGJhY2sgdG8gYSBDYW5jZWxFcnJvclxuXHRcdFx0XHRcdGlmKHR5cGVvZiByZWFzb24gPT09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdFx0cmVhc29uID0gbmV3IENhbmNlbEVycm9yKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlamVjdChyZWFzb24pO1xuXHRcdFx0XHRcdHJldHVybiByZWFzb247XG5cdFx0XHRcdH1lbHNlIGlmKGZ1bGZpbGxlZCA9PT0gUkVKRUNURUQgJiYgcmVzdWx0ID09PSByZWFzb24pe1xuXHRcdFx0XHRcdHJldHVybiByZWFzb247XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNlIGlmKHN0cmljdCA9PT0gdHJ1ZSl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihGVUxGSUxMRURfRVJST1JfTUVTU0FHRSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZyZWV6ZU9iamVjdChwcm9taXNlKTtcblx0fTtcblxuXHREZWZlcnJlZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuXHRcdC8vIHJldHVybnM6IFN0cmluZ1xuXHRcdC8vXHRcdFJldHVybnMgYFtvYmplY3QgRGVmZXJyZWRdYC5cblxuXHRcdHJldHVybiBcIltvYmplY3QgRGVmZXJyZWRdXCI7XG5cdH07XG5cblx0aWYoaW5zdHJ1bWVudGF0aW9uKXtcblx0XHRpbnN0cnVtZW50YXRpb24oRGVmZXJyZWQpO1xuXHR9XG5cblx0cmV0dXJuIERlZmVycmVkO1xufSk7XG4iLCJkZWZpbmUoW1wiLi9hc3BlY3RcIiwgXCIuL29uXCJdLCBmdW5jdGlvbihhc3BlY3QsIG9uKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL0V2ZW50ZWRcblxuIFx0XCJ1c2Ugc3RyaWN0XCI7XG4gXHR2YXIgYWZ0ZXIgPSBhc3BlY3QuYWZ0ZXI7XG5cdGZ1bmN0aW9uIEV2ZW50ZWQoKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEEgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIG1peGluIG9yIGJhc2UgY2xhc3MsXG5cdFx0Ly9cdFx0dG8gYWRkIG9uKCkgYW5kIGVtaXQoKSBtZXRob2RzIHRvIGEgY2xhc3Ncblx0XHQvL1x0XHRmb3IgbGlzdGVuaW5nIGZvciBldmVudHMgYW5kIGVtaXR0aW5nIGV2ZW50czpcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdHxcdGRlZmluZShbXCJkb2pvL0V2ZW50ZWRcIiwgXCJkb2pvL19iYXNlL2RlY2xhcmVcIiwgXCJkb2pvL1N0YXRlZnVsXCJcblx0XHQvL1x0XHR8XHRdLCBmdW5jdGlvbihFdmVudGVkLCBkZWNsYXJlLCBTdGF0ZWZ1bCl7XG5cdFx0Ly9cdFx0fFx0XHR2YXIgRXZlbnRlZFN0YXRlZnVsID0gZGVjbGFyZShbRXZlbnRlZCwgU3RhdGVmdWxdLCB7Li4ufSk7XG5cdFx0Ly9cdFx0fFx0XHR2YXIgaW5zdGFuY2UgPSBuZXcgRXZlbnRlZFN0YXRlZnVsKCk7XG5cdFx0Ly9cdFx0fFx0XHRpbnN0YW5jZS5vbihcIm9wZW5cIiwgZnVuY3Rpb24oZXZlbnQpe1xuXHRcdC8vXHRcdHxcdFx0Li4uIGRvIHNvbWV0aGluZyB3aXRoIGV2ZW50XG5cdFx0Ly9cdFx0fFx0IH0pO1xuXHRcdC8vXHRcdHxcblx0XHQvL1x0XHR8XHRpbnN0YW5jZS5lbWl0KFwib3BlblwiLCB7bmFtZTpcInNvbWUgZXZlbnRcIiwgLi4ufSk7XG5cdH1cblx0RXZlbnRlZC5wcm90b3R5cGUgPSB7XG5cdFx0b246IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKXtcblx0XHRcdHJldHVybiBvbi5wYXJzZSh0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZnVuY3Rpb24odGFyZ2V0LCB0eXBlKXtcblx0XHRcdFx0cmV0dXJuIGFmdGVyKHRhcmdldCwgJ29uJyArIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0ZW1pdDogZnVuY3Rpb24odHlwZSwgZXZlbnQpe1xuXHRcdFx0dmFyIGFyZ3MgPSBbdGhpc107XG5cdFx0XHRhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBvbi5lbWl0LmFwcGx5KG9uLCBhcmdzKTtcblx0XHR9XG5cdH07XG5cdHJldHVybiBFdmVudGVkO1xufSk7XG4iLCJkZWZpbmUoW1wiLi9fYmFzZS9kZWNsYXJlXCIsIFwiLi9fYmFzZS9sYW5nXCIsIFwiLi9fYmFzZS9hcnJheVwiLCBcIi4vd2hlblwiXSwgZnVuY3Rpb24oZGVjbGFyZSwgbGFuZywgYXJyYXksIHdoZW4pe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vU3RhdGVmdWxcblxucmV0dXJuIGRlY2xhcmUoXCJkb2pvLlN0YXRlZnVsXCIsIG51bGwsIHtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0QmFzZSBjbGFzcyBmb3Igb2JqZWN0cyB0aGF0IHByb3ZpZGUgbmFtZWQgcHJvcGVydGllcyB3aXRoIG9wdGlvbmFsIGdldHRlci9zZXR0ZXJcblx0Ly9cdFx0Y29udHJvbCBhbmQgdGhlIGFiaWxpdHkgdG8gd2F0Y2ggZm9yIHByb3BlcnR5IGNoYW5nZXNcblx0Ly9cblx0Ly9cdFx0VGhlIGNsYXNzIGFsc28gcHJvdmlkZXMgdGhlIGZ1bmN0aW9uYWxpdHkgdG8gYXV0by1tYWdpY2FsbHkgbWFuYWdlIGdldHRlcnNcblx0Ly9cdFx0YW5kIHNldHRlcnMgZm9yIG9iamVjdCBhdHRyaWJ1dGVzL3Byb3BlcnRpZXMuXG5cdC8vXHRcdFxuXHQvL1x0XHRHZXR0ZXJzIGFuZCBTZXR0ZXJzIHNob3VsZCBmb2xsb3cgdGhlIGZvcm1hdCBvZiBfeHh4R2V0dGVyIG9yIF94eHhTZXR0ZXIgd2hlcmUgXG5cdC8vXHRcdHRoZSB4eHggaXMgYSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gaGFuZGxlLiAgU28gYW4gYXR0cmlidXRlIG9mIFwiZm9vXCIgXG5cdC8vXHRcdHdvdWxkIGhhdmUgYSBjdXN0b20gZ2V0dGVyIG9mIF9mb29HZXR0ZXIgYW5kIGEgY3VzdG9tIHNldHRlciBvZiBfZm9vU2V0dGVyLlxuXHQvL1xuXHQvLyBleGFtcGxlOlxuXHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL1N0YXRlZnVsXCIsIGZ1bmN0aW9uKFN0YXRlZnVsKSB7XG5cdC8vXHR8XHRcdHZhciBvYmogPSBuZXcgU3RhdGVmdWwoKTtcblx0Ly9cdHxcdFx0b2JqLndhdGNoKFwiZm9vXCIsIGZ1bmN0aW9uKCl7XG5cdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJmb28gY2hhbmdlZCB0byBcIiArIHRoaXMuZ2V0KFwiZm9vXCIpKTtcblx0Ly9cdHxcdFx0fSk7XG5cdC8vXHR8XHRcdG9iai5zZXQoXCJmb29cIixcImJhclwiKTtcblx0Ly9cdHxcdH0pO1xuXG5cdC8vIF9hdHRyUGFpck5hbWVzOiBIYXNoXG5cdC8vXHRcdFVzZWQgYWNyb3NzIGFsbCBpbnN0YW5jZXMgYSBoYXNoIHRvIGNhY2hlIGF0dHJpYnV0ZSBuYW1lcyBhbmQgdGhlaXIgZ2V0dGVyIFxuXHQvL1x0XHRhbmQgc2V0dGVyIG5hbWVzLlxuXHRfYXR0clBhaXJOYW1lczoge30sXG5cblx0X2dldEF0dHJOYW1lczogZnVuY3Rpb24obmFtZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRIZWxwZXIgZnVuY3Rpb24gZm9yIGdldCgpIGFuZCBzZXQoKS5cblx0XHQvL1x0XHRDYWNoZXMgYXR0cmlidXRlIG5hbWUgdmFsdWVzIHNvIHdlIGRvbid0IGRvIHRoZSBzdHJpbmcgb3BzIGV2ZXJ5IHRpbWUuXG5cdFx0Ly8gdGFnczpcblx0XHQvL1x0XHRwcml2YXRlXG5cblx0XHR2YXIgYXBuID0gdGhpcy5fYXR0clBhaXJOYW1lcztcblx0XHRpZihhcG5bbmFtZV0peyByZXR1cm4gYXBuW25hbWVdOyB9XG5cdFx0cmV0dXJuIChhcG5bbmFtZV0gPSB7XG5cdFx0XHRzOiBcIl9cIiArIG5hbWUgKyBcIlNldHRlclwiLFxuXHRcdFx0ZzogXCJfXCIgKyBuYW1lICsgXCJHZXR0ZXJcIlxuXHRcdH0pO1xuXHR9LFxuXG5cdHBvc3RzY3JpcHQ6IGZ1bmN0aW9uKC8qT2JqZWN0PyovIHBhcmFtcyl7XG5cdFx0Ly8gQXV0b21hdGljIHNldHRpbmcgb2YgcGFyYW1zIGR1cmluZyBjb25zdHJ1Y3Rpb25cblx0XHRpZiAocGFyYW1zKXsgdGhpcy5zZXQocGFyYW1zKTsgfVxuXHR9LFxuXG5cdF9nZXQ6IGZ1bmN0aW9uKG5hbWUsIG5hbWVzKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFByaXZhdGUgZnVuY3Rpb24gdGhhdCBkb2VzIGEgZ2V0IGJhc2VkIG9mZiBhIGhhc2ggb2YgbmFtZXNcblx0XHQvLyBuYW1lczpcblx0XHQvL1x0XHRIYXNoIG9mIG5hbWVzIG9mIGN1c3RvbSBhdHRyaWJ1dGVzXG5cdFx0cmV0dXJuIHR5cGVvZiB0aGlzW25hbWVzLmddID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzW25hbWVzLmddKCkgOiB0aGlzW25hbWVdO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKC8qU3RyaW5nKi9uYW1lKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEdldCBhIHByb3BlcnR5IG9uIGEgU3RhdGVmdWwgaW5zdGFuY2UuXG5cdFx0Ly8gbmFtZTpcblx0XHQvL1x0XHRUaGUgcHJvcGVydHkgdG8gZ2V0LlxuXHRcdC8vIHJldHVybnM6XG5cdFx0Ly9cdFx0VGhlIHByb3BlcnR5IHZhbHVlIG9uIHRoaXMgU3RhdGVmdWwgaW5zdGFuY2UuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0R2V0IGEgbmFtZWQgcHJvcGVydHkgb24gYSBTdGF0ZWZ1bCBvYmplY3QuIFRoZSBwcm9wZXJ0eSBtYXlcblx0XHQvL1x0XHRwb3RlbnRpYWxseSBiZSByZXRyaWV2ZWQgdmlhIGEgZ2V0dGVyIG1ldGhvZCBpbiBzdWJjbGFzc2VzLiBJbiB0aGUgYmFzZSBjbGFzc1xuXHRcdC8vXHRcdHRoaXMganVzdCByZXRyaWV2ZXMgdGhlIG9iamVjdCdzIHByb3BlcnR5LlxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9TdGF0ZWZ1bFwiLCBmdW5jdGlvbihTdGF0ZWZ1bCkge1xuXHRcdC8vXHR8XHRcdHZhciBzdGF0ZWZ1bCA9IG5ldyBTdGF0ZWZ1bCh7Zm9vOiAzfSk7XG5cdFx0Ly9cdHxcdFx0c3RhdGVmdWwuZ2V0KFwiZm9vXCIpIC8vIHJldHVybnMgM1xuXHRcdC8vXHR8XHRcdHN0YXRlZnVsLmZvbyAvLyByZXR1cm5zIDNcblx0XHQvL1x0fFx0fSk7XG5cblx0XHRyZXR1cm4gdGhpcy5fZ2V0KG5hbWUsIHRoaXMuX2dldEF0dHJOYW1lcyhuYW1lKSk7IC8vQW55XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oLypTdHJpbmcqL25hbWUsIC8qT2JqZWN0Ki92YWx1ZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZXQgYSBwcm9wZXJ0eSBvbiBhIFN0YXRlZnVsIGluc3RhbmNlXG5cdFx0Ly8gbmFtZTpcblx0XHQvL1x0XHRUaGUgcHJvcGVydHkgdG8gc2V0LlxuXHRcdC8vIHZhbHVlOlxuXHRcdC8vXHRcdFRoZSB2YWx1ZSB0byBzZXQgaW4gdGhlIHByb3BlcnR5LlxuXHRcdC8vIHJldHVybnM6XG5cdFx0Ly9cdFx0VGhlIGZ1bmN0aW9uIHJldHVybnMgdGhpcyBkb2pvLlN0YXRlZnVsIGluc3RhbmNlLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdFNldHMgbmFtZWQgcHJvcGVydGllcyBvbiBhIHN0YXRlZnVsIG9iamVjdCBhbmQgbm90aWZpZXMgYW55IHdhdGNoZXJzIG9mXG5cdFx0Ly9cdFx0dGhlIHByb3BlcnR5LiBBIHByb2dyYW1tYXRpYyBzZXR0ZXIgbWF5IGJlIGRlZmluZWQgaW4gc3ViY2xhc3Nlcy5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vU3RhdGVmdWxcIiwgZnVuY3Rpb24oU3RhdGVmdWwpIHtcblx0XHQvL1x0fFx0XHR2YXIgc3RhdGVmdWwgPSBuZXcgU3RhdGVmdWwoKTtcblx0XHQvL1x0fFx0XHRzdGF0ZWZ1bC53YXRjaChmdW5jdGlvbihuYW1lLCBvbGRWYWx1ZSwgdmFsdWUpe1xuXHRcdC8vXHR8XHRcdFx0Ly8gdGhpcyB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgc2V0IGJlbG93XG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHRcdHN0YXRlZnVsLnNldChmb28sIDUpO1xuXHRcdC8vXHRzZXQoKSBtYXkgYWxzbyBiZSBjYWxsZWQgd2l0aCBhIGhhc2ggb2YgbmFtZS92YWx1ZSBwYWlycywgZXg6XG5cdFx0Ly9cdHxcdFx0c3RhdGVmdWwuc2V0KHtcblx0XHQvL1x0fFx0XHRcdGZvbzogXCJIb3dkeVwiLFxuXHRcdC8vXHR8XHRcdFx0YmFyOiAzXG5cdFx0Ly9cdHxcdFx0fSk7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXHRUaGlzIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBzZXQoZm9vLCBcIkhvd2R5XCIpIGFuZCBzZXQoYmFyLCAzKVxuXG5cdFx0Ly8gSWYgYW4gb2JqZWN0IGlzIHVzZWQsIGl0ZXJhdGUgdGhyb3VnaCBvYmplY3Rcblx0XHRpZih0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIil7XG5cdFx0XHRmb3IodmFyIHggaW4gbmFtZSl7XG5cdFx0XHRcdGlmKG5hbWUuaGFzT3duUHJvcGVydHkoeCkgJiYgeCAhPVwiX3dhdGNoQ2FsbGJhY2tzXCIpe1xuXHRcdFx0XHRcdHRoaXMuc2V0KHgsIG5hbWVbeF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR2YXIgbmFtZXMgPSB0aGlzLl9nZXRBdHRyTmFtZXMobmFtZSksXG5cdFx0XHRvbGRWYWx1ZSA9IHRoaXMuX2dldChuYW1lLCBuYW1lcyksXG5cdFx0XHRzZXR0ZXIgPSB0aGlzW25hbWVzLnNdLFxuXHRcdFx0cmVzdWx0O1xuXHRcdGlmKHR5cGVvZiBzZXR0ZXIgPT09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHQvLyB1c2UgdGhlIGV4cGxpY2l0IHNldHRlclxuXHRcdFx0cmVzdWx0ID0gc2V0dGVyLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuXHRcdH1lbHNle1xuXHRcdFx0Ly8gbm8gc2V0dGVyIHNvIHNldCBhdHRyaWJ1dGUgZGlyZWN0bHlcblx0XHRcdHRoaXNbbmFtZV0gPSB2YWx1ZTtcblx0XHR9XG5cdFx0aWYodGhpcy5fd2F0Y2hDYWxsYmFja3Mpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0Ly8gSWYgc2V0dGVyIHJldHVybmVkIGEgcHJvbWlzZSwgd2FpdCBmb3IgaXQgdG8gY29tcGxldGUsIG90aGVyd2lzZSBjYWxsIHdhdGNoZXMgaW1tZWRpYXRlbHlcblx0XHRcdHdoZW4ocmVzdWx0LCBmdW5jdGlvbigpe1xuXHRcdFx0XHRzZWxmLl93YXRjaENhbGxiYWNrcyhuYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzOyAvLyBkb2pvL1N0YXRlZnVsXG5cdH0sXG5cdF9jaGFuZ2VBdHRyVmFsdWU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEludGVybmFsIGhlbHBlciBmb3IgZGlyZWN0bHkgY2hhbmdpbmcgYW4gYXR0cmlidXRlIHZhbHVlLlxuXHRcdC8vXG5cdFx0Ly8gbmFtZTogU3RyaW5nXG5cdFx0Ly9cdFx0VGhlIHByb3BlcnR5IHRvIHNldC5cblx0XHQvLyB2YWx1ZTogTWl4ZWRcblx0XHQvL1x0XHRUaGUgdmFsdWUgdG8gc2V0IGluIHRoZSBwcm9wZXJ0eS5cblx0XHQvL1xuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdERpcmVjdGx5IGNoYW5nZSB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIGFuIG9iamVjdCwgYnlwYXNzaW5nIGFueSBcblx0XHQvL1x0XHRhY2Nlc3NvciBzZXR0ZXIuICBBbHNvIGhhbmRsZXMgdGhlIGNhbGxpbmcgb2Ygd2F0Y2ggYW5kIGVtaXR0aW5nIGV2ZW50cy4gXG5cdFx0Ly9cdFx0SXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBieSBkZXNjZW5kYW50IGNsYXNzIHdoZW4gdGhlcmUgYXJlIHR3byB2YWx1ZXMgXG5cdFx0Ly9cdFx0b2YgYXR0cmlidXRlcyB0aGF0IGFyZSBsaW5rZWQsIGJ1dCBjYWxsaW5nIC5zZXQoKSBpcyBub3QgYXBwcm9wcmlhdGUuXG5cblx0XHR2YXIgb2xkVmFsdWUgPSB0aGlzLmdldChuYW1lKTtcblx0XHR0aGlzW25hbWVdID0gdmFsdWU7XG5cdFx0aWYodGhpcy5fd2F0Y2hDYWxsYmFja3Mpe1xuXHRcdFx0dGhpcy5fd2F0Y2hDYWxsYmFja3MobmFtZSwgb2xkVmFsdWUsIHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7IC8vIGRvam8vU3RhdGVmdWxcblx0fSxcblx0d2F0Y2g6IGZ1bmN0aW9uKC8qU3RyaW5nPyovbmFtZSwgLypGdW5jdGlvbiovY2FsbGJhY2spe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0V2F0Y2hlcyBhIHByb3BlcnR5IGZvciBjaGFuZ2VzXG5cdFx0Ly8gbmFtZTpcblx0XHQvL1x0XHRJbmRpY2F0ZXMgdGhlIHByb3BlcnR5IHRvIHdhdGNoLiBUaGlzIGlzIG9wdGlvbmFsICh0aGUgY2FsbGJhY2sgbWF5IGJlIHRoZVxuXHRcdC8vXHRcdG9ubHkgcGFyYW1ldGVyKSwgYW5kIGlmIG9taXR0ZWQsIGFsbCB0aGUgcHJvcGVydGllcyB3aWxsIGJlIHdhdGNoZWRcblx0XHQvLyByZXR1cm5zOlxuXHRcdC8vXHRcdEFuIG9iamVjdCBoYW5kbGUgZm9yIHRoZSB3YXRjaC4gVGhlIHVud2F0Y2ggbWV0aG9kIG9mIHRoaXMgb2JqZWN0XG5cdFx0Ly9cdFx0Y2FuIGJlIHVzZWQgdG8gZGlzY29udGludWUgd2F0Y2hpbmcgdGhpcyBwcm9wZXJ0eTpcblx0XHQvL1x0XHR8XHR2YXIgd2F0Y2hIYW5kbGUgPSBvYmoud2F0Y2goXCJmb29cIiwgY2FsbGJhY2spO1xuXHRcdC8vXHRcdHxcdHdhdGNoSGFuZGxlLnVud2F0Y2goKTsgLy8gY2FsbGJhY2sgd29uJ3QgYmUgY2FsbGVkIG5vd1xuXHRcdC8vIGNhbGxiYWNrOlxuXHRcdC8vXHRcdFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIHByb3BlcnR5IGNoYW5nZXMuIFRoaXMgd2lsbCBiZSBjYWxsZWQgYWZ0ZXJcblx0XHQvL1x0XHR0aGUgcHJvcGVydHkgaGFzIGJlZW4gY2hhbmdlZC4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHx0aGlzfFxuXHRcdC8vXHRcdHNldCB0byB0aGUgaW5zdGFuY2UsIHRoZSBmaXJzdCBhcmd1bWVudCBhcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHksIHRoZVxuXHRcdC8vXHRcdHNlY29uZCBhcmd1bWVudCBhcyB0aGUgb2xkIHZhbHVlIGFuZCB0aGUgdGhpcmQgYXJndW1lbnQgYXMgdGhlIG5ldyB2YWx1ZS5cblxuXHRcdHZhciBjYWxsYmFja3MgPSB0aGlzLl93YXRjaENhbGxiYWNrcztcblx0XHRpZighY2FsbGJhY2tzKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGNhbGxiYWNrcyA9IHRoaXMuX3dhdGNoQ2FsbGJhY2tzID0gZnVuY3Rpb24obmFtZSwgb2xkVmFsdWUsIHZhbHVlLCBpZ25vcmVDYXRjaGFsbCl7XG5cdFx0XHRcdHZhciBub3RpZnkgPSBmdW5jdGlvbihwcm9wZXJ0eUNhbGxiYWNrcyl7XG5cdFx0XHRcdFx0aWYocHJvcGVydHlDYWxsYmFja3Mpe1xuXHRcdFx0XHRcdFx0cHJvcGVydHlDYWxsYmFja3MgPSBwcm9wZXJ0eUNhbGxiYWNrcy5zbGljZSgpO1xuXHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMCwgbCA9IHByb3BlcnR5Q2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5Q2FsbGJhY2tzW2ldLmNhbGwoc2VsZiwgbmFtZSwgb2xkVmFsdWUsIHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdG5vdGlmeShjYWxsYmFja3NbJ18nICsgbmFtZV0pO1xuXHRcdFx0XHRpZighaWdub3JlQ2F0Y2hhbGwpe1xuXHRcdFx0XHRcdG5vdGlmeShjYWxsYmFja3NbXCIqXCJdKTsgLy8gdGhlIGNhdGNoLWFsbFxuXHRcdFx0XHR9XG5cdFx0XHR9OyAvLyB3ZSB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGFuIG9iamVjdCBzbyBpdCB3aWxsIGJlIGlnbm9yZWQgYnkgSlNPTiBjb252ZXJzaW9uXG5cdFx0fVxuXHRcdGlmKCFjYWxsYmFjayAmJiB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdGNhbGxiYWNrID0gbmFtZTtcblx0XHRcdG5hbWUgPSBcIipcIjtcblx0XHR9ZWxzZXtcblx0XHRcdC8vIHByZXBlbmQgd2l0aCBkYXNoIHRvIHByZXZlbnQgbmFtZSBjb25mbGljdHMgd2l0aCBmdW5jdGlvbiAobGlrZSBcIm5hbWVcIiBwcm9wZXJ0eSlcblx0XHRcdG5hbWUgPSAnXycgKyBuYW1lO1xuXHRcdH1cblx0XHR2YXIgcHJvcGVydHlDYWxsYmFja3MgPSBjYWxsYmFja3NbbmFtZV07XG5cdFx0aWYodHlwZW9mIHByb3BlcnR5Q2FsbGJhY2tzICE9PSBcIm9iamVjdFwiKXtcblx0XHRcdHByb3BlcnR5Q2FsbGJhY2tzID0gY2FsbGJhY2tzW25hbWVdID0gW107XG5cdFx0fVxuXHRcdHByb3BlcnR5Q2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXG5cdFx0Ly8gVE9ETzogUmVtb3ZlIHVud2F0Y2ggaW4gMi4wXG5cdFx0dmFyIGhhbmRsZSA9IHt9O1xuXHRcdGhhbmRsZS51bndhdGNoID0gaGFuZGxlLnJlbW92ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgaW5kZXggPSBhcnJheS5pbmRleE9mKHByb3BlcnR5Q2FsbGJhY2tzLCBjYWxsYmFjayk7XG5cdFx0XHRpZihpbmRleCA+IC0xKXtcblx0XHRcdFx0cHJvcGVydHlDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBoYW5kbGU7IC8vT2JqZWN0XG5cdH1cblxufSk7XG5cbn0pO1xuIiwiZGVmaW5lKFtcIi4va2VybmVsXCIsIFwiLi9sYW5nXCIsIFwiLi9hcnJheVwiLCBcIi4vY29uZmlnXCJdLCBmdW5jdGlvbihkb2pvLCBsYW5nLCBBcnJheVV0aWwsIGNvbmZpZyl7XG5cblx0dmFyIENvbG9yID0gZG9qby5Db2xvciA9IGZ1bmN0aW9uKC8qQXJyYXl8U3RyaW5nfE9iamVjdCovIGNvbG9yKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRha2VzIGEgbmFtZWQgc3RyaW5nLCBoZXggc3RyaW5nLCBhcnJheSBvZiByZ2Igb3IgcmdiYSB2YWx1ZXMsXG5cdFx0Ly9cdFx0YW4gb2JqZWN0IHdpdGggciwgZywgYiwgYW5kIGEgcHJvcGVydGllcywgb3IgYW5vdGhlciBgQ29sb3JgIG9iamVjdFxuXHRcdC8vXHRcdGFuZCBjcmVhdGVzIGEgbmV3IENvbG9yIGluc3RhbmNlIHRvIHdvcmsgZnJvbS5cblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0V29yayB3aXRoIGEgQ29sb3IgaW5zdGFuY2U6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9fYmFzZS9jb2xvclwiXSwgZnVuY3Rpb24oQ29sb3Ipe1xuXHRcdC8vXHR8XHRcdHZhciBjID0gbmV3IENvbG9yKCk7XG5cdFx0Ly9cdHxcdFx0Yy5zZXRDb2xvcihbMCwwLDBdKTsgLy8gYmxhY2tcblx0XHQvL1x0fFx0XHR2YXIgaGV4ID0gYy50b0hleCgpOyAvLyAjMDAwMDAwXG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRXb3JrIHdpdGggYSBub2RlJ3MgY29sb3I6XG5cdFx0Ly9cdHwgXG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9fYmFzZS9jb2xvclwiLCBcImRvam8vZG9tLXN0eWxlXCJdLCBmdW5jdGlvbihDb2xvciwgZG9tU3R5bGUpe1xuXHRcdC8vXHR8XHRcdHZhciBjb2xvciA9IGRvbVN0eWxlKFwic29tZU5vZGVcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIik7XG5cdFx0Ly9cdHxcdFx0dmFyIG4gPSBuZXcgQ29sb3IoY29sb3IpO1xuXHRcdC8vXHR8XHRcdC8vIGFkanVzdCB0aGUgY29sb3Igc29tZVxuXHRcdC8vXHR8XHRcdG4uciAqPSAuNTtcblx0XHQvL1x0fFx0XHRjb25zb2xlLmxvZyhuLnRvU3RyaW5nKCkpOyAvLyByZ2IoMTI4LCAyNTUsIDI1NSk7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdGlmKGNvbG9yKXsgdGhpcy5zZXRDb2xvcihjb2xvcik7IH1cblx0fTtcblxuXHQvLyBGSVhNRTpcblx0Ly8gdGhlcmUncyBnb3QgdG8gYmUgYSBtb3JlIHNwYWNlLWVmZmljaWVudCB3YXkgdG8gZW5jb2RlIG9yIGRpc2NvdmVyXG5cdC8vIHRoZXNlISEgVXNlIGhleD9cblx0Q29sb3IubmFtZWQgPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHREaWN0aW9uYXJ5IGxpc3Qgb2YgYWxsIENTUyBuYW1lZCBjb2xvcnMsIGJ5IG5hbWUuIFZhbHVlcyBhcmUgMy1pdGVtIGFycmF5cyB3aXRoIGNvcnJlc3BvbmRpbmcgUkcgYW5kIEIgdmFsdWVzLlxuXHRcdFwiYmxhY2tcIjogIFswLDAsMF0sXG5cdFx0XCJzaWx2ZXJcIjogWzE5MiwxOTIsMTkyXSxcblx0XHRcImdyYXlcIjpcdCAgWzEyOCwxMjgsMTI4XSxcblx0XHRcIndoaXRlXCI6ICBbMjU1LDI1NSwyNTVdLFxuXHRcdFwibWFyb29uXCI6IFsxMjgsMCwwXSxcblx0XHRcInJlZFwiOlx0ICBbMjU1LDAsMF0sXG5cdFx0XCJwdXJwbGVcIjogWzEyOCwwLDEyOF0sXG5cdFx0XCJmdWNoc2lhXCI6WzI1NSwwLDI1NV0sXG5cdFx0XCJncmVlblwiOiAgWzAsMTI4LDBdLFxuXHRcdFwibGltZVwiOlx0ICBbMCwyNTUsMF0sXG5cdFx0XCJvbGl2ZVwiOiAgWzEyOCwxMjgsMF0sXG5cdFx0XCJ5ZWxsb3dcIjogWzI1NSwyNTUsMF0sXG5cdFx0XCJuYXZ5XCI6XHQgIFswLDAsMTI4XSxcblx0XHRcImJsdWVcIjpcdCAgWzAsMCwyNTVdLFxuXHRcdFwidGVhbFwiOlx0ICBbMCwxMjgsMTI4XSxcblx0XHRcImFxdWFcIjpcdCAgWzAsMjU1LDI1NV0sXG5cdFx0XCJ0cmFuc3BhcmVudFwiOiBjb25maWcudHJhbnNwYXJlbnRDb2xvciB8fCBbMCwwLDAsMF1cblx0fTtcblxuXHRsYW5nLmV4dGVuZChDb2xvciwge1xuXHRcdHI6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDEsXG5cdFx0X3NldDogZnVuY3Rpb24ociwgZywgYiwgYSl7XG5cdFx0XHR2YXIgdCA9IHRoaXM7IHQuciA9IHI7IHQuZyA9IGc7IHQuYiA9IGI7IHQuYSA9IGE7XG5cdFx0fSxcblx0XHRzZXRDb2xvcjogZnVuY3Rpb24oLypBcnJheXxTdHJpbmd8T2JqZWN0Ki8gY29sb3Ipe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRha2VzIGEgbmFtZWQgc3RyaW5nLCBoZXggc3RyaW5nLCBhcnJheSBvZiByZ2Igb3IgcmdiYSB2YWx1ZXMsXG5cdFx0XHQvL1x0XHRhbiBvYmplY3Qgd2l0aCByLCBnLCBiLCBhbmQgYSBwcm9wZXJ0aWVzLCBvciBhbm90aGVyIGBDb2xvcmAgb2JqZWN0XG5cdFx0XHQvL1x0XHRhbmQgc2V0cyB0aGlzIGNvbG9yIGluc3RhbmNlIHRvIHRoYXQgdmFsdWUuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vX2Jhc2UvY29sb3JcIl0sIGZ1bmN0aW9uKENvbG9yKXtcblx0XHRcdC8vXHR8XHRcdHZhciBjID0gbmV3IENvbG9yKCk7IC8vIG5vIGNvbG9yXG5cdFx0XHQvL1x0fFx0XHRjLnNldENvbG9yKFwiI2VkZWRlZFwiKTsgLy8gZ3JleWlzaFxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0aWYobGFuZy5pc1N0cmluZyhjb2xvcikpe1xuXHRcdFx0XHRDb2xvci5mcm9tU3RyaW5nKGNvbG9yLCB0aGlzKTtcblx0XHRcdH1lbHNlIGlmKGxhbmcuaXNBcnJheShjb2xvcikpe1xuXHRcdFx0XHRDb2xvci5mcm9tQXJyYXkoY29sb3IsIHRoaXMpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHRoaXMuX3NldChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hKTtcblx0XHRcdFx0aWYoIShjb2xvciBpbnN0YW5jZW9mIENvbG9yKSl7IHRoaXMuc2FuaXRpemUoKTsgfVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XHQvLyBDb2xvclxuXHRcdH0sXG5cdFx0c2FuaXRpemU6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RW5zdXJlcyB0aGUgb2JqZWN0IGhhcyBjb3JyZWN0IGF0dHJpYnV0ZXNcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0dGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZG9lcyBub3RoaW5nLCBpbmNsdWRlIGRvam8uY29sb3JzIHRvXG5cdFx0XHQvL1x0XHRhdWdtZW50IGl0IHdpdGggcmVhbCBjaGVja3Ncblx0XHRcdHJldHVybiB0aGlzO1x0Ly8gQ29sb3Jcblx0XHR9LFxuXHRcdHRvUmdiOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgMyBjb21wb25lbnQgYXJyYXkgb2YgcmdiIHZhbHVlc1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vX2Jhc2UvY29sb3JcIl0sIGZ1bmN0aW9uKENvbG9yKXtcblx0XHRcdC8vXHR8XHRcdHZhciBjID0gbmV3IENvbG9yKFwiIzAwMDAwMFwiKTtcblx0XHRcdC8vXHR8XHRcdGNvbnNvbGUubG9nKGMudG9SZ2IoKSk7IC8vIFswLDAsMF1cblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdHZhciB0ID0gdGhpcztcblx0XHRcdHJldHVybiBbdC5yLCB0LmcsIHQuYl07IC8vIEFycmF5XG5cdFx0fSxcblx0XHR0b1JnYmE6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIDQgY29tcG9uZW50IGFycmF5IG9mIHJnYmEgdmFsdWVzIGZyb20gdGhlIGNvbG9yXG5cdFx0XHQvL1x0XHRyZXByZXNlbnRlZCBieSB0aGlzIG9iamVjdC5cblx0XHRcdHZhciB0ID0gdGhpcztcblx0XHRcdHJldHVybiBbdC5yLCB0LmcsIHQuYiwgdC5hXTtcdC8vIEFycmF5XG5cdFx0fSxcblx0XHR0b0hleDogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgQ1NTIGNvbG9yIHN0cmluZyBpbiBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvblxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vX2Jhc2UvY29sb3JcIl0sIGZ1bmN0aW9uKENvbG9yKXtcblx0XHRcdC8vXHR8XHRcdGNvbnNvbGUubG9nKG5ldyBDb2xvcihbMCwwLDBdKS50b0hleCgpKTsgLy8gIzAwMDAwMFxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0dmFyIGFyciA9IEFycmF5VXRpbC5tYXAoW1wiclwiLCBcImdcIiwgXCJiXCJdLCBmdW5jdGlvbih4KXtcblx0XHRcdFx0dmFyIHMgPSB0aGlzW3hdLnRvU3RyaW5nKDE2KTtcblx0XHRcdFx0cmV0dXJuIHMubGVuZ3RoIDwgMiA/IFwiMFwiICsgcyA6IHM7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdHJldHVybiBcIiNcIiArIGFyci5qb2luKFwiXCIpO1x0Ly8gU3RyaW5nXG5cdFx0fSxcblx0XHR0b0NzczogZnVuY3Rpb24oLypCb29sZWFuPyovIGluY2x1ZGVBbHBoYSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIGNzcyBjb2xvciBzdHJpbmcgaW4gcmdiKGEpIHJlcHJlc2VudGF0aW9uXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9fYmFzZS9jb2xvclwiXSwgZnVuY3Rpb24oQ29sb3Ipe1xuXHRcdFx0Ly9cdHxcdFx0dmFyIGMgPSBuZXcgQ29sb3IoXCIjRkZGXCIpLnRvQ3NzKCk7XG5cdFx0XHQvL1x0fFx0XHRjb25zb2xlLmxvZyhjKTsgLy8gcmdiKCcyNTUnLCcyNTUnLCcyNTUnKVxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0dmFyIHQgPSB0aGlzLCByZ2IgPSB0LnIgKyBcIiwgXCIgKyB0LmcgKyBcIiwgXCIgKyB0LmI7XG5cdFx0XHRyZXR1cm4gKGluY2x1ZGVBbHBoYSA/IFwicmdiYShcIiArIHJnYiArIFwiLCBcIiArIHQuYSA6IFwicmdiKFwiICsgcmdiKSArIFwiKVwiO1x0Ly8gU3RyaW5nXG5cdFx0fSxcblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuXHRcdFx0cmV0dXJuIHRoaXMudG9Dc3ModHJ1ZSk7IC8vIFN0cmluZ1xuXHRcdH1cblx0fSk7XG5cblx0Q29sb3IuYmxlbmRDb2xvcnMgPSBkb2pvLmJsZW5kQ29sb3JzID0gZnVuY3Rpb24oXG5cdFx0LypDb2xvciovIHN0YXJ0LFxuXHRcdC8qQ29sb3IqLyBlbmQsXG5cdFx0LypOdW1iZXIqLyB3ZWlnaHQsXG5cdFx0LypDb2xvcj8qLyBvYmpcblx0KXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEJsZW5kIGNvbG9ycyBlbmQgYW5kIHN0YXJ0IHdpdGggd2VpZ2h0IGZyb20gMCB0byAxLCAwLjUgYmVpbmcgYSA1MC81MCBibGVuZCxcblx0XHQvL1x0XHRjYW4gcmV1c2UgYSBwcmV2aW91c2x5IGFsbG9jYXRlZCBDb2xvciBvYmplY3QgZm9yIHRoZSByZXN1bHRcblx0XHR2YXIgdCA9IG9iaiB8fCBuZXcgQ29sb3IoKTtcblx0XHR0LnIgPSBNYXRoLnJvdW5kKHN0YXJ0LnIgKyAoZW5kLnIgLSBzdGFydC5yKSAqIHdlaWdodCk7XG5cdFx0dC5nID0gTWF0aC5yb3VuZChzdGFydC5nICsgKGVuZC5nIC0gc3RhcnQuZykgKiB3ZWlnaHQpO1xuXHRcdHQuYiA9IE1hdGgucm91bmQoc3RhcnQuYiArIChlbmQuYiAtIHN0YXJ0LmIpICogd2VpZ2h0KTtcblx0XHR0LmEgPSBzdGFydC5hICsgKGVuZC5hIC0gc3RhcnQuYSkgKiB3ZWlnaHQ7XG5cdFx0cmV0dXJuIHQuc2FuaXRpemUoKTtcdC8vIENvbG9yXG5cdH07XG5cblx0Q29sb3IuZnJvbVJnYiA9IGRvam8uY29sb3JGcm9tUmdiID0gZnVuY3Rpb24oLypTdHJpbmcqLyBjb2xvciwgLypDb2xvcj8qLyBvYmope1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmV0dXJucyBhIGBDb2xvcmAgaW5zdGFuY2UgZnJvbSBhIHN0cmluZyBvZiB0aGUgZm9ybVxuXHRcdC8vXHRcdFwicmdiKC4uLilcIiBvciBcInJnYmEoLi4uKVwiLiBPcHRpb25hbGx5IGFjY2VwdHMgYSBgQ29sb3JgXG5cdFx0Ly9cdFx0b2JqZWN0IHRvIHVwZGF0ZSB3aXRoIHRoZSBwYXJzZWQgdmFsdWUgYW5kIHJldHVybiBpbnN0ZWFkIG9mXG5cdFx0Ly9cdFx0Y3JlYXRpbmcgYSBuZXcgb2JqZWN0LlxuXHRcdC8vIHJldHVybnM6XG5cdFx0Ly9cdFx0QSBDb2xvciBvYmplY3QuIElmIG9iaiBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgdGhlIHJldHVybiB2YWx1ZS5cblx0XHR2YXIgbSA9IGNvbG9yLnRvTG93ZXJDYXNlKCkubWF0Y2goL15yZ2JhP1xcKChbXFxzXFwuLDAtOV0rKVxcKS8pO1xuXHRcdHJldHVybiBtICYmIENvbG9yLmZyb21BcnJheShtWzFdLnNwbGl0KC9cXHMqLFxccyovKSwgb2JqKTtcdC8vIENvbG9yXG5cdH07XG5cblx0Q29sb3IuZnJvbUhleCA9IGRvam8uY29sb3JGcm9tSGV4ID0gZnVuY3Rpb24oLypTdHJpbmcqLyBjb2xvciwgLypDb2xvcj8qLyBvYmope1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0Q29udmVydHMgYSBoZXggc3RyaW5nIHdpdGggYSAnIycgcHJlZml4IHRvIGEgY29sb3Igb2JqZWN0LlxuXHRcdC8vXHRcdFN1cHBvcnRzIDEyLWJpdCAjcmdiIHNob3J0aGFuZC4gT3B0aW9uYWxseSBhY2NlcHRzIGFcblx0XHQvL1x0XHRgQ29sb3JgIG9iamVjdCB0byB1cGRhdGUgd2l0aCB0aGUgcGFyc2VkIHZhbHVlLlxuXHRcdC8vXG5cdFx0Ly8gcmV0dXJuczpcblx0XHQvL1x0XHRBIENvbG9yIG9iamVjdC4gSWYgb2JqIGlzIHBhc3NlZCwgaXQgd2lsbCBiZSB0aGUgcmV0dXJuIHZhbHVlLlxuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL19iYXNlL2NvbG9yXCJdLCBmdW5jdGlvbihDb2xvcil7XG5cdFx0Ly9cdHxcdFx0dmFyIHRoaW5nID0gbmV3IENvbG9yKCkuZnJvbUhleChcIiNlZGVkZWRcIik7IC8vIGdyZXksIGxvbmdoYW5kXG5cdFx0Ly9cdHxcdFx0dmFyIHRoaW5nMiA9IG5ldyBDb2xvcigpLmZyb21IZXgoXCIjMDAwXCIpOyAvLyBibGFjaywgc2hvcnRoYW5kXG5cdFx0Ly9cdHxcdH0pO1xuXHRcdHZhciB0ID0gb2JqIHx8IG5ldyBDb2xvcigpLFxuXHRcdFx0Yml0cyA9IChjb2xvci5sZW5ndGggPT0gNCkgPyA0IDogOCxcblx0XHRcdG1hc2sgPSAoMSA8PCBiaXRzKSAtIDE7XG5cdFx0Y29sb3IgPSBOdW1iZXIoXCIweFwiICsgY29sb3Iuc3Vic3RyKDEpKTtcblx0XHRpZihpc05hTihjb2xvcikpe1xuXHRcdFx0cmV0dXJuIG51bGw7IC8vIENvbG9yXG5cdFx0fVxuXHRcdEFycmF5VXRpbC5mb3JFYWNoKFtcImJcIiwgXCJnXCIsIFwiclwiXSwgZnVuY3Rpb24oeCl7XG5cdFx0XHR2YXIgYyA9IGNvbG9yICYgbWFzaztcblx0XHRcdGNvbG9yID4+PSBiaXRzO1xuXHRcdFx0dFt4XSA9IGJpdHMgPT0gNCA/IDE3ICogYyA6IGM7XG5cdFx0fSk7XG5cdFx0dC5hID0gMTtcblx0XHRyZXR1cm4gdDtcdC8vIENvbG9yXG5cdH07XG5cblx0Q29sb3IuZnJvbUFycmF5ID0gZG9qby5jb2xvckZyb21BcnJheSA9IGZ1bmN0aW9uKC8qQXJyYXkqLyBhLCAvKkNvbG9yPyovIG9iail7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRCdWlsZHMgYSBgQ29sb3JgIGZyb20gYSAzIG9yIDQgZWxlbWVudCBhcnJheSwgbWFwcGluZyBlYWNoXG5cdFx0Ly9cdFx0ZWxlbWVudCBpbiBzZXF1ZW5jZSB0byB0aGUgcmdiKGEpIHZhbHVlcyBvZiB0aGUgY29sb3IuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vX2Jhc2UvY29sb3JcIl0sIGZ1bmN0aW9uKENvbG9yKXtcblx0XHQvL1x0XHR8XHRcdHZhciBteUNvbG9yID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KFsyMzcsMjM3LDIzNywwLjVdKTsgLy8gZ3JleSwgNTAlIGFscGhhXG5cdFx0Ly9cdFx0fFx0fSk7XG5cdFx0Ly8gcmV0dXJuczpcblx0XHQvL1x0XHRBIENvbG9yIG9iamVjdC4gSWYgb2JqIGlzIHBhc3NlZCwgaXQgd2lsbCBiZSB0aGUgcmV0dXJuIHZhbHVlLlxuXHRcdHZhciB0ID0gb2JqIHx8IG5ldyBDb2xvcigpO1xuXHRcdHQuX3NldChOdW1iZXIoYVswXSksIE51bWJlcihhWzFdKSwgTnVtYmVyKGFbMl0pLCBOdW1iZXIoYVszXSkpO1xuXHRcdGlmKGlzTmFOKHQuYSkpeyB0LmEgPSAxOyB9XG5cdFx0cmV0dXJuIHQuc2FuaXRpemUoKTtcdC8vIENvbG9yXG5cdH07XG5cblx0Q29sb3IuZnJvbVN0cmluZyA9IGRvam8uY29sb3JGcm9tU3RyaW5nID0gZnVuY3Rpb24oLypTdHJpbmcqLyBzdHIsIC8qQ29sb3I/Ki8gb2JqKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFBhcnNlcyBgc3RyYCBmb3IgYSBjb2xvciB2YWx1ZS4gQWNjZXB0cyBoZXgsIHJnYiwgYW5kIHJnYmFcblx0XHQvL1x0XHRzdHlsZSBjb2xvciB2YWx1ZXMuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0QWNjZXB0YWJsZSBpbnB1dCB2YWx1ZXMgZm9yIHN0ciBtYXkgaW5jbHVkZSBhcnJheXMgb2YgYW55IGZvcm1cblx0XHQvL1x0XHRhY2NlcHRlZCBieSBkb2pvLmNvbG9yRnJvbUFycmF5LCBoZXggc3RyaW5ncyBzdWNoIGFzIFwiI2FhYWFhYVwiLCBvclxuXHRcdC8vXHRcdHJnYiBvciByZ2JhIHN0cmluZ3Mgc3VjaCBhcyBcInJnYigxMzMsIDIwMCwgMTYpXCIgb3IgXCJyZ2JhKDEwLCAxMCxcblx0XHQvL1x0XHQxMCwgNTApXCJcblx0XHQvLyByZXR1cm5zOlxuXHRcdC8vXHRcdEEgQ29sb3Igb2JqZWN0LiBJZiBvYmogaXMgcGFzc2VkLCBpdCB3aWxsIGJlIHRoZSByZXR1cm4gdmFsdWUuXG5cdFx0dmFyIGEgPSBDb2xvci5uYW1lZFtzdHJdO1xuXHRcdHJldHVybiBhICYmIENvbG9yLmZyb21BcnJheShhLCBvYmopIHx8IENvbG9yLmZyb21SZ2Ioc3RyLCBvYmopIHx8IENvbG9yLmZyb21IZXgoc3RyLCBvYmopO1x0Ly8gQ29sb3Jcblx0fTtcblxuXHRyZXR1cm4gQ29sb3I7XG59KTtcbiIsImRlZmluZShbXG5cdFwiLi9rZXJuZWxcIixcblx0XCIuLi9EZWZlcnJlZFwiLFxuXHRcIi4uL3Byb21pc2UvUHJvbWlzZVwiLFxuXHRcIi4uL2Vycm9ycy9DYW5jZWxFcnJvclwiLFxuXHRcIi4uL2hhc1wiLFxuXHRcIi4vbGFuZ1wiLFxuXHRcIi4uL3doZW5cIlxuXSwgZnVuY3Rpb24oZG9qbywgTmV3RGVmZXJyZWQsIFByb21pc2UsIENhbmNlbEVycm9yLCBoYXMsIGxhbmcsIHdoZW4pe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vX2Jhc2UvRGVmZXJyZWRcblxuXHR2YXIgbXV0YXRvciA9IGZ1bmN0aW9uKCl7fTtcblx0dmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemUgfHwgZnVuY3Rpb24oKXt9O1xuXHQvLyBBIGRlZmVycmVkIHByb3ZpZGVzIGFuIEFQSSBmb3IgY3JlYXRpbmcgYW5kIHJlc29sdmluZyBhIHByb21pc2UuXG5cdHZhciBEZWZlcnJlZCA9IGRvam8uRGVmZXJyZWQgPSBmdW5jdGlvbigvKkZ1bmN0aW9uPyovIGNhbmNlbGxlcil7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHREZXByZWNhdGVkLiAgIFRoaXMgbW9kdWxlIGRlZmluZXMgdGhlIGxlZ2FjeSBkb2pvL19iYXNlL0RlZmVycmVkIEFQSS5cblx0XHQvL1x0XHROZXcgY29kZSBzaG91bGQgdXNlIGRvam8vRGVmZXJyZWQgaW5zdGVhZC5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRUaGUgRGVmZXJyZWQgQVBJIGlzIGJhc2VkIG9uIHRoZSBjb25jZXB0IG9mIHByb21pc2VzIHRoYXQgcHJvdmlkZSBhXG5cdFx0Ly9cdFx0Z2VuZXJpYyBpbnRlcmZhY2UgaW50byB0aGUgZXZlbnR1YWwgY29tcGxldGlvbiBvZiBhbiBhc3luY2hyb25vdXMgYWN0aW9uLlxuXHRcdC8vXHRcdFRoZSBtb3RpdmF0aW9uIGZvciBwcm9taXNlcyBmdW5kYW1lbnRhbGx5IGlzIGFib3V0IGNyZWF0aW5nIGFcblx0XHQvL1x0XHRzZXBhcmF0aW9uIG9mIGNvbmNlcm5zIHRoYXQgYWxsb3dzIG9uZSB0byBhY2hpZXZlIHRoZSBzYW1lIHR5cGUgb2Zcblx0XHQvL1x0XHRjYWxsIHBhdHRlcm5zIGFuZCBsb2dpY2FsIGRhdGEgZmxvdyBpbiBhc3luY2hyb25vdXMgY29kZSBhcyBjYW4gYmVcblx0XHQvL1x0XHRhY2hpZXZlZCBpbiBzeW5jaHJvbm91cyBjb2RlLiBQcm9taXNlcyBhbGxvd3Mgb25lXG5cdFx0Ly9cdFx0dG8gYmUgYWJsZSB0byBjYWxsIGEgZnVuY3Rpb24gcHVyZWx5IHdpdGggYXJndW1lbnRzIG5lZWRlZCBmb3Jcblx0XHQvL1x0XHRleGVjdXRpb24sIHdpdGhvdXQgY29uZmxhdGluZyB0aGUgY2FsbCB3aXRoIGNvbmNlcm5zIG9mIHdoZXRoZXIgaXQgaXNcblx0XHQvL1x0XHRzeW5jIG9yIGFzeW5jLiBPbmUgc2hvdWxkbid0IG5lZWQgdG8gYWx0ZXIgYSBjYWxsJ3MgYXJndW1lbnRzIGlmIHRoZVxuXHRcdC8vXHRcdGltcGxlbWVudGF0aW9uIHN3aXRjaGVzIGZyb20gc3luYyB0byBhc3luYyAob3IgdmljZSB2ZXJzYSkuIEJ5IGhhdmluZ1xuXHRcdC8vXHRcdGFzeW5jIGZ1bmN0aW9ucyByZXR1cm4gcHJvbWlzZXMsIHRoZSBjb25jZXJucyBvZiBtYWtpbmcgdGhlIGNhbGwgYXJlXG5cdFx0Ly9cdFx0c2VwYXJhdGVkIGZyb20gdGhlIGNvbmNlcm5zIG9mIGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbiAod2hpY2ggYXJlXG5cdFx0Ly9cdFx0aGFuZGxlZCBieSB0aGUgcHJvbWlzZSkuXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGUgRGVmZXJyZWQgaXMgYSB0eXBlIG9mIHByb21pc2UgdGhhdCBwcm92aWRlcyBtZXRob2RzIGZvciBmdWxmaWxsaW5nIHRoZVxuXHRcdC8vXHRcdHByb21pc2Ugd2l0aCBhIHN1Y2Nlc3NmdWwgcmVzdWx0IG9yIGFuIGVycm9yLiBUaGUgbW9zdCBpbXBvcnRhbnQgbWV0aG9kIGZvclxuXHRcdC8vXHRcdHdvcmtpbmcgd2l0aCBEb2pvJ3MgcHJvbWlzZXMgaXMgdGhlIHRoZW4oKSBtZXRob2QsIHdoaWNoIGZvbGxvd3MgdGhlXG5cdFx0Ly9cdFx0Q29tbW9uSlMgcHJvcG9zZWQgcHJvbWlzZSBBUEkuIEFuIGV4YW1wbGUgb2YgdXNpbmcgYSBEb2pvIHByb21pc2U6XG5cdFx0Ly9cblx0XHQvL1x0XHR8XHR2YXIgcmVzdWx0aW5nUHJvbWlzZSA9IHNvbWVBc3luY09wZXJhdGlvbi50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG5cdFx0Ly9cdFx0fFx0XHQuLi4gaGFuZGxlIHJlc3VsdCAuLi5cblx0XHQvL1x0XHR8XHR9LFxuXHRcdC8vXHRcdHxcdGZ1bmN0aW9uKGVycm9yKXtcblx0XHQvL1x0XHR8XHRcdC4uLiBoYW5kbGUgZXJyb3IgLi4uXG5cdFx0Ly9cdFx0fFx0fSk7XG5cdFx0Ly9cblx0XHQvL1x0XHRUaGUgLnRoZW4oKSBjYWxsIHJldHVybnMgYSBuZXcgcHJvbWlzZSB0aGF0IHJlcHJlc2VudHMgdGhlIHJlc3VsdCBvZiB0aGVcblx0XHQvL1x0XHRleGVjdXRpb24gb2YgdGhlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2tzIHdpbGwgbmV2ZXIgYWZmZWN0IHRoZSBvcmlnaW5hbCBwcm9taXNlcyB2YWx1ZS5cblx0XHQvL1xuXHRcdC8vXHRcdFRoZSBEZWZlcnJlZCBpbnN0YW5jZXMgYWxzbyBwcm92aWRlIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTpcblx0XHQvL1xuXHRcdC8vXHRcdC0gYWRkQ2FsbGJhY2soaGFuZGxlcilcblx0XHQvL1x0XHQtIGFkZEVycmJhY2soaGFuZGxlcilcblx0XHQvL1x0XHQtIGNhbGxiYWNrKHJlc3VsdClcblx0XHQvL1x0XHQtIGVycmJhY2socmVzdWx0KVxuXHRcdC8vXG5cdFx0Ly9cdFx0Q2FsbGJhY2tzIGFyZSBhbGxvd2VkIHRvIHJldHVybiBwcm9taXNlcyB0aGVtc2VsdmVzLCBzb1xuXHRcdC8vXHRcdHlvdSBjYW4gYnVpbGQgY29tcGxpY2F0ZWQgc2VxdWVuY2VzIG9mIGV2ZW50cyB3aXRoIGVhc2UuXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGUgY3JlYXRvciBvZiB0aGUgRGVmZXJyZWQgbWF5IHNwZWNpZnkgYSBjYW5jZWxsZXIuICBUaGUgY2FuY2VsbGVyXG5cdFx0Ly9cdFx0aXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGlmIERlZmVycmVkLmNhbmNlbCBpcyBjYWxsZWRcblx0XHQvL1x0XHRiZWZvcmUgdGhlIERlZmVycmVkIGZpcmVzLiBZb3UgY2FuIHVzZSB0aGlzIHRvIGltcGxlbWVudCBjbGVhblxuXHRcdC8vXHRcdGFib3J0aW5nIG9mIGFuIFhNTEh0dHBSZXF1ZXN0LCBldGMuIE5vdGUgdGhhdCBjYW5jZWwgd2lsbCBmaXJlIHRoZVxuXHRcdC8vXHRcdGRlZmVycmVkIHdpdGggYSBDYW5jZWxsZWRFcnJvciAodW5sZXNzIHlvdXIgY2FuY2VsbGVyIHJldHVybnNcblx0XHQvL1x0XHRhbm90aGVyIGtpbmQgb2YgZXJyb3IpLCBzbyB0aGUgZXJyYmFja3Mgc2hvdWxkIGJlIHByZXBhcmVkIHRvXG5cdFx0Ly9cdFx0aGFuZGxlIHRoYXQgZXJyb3IgZm9yIGNhbmNlbGxhYmxlIERlZmVycmVkcy5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHR2YXIgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcblx0XHQvL1x0fFx0c2V0VGltZW91dChmdW5jdGlvbigpeyBkZWZlcnJlZC5jYWxsYmFjayh7c3VjY2VzczogdHJ1ZX0pOyB9LCAxMDAwKTtcblx0XHQvL1x0fFx0cmV0dXJuIGRlZmVycmVkO1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0RGVmZXJyZWQgb2JqZWN0cyBhcmUgb2Z0ZW4gdXNlZCB3aGVuIG1ha2luZyBjb2RlIGFzeW5jaHJvbm91cy4gSXRcblx0XHQvL1x0XHRtYXkgYmUgZWFzaWVzdCB0byB3cml0ZSBmdW5jdGlvbnMgaW4gYSBzeW5jaHJvbm91cyBtYW5uZXIgYW5kIHRoZW5cblx0XHQvL1x0XHRzcGxpdCBjb2RlIHVzaW5nIGEgZGVmZXJyZWQgdG8gdHJpZ2dlciBhIHJlc3BvbnNlIHRvIGEgbG9uZy1saXZlZFxuXHRcdC8vXHRcdG9wZXJhdGlvbi4gRm9yIGV4YW1wbGUsIGluc3RlYWQgb2YgcmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbiB0b1xuXHRcdC8vXHRcdGRlbm90ZSB3aGVuIGEgcmVuZGVyaW5nIG9wZXJhdGlvbiBjb21wbGV0ZXMsIHRoZSBmdW5jdGlvbiBjYW5cblx0XHQvL1x0XHRzaW1wbHkgcmV0dXJuIGEgZGVmZXJyZWQ6XG5cdFx0Ly9cblx0XHQvL1x0XHR8XHQvLyBjYWxsYmFjayBzdHlsZTpcblx0XHQvL1x0XHR8XHRmdW5jdGlvbiByZW5kZXJMb3RzT2ZEYXRhKGRhdGEsIGNhbGxiYWNrKXtcblx0XHQvL1x0XHR8XHRcdHZhciBzdWNjZXNzID0gZmFsc2Vcblx0XHQvL1x0XHR8XHRcdHRyeXtcblx0XHQvL1x0XHR8XHRcdFx0Zm9yKHZhciB4IGluIGRhdGEpe1xuXHRcdC8vXHRcdHxcdFx0XHRcdHJlbmRlckRhdGFpdGVtKGRhdGFbeF0pO1xuXHRcdC8vXHRcdHxcdFx0XHR9XG5cdFx0Ly9cdFx0fFx0XHRcdHN1Y2Nlc3MgPSB0cnVlO1xuXHRcdC8vXHRcdHxcdFx0fWNhdGNoKGUpeyB9XG5cdFx0Ly9cdFx0fFx0XHRpZihjYWxsYmFjayl7XG5cdFx0Ly9cdFx0fFx0XHRcdGNhbGxiYWNrKHN1Y2Nlc3MpO1xuXHRcdC8vXHRcdHxcdFx0fVxuXHRcdC8vXHRcdHxcdH1cblx0XHQvL1xuXHRcdC8vXHRcdHxcdC8vIHVzaW5nIGNhbGxiYWNrIHN0eWxlXG5cdFx0Ly9cdFx0fFx0cmVuZGVyTG90c09mRGF0YShzb21lRGF0YU9iaiwgZnVuY3Rpb24oc3VjY2Vzcyl7XG5cdFx0Ly9cdFx0fFx0XHQvLyBoYW5kbGVzIHN1Y2Nlc3Mgb3IgZmFpbHVyZVxuXHRcdC8vXHRcdHxcdFx0aWYoIXN1Y2Nlc3Mpe1xuXHRcdC8vXHRcdHxcdFx0XHRwcm9tcHRVc2VyVG9SZWNvdmVyKCk7XG5cdFx0Ly9cdFx0fFx0XHR9XG5cdFx0Ly9cdFx0fFx0fSk7XG5cdFx0Ly9cdFx0fFx0Ly8gTk9URTogbm8gd2F5IHRvIGFkZCBhbm90aGVyIGNhbGxiYWNrIGhlcmUhIVxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0VXNpbmcgYSBEZWZlcnJlZCBkb2Vzbid0IHNpbXBsaWZ5IHRoZSBzZW5kaW5nIGNvZGUgYW55LCBidXQgaXRcblx0XHQvL1x0XHRwcm92aWRlcyBhIHN0YW5kYXJkIGludGVyZmFjZSBmb3IgY2FsbGVycyBhbmQgc2VuZGVycyBhbGlrZSxcblx0XHQvL1x0XHRwcm92aWRpbmcgYm90aCB3aXRoIGEgc2ltcGxlIHdheSB0byBzZXJ2aWNlIG11bHRpcGxlIGNhbGxiYWNrcyBmb3Jcblx0XHQvL1x0XHRhbiBvcGVyYXRpb24gYW5kIGZyZWVpbmcgYm90aCBzaWRlcyBmcm9tIHdvcnJ5aW5nIGFib3V0IGRldGFpbHNcblx0XHQvL1x0XHRzdWNoIGFzIFwiZGlkIHRoaXMgZ2V0IGNhbGxlZCBhbHJlYWR5P1wiLiBXaXRoIERlZmVycmVkcywgbmV3XG5cdFx0Ly9cdFx0Y2FsbGJhY2tzIGNhbiBiZSBhZGRlZCBhdCBhbnkgdGltZS5cblx0XHQvL1xuXHRcdC8vXHRcdHxcdC8vIERlZmVycmVkIHN0eWxlOlxuXHRcdC8vXHRcdHxcdGZ1bmN0aW9uIHJlbmRlckxvdHNPZkRhdGEoZGF0YSl7XG5cdFx0Ly9cdFx0fFx0XHR2YXIgZCA9IG5ldyBEZWZlcnJlZCgpO1xuXHRcdC8vXHRcdHxcdFx0dHJ5e1xuXHRcdC8vXHRcdHxcdFx0XHRmb3IodmFyIHggaW4gZGF0YSl7XG5cdFx0Ly9cdFx0fFx0XHRcdFx0cmVuZGVyRGF0YWl0ZW0oZGF0YVt4XSk7XG5cdFx0Ly9cdFx0fFx0XHRcdH1cblx0XHQvL1x0XHR8XHRcdFx0ZC5jYWxsYmFjayh0cnVlKTtcblx0XHQvL1x0XHR8XHRcdH1jYXRjaChlKXtcblx0XHQvL1x0XHR8XHRcdFx0ZC5lcnJiYWNrKG5ldyBFcnJvcihcInJlbmRlcmluZyBmYWlsZWRcIikpO1xuXHRcdC8vXHRcdHxcdFx0fVxuXHRcdC8vXHRcdHxcdFx0cmV0dXJuIGQ7XG5cdFx0Ly9cdFx0fFx0fVxuXHRcdC8vXG5cdFx0Ly9cdFx0fFx0Ly8gdXNpbmcgRGVmZXJyZWQgc3R5bGVcblx0XHQvL1x0XHR8XHRyZW5kZXJMb3RzT2ZEYXRhKHNvbWVEYXRhT2JqKS50aGVuKG51bGwsIGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdFx0fFx0XHRwcm9tcHRVc2VyVG9SZWNvdmVyKCk7XG5cdFx0Ly9cdFx0fFx0fSk7XG5cdFx0Ly9cdFx0fFx0Ly8gTk9URTogYWRkRXJyYmFjayBhbmQgYWRkQ2FsbGJhY2sgYm90aCByZXR1cm4gdGhlIERlZmVycmVkXG5cdFx0Ly9cdFx0fFx0Ly8gYWdhaW4sIHNvIHdlIGNvdWxkIGNoYWluIGFkZGluZyBjYWxsYmFja3Mgb3Igc2F2ZSB0aGVcblx0XHQvL1x0XHR8XHQvLyBkZWZlcnJlZCBmb3IgbGF0ZXIgc2hvdWxkIHdlIG5lZWQgdG8gYmUgbm90aWZpZWQgYWdhaW4uXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRJbiB0aGlzIGV4YW1wbGUsIHJlbmRlckxvdHNPZkRhdGEgaXMgc3luY2hyb25vdXMgYW5kIHNvIGJvdGhcblx0XHQvL1x0XHR2ZXJzaW9ucyBhcmUgcHJldHR5IGFydGlmaWNpYWwuIFB1dHRpbmcgdGhlIGRhdGEgZGlzcGxheSBvbiBhXG5cdFx0Ly9cdFx0dGltZW91dCBoZWxwcyBzaG93IHdoeSBEZWZlcnJlZHMgcm9jazpcblx0XHQvL1xuXHRcdC8vXHRcdHxcdC8vIERlZmVycmVkIHN0eWxlIGFuZCBhc3luYyBmdW5jXG5cdFx0Ly9cdFx0fFx0ZnVuY3Rpb24gcmVuZGVyTG90c09mRGF0YShkYXRhKXtcblx0XHQvL1x0XHR8XHRcdHZhciBkID0gbmV3IERlZmVycmVkKCk7XG5cdFx0Ly9cdFx0fFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdFx0fFx0XHRcdHRyeXtcblx0XHQvL1x0XHR8XHRcdFx0XHRmb3IodmFyIHggaW4gZGF0YSl7XG5cdFx0Ly9cdFx0fFx0XHRcdFx0XHRyZW5kZXJEYXRhaXRlbShkYXRhW3hdKTtcblx0XHQvL1x0XHR8XHRcdFx0XHR9XG5cdFx0Ly9cdFx0fFx0XHRcdFx0ZC5jYWxsYmFjayh0cnVlKTtcblx0XHQvL1x0XHR8XHRcdFx0fWNhdGNoKGUpe1xuXHRcdC8vXHRcdHxcdFx0XHRcdGQuZXJyYmFjayhuZXcgRXJyb3IoXCJyZW5kZXJpbmcgZmFpbGVkXCIpKTtcblx0XHQvL1x0XHR8XHRcdFx0fVxuXHRcdC8vXHRcdHxcdFx0fSwgMTAwKTtcblx0XHQvL1x0XHR8XHRcdHJldHVybiBkO1xuXHRcdC8vXHRcdHxcdH1cblx0XHQvL1xuXHRcdC8vXHRcdHxcdC8vIHVzaW5nIERlZmVycmVkIHN0eWxlXG5cdFx0Ly9cdFx0fFx0cmVuZGVyTG90c09mRGF0YShzb21lRGF0YU9iaikudGhlbihudWxsLCBmdW5jdGlvbigpe1xuXHRcdC8vXHRcdHxcdFx0cHJvbXB0VXNlclRvUmVjb3ZlcigpO1xuXHRcdC8vXHRcdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly9cdFx0Tm90ZSB0aGF0IHRoZSBjYWxsZXIgZG9lc24ndCBoYXZlIHRvIGNoYW5nZSBoaXMgY29kZSBhdCBhbGwgdG9cblx0XHQvL1x0XHRoYW5kbGUgdGhlIGFzeW5jaHJvbm91cyBjYXNlLlxuXG5cdFx0dmFyIHJlc3VsdCwgZmluaXNoZWQsIGNhbmNlbGVkLCBmaXJlZCwgaXNFcnJvciwgaGVhZCwgbmV4dExpc3RlbmVyO1xuXHRcdHZhciBwcm9taXNlID0gKHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKCkpO1xuXG5cdFx0ZnVuY3Rpb24gY29tcGxldGUodmFsdWUpe1xuXHRcdFx0aWYoZmluaXNoZWQpe1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGRlZmVycmVkIGhhcyBhbHJlYWR5IGJlZW4gcmVzb2x2ZWRcIik7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSB2YWx1ZTtcblx0XHRcdGZpbmlzaGVkID0gdHJ1ZTtcblx0XHRcdG5vdGlmeSgpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBub3RpZnkoKXtcblx0XHRcdHZhciBtdXRhdGVkO1xuXHRcdFx0d2hpbGUoIW11dGF0ZWQgJiYgbmV4dExpc3RlbmVyKXtcblx0XHRcdFx0dmFyIGxpc3RlbmVyID0gbmV4dExpc3RlbmVyO1xuXHRcdFx0XHRuZXh0TGlzdGVuZXIgPSBuZXh0TGlzdGVuZXIubmV4dDtcblx0XHRcdFx0aWYoKG11dGF0ZWQgPSAobGlzdGVuZXIucHJvZ3Jlc3MgPT0gbXV0YXRvcikpKXsgLy8gYXNzaWdubWVudCBhbmQgY2hlY2tcblx0XHRcdFx0XHRmaW5pc2hlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGZ1bmMgPSAoaXNFcnJvciA/IGxpc3RlbmVyLmVycm9yIDogbGlzdGVuZXIucmVzb2x2ZWQpO1xuXHRcdFx0XHRpZihoYXMoXCJjb25maWctdXNlRGVmZXJyZWRJbnN0cnVtZW50YXRpb25cIikpe1xuXHRcdFx0XHRcdGlmKGlzRXJyb3IgJiYgTmV3RGVmZXJyZWQuaW5zdHJ1bWVudFJlamVjdGVkKXtcblx0XHRcdFx0XHRcdE5ld0RlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZChyZXN1bHQsICEhZnVuYyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGZ1bmMpe1xuXHRcdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRcdHZhciBuZXdSZXN1bHQgPSBmdW5jKHJlc3VsdCk7XG5cdFx0XHRcdFx0XHRpZiAobmV3UmVzdWx0ICYmIHR5cGVvZiBuZXdSZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdFx0XHRcdFx0bmV3UmVzdWx0LnRoZW4obGFuZy5oaXRjaChsaXN0ZW5lci5kZWZlcnJlZCwgXCJyZXNvbHZlXCIpLCBsYW5nLmhpdGNoKGxpc3RlbmVyLmRlZmVycmVkLCBcInJlamVjdFwiKSwgbGFuZy5oaXRjaChsaXN0ZW5lci5kZWZlcnJlZCwgXCJwcm9ncmVzc1wiKSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHVuY2hhbmdlZCA9IG11dGF0ZWQgJiYgbmV3UmVzdWx0ID09PSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZihtdXRhdGVkICYmICF1bmNoYW5nZWQpe1xuXHRcdFx0XHRcdFx0XHRpc0Vycm9yID0gbmV3UmVzdWx0IGluc3RhbmNlb2YgRXJyb3I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRsaXN0ZW5lci5kZWZlcnJlZFt1bmNoYW5nZWQgJiYgaXNFcnJvciA/IFwicmVqZWN0XCIgOiBcInJlc29sdmVcIl0odW5jaGFuZ2VkID8gcmVzdWx0IDogbmV3UmVzdWx0KTtcblx0XHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0XHRsaXN0ZW5lci5kZWZlcnJlZC5yZWplY3QoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRpZihpc0Vycm9yKXtcblx0XHRcdFx0XHRcdGxpc3RlbmVyLmRlZmVycmVkLnJlamVjdChyZXN1bHQpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0bGlzdGVuZXIuZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuaXNSZXNvbHZlZCA9IHByb21pc2UuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIHdoZXRoZXIgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkLlxuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXG5cdFx0XHRyZXR1cm4gZmlyZWQgPT0gMDtcblx0XHR9O1xuXG5cdFx0dGhpcy5pc1JlamVjdGVkID0gcHJvbWlzZS5pc1JlamVjdGVkID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDaGVja3Mgd2hldGhlciB0aGUgZGVmZXJyZWQgaGFzIGJlZW4gcmVqZWN0ZWQuXG5cdFx0XHQvLyByZXR1cm5zOiBCb29sZWFuXG5cblx0XHRcdHJldHVybiBmaXJlZCA9PSAxO1xuXHRcdH07XG5cblx0XHR0aGlzLmlzRnVsZmlsbGVkID0gcHJvbWlzZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIHdoZXRoZXIgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlxuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXG5cdFx0XHRyZXR1cm4gZmlyZWQgPj0gMDtcblx0XHR9O1xuXG5cdFx0dGhpcy5pc0NhbmNlbGVkID0gcHJvbWlzZS5pc0NhbmNlbGVkID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDaGVja3Mgd2hldGhlciB0aGUgZGVmZXJyZWQgaGFzIGJlZW4gY2FuY2VsZWQuXG5cdFx0XHQvLyByZXR1cm5zOiBCb29sZWFuXG5cblx0XHRcdHJldHVybiBjYW5jZWxlZDtcblx0XHR9O1xuXG5cdFx0Ly8gY2FsbGluZyByZXNvbHZlIHdpbGwgcmVzb2x2ZSB0aGUgcHJvbWlzZVxuXHRcdHRoaXMucmVzb2x2ZSA9IHRoaXMuY2FsbGJhY2sgPSBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RnVsZmlsbHMgdGhlIERlZmVycmVkIGluc3RhbmNlIHN1Y2Nlc3NmdWxseSB3aXRoIHRoZSBwcm92aWRlIHZhbHVlXG5cdFx0XHR0aGlzLmZpcmVkID0gZmlyZWQgPSAwO1xuXHRcdFx0dGhpcy5yZXN1bHRzID0gW3ZhbHVlLCBudWxsXTtcblx0XHRcdGNvbXBsZXRlKHZhbHVlKTtcblx0XHR9O1xuXG5cblx0XHQvLyBjYWxsaW5nIGVycm9yIHdpbGwgaW5kaWNhdGUgdGhhdCB0aGUgcHJvbWlzZSBmYWlsZWRcblx0XHR0aGlzLnJlamVjdCA9IHRoaXMuZXJyYmFjayA9IGZ1bmN0aW9uKGVycm9yKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRGdWxmaWxscyB0aGUgRGVmZXJyZWQgaW5zdGFuY2UgYXMgYW4gZXJyb3Igd2l0aCB0aGUgcHJvdmlkZWQgZXJyb3Jcblx0XHRcdGlzRXJyb3IgPSB0cnVlO1xuXHRcdFx0dGhpcy5maXJlZCA9IGZpcmVkID0gMTtcblx0XHRcdGlmKGhhcyhcImNvbmZpZy11c2VEZWZlcnJlZEluc3RydW1lbnRhdGlvblwiKSl7XG5cdFx0XHRcdGlmKE5ld0RlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZCl7XG5cdFx0XHRcdFx0TmV3RGVmZXJyZWQuaW5zdHJ1bWVudFJlamVjdGVkKGVycm9yLCAhIW5leHRMaXN0ZW5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNvbXBsZXRlKGVycm9yKTtcblx0XHRcdHRoaXMucmVzdWx0cyA9IFtudWxsLCBlcnJvcl07XG5cdFx0fTtcblx0XHQvLyBjYWxsIHByb2dyZXNzIHRvIHByb3ZpZGUgdXBkYXRlcyBvbiB0aGUgcHJvZ3Jlc3Mgb24gdGhlIGNvbXBsZXRpb24gb2YgdGhlIHByb21pc2Vcblx0XHR0aGlzLnByb2dyZXNzID0gZnVuY3Rpb24odXBkYXRlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRTZW5kIHByb2dyZXNzIGV2ZW50cyB0byBhbGwgbGlzdGVuZXJzXG5cdFx0XHR2YXIgbGlzdGVuZXIgPSBuZXh0TGlzdGVuZXI7XG5cdFx0XHR3aGlsZShsaXN0ZW5lcil7XG5cdFx0XHRcdHZhciBwcm9ncmVzcyA9IGxpc3RlbmVyLnByb2dyZXNzO1xuXHRcdFx0XHRwcm9ncmVzcyAmJiBwcm9ncmVzcyh1cGRhdGUpO1xuXHRcdFx0XHRsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR0aGlzLmFkZENhbGxiYWNrcyA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBlcnJiYWNrKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBZGRzIGNhbGxiYWNrIGFuZCBlcnJvciBjYWxsYmFjayBmb3IgdGhpcyBkZWZlcnJlZCBpbnN0YW5jZS5cblx0XHRcdC8vIGNhbGxiYWNrOiBGdW5jdGlvbj9cblx0XHRcdC8vXHRcdFRoZSBjYWxsYmFjayBhdHRhY2hlZCB0byB0aGlzIGRlZmVycmVkIG9iamVjdC5cblx0XHRcdC8vIGVycmJhY2s6IEZ1bmN0aW9uP1xuXHRcdFx0Ly9cdFx0VGhlIGVycm9yIGNhbGxiYWNrIGF0dGFjaGVkIHRvIHRoaXMgZGVmZXJyZWQgb2JqZWN0LlxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdFJldHVybnMgdGhpcyBkZWZlcnJlZCBvYmplY3QuXG5cdFx0XHR0aGlzLnRoZW4oY2FsbGJhY2ssIGVycmJhY2ssIG11dGF0b3IpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XHQvLyBEZWZlcnJlZFxuXHRcdH07XG5cdFx0Ly8gcHJvdmlkZSB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHByb21pc2Vcblx0XHRwcm9taXNlLnRoZW4gPSB0aGlzLnRoZW4gPSBmdW5jdGlvbigvKkZ1bmN0aW9uPyovcmVzb2x2ZWRDYWxsYmFjaywgLypGdW5jdGlvbj8qL2Vycm9yQ2FsbGJhY2ssIC8qRnVuY3Rpb24/Ki9wcm9ncmVzc0NhbGxiYWNrKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBZGRzIGEgZnVsZmlsbGVkSGFuZGxlciwgZXJyb3JIYW5kbGVyLCBhbmQgcHJvZ3Jlc3NIYW5kbGVyIHRvIGJlIGNhbGxlZCBmb3Jcblx0XHRcdC8vXHRcdGNvbXBsZXRpb24gb2YgYSBwcm9taXNlLiBUaGUgZnVsZmlsbGVkSGFuZGxlciBpcyBjYWxsZWQgd2hlbiB0aGUgcHJvbWlzZVxuXHRcdFx0Ly9cdFx0aXMgZnVsZmlsbGVkLiBUaGUgZXJyb3JIYW5kbGVyIGlzIGNhbGxlZCB3aGVuIGEgcHJvbWlzZSBmYWlscy4gVGhlXG5cdFx0XHQvL1x0XHRwcm9ncmVzc0hhbmRsZXIgaXMgY2FsbGVkIGZvciBwcm9ncmVzcyBldmVudHMuIEFsbCBhcmd1bWVudHMgYXJlIG9wdGlvbmFsXG5cdFx0XHQvL1x0XHRhbmQgbm9uLWZ1bmN0aW9uIHZhbHVlcyBhcmUgaWdub3JlZC4gVGhlIHByb2dyZXNzSGFuZGxlciBpcyBub3Qgb25seSBhblxuXHRcdFx0Ly9cdFx0b3B0aW9uYWwgYXJndW1lbnQsIGJ1dCBwcm9ncmVzcyBldmVudHMgYXJlIHB1cmVseSBvcHRpb25hbC4gUHJvbWlzZVxuXHRcdFx0Ly9cdFx0cHJvdmlkZXJzIGFyZSBub3QgcmVxdWlyZWQgdG8gZXZlciBjcmVhdGUgcHJvZ3Jlc3MgZXZlbnRzLlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSBuZXcgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIHRoZSBnaXZlblxuXHRcdFx0Ly9cdFx0ZnVsZmlsbGVkSGFuZGxlciBvciBlcnJvckhhbmRsZXIgY2FsbGJhY2sgaXMgZmluaXNoZWQuIFRoaXMgYWxsb3dzIHByb21pc2Vcblx0XHRcdC8vXHRcdG9wZXJhdGlvbnMgdG8gYmUgY2hhaW5lZCB0b2dldGhlci4gVGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIGNhbGxiYWNrXG5cdFx0XHQvL1x0XHRoYW5kbGVyIGlzIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBmb3IgdGhlIHJldHVybmVkIHByb21pc2UuIElmIHRoZSBjYWxsYmFja1xuXHRcdFx0Ly9cdFx0dGhyb3dzIGFuIGVycm9yLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIG1vdmVkIHRvIGZhaWxlZCBzdGF0ZS5cblx0XHRcdC8vXG5cdFx0XHQvLyByZXR1cm5zOlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIG5ldyBwcm9taXNlIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVzdWx0IG9mIHRoZVxuXHRcdFx0Ly9cdFx0ZXhlY3V0aW9uIG9mIHRoZSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrcyB3aWxsIG5ldmVyIGFmZmVjdCB0aGUgb3JpZ2luYWwgcHJvbWlzZXMgdmFsdWUuXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0QW4gZXhhbXBsZSBvZiB1c2luZyBhIENvbW1vbkpTIGNvbXBsaWFudCBwcm9taXNlOlxuXHRcdFx0Ly9cdFx0fFx0YXN5bmNDb21wdXRlVGhlQW5zd2VyVG9FdmVyeXRoaW5nKCkuXG5cdFx0XHQvL1x0XHR8XHRcdHRoZW4oYWRkVHdvKS5cblx0XHRcdC8vXHRcdHxcdFx0dGhlbihwcmludFJlc3VsdCwgb25FcnJvcik7XG5cdFx0XHQvL1x0XHR8XHQ+NDRcblx0XHRcdC8vXG5cdFx0XHR2YXIgcmV0dXJuRGVmZXJyZWQgPSBwcm9ncmVzc0NhbGxiYWNrID09IG11dGF0b3IgPyB0aGlzIDogbmV3IERlZmVycmVkKHByb21pc2UuY2FuY2VsKTtcblx0XHRcdHZhciBsaXN0ZW5lciA9IHtcblx0XHRcdFx0cmVzb2x2ZWQ6IHJlc29sdmVkQ2FsbGJhY2ssXG5cdFx0XHRcdGVycm9yOiBlcnJvckNhbGxiYWNrLFxuXHRcdFx0XHRwcm9ncmVzczogcHJvZ3Jlc3NDYWxsYmFjayxcblx0XHRcdFx0ZGVmZXJyZWQ6IHJldHVybkRlZmVycmVkXG5cdFx0XHR9O1xuXHRcdFx0aWYobmV4dExpc3RlbmVyKXtcblx0XHRcdFx0aGVhZCA9IGhlYWQubmV4dCA9IGxpc3RlbmVyO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZXtcblx0XHRcdFx0bmV4dExpc3RlbmVyID0gaGVhZCA9IGxpc3RlbmVyO1xuXHRcdFx0fVxuXHRcdFx0aWYoZmluaXNoZWQpe1xuXHRcdFx0XHRub3RpZnkoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXR1cm5EZWZlcnJlZC5wcm9taXNlOyAvLyBQcm9taXNlXG5cdFx0fTtcblx0XHR2YXIgZGVmZXJyZWQgPSB0aGlzO1xuXHRcdHByb21pc2UuY2FuY2VsID0gdGhpcy5jYW5jZWwgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbmNlbHMgdGhlIGFzeW5jaHJvbm91cyBvcGVyYXRpb25cblx0XHRcdGlmKCFmaW5pc2hlZCl7XG5cdFx0XHRcdHZhciBlcnJvciA9IGNhbmNlbGxlciAmJiBjYW5jZWxsZXIoZGVmZXJyZWQpO1xuXHRcdFx0XHRpZighZmluaXNoZWQpe1xuXHRcdFx0XHRcdGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKXtcblx0XHRcdFx0XHRcdGVycm9yID0gbmV3IENhbmNlbEVycm9yKGVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXJyb3IubG9nID0gZmFsc2U7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2FuY2VsZWQgPSB0cnVlO1xuXHRcdH07XG5cdFx0ZnJlZXplKHByb21pc2UpO1xuXHR9O1xuXHRsYW5nLmV4dGVuZChEZWZlcnJlZCwge1xuXHRcdGFkZENhbGxiYWNrOiBmdW5jdGlvbigvKkZ1bmN0aW9uKi8gY2FsbGJhY2spe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEFkZHMgc3VjY2Vzc2Z1bCBjYWxsYmFjayBmb3IgdGhpcyBkZWZlcnJlZCBpbnN0YW5jZS5cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRoaXMgZGVmZXJyZWQgb2JqZWN0LlxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkQ2FsbGJhY2tzKGxhbmcuaGl0Y2guYXBwbHkoZG9qbywgYXJndW1lbnRzKSk7XHQvLyBEZWZlcnJlZFxuXHRcdH0sXG5cblx0XHRhZGRFcnJiYWNrOiBmdW5jdGlvbigvKkZ1bmN0aW9uKi8gZXJyYmFjayl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0QWRkcyBlcnJvciBjYWxsYmFjayBmb3IgdGhpcyBkZWZlcnJlZCBpbnN0YW5jZS5cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRoaXMgZGVmZXJyZWQgb2JqZWN0LlxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkQ2FsbGJhY2tzKG51bGwsIGxhbmcuaGl0Y2guYXBwbHkoZG9qbywgYXJndW1lbnRzKSk7XHQvLyBEZWZlcnJlZFxuXHRcdH0sXG5cblx0XHRhZGRCb3RoOiBmdW5jdGlvbigvKkZ1bmN0aW9uKi8gY2FsbGJhY2spe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEFkZCBoYW5kbGVyIGFzIGJvdGggc3VjY2Vzc2Z1bCBjYWxsYmFjayBhbmQgZXJyb3IgY2FsbGJhY2sgZm9yIHRoaXMgZGVmZXJyZWQgaW5zdGFuY2UuXG5cdFx0XHQvLyByZXR1cm5zOlxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0aGlzIGRlZmVycmVkIG9iamVjdC5cblx0XHRcdHZhciBlbmNsb3NlZCA9IGxhbmcuaGl0Y2guYXBwbHkoZG9qbywgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiB0aGlzLmFkZENhbGxiYWNrcyhlbmNsb3NlZCwgZW5jbG9zZWQpO1x0Ly8gRGVmZXJyZWRcblx0XHR9LFxuXHRcdGZpcmVkOiAtMVxuXHR9KTtcblxuXHREZWZlcnJlZC53aGVuID0gZG9qby53aGVuID0gd2hlbjtcblxuXHRyZXR1cm4gRGVmZXJyZWQ7XG59KTtcbiIsImRlZmluZShbXCIuL2tlcm5lbFwiLCBcIi4uL2hhc1wiLCBcIi4vbGFuZ1wiXSwgZnVuY3Rpb24oZG9qbywgaGFzLCBsYW5nKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL19iYXNlL2FycmF5XG5cblx0Ly8gb3VyIG9sZCBzaW1wbGUgZnVuY3Rpb24gYnVpbGRlciBzdHVmZlxuXHR2YXIgY2FjaGUgPSB7fSwgdTtcblxuXHRmdW5jdGlvbiBidWlsZEZuKGZuKXtcblx0XHRyZXR1cm4gY2FjaGVbZm5dID0gbmV3IEZ1bmN0aW9uKFwiaXRlbVwiLCBcImluZGV4XCIsIFwiYXJyYXlcIiwgZm4pOyAvLyBGdW5jdGlvblxuXHR9XG5cdC8vIG1hZ2ljIHNuaXBwZXQ6IGlmKHR5cGVvZiBmbiA9PSBcInN0cmluZ1wiKSBmbiA9IGNhY2hlW2ZuXSB8fCBidWlsZEZuKGZuKTtcblxuXHQvLyBldmVyeSAmIHNvbWVcblxuXHRmdW5jdGlvbiBldmVyeU9yU29tZShzb21lKXtcblx0XHR2YXIgZXZlcnkgPSAhc29tZTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oYSwgZm4sIG8pe1xuXHRcdFx0dmFyIGkgPSAwLCBsID0gYSAmJiBhLmxlbmd0aCB8fCAwLCByZXN1bHQ7XG5cdFx0XHRpZihsICYmIHR5cGVvZiBhID09IFwic3RyaW5nXCIpIGEgPSBhLnNwbGl0KFwiXCIpO1xuXHRcdFx0aWYodHlwZW9mIGZuID09IFwic3RyaW5nXCIpIGZuID0gY2FjaGVbZm5dIHx8IGJ1aWxkRm4oZm4pO1xuXHRcdFx0aWYobyl7XG5cdFx0XHRcdGZvcig7IGkgPCBsOyArK2kpe1xuXHRcdFx0XHRcdHJlc3VsdCA9ICFmbi5jYWxsKG8sIGFbaV0sIGksIGEpO1xuXHRcdFx0XHRcdGlmKHNvbWUgXiByZXN1bHQpe1xuXHRcdFx0XHRcdFx0cmV0dXJuICFyZXN1bHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Zm9yKDsgaSA8IGw7ICsraSl7XG5cdFx0XHRcdFx0cmVzdWx0ID0gIWZuKGFbaV0sIGksIGEpO1xuXHRcdFx0XHRcdGlmKHNvbWUgXiByZXN1bHQpe1xuXHRcdFx0XHRcdFx0cmV0dXJuICFyZXN1bHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZXZlcnk7IC8vIEJvb2xlYW5cblx0XHR9O1xuXHR9XG5cblx0Ly8gaW5kZXhPZiwgbGFzdEluZGV4T2ZcblxuXHRmdW5jdGlvbiBpbmRleCh1cCl7XG5cdFx0dmFyIGRlbHRhID0gMSwgbE92ZXIgPSAwLCB1T3ZlciA9IDA7XG5cdFx0aWYoIXVwKXtcblx0XHRcdGRlbHRhID0gbE92ZXIgPSB1T3ZlciA9IC0xO1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuY3Rpb24oYSwgeCwgZnJvbSwgbGFzdCl7XG5cdFx0XHRpZihsYXN0ICYmIGRlbHRhID4gMCl7XG5cdFx0XHRcdC8vIFRPRE86IHdoeSBkbyB3ZSB1c2UgYSBub24tc3RhbmRhcmQgc2lnbmF0dXJlPyB3aHkgZG8gd2UgbmVlZCBcImxhc3RcIj9cblx0XHRcdFx0cmV0dXJuIGFycmF5Lmxhc3RJbmRleE9mKGEsIHgsIGZyb20pO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGwgPSBhICYmIGEubGVuZ3RoIHx8IDAsIGVuZCA9IHVwID8gbCArIHVPdmVyIDogbE92ZXIsIGk7XG5cdFx0XHRpZihmcm9tID09PSB1KXtcblx0XHRcdFx0aSA9IHVwID8gbE92ZXIgOiBsICsgdU92ZXI7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0aWYoZnJvbSA8IDApe1xuXHRcdFx0XHRcdGkgPSBsICsgZnJvbTtcblx0XHRcdFx0XHRpZihpIDwgMCl7XG5cdFx0XHRcdFx0XHRpID0gbE92ZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRpID0gZnJvbSA+PSBsID8gbCArIHVPdmVyIDogZnJvbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYobCAmJiB0eXBlb2YgYSA9PSBcInN0cmluZ1wiKSBhID0gYS5zcGxpdChcIlwiKTtcblx0XHRcdGZvcig7IGkgIT0gZW5kOyBpICs9IGRlbHRhKXtcblx0XHRcdFx0aWYoYVtpXSA9PSB4KXtcblx0XHRcdFx0XHRyZXR1cm4gaTsgLy8gTnVtYmVyXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAtMTsgLy8gTnVtYmVyXG5cdFx0fTtcblx0fVxuXG5cdHZhciBhcnJheSA9IHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoZSBKYXZhc2NyaXB0IHYxLjYgYXJyYXkgZXh0ZW5zaW9ucy5cblxuXHRcdGV2ZXJ5OiBldmVyeU9yU29tZShmYWxzZSksXG5cdFx0Lyo9PT09PVxuXHRcdCBldmVyeTogZnVuY3Rpb24oYXJyLCBjYWxsYmFjaywgdGhpc09iamVjdCl7XG5cdFx0XHQgLy8gc3VtbWFyeTpcblx0XHRcdCAvL1x0XHREZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGV2ZXJ5IGl0ZW0gaW4gYXJyIHNhdGlzZmllcyB0aGVcblx0XHRcdCAvL1x0XHRjb25kaXRpb24gaW1wbGVtZW50ZWQgYnkgY2FsbGJhY2suXG5cdFx0XHQgLy8gYXJyOiBBcnJheXxTdHJpbmdcblx0XHRcdCAvL1x0XHR0aGUgYXJyYXkgdG8gaXRlcmF0ZSBvbi4gSWYgYSBzdHJpbmcsIG9wZXJhdGVzIG9uIGluZGl2aWR1YWwgY2hhcmFjdGVycy5cblx0XHRcdCAvLyBjYWxsYmFjazogRnVuY3Rpb258U3RyaW5nXG5cdFx0XHQgLy9cdFx0YSBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBpdGVtLCBpbmRleCxcblx0XHRcdCAvL1x0XHRhbmQgYXJyYXkgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgY29uZGl0aW9uIGlzIG1ldC5cblx0XHRcdCAvLyB0aGlzT2JqZWN0OiBPYmplY3Q/XG5cdFx0XHQgLy9cdFx0bWF5IGJlIHVzZWQgdG8gc2NvcGUgdGhlIGNhbGwgdG8gY2FsbGJhY2tcblx0XHRcdCAvLyByZXR1cm5zOiBCb29sZWFuXG5cdFx0XHQgLy8gZGVzY3JpcHRpb246XG5cdFx0XHQgLy9cdFx0VGhpcyBmdW5jdGlvbiBjb3JyZXNwb25kcyB0byB0aGUgSmF2YVNjcmlwdCAxLjYgQXJyYXkuZXZlcnkoKSBtZXRob2QsIHdpdGggb25lIGRpZmZlcmVuY2U6IHdoZW5cblx0XHRcdCAvL1x0XHRydW4gb3ZlciBzcGFyc2UgYXJyYXlzLCB0aGlzIGltcGxlbWVudGF0aW9uIHBhc3NlcyB0aGUgXCJob2xlc1wiIGluIHRoZSBzcGFyc2UgYXJyYXkgdG9cblx0XHRcdCAvL1x0XHR0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIHZhbHVlIG9mIHVuZGVmaW5lZC4gSmF2YVNjcmlwdCAxLjYncyBldmVyeSBza2lwcyB0aGUgaG9sZXMgaW4gdGhlIHNwYXJzZSBhcnJheS5cblx0XHRcdCAvL1x0XHRGb3IgbW9yZSBkZXRhaWxzLCBzZWU6XG5cdFx0XHQgLy9cdFx0aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9ldmVyeVxuXHRcdFx0IC8vIGV4YW1wbGU6XG5cdFx0XHQgLy9cdHxcdC8vIHJldHVybnMgZmFsc2Vcblx0XHRcdCAvL1x0fFx0YXJyYXkuZXZlcnkoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihpdGVtKXsgcmV0dXJuIGl0ZW0+MTsgfSk7XG5cdFx0XHQgLy8gZXhhbXBsZTpcblx0XHRcdCAvL1x0fFx0Ly8gcmV0dXJucyB0cnVlXG5cdFx0XHQgLy9cdHxcdGFycmF5LmV2ZXJ5KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24oaXRlbSl7IHJldHVybiBpdGVtPjA7IH0pO1xuXHRcdCB9LFxuXHRcdCA9PT09PSovXG5cblx0XHRzb21lOiBldmVyeU9yU29tZSh0cnVlKSxcblx0XHQvKj09PT09XG5cdFx0c29tZTogZnVuY3Rpb24oYXJyLCBjYWxsYmFjaywgdGhpc09iamVjdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBhbnkgaXRlbSBpbiBhcnIgc2F0aXNmaWVzIHRoZVxuXHRcdFx0Ly9cdFx0Y29uZGl0aW9uIGltcGxlbWVudGVkIGJ5IGNhbGxiYWNrLlxuXHRcdFx0Ly8gYXJyOiBBcnJheXxTdHJpbmdcblx0XHRcdC8vXHRcdHRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuIElmIGEgc3RyaW5nLCBvcGVyYXRlcyBvbiBpbmRpdmlkdWFsIGNoYXJhY3RlcnMuXG5cdFx0XHQvLyBjYWxsYmFjazogRnVuY3Rpb258U3RyaW5nXG5cdFx0XHQvL1x0XHRhIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IGl0ZW0sIGluZGV4LFxuXHRcdFx0Ly9cdFx0YW5kIGFycmF5IGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIGNvbmRpdGlvbiBpcyBtZXQuXG5cdFx0XHQvLyB0aGlzT2JqZWN0OiBPYmplY3Q/XG5cdFx0XHQvL1x0XHRtYXkgYmUgdXNlZCB0byBzY29wZSB0aGUgY2FsbCB0byBjYWxsYmFja1xuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRUaGlzIGZ1bmN0aW9uIGNvcnJlc3BvbmRzIHRvIHRoZSBKYXZhU2NyaXB0IDEuNiBBcnJheS5zb21lKCkgbWV0aG9kLCB3aXRoIG9uZSBkaWZmZXJlbmNlOiB3aGVuXG5cdFx0XHQvL1x0XHRydW4gb3ZlciBzcGFyc2UgYXJyYXlzLCB0aGlzIGltcGxlbWVudGF0aW9uIHBhc3NlcyB0aGUgXCJob2xlc1wiIGluIHRoZSBzcGFyc2UgYXJyYXkgdG9cblx0XHRcdC8vXHRcdHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGEgdmFsdWUgb2YgdW5kZWZpbmVkLiBKYXZhU2NyaXB0IDEuNidzIHNvbWUgc2tpcHMgdGhlIGhvbGVzIGluIHRoZSBzcGFyc2UgYXJyYXkuXG5cdFx0XHQvL1x0XHRGb3IgbW9yZSBkZXRhaWxzLCBzZWU6XG5cdFx0XHQvL1x0XHRodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L3NvbWVcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fCAvLyBpcyB0cnVlXG5cdFx0XHQvL1x0fCBhcnJheS5zb21lKFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24oaXRlbSl7IHJldHVybiBpdGVtPjE7IH0pO1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8IC8vIGlzIGZhbHNlXG5cdFx0XHQvL1x0fCBhcnJheS5zb21lKFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24oaXRlbSl7IHJldHVybiBpdGVtPDE7IH0pO1xuXHRcdH0sXG5cdFx0PT09PT0qL1xuXG5cdFx0aW5kZXhPZjogaW5kZXgodHJ1ZSksXG5cdFx0Lyo9PT09PVxuXHRcdGluZGV4T2Y6IGZ1bmN0aW9uKGFyciwgdmFsdWUsIGZyb21JbmRleCwgZmluZExhc3Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdGxvY2F0ZXMgdGhlIGZpcnN0IGluZGV4IG9mIHRoZSBwcm92aWRlZCB2YWx1ZSBpbiB0aGVcblx0XHRcdC8vXHRcdHBhc3NlZCBhcnJheS4gSWYgdGhlIHZhbHVlIGlzIG5vdCBmb3VuZCwgLTEgaXMgcmV0dXJuZWQuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoaXMgbWV0aG9kIGNvcnJlc3BvbmRzIHRvIHRoZSBKYXZhU2NyaXB0IDEuNiBBcnJheS5pbmRleE9mIG1ldGhvZCwgd2l0aCB0d28gZGlmZmVyZW5jZXM6XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0MS4gd2hlbiBydW4gb3ZlciBzcGFyc2UgYXJyYXlzLCB0aGUgRG9qbyBmdW5jdGlvbiBpbnZva2VzIHRoZSBjYWxsYmFjayBmb3IgZXZlcnkgaW5kZXhcblx0XHRcdC8vXHRcdCAgIHdoZXJlYXMgSmF2YVNjcmlwdCAxLjYncyBpbmRleE9mIHNraXBzIHRoZSBob2xlcyBpbiB0aGUgc3BhcnNlIGFycmF5LlxuXHRcdFx0Ly9cdFx0Mi4gdXNlcyBlcXVhbGl0eSAoPT0pIHJhdGhlciB0aGFuIHN0cmljdCBlcXVhbGl0eSAoPT09KVxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdEZvciBkZXRhaWxzIG9uIHRoaXMgbWV0aG9kLCBzZWU6XG5cdFx0XHQvL1x0XHRodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L2luZGV4T2Zcblx0XHRcdC8vIGFycjogQXJyYXlcblx0XHRcdC8vIHZhbHVlOiBPYmplY3Rcblx0XHRcdC8vIGZyb21JbmRleDogSW50ZWdlcj9cblx0XHRcdC8vIGZpbmRMYXN0OiBCb29sZWFuP1xuXHRcdFx0Ly9cdFx0TWFrZXMgaW5kZXhPZigpIHdvcmsgbGlrZSBsYXN0SW5kZXhPZigpLiAgVXNlZCBpbnRlcm5hbGx5OyBub3QgbWVhbnQgZm9yIGV4dGVybmFsIHVzYWdlLlxuXHRcdFx0Ly8gcmV0dXJuczogTnVtYmVyXG5cdFx0fSxcblx0XHQ9PT09PSovXG5cblx0XHRsYXN0SW5kZXhPZjogaW5kZXgoZmFsc2UpLFxuXHRcdC8qPT09PT1cblx0XHRsYXN0SW5kZXhPZjogZnVuY3Rpb24oYXJyLCB2YWx1ZSwgZnJvbUluZGV4KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRsb2NhdGVzIHRoZSBsYXN0IGluZGV4IG9mIHRoZSBwcm92aWRlZCB2YWx1ZSBpbiB0aGUgcGFzc2VkXG5cdFx0XHQvL1x0XHRhcnJheS4gSWYgdGhlIHZhbHVlIGlzIG5vdCBmb3VuZCwgLTEgaXMgcmV0dXJuZWQuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQgXHQvL1x0XHRUaGlzIG1ldGhvZCBjb3JyZXNwb25kcyB0byB0aGUgSmF2YVNjcmlwdCAxLjYgQXJyYXkubGFzdEluZGV4T2YgbWV0aG9kLCB3aXRoIHR3byBkaWZmZXJlbmNlczpcblx0XHQgXHQvL1xuXHRcdCBcdC8vXHRcdDEuIHdoZW4gcnVuIG92ZXIgc3BhcnNlIGFycmF5cywgdGhlIERvam8gZnVuY3Rpb24gaW52b2tlcyB0aGUgY2FsbGJhY2sgZm9yIGV2ZXJ5IGluZGV4XG5cdFx0IFx0Ly9cdFx0ICAgd2hlcmVhcyBKYXZhU2NyaXB0IDEuNidzIGxhc0luZGV4T2Ygc2tpcHMgdGhlIGhvbGVzIGluIHRoZSBzcGFyc2UgYXJyYXkuXG5cdFx0IFx0Ly9cdFx0Mi4gdXNlcyBlcXVhbGl0eSAoPT0pIHJhdGhlciB0aGFuIHN0cmljdCBlcXVhbGl0eSAoPT09KVxuXHRcdCBcdC8vXG5cdFx0IFx0Ly9cdFx0Rm9yIGRldGFpbHMgb24gdGhpcyBtZXRob2QsIHNlZTpcblx0XHQgXHQvL1x0XHRodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L2xhc3RJbmRleE9mXG5cdFx0XHQvLyBhcnI6IEFycmF5LFxuXHRcdFx0Ly8gdmFsdWU6IE9iamVjdCxcblx0XHRcdC8vIGZyb21JbmRleDogSW50ZWdlcj9cblx0XHRcdC8vIHJldHVybnM6IE51bWJlclxuXHRcdH0sXG5cdFx0PT09PT0qL1xuXG5cdFx0Zm9yRWFjaDogZnVuY3Rpb24oYXJyLCBjYWxsYmFjaywgdGhpc09iamVjdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Zm9yIGV2ZXJ5IGl0ZW0gaW4gYXJyLCBjYWxsYmFjayBpcyBpbnZva2VkLiBSZXR1cm4gdmFsdWVzIGFyZSBpZ25vcmVkLlxuXHRcdFx0Ly9cdFx0SWYgeW91IHdhbnQgdG8gYnJlYWsgb3V0IG9mIHRoZSBsb29wLCBjb25zaWRlciB1c2luZyBhcnJheS5ldmVyeSgpIG9yIGFycmF5LnNvbWUoKS5cblx0XHRcdC8vXHRcdGZvckVhY2ggZG9lcyBub3QgYWxsb3cgYnJlYWtpbmcgb3V0IG9mIHRoZSBsb29wIG92ZXIgdGhlIGl0ZW1zIGluIGFyci5cblx0XHRcdC8vIGFycjpcblx0XHRcdC8vXHRcdHRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuIElmIGEgc3RyaW5nLCBvcGVyYXRlcyBvbiBpbmRpdmlkdWFsIGNoYXJhY3RlcnMuXG5cdFx0XHQvLyBjYWxsYmFjazpcblx0XHRcdC8vXHRcdGEgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogaXRlbSwgaW5kZXgsIGFuZCBhcnJheVxuXHRcdFx0Ly8gdGhpc09iamVjdDpcblx0XHRcdC8vXHRcdG1heSBiZSB1c2VkIHRvIHNjb3BlIHRoZSBjYWxsIHRvIGNhbGxiYWNrXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoaXMgZnVuY3Rpb24gY29ycmVzcG9uZHMgdG8gdGhlIEphdmFTY3JpcHQgMS42IEFycmF5LmZvckVhY2goKSBtZXRob2QsIHdpdGggb25lIGRpZmZlcmVuY2U6IHdoZW5cblx0XHRcdC8vXHRcdHJ1biBvdmVyIHNwYXJzZSBhcnJheXMsIHRoaXMgaW1wbGVtZW50YXRpb24gcGFzc2VzIHRoZSBcImhvbGVzXCIgaW4gdGhlIHNwYXJzZSBhcnJheSB0b1xuXHRcdFx0Ly9cdFx0dGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSB2YWx1ZSBvZiB1bmRlZmluZWQuIEphdmFTY3JpcHQgMS42J3MgZm9yRWFjaCBza2lwcyB0aGUgaG9sZXMgaW4gdGhlIHNwYXJzZSBhcnJheS5cblx0XHRcdC8vXHRcdEZvciBtb3JlIGRldGFpbHMsIHNlZTpcblx0XHRcdC8vXHRcdGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvZm9yRWFjaFxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8IC8vIGxvZyBvdXQgYWxsIG1lbWJlcnMgb2YgdGhlIGFycmF5OlxuXHRcdFx0Ly9cdHwgYXJyYXkuZm9yRWFjaChcblx0XHRcdC8vXHR8XHRcdFsgXCJ0aGluZ2VyXCIsIFwiYmxhaFwiLCBcImhvd2R5XCIsIDEwIF0sXG5cdFx0XHQvL1x0fFx0XHRmdW5jdGlvbihpdGVtKXtcblx0XHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coaXRlbSk7XG5cdFx0XHQvL1x0fFx0XHR9XG5cdFx0XHQvL1x0fCApO1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8IC8vIGxvZyBvdXQgdGhlIG1lbWJlcnMgYW5kIHRoZWlyIGluZGV4ZXNcblx0XHRcdC8vXHR8IGFycmF5LmZvckVhY2goXG5cdFx0XHQvL1x0fFx0XHRbIFwidGhpbmdlclwiLCBcImJsYWhcIiwgXCJob3dkeVwiLCAxMCBdLFxuXHRcdFx0Ly9cdHxcdFx0ZnVuY3Rpb24oaXRlbSwgaWR4LCBhcnIpe1xuXHRcdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhpdGVtLCBcImF0IGluZGV4OlwiLCBpZHgpO1xuXHRcdFx0Ly9cdHxcdFx0fVxuXHRcdFx0Ly9cdHwgKTtcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fCAvLyB1c2UgYSBzY29wZWQgb2JqZWN0IG1lbWJlciBhcyB0aGUgY2FsbGJhY2tcblx0XHRcdC8vXHR8XG5cdFx0XHQvL1x0fCB2YXIgb2JqID0ge1xuXHRcdFx0Ly9cdHxcdFx0cHJlZml4OiBcImxvZ2dlZCB2aWEgb2JqLmNhbGxiYWNrOlwiLFxuXHRcdFx0Ly9cdHxcdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyh0aGlzLnByZWZpeCwgaXRlbSk7XG5cdFx0XHQvL1x0fFx0XHR9XG5cdFx0XHQvL1x0fCB9O1xuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8IC8vIHNwZWNpZnlpbmcgdGhlIHNjb3BlIGZ1bmN0aW9uIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBpbiB0aGF0IHNjb3BlXG5cdFx0XHQvL1x0fCBhcnJheS5mb3JFYWNoKFxuXHRcdFx0Ly9cdHxcdFx0WyBcInRoaW5nZXJcIiwgXCJibGFoXCIsIFwiaG93ZHlcIiwgMTAgXSxcblx0XHRcdC8vXHR8XHRcdG9iai5jYWxsYmFjayxcblx0XHRcdC8vXHR8XHRcdG9ialxuXHRcdFx0Ly9cdHwgKTtcblx0XHRcdC8vXHR8XG5cdFx0XHQvL1x0fCAvLyBhbHRlcm5hdGVseSwgd2UgY2FuIGFjY29tcGxpc2ggdGhlIHNhbWUgdGhpbmcgd2l0aCBsYW5nLmhpdGNoKClcblx0XHRcdC8vXHR8IGFycmF5LmZvckVhY2goXG5cdFx0XHQvL1x0fFx0XHRbIFwidGhpbmdlclwiLCBcImJsYWhcIiwgXCJob3dkeVwiLCAxMCBdLFxuXHRcdFx0Ly9cdHxcdFx0bGFuZy5oaXRjaChvYmosIFwiY2FsbGJhY2tcIilcblx0XHRcdC8vXHR8ICk7XG5cdFx0XHQvLyBhcnI6IEFycmF5fFN0cmluZ1xuXHRcdFx0Ly8gY2FsbGJhY2s6IEZ1bmN0aW9ufFN0cmluZ1xuXHRcdFx0Ly8gdGhpc09iamVjdDogT2JqZWN0P1xuXG5cdFx0XHR2YXIgaSA9IDAsIGwgPSBhcnIgJiYgYXJyLmxlbmd0aCB8fCAwO1xuXHRcdFx0aWYobCAmJiB0eXBlb2YgYXJyID09IFwic3RyaW5nXCIpIGFyciA9IGFyci5zcGxpdChcIlwiKTtcblx0XHRcdGlmKHR5cGVvZiBjYWxsYmFjayA9PSBcInN0cmluZ1wiKSBjYWxsYmFjayA9IGNhY2hlW2NhbGxiYWNrXSB8fCBidWlsZEZuKGNhbGxiYWNrKTtcblx0XHRcdGlmKHRoaXNPYmplY3Qpe1xuXHRcdFx0XHRmb3IoOyBpIDwgbDsgKytpKXtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXNPYmplY3QsIGFycltpXSwgaSwgYXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGZvcig7IGkgPCBsOyArK2kpe1xuXHRcdFx0XHRcdGNhbGxiYWNrKGFycltpXSwgaSwgYXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRtYXA6IGZ1bmN0aW9uKGFyciwgY2FsbGJhY2ssIHRoaXNPYmplY3QsIEN0cil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0YXBwbGllcyBjYWxsYmFjayB0byBlYWNoIGVsZW1lbnQgb2YgYXJyIGFuZCByZXR1cm5zXG5cdFx0XHQvL1x0XHRhbiBBcnJheSB3aXRoIHRoZSByZXN1bHRzXG5cdFx0XHQvLyBhcnI6IEFycmF5fFN0cmluZ1xuXHRcdFx0Ly9cdFx0dGhlIGFycmF5IHRvIGl0ZXJhdGUgb24uIElmIGEgc3RyaW5nLCBvcGVyYXRlcyBvblxuXHRcdFx0Ly9cdFx0aW5kaXZpZHVhbCBjaGFyYWN0ZXJzLlxuXHRcdFx0Ly8gY2FsbGJhY2s6IEZ1bmN0aW9ufFN0cmluZ1xuXHRcdFx0Ly9cdFx0YSBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzLCAoaXRlbSwgaW5kZXgsXG5cdFx0XHQvL1x0XHRhcnJheSksXHQgYW5kIHJldHVybnMgYSB2YWx1ZVxuXHRcdFx0Ly8gdGhpc09iamVjdDogT2JqZWN0P1xuXHRcdFx0Ly9cdFx0bWF5IGJlIHVzZWQgdG8gc2NvcGUgdGhlIGNhbGwgdG8gY2FsbGJhY2tcblx0XHRcdC8vIHJldHVybnM6IEFycmF5XG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoaXMgZnVuY3Rpb24gY29ycmVzcG9uZHMgdG8gdGhlIEphdmFTY3JpcHQgMS42IEFycmF5Lm1hcCgpIG1ldGhvZCwgd2l0aCBvbmUgZGlmZmVyZW5jZTogd2hlblxuXHRcdFx0Ly9cdFx0cnVuIG92ZXIgc3BhcnNlIGFycmF5cywgdGhpcyBpbXBsZW1lbnRhdGlvbiBwYXNzZXMgdGhlIFwiaG9sZXNcIiBpbiB0aGUgc3BhcnNlIGFycmF5IHRvXG5cdFx0XHQvL1x0XHR0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIHZhbHVlIG9mIHVuZGVmaW5lZC4gSmF2YVNjcmlwdCAxLjYncyBtYXAgc2tpcHMgdGhlIGhvbGVzIGluIHRoZSBzcGFyc2UgYXJyYXkuXG5cdFx0XHQvL1x0XHRGb3IgbW9yZSBkZXRhaWxzLCBzZWU6XG5cdFx0XHQvL1x0XHRodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L21hcFxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8IC8vIHJldHVybnMgWzIsIDMsIDQsIDVdXG5cdFx0XHQvL1x0fCBhcnJheS5tYXAoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihpdGVtKXsgcmV0dXJuIGl0ZW0rMSB9KTtcblxuXHRcdFx0Ly8gVE9ETzogd2h5IGRvIHdlIGhhdmUgYSBub24tc3RhbmRhcmQgc2lnbmF0dXJlIGhlcmU/IGRvIHdlIG5lZWQgXCJDdHJcIj9cblx0XHRcdHZhciBpID0gMCwgbCA9IGFyciAmJiBhcnIubGVuZ3RoIHx8IDAsIG91dCA9IG5ldyAoQ3RyIHx8IEFycmF5KShsKTtcblx0XHRcdGlmKGwgJiYgdHlwZW9mIGFyciA9PSBcInN0cmluZ1wiKSBhcnIgPSBhcnIuc3BsaXQoXCJcIik7XG5cdFx0XHRpZih0eXBlb2YgY2FsbGJhY2sgPT0gXCJzdHJpbmdcIikgY2FsbGJhY2sgPSBjYWNoZVtjYWxsYmFja10gfHwgYnVpbGRGbihjYWxsYmFjayk7XG5cdFx0XHRpZih0aGlzT2JqZWN0KXtcblx0XHRcdFx0Zm9yKDsgaSA8IGw7ICsraSl7XG5cdFx0XHRcdFx0b3V0W2ldID0gY2FsbGJhY2suY2FsbCh0aGlzT2JqZWN0LCBhcnJbaV0sIGksIGFycik7XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNle1xuXHRcdFx0XHRmb3IoOyBpIDwgbDsgKytpKXtcblx0XHRcdFx0XHRvdXRbaV0gPSBjYWxsYmFjayhhcnJbaV0sIGksIGFycik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXQ7IC8vIEFycmF5XG5cdFx0fSxcblxuXHRcdGZpbHRlcjogZnVuY3Rpb24oYXJyLCBjYWxsYmFjaywgdGhpc09iamVjdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIG5ldyBBcnJheSB3aXRoIHRob3NlIGl0ZW1zIGZyb20gYXJyIHRoYXQgbWF0Y2ggdGhlXG5cdFx0XHQvL1x0XHRjb25kaXRpb24gaW1wbGVtZW50ZWQgYnkgY2FsbGJhY2suXG5cdFx0XHQvLyBhcnI6IEFycmF5XG5cdFx0XHQvL1x0XHR0aGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHRcdFx0Ly8gY2FsbGJhY2s6IEZ1bmN0aW9ufFN0cmluZ1xuXHRcdFx0Ly9cdFx0YSBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHMgKGl0ZW0sXG5cdFx0XHQvL1x0XHRpbmRleCwgYXJyYXkpLiBUaGUgcmV0dXJuIG9mIHRoaXMgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG9cblx0XHRcdC8vXHRcdGJlIGEgYm9vbGVhbiB3aGljaCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhc3NlZC1pbiBpdGVtXG5cdFx0XHQvL1x0XHR3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSByZXR1cm5lZCBhcnJheS5cblx0XHRcdC8vIHRoaXNPYmplY3Q6IE9iamVjdD9cblx0XHRcdC8vXHRcdG1heSBiZSB1c2VkIHRvIHNjb3BlIHRoZSBjYWxsIHRvIGNhbGxiYWNrXG5cdFx0XHQvLyByZXR1cm5zOiBBcnJheVxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRUaGlzIGZ1bmN0aW9uIGNvcnJlc3BvbmRzIHRvIHRoZSBKYXZhU2NyaXB0IDEuNiBBcnJheS5maWx0ZXIoKSBtZXRob2QsIHdpdGggb25lIGRpZmZlcmVuY2U6IHdoZW5cblx0XHRcdC8vXHRcdHJ1biBvdmVyIHNwYXJzZSBhcnJheXMsIHRoaXMgaW1wbGVtZW50YXRpb24gcGFzc2VzIHRoZSBcImhvbGVzXCIgaW4gdGhlIHNwYXJzZSBhcnJheSB0b1xuXHRcdFx0Ly9cdFx0dGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSB2YWx1ZSBvZiB1bmRlZmluZWQuIEphdmFTY3JpcHQgMS42J3MgZmlsdGVyIHNraXBzIHRoZSBob2xlcyBpbiB0aGUgc3BhcnNlIGFycmF5LlxuXHRcdFx0Ly9cdFx0Rm9yIG1vcmUgZGV0YWlscywgc2VlOlxuXHRcdFx0Ly9cdFx0aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9maWx0ZXJcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fCAvLyByZXR1cm5zIFsyLCAzLCA0XVxuXHRcdFx0Ly9cdHwgYXJyYXkuZmlsdGVyKFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24oaXRlbSl7IHJldHVybiBpdGVtPjE7IH0pO1xuXG5cdFx0XHQvLyBUT0RPOiBkbyB3ZSBuZWVkIFwiQ3RyXCIgaGVyZSBsaWtlIGluIG1hcCgpP1xuXHRcdFx0dmFyIGkgPSAwLCBsID0gYXJyICYmIGFyci5sZW5ndGggfHwgMCwgb3V0ID0gW10sIHZhbHVlO1xuXHRcdFx0aWYobCAmJiB0eXBlb2YgYXJyID09IFwic3RyaW5nXCIpIGFyciA9IGFyci5zcGxpdChcIlwiKTtcblx0XHRcdGlmKHR5cGVvZiBjYWxsYmFjayA9PSBcInN0cmluZ1wiKSBjYWxsYmFjayA9IGNhY2hlW2NhbGxiYWNrXSB8fCBidWlsZEZuKGNhbGxiYWNrKTtcblx0XHRcdGlmKHRoaXNPYmplY3Qpe1xuXHRcdFx0XHRmb3IoOyBpIDwgbDsgKytpKXtcblx0XHRcdFx0XHR2YWx1ZSA9IGFycltpXTtcblx0XHRcdFx0XHRpZihjYWxsYmFjay5jYWxsKHRoaXNPYmplY3QsIHZhbHVlLCBpLCBhcnIpKXtcblx0XHRcdFx0XHRcdG91dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNle1xuXHRcdFx0XHRmb3IoOyBpIDwgbDsgKytpKXtcblx0XHRcdFx0XHR2YWx1ZSA9IGFycltpXTtcblx0XHRcdFx0XHRpZihjYWxsYmFjayh2YWx1ZSwgaSwgYXJyKSl7XG5cdFx0XHRcdFx0XHRvdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0OyAvLyBBcnJheVxuXHRcdH0sXG5cblx0XHRjbGVhckNhY2hlOiBmdW5jdGlvbigpe1xuXHRcdFx0Y2FjaGUgPSB7fTtcblx0XHR9XG5cdH07XG5cblxuXHRoYXMoXCJleHRlbmQtZG9qb1wiKSAmJiBsYW5nLm1peGluKGRvam8sIGFycmF5KTtcblxuXHRyZXR1cm4gYXJyYXk7XG59KTtcbiIsImRlZmluZShbXCIuLi9nbG9iYWxcIiwgXCIuLi9oYXNcIiwgXCJyZXF1aXJlXCJdLCBmdW5jdGlvbihnbG9iYWwsIGhhcywgcmVxdWlyZSl7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9fYmFzZS9jb25maWdcblxuLyo9PT09PVxucmV0dXJuIHtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0VGhpcyBtb2R1bGUgZGVmaW5lcyB0aGUgdXNlciBjb25maWd1cmF0aW9uIGR1cmluZyBib290c3RyYXAuXG5cdC8vIGRlc2NyaXB0aW9uOlxuXHQvL1x0XHRCeSBkZWZpbmluZyB1c2VyIGNvbmZpZ3VyYXRpb24gYXMgYSBtb2R1bGUgdmFsdWUsIGFuIGVudGlyZSBjb25maWd1cmF0aW9uIGNhbiBiZSBzcGVjaWZpZWQgaW4gYSBidWlsZCxcblx0Ly9cdFx0dGhlcmVieSBlbGltaW5hdGluZyB0aGUgbmVlZCBmb3Igc25pZmZpbmcgYW5kIG9yIGV4cGxpY2l0bHkgc2V0dGluZyBpbiB0aGUgZ2xvYmFsIHZhcmlhYmxlIGRvam9Db25maWcuXG5cdC8vXHRcdEFsc28sIHdoZW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mIGRvam8gZXhpc3QgaW4gYSBzaW5nbGUgYXBwbGljYXRpb24sIGVhY2ggd2lsbCBuZWNlc3NhcmlseSBiZSBsb2NhdGVkXG5cdC8vXHRcdGF0IGFuIHVuaXF1ZSBhYnNvbHV0ZSBtb2R1bGUgaWRlbnRpZmllciBhcyBnaXZlbiBieSB0aGUgcGFja2FnZSBjb25maWd1cmF0aW9uLiBJbXBsZW1lbnRpbmcgY29uZmlndXJhdGlvblxuXHQvL1x0XHRhcyBhIG1vZHVsZSBhbGxvd3MgZm9yIHNwZWNpZnlpbmcgdW5pcXVlLCBwZXItaW5zdGFuY2UgY29uZmlndXJhdGlvbnMuXG5cdC8vIGV4YW1wbGU6XG5cdC8vXHRcdENyZWF0ZSBhIHNlY29uZCBpbnN0YW5jZSBvZiBkb2pvIHdpdGggYSBkaWZmZXJlbnQsIGluc3RhbmNlLXVuaXF1ZSBjb25maWd1cmF0aW9uIChhc3N1bWUgdGhlIGxvYWRlciBhbmRcblx0Ly9cdFx0ZG9qby5qcyBhcmUgYWxyZWFkeSBsb2FkZWQpLlxuXHQvL1x0XHR8XHQvLyBzcGVjaWZ5IGEgY29uZmlndXJhdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgZG9qbyBhdCB0aGUgYWJzb2x1dGUgbW9kdWxlIGlkZW50aWZpZXIgXCJteURvam9cIlxuXHQvL1x0XHR8XHRyZXF1aXJlKHtcblx0Ly9cdFx0fFx0XHRwYWNrYWdlczpbe1xuXHQvL1x0XHR8XHRcdFx0bmFtZTpcIm15RG9qb1wiLFxuXHQvL1x0XHR8XHRcdFx0bG9jYXRpb246XCIuXCIsIC8vYXNzdW1lIGJhc2VVcmwgcG9pbnRzIHRvIGRvam8uanNcblx0Ly9cdFx0fFx0XHR9XVxuXHQvL1x0XHR8XHR9KTtcblx0Ly9cdFx0fFxuXHQvL1x0XHR8XHQvLyBzcGVjaWZ5IGEgY29uZmlndXJhdGlvbiBmb3IgdGhlIG15RG9qbyBpbnN0YW5jZVxuXHQvL1x0XHR8XHRkZWZpbmUoXCJteURvam8vY29uZmlnXCIsIHtcblx0Ly9cdFx0fFx0XHQvLyBub3JtYWwgY29uZmlndXJhdGlvbiB2YXJpYWJsZXMgZ28gaGVyZSwgZS5nLixcblx0Ly9cdFx0fFx0XHRsb2NhbGU6XCJmci1jYVwiXG5cdC8vXHRcdHxcdH0pO1xuXHQvL1x0XHR8XG5cdC8vXHRcdHxcdC8vIGxvYWQgYW5kIHVzZSB0aGUgbmV3IGluc3RhbmNlIG9mIGRvam9cblx0Ly9cdFx0fFx0cmVxdWlyZShbXCJteURvam9cIl0sIGZ1bmN0aW9uKGRvam8pe1xuXHQvL1x0XHR8XHRcdC8vIGRvam8gaXMgdGhlIG5ldyBpbnN0YW5jZSBvZiBkb2pvXG5cdC8vXHRcdHxcdFx0Ly8gdXNlIGFzIHJlcXVpcmVkXG5cdC8vXHRcdHxcdH0pO1xuXG5cdC8vIGlzRGVidWc6IEJvb2xlYW5cblx0Ly9cdFx0RGVmYXVsdHMgdG8gYGZhbHNlYC4gSWYgc2V0IHRvIGB0cnVlYCwgZW5zdXJlcyB0aGF0IERvam8gcHJvdmlkZXNcblx0Ly9cdFx0ZXh0ZW5kZWQgZGVidWdnaW5nIGZlZWRiYWNrIHRvIHRoZSBjb25zb2xlLlxuXHRpc0RlYnVnOiBmYWxzZSxcblxuXHQvLyBsb2NhbGU6IFN0cmluZ1xuXHQvL1x0XHRUaGUgbG9jYWxlIHRvIGFzc3VtZSBmb3IgbG9hZGluZyBsb2NhbGl6ZWQgcmVzb3VyY2VzIGluIHRoaXMgcGFnZSxcblx0Ly9cdFx0c3BlY2lmaWVkIGFjY29yZGluZyB0byBbUkZDIDMwNjZdKGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMwNjYudHh0KS5cblx0Ly9cdFx0TXVzdCBiZSBzcGVjaWZpZWQgZW50aXJlbHkgaW4gbG93ZXJjYXNlLCBlLmcuIGBlbi11c2AgYW5kIGB6aC1jbmAuXG5cdC8vXHRcdFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgYGRvam8uaTE4bmAgYW5kIGBkb2pvLnJlcXVpcmVMb2NhbGl6YXRpb25gXG5cdC8vXHRcdGZvciBkZXRhaWxzIG9uIGxvYWRpbmcgbG9jYWxpemVkIHJlc291cmNlcy4gSWYgbm8gbG9jYWxlIGlzIHNwZWNpZmllZCxcblx0Ly9cdFx0RG9qbyBhc3N1bWVzIHRoZSBsb2NhbGUgb2YgdGhlIHVzZXIgYWdlbnQsIGFjY29yZGluZyB0byBgbmF2aWdhdG9yLnVzZXJMYW5ndWFnZWBcblx0Ly9cdFx0b3IgYG5hdmlnYXRvci5sYW5ndWFnZWAgcHJvcGVydGllcy5cblx0bG9jYWxlOiB1bmRlZmluZWQsXG5cblx0Ly8gZXh0cmFMb2NhbGU6IEFycmF5XG5cdC8vXHRcdE5vIGRlZmF1bHQgdmFsdWUuIFNwZWNpZmllcyBhZGRpdGlvbmFsIGxvY2FsZXMgd2hvc2Vcblx0Ly9cdFx0cmVzb3VyY2VzIHNob3VsZCBhbHNvIGJlIGxvYWRlZCBhbG9uZ3NpZGUgdGhlIGRlZmF1bHQgbG9jYWxlIHdoZW5cblx0Ly9cdFx0Y2FsbHMgdG8gYGRvam8ucmVxdWlyZUxvY2FsaXphdGlvbigpYCBhcmUgcHJvY2Vzc2VkLlxuXHRleHRyYUxvY2FsZTogdW5kZWZpbmVkLFxuXG5cdC8vIGJhc2VVcmw6IFN0cmluZ1xuXHQvL1x0XHRUaGUgZGlyZWN0b3J5IGluIHdoaWNoIGBkb2pvLmpzYCBpcyBsb2NhdGVkLiBVbmRlciBub3JtYWxcblx0Ly9cdFx0Y29uZGl0aW9ucywgRG9qbyBhdXRvLWRldGVjdHMgdGhlIGNvcnJlY3QgbG9jYXRpb24gZnJvbSB3aGljaCBpdFxuXHQvL1x0XHR3YXMgbG9hZGVkLiBZb3UgbWF5IG5lZWQgdG8gbWFudWFsbHkgY29uZmlndXJlIGBiYXNlVXJsYCBpbiBjYXNlc1xuXHQvL1x0XHR3aGVyZSB5b3UgaGF2ZSByZW5hbWVkIGBkb2pvLmpzYCBvciBpbiB3aGljaCBgPGJhc2U+YCB0YWdzIGNvbmZ1c2Vcblx0Ly9cdFx0c29tZSBicm93c2VycyAoZS5nLiBJRSA2KS4gVGhlIHZhcmlhYmxlIGBkb2pvLmJhc2VVcmxgIGlzIGFzc2lnbmVkXG5cdC8vXHRcdGVpdGhlciB0aGUgdmFsdWUgb2YgYGRqQ29uZmlnLmJhc2VVcmxgIGlmIG9uZSBpcyBwcm92aWRlZCBvciB0aGVcblx0Ly9cdFx0YXV0by1kZXRlY3RlZCByb290IGlmIG5vdC4gT3RoZXIgbW9kdWxlcyBhcmUgbG9jYXRlZCByZWxhdGl2ZSB0b1xuXHQvL1x0XHR0aGlzIHBhdGguIFRoZSBwYXRoIHNob3VsZCBlbmQgaW4gYSBzbGFzaC5cblx0YmFzZVVybDogdW5kZWZpbmVkLFxuXG5cdC8vIG1vZHVsZVBhdGhzOiBbZGVwcmVjYXRlZF0gT2JqZWN0XG5cdC8vXHRcdEEgbWFwIG9mIG1vZHVsZSBuYW1lcyB0byBwYXRocyByZWxhdGl2ZSB0byBgZG9qby5iYXNlVXJsYC4gVGhlXG5cdC8vXHRcdGtleS92YWx1ZSBwYWlycyBjb3JyZXNwb25kIGRpcmVjdGx5IHRvIHRoZSBhcmd1bWVudHMgd2hpY2hcblx0Ly9cdFx0YGRvam8ucmVnaXN0ZXJNb2R1bGVQYXRoYCBhY2NlcHRzLiBTcGVjaWZ5aW5nXG5cdC8vXHRcdGBkakNvbmZpZy5tb2R1bGVQYXRocyA9IHsgXCJmb29cIjogXCIuLi8uLi9iYXJcIiB9YCBpcyB0aGUgZXF1aXZhbGVudFxuXHQvL1x0XHRvZiBjYWxsaW5nIGBkb2pvLnJlZ2lzdGVyTW9kdWxlUGF0aChcImZvb1wiLCBcIi4uLy4uL2JhclwiKTtgLiBNdWx0aXBsZVxuXHQvL1x0XHRtb2R1bGVzIG1heSBiZSBjb25maWd1cmVkIHZpYSBgZGpDb25maWcubW9kdWxlUGF0aHNgLlxuXHRtb2R1bGVQYXRoczoge30sXG5cblx0Ly8gYWRkT25Mb2FkOiBGdW5jdGlvbnxBcnJheVxuXHQvL1x0XHRBZGRzIGEgY2FsbGJhY2sgdmlhIGRvam8vcmVhZHkuIFVzZWZ1bCB3aGVuIERvam8gaXMgYWRkZWQgYWZ0ZXJcblx0Ly9cdFx0dGhlIHBhZ2UgbG9hZHMgYW5kIGRqQ29uZmlnLmFmdGVyT25Mb2FkIGlzIHRydWUuIFN1cHBvcnRzIHRoZSBzYW1lXG5cdC8vXHRcdGFyZ3VtZW50cyBhcyBkb2pvL3JlYWR5LiBXaGVuIHVzaW5nIGEgZnVuY3Rpb24gcmVmZXJlbmNlLCB1c2Vcblx0Ly9cdFx0YGRqQ29uZmlnLmFkZE9uTG9hZCA9IGZ1bmN0aW9uKCl7fTtgLiBGb3Igb2JqZWN0IHdpdGggZnVuY3Rpb24gbmFtZSB1c2Vcblx0Ly9cdFx0YGRqQ29uZmlnLmFkZE9uTG9hZCA9IFtteU9iamVjdCwgXCJmdW5jdGlvbk5hbWVcIl07YCBhbmQgZm9yIG9iamVjdCB3aXRoXG5cdC8vXHRcdGZ1bmN0aW9uIHJlZmVyZW5jZSB1c2Vcblx0Ly9cdFx0YGRqQ29uZmlnLmFkZE9uTG9hZCA9IFtteU9iamVjdCwgZnVuY3Rpb24oKXt9XTtgXG5cdGFkZE9uTG9hZDogbnVsbCxcblxuXHQvLyBwYXJzZU9uTG9hZDogQm9vbGVhblxuXHQvL1x0XHRSdW4gdGhlIHBhcnNlciBhZnRlciB0aGUgcGFnZSBpcyBsb2FkZWRcblx0cGFyc2VPbkxvYWQ6IGZhbHNlLFxuXG5cdC8vIHJlcXVpcmU6IFN0cmluZ1tdXG5cdC8vXHRcdEFuIGFycmF5IG9mIG1vZHVsZSBuYW1lcyB0byBiZSBsb2FkZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgZG9qby5qcyBoYXMgYmVlbiBpbmNsdWRlZFxuXHQvL1x0XHRpbiBhIHBhZ2UuXG5cdHJlcXVpcmU6IFtdLFxuXG5cdC8vIGRlZmF1bHREdXJhdGlvbjogTnVtYmVyXG5cdC8vXHRcdERlZmF1bHQgZHVyYXRpb24sIGluIG1pbGxpc2Vjb25kcywgZm9yIHdpcGUgYW5kIGZhZGUgYW5pbWF0aW9ucyB3aXRoaW4gZGlqaXRzLlxuXHQvL1x0XHRBc3NpZ25lZCB0byBkaWppdC5kZWZhdWx0RHVyYXRpb24uXG5cdGRlZmF1bHREdXJhdGlvbjogMjAwLFxuXG5cdC8vIGRvam9CbGFua0h0bWxVcmw6IFN0cmluZ1xuXHQvL1x0XHRVc2VkIGJ5IHNvbWUgbW9kdWxlcyB0byBjb25maWd1cmUgYW4gZW1wdHkgaWZyYW1lLiBVc2VkIGJ5IGRvam8vaW8vaWZyYW1lIGFuZFxuXHQvL1x0XHRkb2pvL2JhY2ssIGFuZCBkaWppdC9wb3B1cCBzdXBwb3J0IGluIElFIHdoZXJlIGFuIGlmcmFtZSBpcyBuZWVkZWQgdG8gbWFrZSBzdXJlIG5hdGl2ZVxuXHQvL1x0XHRjb250cm9scyBkbyBub3QgYmxlZWQgdGhyb3VnaCB0aGUgcG9wdXBzLiBOb3JtYWxseSB0aGlzIGNvbmZpZ3VyYXRpb24gdmFyaWFibGVcblx0Ly9cdFx0ZG9lcyBub3QgbmVlZCB0byBiZSBzZXQsIGV4Y2VwdCB3aGVuIHVzaW5nIGNyb3NzLWRvbWFpbi9DRE4gRG9qbyBidWlsZHMuXG5cdC8vXHRcdFNhdmUgZG9qby9yZXNvdXJjZXMvYmxhbmsuaHRtbCB0byB5b3VyIGRvbWFpbiBhbmQgc2V0IGBkakNvbmZpZy5kb2pvQmxhbmtIdG1sVXJsYFxuXHQvL1x0XHR0byB0aGUgcGF0aCBvbiB5b3VyIGRvbWFpbiB5b3VyIGNvcHkgb2YgYmxhbmsuaHRtbC5cblx0ZG9qb0JsYW5rSHRtbFVybDogdW5kZWZpbmVkLFxuXG5cdC8vIGlvUHVibGlzaDogQm9vbGVhbj9cblx0Ly9cdFx0U2V0IHRoaXMgdG8gdHJ1ZSB0byBlbmFibGUgcHVibGlzaGluZyBvZiB0b3BpY3MgZm9yIHRoZSBkaWZmZXJlbnQgcGhhc2VzIG9mXG5cdC8vXHRcdElPIG9wZXJhdGlvbnMuIFB1Ymxpc2hpbmcgaXMgZG9uZSB2aWEgZG9qby90b3BpYy5wdWJsaXNoKCkuIFNlZSBkb2pvL21haW4uX19Jb1B1Ymxpc2ggZm9yIGEgbGlzdFxuXHQvL1x0XHRvZiB0b3BpY3MgdGhhdCBhcmUgcHVibGlzaGVkLlxuXHRpb1B1Ymxpc2g6IGZhbHNlLFxuXG5cdC8vIHRyYW5zcGFyZW50Q29sb3I6IEFycmF5XG5cdC8vXHRcdEFycmF5IGNvbnRhaW5pbmcgdGhlIHIsIGcsIGIgY29tcG9uZW50cyB1c2VkIGFzIHRyYW5zcGFyZW50IGNvbG9yIGluIGRvam8uQ29sb3I7XG5cdC8vXHRcdGlmIHVuZGVmaW5lZCwgWzI1NSwyNTUsMjU1XSAod2hpdGUpIHdpbGwgYmUgdXNlZC5cblx0dHJhbnNwYXJlbnRDb2xvcjogdW5kZWZpbmVkLFxuXHRcblx0Ly8gZGVwczogRnVuY3Rpb258QXJyYXlcblx0Ly9cdFx0RGVmaW5lcyBkZXBlbmRlbmNpZXMgdG8gYmUgdXNlZCBiZWZvcmUgdGhlIGxvYWRlciBoYXMgYmVlbiBsb2FkZWQuXG5cdC8vXHRcdFdoZW4gcHJvdmlkZWQsIHRoZXkgY2F1c2UgdGhlIGxvYWRlciB0byBleGVjdXRlIHJlcXVpcmUoZGVwcywgY2FsbGJhY2spIFxuXHQvL1x0XHRvbmNlIGl0IGhhcyBmaW5pc2hlZCBsb2FkaW5nLiBTaG91bGQgYmUgdXNlZCB3aXRoIGNhbGxiYWNrLlxuXHRkZXBzOiB1bmRlZmluZWQsXG5cdFxuXHQvLyBjYWxsYmFjazogRnVuY3Rpb258QXJyYXlcblx0Ly9cdFx0RGVmaW5lcyBhIGNhbGxiYWNrIHRvIGJlIHVzZWQgd2hlbiBkZXBlbmRlbmNpZXMgYXJlIGRlZmluZWQgYmVmb3JlIFxuXHQvL1x0XHR0aGUgbG9hZGVyIGhhcyBiZWVuIGxvYWRlZC4gV2hlbiBwcm92aWRlZCwgdGhleSBjYXVzZSB0aGUgbG9hZGVyIHRvIFxuXHQvL1x0XHRleGVjdXRlIHJlcXVpcmUoZGVwcywgY2FsbGJhY2spIG9uY2UgaXQgaGFzIGZpbmlzaGVkIGxvYWRpbmcuIFxuXHQvL1x0XHRTaG91bGQgYmUgdXNlZCB3aXRoIGRlcHMuXG5cdGNhbGxiYWNrOiB1bmRlZmluZWQsXG5cdFxuXHQvLyBkZWZlcnJlZEluc3RydW1lbnRhdGlvbjogQm9vbGVhblxuXHQvL1x0XHRXaGV0aGVyIGRlZmVycmVkIGluc3RydW1lbnRhdGlvbiBzaG91bGQgYmUgbG9hZGVkIG9yIGluY2x1ZGVkXG5cdC8vXHRcdGluIGJ1aWxkcy5cblx0ZGVmZXJyZWRJbnN0cnVtZW50YXRpb246IHRydWUsXG5cblx0Ly8gdXNlRGVmZXJyZWRJbnN0cnVtZW50YXRpb246IEJvb2xlYW58U3RyaW5nXG5cdC8vXHRcdFdoZXRoZXIgdGhlIGRlZmVycmVkIGluc3RydW1lbnRhdGlvbiBzaG91bGQgYmUgdXNlZC5cblx0Ly9cblx0Ly9cdFx0KiBgXCJyZXBvcnQtcmVqZWN0aW9uc1wiYDogcmVwb3J0IGVhY2ggcmVqZWN0aW9uIGFzIGl0IG9jY3Vycy5cblx0Ly9cdFx0KiBgdHJ1ZWAgb3IgYDFgIG9yIGBcInJlcG9ydC11bmhhbmRsZWQtcmVqZWN0aW9uc1wiYDogd2FpdCAxIHNlY29uZFxuXHQvL1x0XHRcdGluIGFuIGF0dGVtcHQgdG8gZGV0ZWN0IHVuaGFuZGxlZCByZWplY3Rpb25zLlxuXHR1c2VEZWZlcnJlZEluc3RydW1lbnRhdGlvbjogXCJyZXBvcnQtdW5oYW5kbGVkLXJlamVjdGlvbnNcIlxufTtcbj09PT09Ki9cblxuXHR2YXIgcmVzdWx0ID0ge307XG5cdGlmKGhhcyhcImRvam8tY29uZmlnLWFwaVwiKSl7XG5cdFx0Ly8gbXVzdCBiZSB0aGUgZG9qbyBsb2FkZXI7IHRha2UgYSBzaGFsbG93IGNvcHkgb2YgcmVxdWlyZS5yYXdDb25maWdcblx0XHR2YXIgc3JjID0gcmVxdWlyZS5yYXdDb25maWcsIHA7XG5cdFx0Zm9yKHAgaW4gc3JjKXtcblx0XHRcdHJlc3VsdFtwXSA9IHNyY1twXTtcblx0XHR9XG5cdH1lbHNle1xuXHRcdHZhciBhZHZpc2VIYXMgPSBmdW5jdGlvbihmZWF0dXJlU2V0LCBwcmVmaXgsIGJvb3Rpbmcpe1xuXHRcdFx0Zm9yKHAgaW4gZmVhdHVyZVNldCl7XG5cdFx0XHRcdHAhPVwiaGFzXCIgJiYgaGFzLmFkZChwcmVmaXggKyBwLCBmZWF0dXJlU2V0W3BdLCAwLCBib290aW5nKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJlc3VsdCA9IGhhcyhcImRvam8tbG9hZGVyXCIpID9cblx0XHRcdC8vIG11c3QgYmUgYSBidWlsdCB2ZXJzaW9uIG9mIHRoZSBkb2pvIGxvYWRlcjsgYWxsIGNvbmZpZyBzdHVmZmVkIGluIHJlcXVpcmUucmF3Q29uZmlnXG5cdFx0XHRyZXF1aXJlLnJhd0NvbmZpZyA6XG5cdFx0XHQvLyBhIGZvcmVpZ24gbG9hZGVyXG5cdFx0XHRnbG9iYWwuZG9qb0NvbmZpZyB8fCBnbG9iYWwuZGpDb25maWcgfHwge307XG5cdFx0YWR2aXNlSGFzKHJlc3VsdCwgXCJjb25maWdcIiwgMSk7XG5cdFx0YWR2aXNlSGFzKHJlc3VsdC5oYXMsIFwiXCIsIDEpO1xuXHR9XG5cblx0aWYoIXJlc3VsdC5sb2NhbGUgJiYgdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiKXtcblx0XHQvLyBEZWZhdWx0IGxvY2FsZSBmb3IgYnJvd3NlcnMgKGVuc3VyZSBpdCdzIHJlYWQgZnJvbSB1c2VyLXNldHRpbmdzIG5vdCBkb3dubG9hZCBsb2NhbGUpLlxuXHRcdHZhciBsYW5ndWFnZSA9IChuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmIG5hdmlnYXRvci5sYW5ndWFnZXMubGVuZ3RoKSA/IG5hdmlnYXRvci5sYW5ndWFnZXNbMF0gOlxuXHRcdFx0KG5hdmlnYXRvci5sYW5ndWFnZSB8fCBuYXZpZ2F0b3IudXNlckxhbmd1YWdlKTtcblx0XHRpZihsYW5ndWFnZSl7XG5cdFx0XHRyZXN1bHQubG9jYWxlID0gbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufSk7XG5cbiIsImRlZmluZShbXCIuL2tlcm5lbFwiLCBcIi4uL29uXCIsIFwiLi4vdG9waWNcIiwgXCIuLi9hc3BlY3RcIiwgXCIuL2V2ZW50XCIsIFwiLi4vbW91c2VcIiwgXCIuL3NuaWZmXCIsIFwiLi9sYW5nXCIsIFwiLi4va2V5c1wiXSwgZnVuY3Rpb24oZG9qbywgb24sIGh1YiwgYXNwZWN0LCBldmVudE1vZHVsZSwgbW91c2UsIGhhcywgbGFuZyl7XG4vLyBtb2R1bGU6XG4vL1x0XHRkb2pvL19iYXNlL2Nvbm5lY3RcblxuaGFzLmFkZChcImV2ZW50cy1rZXlwcmVzcy10eXBlZFwiLCBmdW5jdGlvbigpeyAvLyBrZXlwcmVzc2VzIHNob3VsZCBvbmx5IG9jY3VyIGEgcHJpbnRhYmxlIGNoYXJhY3RlciBpcyBoaXRcblx0dmFyIHRlc3RLZXlFdmVudCA9IHtjaGFyQ29kZTogMH07XG5cdHRyeXtcblx0XHR0ZXN0S2V5RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIktleWJvYXJkRXZlbnRcIik7XG5cdFx0KHRlc3RLZXlFdmVudC5pbml0S2V5Ym9hcmRFdmVudCB8fCB0ZXN0S2V5RXZlbnQuaW5pdEtleUV2ZW50KS5jYWxsKHRlc3RLZXlFdmVudCwgXCJrZXlwcmVzc1wiLCB0cnVlLCB0cnVlLCBudWxsLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgOSwgMyk7XG5cdH1jYXRjaChlKXt9XG5cdHJldHVybiB0ZXN0S2V5RXZlbnQuY2hhckNvZGUgPT0gMCAmJiAhaGFzKFwib3BlcmFcIik7XG59KTtcblxuZnVuY3Rpb24gY29ubmVjdF8ob2JqLCBldmVudCwgY29udGV4dCwgbWV0aG9kLCBkb250Rml4KXtcblx0bWV0aG9kID0gbGFuZy5oaXRjaChjb250ZXh0LCBtZXRob2QpO1xuXHRpZighb2JqIHx8ICEob2JqLmFkZEV2ZW50TGlzdGVuZXIgfHwgb2JqLmF0dGFjaEV2ZW50KSl7XG5cdFx0Ly8gaXQgaXMgYSBub3QgYSBET00gbm9kZSBhbmQgd2UgYXJlIHVzaW5nIHRoZSBkb2pvLmNvbm5lY3Qgc3R5bGUgb2YgdHJlYXRpbmcgYVxuXHRcdC8vIG1ldGhvZCBsaWtlIGFuIGV2ZW50LCBtdXN0IGdvIHJpZ2h0IHRvIGFzcGVjdFxuXHRcdHJldHVybiBhc3BlY3QuYWZ0ZXIob2JqIHx8IGRvam8uZ2xvYmFsLCBldmVudCwgbWV0aG9kLCB0cnVlKTtcblx0fVxuXHRpZih0eXBlb2YgZXZlbnQgPT0gXCJzdHJpbmdcIiAmJiBldmVudC5zdWJzdHJpbmcoMCwgMikgPT0gXCJvblwiKXtcblx0XHRldmVudCA9IGV2ZW50LnN1YnN0cmluZygyKTtcblx0fVxuXHRpZighb2JqKXtcblx0XHRvYmogPSBkb2pvLmdsb2JhbDtcblx0fVxuXHRpZighZG9udEZpeCl7XG5cdFx0c3dpdGNoKGV2ZW50KXtcblx0XHRcdC8vIGRvam8uY29ubmVjdCBoYXMgc3BlY2lhbCBoYW5kbGluZyBmb3IgdGhlc2UgZXZlbnQgdHlwZXNcblx0XHRcdGNhc2UgXCJrZXlwcmVzc1wiOlxuXHRcdFx0XHRldmVudCA9IGtleXByZXNzO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJtb3VzZWVudGVyXCI6XG5cdFx0XHRcdGV2ZW50ID0gbW91c2UuZW50ZXI7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcIm1vdXNlbGVhdmVcIjpcblx0XHRcdFx0ZXZlbnQgPSBtb3VzZS5sZWF2ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvbihvYmosIGV2ZW50LCBtZXRob2QsIGRvbnRGaXgpO1xufVxuXG52YXIgX3B1bmN0TWFwID0ge1xuXHQxMDY6NDIsXG5cdDExMTo0Nyxcblx0MTg2OjU5LFxuXHQxODc6NDMsXG5cdDE4ODo0NCxcblx0MTg5OjQ1LFxuXHQxOTA6NDYsXG5cdDE5MTo0Nyxcblx0MTkyOjk2LFxuXHQyMTk6OTEsXG5cdDIyMDo5Mixcblx0MjIxOjkzLFxuXHQyMjI6MzksXG5cdDIyOToxMTNcbn07XG52YXIgZXZ0Q29weUtleSA9IGhhcyhcIm1hY1wiKSA/IFwibWV0YUtleVwiIDogXCJjdHJsS2V5XCI7XG5cblxudmFyIF9zeW50aGVzaXplRXZlbnQgPSBmdW5jdGlvbihldnQsIHByb3BzKXtcblx0dmFyIGZhdXggPSBsYW5nLm1peGluKHt9LCBldnQsIHByb3BzKTtcblx0c2V0S2V5Q2hhcihmYXV4KTtcblx0Ly8gRklYTUU6IHdvdWxkIHByZWZlciB0byB1c2UgbGFuZy5oaXRjaDogbGFuZy5oaXRjaChldnQsIGV2dC5wcmV2ZW50RGVmYXVsdCk7XG5cdC8vIGJ1dCBpdCB0aHJvd3MgYW4gZXJyb3Igd2hlbiBwcmV2ZW50RGVmYXVsdCBpcyBpbnZva2VkIG9uIFNhZmFyaVxuXHQvLyBkb2VzIEV2ZW50LnByZXZlbnREZWZhdWx0IG5vdCBzdXBwb3J0IFwiYXBwbHlcIiBvbiBTYWZhcmk/XG5cdGZhdXgucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpeyBldnQucHJldmVudERlZmF1bHQoKTsgfTtcblx0ZmF1eC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpeyBldnQuc3RvcFByb3BhZ2F0aW9uKCk7IH07XG5cdHJldHVybiBmYXV4O1xufTtcbmZ1bmN0aW9uIHNldEtleUNoYXIoZXZ0KXtcblx0ZXZ0LmtleUNoYXIgPSBldnQuY2hhckNvZGUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2dC5jaGFyQ29kZSkgOiAnJztcblx0ZXZ0LmNoYXJPckNvZGUgPSBldnQua2V5Q2hhciB8fCBldnQua2V5Q29kZTtcbn1cbnZhciBrZXlwcmVzcztcbmlmKGhhcyhcImV2ZW50cy1rZXlwcmVzcy10eXBlZFwiKSl7XG5cdC8vIHRoaXMgZW11bGF0ZXMgRmlyZWZveCdzIGtleXByZXNzIGJlaGF2aW9yIHdoZXJlIGV2ZXJ5IGtleWRvd24gY2FuIGNvcnJlc3BvbmQgdG8gYSBrZXlwcmVzc1xuXHR2YXIgX3RyeVNldEtleUNvZGUgPSBmdW5jdGlvbihlLCBjb2RlKXtcblx0XHR0cnl7XG5cdFx0XHQvLyBzcXVlbGNoIGVycm9ycyB3aGVuIGtleUNvZGUgaXMgcmVhZC1vbmx5XG5cdFx0XHQvLyAoZS5nLiBpZiBrZXlDb2RlIGlzIGN0cmwgb3Igc2hpZnQpXG5cdFx0XHRyZXR1cm4gKGUua2V5Q29kZSA9IGNvZGUpO1xuXHRcdH1jYXRjaChlKXtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0fTtcblx0a2V5cHJlc3MgPSBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKXtcblx0XHR2YXIga2V5ZG93blNpZ25hbCA9IG9uKG9iamVjdCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHQvLyBtdW5nZSBrZXkvY2hhckNvZGVcblx0XHRcdHZhciBrPWV2dC5rZXlDb2RlO1xuXHRcdFx0Ly8gVGhlc2UgYXJlIFdpbmRvd3MgVmlydHVhbCBLZXkgQ29kZXNcblx0XHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vbGlicmFyeS9kZWZhdWx0LmFzcD91cmw9L2xpYnJhcnkvZW4tdXMvd2ludWkvV2luVUkvV2luZG93c1VzZXJJbnRlcmZhY2UvVXNlcklucHV0L1ZpcnR1YWxLZXlDb2Rlcy5hc3Bcblx0XHRcdHZhciB1bnByaW50YWJsZSA9IChrIT0xMykgJiYgayE9MzIgJiYgKGshPTI3fHwhaGFzKFwiaWVcIikpICYmIChrPDQ4fHxrPjkwKSAmJiAoazw5Nnx8az4xMTEpICYmIChrPDE4Nnx8az4xOTIpICYmIChrPDIxOXx8az4yMjIpICYmIGshPTIyOTtcblx0XHRcdC8vIHN5bnRoZXNpemUga2V5cHJlc3MgZm9yIG1vc3QgdW5wcmludGFibGVzIGFuZCBDVFJMLWtleXNcblx0XHRcdGlmKHVucHJpbnRhYmxlfHxldnQuY3RybEtleSl7XG5cdFx0XHRcdHZhciBjID0gdW5wcmludGFibGUgPyAwIDogaztcblx0XHRcdFx0aWYoZXZ0LmN0cmxLZXkpe1xuXHRcdFx0XHRcdGlmKGs9PTMgfHwgaz09MTMpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxpc3RlbmVyLmNhbGwoZXZ0LmN1cnJlbnRUYXJnZXQsIGV2dCk7IC8vIElFIHdpbGwgcG9zdCBDVFJMLUJSRUFLLCBDVFJMLUVOVEVSIGFzIGtleXByZXNzIG5hdGl2ZWx5XG5cdFx0XHRcdFx0fWVsc2UgaWYoYz45NSAmJiBjPDEwNil7XG5cdFx0XHRcdFx0XHRjIC09IDQ4OyAvLyBtYXAgQ1RSTC1bbnVtcGFkIDAtOV0gdG8gQVNDSUlcblx0XHRcdFx0XHR9ZWxzZSBpZigoIWV2dC5zaGlmdEtleSkmJihjPj02NSYmYzw9OTApKXtcblx0XHRcdFx0XHRcdGMgKz0gMzI7IC8vIG1hcCBDVFJMLVtBLVpdIHRvIGxvd2VyY2FzZVxuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0YyA9IF9wdW5jdE1hcFtjXSB8fCBjOyAvLyBtYXAgb3RoZXIgcHJvYmxlbWF0aWMgQ1RSTCBjb21iaW5hdGlvbnMgdG8gQVNDSUlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc2ltdWxhdGUgYSBrZXlwcmVzcyBldmVudFxuXHRcdFx0XHR2YXIgZmF1eCA9IF9zeW50aGVzaXplRXZlbnQoZXZ0LCB7dHlwZTogJ2tleXByZXNzJywgZmF1eDogdHJ1ZSwgY2hhckNvZGU6IGN9KTtcblx0XHRcdFx0bGlzdGVuZXIuY2FsbChldnQuY3VycmVudFRhcmdldCwgZmF1eCk7XG5cdFx0XHRcdGlmKGhhcyhcImllXCIpKXtcblx0XHRcdFx0XHRfdHJ5U2V0S2V5Q29kZShldnQsIGZhdXgua2V5Q29kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHR2YXIga2V5cHJlc3NTaWduYWwgPSBvbihvYmplY3QsIFwia2V5cHJlc3NcIiwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdHZhciBjID0gZXZ0LmNoYXJDb2RlO1xuXHRcdFx0YyA9IGM+PTMyID8gYyA6IDA7XG5cdFx0XHRldnQgPSBfc3ludGhlc2l6ZUV2ZW50KGV2dCwge2NoYXJDb2RlOiBjLCBmYXV4OiB0cnVlfSk7XG5cdFx0XHRyZXR1cm4gbGlzdGVuZXIuY2FsbCh0aGlzLCBldnQpO1xuXHRcdH0pO1xuXHRcdHJldHVybiB7XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGtleWRvd25TaWduYWwucmVtb3ZlKCk7XG5cdFx0XHRcdGtleXByZXNzU2lnbmFsLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG59ZWxzZXtcblx0aWYoaGFzKFwib3BlcmFcIikpe1xuXHRcdGtleXByZXNzID0gZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcil7XG5cdFx0XHRyZXR1cm4gb24ob2JqZWN0LCBcImtleXByZXNzXCIsIGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHRcdHZhciBjID0gZXZ0LndoaWNoO1xuXHRcdFx0XHRpZihjPT0zKXtcblx0XHRcdFx0XHRjPTk5OyAvLyBNb3ppbGxhIG1hcHMgQ1RSTC1CUkVBSyB0byBDVFJMLWNcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBjYW4ndCB0cmFwIHNvbWUga2V5cyBhdCBhbGwsIGxpa2UgSU5TRVJUIGFuZCBERUxFVEVcblx0XHRcdFx0Ly8gdGhlcmUgaXMgbm8gZGlmZmVyZW50aWF0aW5nIGluZm8gYmV0d2VlbiBERUxFVEUgYW5kIFwiLlwiLCBvciBJTlNFUlQgYW5kIFwiLVwiXG5cdFx0XHRcdGMgPSBjPDMyICYmICFldnQuc2hpZnRLZXkgPyAwIDogYztcblx0XHRcdFx0aWYoZXZ0LmN0cmxLZXkgJiYgIWV2dC5zaGlmdEtleSAmJiBjPj02NSAmJiBjPD05MCl7XG5cdFx0XHRcdFx0Ly8gbG93ZXJjYXNlIENUUkwtW0EtWl0ga2V5c1xuXHRcdFx0XHRcdGMgKz0gMzI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGxpc3RlbmVyLmNhbGwodGhpcywgX3N5bnRoZXNpemVFdmVudChldnQsIHsgY2hhckNvZGU6IGMgfSkpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fWVsc2V7XG5cdFx0a2V5cHJlc3MgPSBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKXtcblx0XHRcdHJldHVybiBvbihvYmplY3QsIFwia2V5cHJlc3NcIiwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0c2V0S2V5Q2hhcihldnQpO1xuXHRcdFx0XHRyZXR1cm4gbGlzdGVuZXIuY2FsbCh0aGlzLCBldnQpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fVxufVxuXG52YXIgY29ubmVjdCA9IHtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0VGhpcyBtb2R1bGUgZGVmaW5lcyB0aGUgZG9qby5jb25uZWN0IEFQSS5cblx0Ly9cdFx0VGhpcyBtb2R1bGVzIGFsc28gcHJvdmlkZXMga2V5Ym9hcmQgZXZlbnQgaGFuZGxpbmcgaGVscGVycy5cblx0Ly9cdFx0VGhpcyBtb2R1bGUgZXhwb3J0cyBhbiBleHRlbnNpb24gZXZlbnQgZm9yIGVtdWxhdGluZyBGaXJlZm94J3Mga2V5cHJlc3MgaGFuZGxpbmcuXG5cdC8vXHRcdEhvd2V2ZXIsIHRoaXMgZXh0ZW5zaW9uIGV2ZW50IGV4aXN0cyBwcmltYXJpbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGFuZFxuXHQvL1x0XHRpcyBub3QgcmVjb21tZW5kZWQuIFdlYktpdCBhbmQgSUUgdXNlcyBhbiBhbHRlcm5hdGUga2V5cHJlc3MgaGFuZGxpbmcgKG9ubHlcblx0Ly9cdFx0ZmlyaW5nIGZvciBwcmludGFibGUgY2hhcmFjdGVycywgdG8gZGlzdGluZ3Vpc2ggZnJvbSBrZXlkb3duIGV2ZW50cyksIGFuZCBtb3N0XG5cdC8vXHRcdGNvbnNpZGVyIHRoZSBXZWJLaXQvSUUgYmVoYXZpb3IgbW9yZSBkZXNpcmFibGUuXG5cblx0X2tleXByZXNzOmtleXByZXNzLFxuXG5cdGNvbm5lY3Q6ZnVuY3Rpb24ob2JqLCBldmVudCwgY29udGV4dCwgbWV0aG9kLCBkb250Rml4KXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdGBkb2pvLmNvbm5lY3RgIGlzIGEgZGVwcmVjYXRlZCBldmVudCBoYW5kbGluZyBhbmQgZGVsZWdhdGlvbiBtZXRob2QgaW5cblx0XHQvL1x0XHREb2pvLiBJdCBhbGxvd3Mgb25lIGZ1bmN0aW9uIHRvIFwibGlzdGVuIGluXCIgb24gdGhlIGV4ZWN1dGlvbiBvZlxuXHRcdC8vXHRcdGFueSBvdGhlciwgdHJpZ2dlcmluZyB0aGUgc2Vjb25kIHdoZW5ldmVyIHRoZSBmaXJzdCBpcyBjYWxsZWQuIE1hbnlcblx0XHQvL1x0XHRsaXN0ZW5lcnMgbWF5IGJlIGF0dGFjaGVkIHRvIGEgZnVuY3Rpb24sIGFuZCBzb3VyY2UgZnVuY3Rpb25zIG1heVxuXHRcdC8vXHRcdGJlIGVpdGhlciByZWd1bGFyIGZ1bmN0aW9uIGNhbGxzIG9yIERPTSBldmVudHMuXG5cdFx0Ly9cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRDb25uZWN0cyBsaXN0ZW5lcnMgdG8gYWN0aW9ucywgc28gdGhhdCBhZnRlciBldmVudCBmaXJlcywgYVxuXHRcdC8vXHRcdGxpc3RlbmVyIGlzIGNhbGxlZCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG9yaWdpbmFsXG5cdFx0Ly9cdFx0ZnVuY3Rpb24uXG5cdFx0Ly9cblx0XHQvL1x0XHRTaW5jZSBgZG9qby5jb25uZWN0YCBhbGxvd3MgdGhlIHNvdXJjZSBvZiBldmVudHMgdG8gYmUgZWl0aGVyIGFcblx0XHQvL1x0XHRcInJlZ3VsYXJcIiBKYXZhU2NyaXB0IGZ1bmN0aW9uIG9yIGEgRE9NIGV2ZW50LCBpdCBwcm92aWRlcyBhIHVuaWZvcm1cblx0XHQvL1x0XHRpbnRlcmZhY2UgZm9yIGxpc3RlbmluZyB0byBhbGwgdGhlIHR5cGVzIG9mIGV2ZW50cyB0aGF0IGFuXG5cdFx0Ly9cdFx0YXBwbGljYXRpb24gaXMgbGlrZWx5IHRvIGRlYWwgd2l0aCB0aG91Z2ggYSBzaW5nbGUsIHVuaWZpZWRcblx0XHQvL1x0XHRpbnRlcmZhY2UuIERPTSBwcm9ncmFtbWVycyBtYXkgd2FudCB0byB0aGluayBvZiBpdCBhc1xuXHRcdC8vXHRcdFwiYWRkRXZlbnRMaXN0ZW5lciBmb3IgZXZlcnl0aGluZyBhbmQgYW55dGhpbmdcIi5cblx0XHQvL1xuXHRcdC8vXHRcdFdoZW4gc2V0dGluZyB1cCBhIGNvbm5lY3Rpb24sIHRoZSBgZXZlbnRgIHBhcmFtZXRlciBtdXN0IGJlIGFcblx0XHQvL1x0XHRzdHJpbmcgdGhhdCBpcyB0aGUgbmFtZSBvZiB0aGUgbWV0aG9kL2V2ZW50IHRvIGJlIGxpc3RlbmVkIGZvci4gSWZcblx0XHQvL1x0XHRgb2JqYCBpcyBudWxsLCBga2VybmVsLmdsb2JhbGAgaXMgYXNzdW1lZCwgbWVhbmluZyB0aGF0IGNvbm5lY3Rpb25zXG5cdFx0Ly9cdFx0dG8gZ2xvYmFsIG1ldGhvZHMgYXJlIHN1cHBvcnRlZCBidXQgYWxzbyB0aGF0IHlvdSBtYXkgaW5hZHZlcnRlbnRseVxuXHRcdC8vXHRcdGNvbm5lY3QgdG8gYSBnbG9iYWwgYnkgcGFzc2luZyBhbiBpbmNvcnJlY3Qgb2JqZWN0IG5hbWUgb3IgaW52YWxpZFxuXHRcdC8vXHRcdHJlZmVyZW5jZS5cblx0XHQvL1xuXHRcdC8vXHRcdGBkb2pvLmNvbm5lY3RgIGdlbmVyYWxseSBpcyBmb3JnaXZpbmcuIElmIHlvdSBwYXNzIHRoZSBuYW1lIG9mIGFcblx0XHQvL1x0XHRmdW5jdGlvbiBvciBtZXRob2QgdGhhdCBkb2VzIG5vdCB5ZXQgZXhpc3Qgb24gYG9iamAsIGNvbm5lY3Qgd2lsbFxuXHRcdC8vXHRcdG5vdCBmYWlsLCBidXQgd2lsbCBpbnN0ZWFkIHNldCB1cCBhIHN0dWIgbWV0aG9kLiBTaW1pbGFybHksIG51bGxcblx0XHQvL1x0XHRhcmd1bWVudHMgbWF5IHNpbXBseSBiZSBvbWl0dGVkIHN1Y2ggdGhhdCBmZXdlciB0aGFuIDQgYXJndW1lbnRzXG5cdFx0Ly9cdFx0bWF5IGJlIHJlcXVpcmVkIHRvIHNldCB1cCBhIGNvbm5lY3Rpb24gU2VlIHRoZSBleGFtcGxlcyBmb3IgZGV0YWlscy5cblx0XHQvL1xuXHRcdC8vXHRcdFRoZSByZXR1cm4gdmFsdWUgaXMgYSBoYW5kbGUgdGhhdCBpcyBuZWVkZWQgdG9cblx0XHQvL1x0XHRyZW1vdmUgdGhpcyBjb25uZWN0aW9uIHdpdGggYGRvam8uZGlzY29ubmVjdGAuXG5cdFx0Ly9cblx0XHQvLyBvYmo6IE9iamVjdD9cblx0XHQvL1x0XHRUaGUgc291cmNlIG9iamVjdCBmb3IgdGhlIGV2ZW50IGZ1bmN0aW9uLlxuXHRcdC8vXHRcdERlZmF1bHRzIHRvIGBrZXJuZWwuZ2xvYmFsYCBpZiBudWxsLlxuXHRcdC8vXHRcdElmIG9iaiBpcyBhIERPTSBub2RlLCB0aGUgY29ubmVjdGlvbiBpcyBkZWxlZ2F0ZWRcblx0XHQvL1x0XHR0byB0aGUgRE9NIGV2ZW50IG1hbmFnZXIgKHVubGVzcyBkb250Rml4IGlzIHRydWUpLlxuXHRcdC8vXG5cdFx0Ly8gZXZlbnQ6IFN0cmluZ1xuXHRcdC8vXHRcdFN0cmluZyBuYW1lIG9mIHRoZSBldmVudCBmdW5jdGlvbiBpbiBvYmouXG5cdFx0Ly9cdFx0SS5lLiBpZGVudGlmaWVzIGEgcHJvcGVydHkgYG9ialtldmVudF1gLlxuXHRcdC8vXG5cdFx0Ly8gY29udGV4dDogT2JqZWN0fG51bGxcblx0XHQvL1x0XHRUaGUgb2JqZWN0IHRoYXQgbWV0aG9kIHdpbGwgcmVjZWl2ZSBhcyBcInRoaXNcIi5cblx0XHQvL1xuXHRcdC8vXHRcdElmIGNvbnRleHQgaXMgbnVsbCBhbmQgbWV0aG9kIGlzIGEgZnVuY3Rpb24sIHRoZW4gbWV0aG9kXG5cdFx0Ly9cdFx0aW5oZXJpdHMgdGhlIGNvbnRleHQgb2YgZXZlbnQuXG5cdFx0Ly9cblx0XHQvL1x0XHRJZiBtZXRob2QgaXMgYSBzdHJpbmcgdGhlbiBjb250ZXh0IG11c3QgYmUgdGhlIHNvdXJjZVxuXHRcdC8vXHRcdG9iamVjdCBvYmplY3QgZm9yIG1ldGhvZCAoY29udGV4dFttZXRob2RdKS4gSWYgY29udGV4dCBpcyBudWxsLFxuXHRcdC8vXHRcdGtlcm5lbC5nbG9iYWwgaXMgdXNlZC5cblx0XHQvL1xuXHRcdC8vIG1ldGhvZDogU3RyaW5nfEZ1bmN0aW9uXG5cdFx0Ly9cdFx0QSBmdW5jdGlvbiByZWZlcmVuY2UsIG9yIG5hbWUgb2YgYSBmdW5jdGlvbiBpbiBjb250ZXh0LlxuXHRcdC8vXHRcdFRoZSBmdW5jdGlvbiBpZGVudGlmaWVkIGJ5IG1ldGhvZCBmaXJlcyBhZnRlciBldmVudCBkb2VzLlxuXHRcdC8vXHRcdG1ldGhvZCByZWNlaXZlcyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhlIGV2ZW50LlxuXHRcdC8vXHRcdFNlZSBjb250ZXh0IGFyZ3VtZW50IGNvbW1lbnRzIGZvciBpbmZvcm1hdGlvbiBvbiBtZXRob2QncyBzY29wZS5cblx0XHQvL1xuXHRcdC8vIGRvbnRGaXg6IEJvb2xlYW4/XG5cdFx0Ly9cdFx0SWYgb2JqIGlzIGEgRE9NIG5vZGUsIHNldCBkb250Rml4IHRvIHRydWUgdG8gcHJldmVudCBkZWxlZ2F0aW9uXG5cdFx0Ly9cdFx0b2YgdGhpcyBjb25uZWN0aW9uIHRvIHRoZSBET00gZXZlbnQgbWFuYWdlci5cblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0V2hlbiBvYmoub25jaGFuZ2UoKSwgZG8gdWkudXBkYXRlKCk6XG5cdFx0Ly9cdHxcdGRvam8uY29ubmVjdChvYmosIFwib25jaGFuZ2VcIiwgdWksIFwidXBkYXRlXCIpO1xuXHRcdC8vXHR8XHRkb2pvLmNvbm5lY3Qob2JqLCBcIm9uY2hhbmdlXCIsIHVpLCB1aS51cGRhdGUpOyAvLyBzYW1lXG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFVzaW5nIHJldHVybiB2YWx1ZSBmb3IgZGlzY29ubmVjdDpcblx0XHQvL1x0fFx0dmFyIGxpbmsgPSBkb2pvLmNvbm5lY3Qob2JqLCBcIm9uY2hhbmdlXCIsIHVpLCBcInVwZGF0ZVwiKTtcblx0XHQvL1x0fFx0Li4uXG5cdFx0Ly9cdHxcdGRvam8uZGlzY29ubmVjdChsaW5rKTtcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0V2hlbiBvbmdsb2JhbGV2ZW50IGV4ZWN1dGVzLCB3YXRjaGVyLmhhbmRsZXIgaXMgaW52b2tlZDpcblx0XHQvL1x0fFx0ZG9qby5jb25uZWN0KG51bGwsIFwib25nbG9iYWxldmVudFwiLCB3YXRjaGVyLCBcImhhbmRsZXJcIik7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFdoZW4gb2Iub25DdXN0b21FdmVudCBleGVjdXRlcywgY3VzdG9tRXZlbnRIYW5kbGVyIGlzIGludm9rZWQ6XG5cdFx0Ly9cdHxcdGRvam8uY29ubmVjdChvYiwgXCJvbkN1c3RvbUV2ZW50XCIsIG51bGwsIFwiY3VzdG9tRXZlbnRIYW5kbGVyXCIpO1xuXHRcdC8vXHR8XHRkb2pvLmNvbm5lY3Qob2IsIFwib25DdXN0b21FdmVudFwiLCBcImN1c3RvbUV2ZW50SGFuZGxlclwiKTsgLy8gc2FtZVxuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRXaGVuIG9iLm9uQ3VzdG9tRXZlbnQgZXhlY3V0ZXMsIGN1c3RvbUV2ZW50SGFuZGxlciBpcyBpbnZva2VkXG5cdFx0Ly9cdFx0d2l0aCB0aGUgc2FtZSBzY29wZSAodGhpcyk6XG5cdFx0Ly9cdHxcdGRvam8uY29ubmVjdChvYiwgXCJvbkN1c3RvbUV2ZW50XCIsIG51bGwsIGN1c3RvbUV2ZW50SGFuZGxlcik7XG5cdFx0Ly9cdHxcdGRvam8uY29ubmVjdChvYiwgXCJvbkN1c3RvbUV2ZW50XCIsIGN1c3RvbUV2ZW50SGFuZGxlcik7IC8vIHNhbWVcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0V2hlbiBnbG9iYWxFdmVudCBleGVjdXRlcywgZ2xvYmFsSGFuZGxlciBpcyBpbnZva2VkXG5cdFx0Ly9cdFx0d2l0aCB0aGUgc2FtZSBzY29wZSAodGhpcyk6XG5cdFx0Ly9cdHxcdGRvam8uY29ubmVjdChudWxsLCBcImdsb2JhbEV2ZW50XCIsIG51bGwsIGdsb2JhbEhhbmRsZXIpO1xuXHRcdC8vXHR8XHRkb2pvLmNvbm5lY3QoXCJnbG9iYWxFdmVudFwiLCBnbG9iYWxIYW5kbGVyKTsgLy8gc2FtZVxuXG5cdFx0Ly8gbm9ybWFsaXplIGFyZ3VtZW50c1xuXHRcdHZhciBhPWFyZ3VtZW50cywgYXJncz1bXSwgaT0wO1xuXHRcdC8vIGlmIGFbMF0gaXMgYSBTdHJpbmcsIG9iaiB3YXMgb21pdHRlZFxuXHRcdGFyZ3MucHVzaCh0eXBlb2YgYVswXSA9PSBcInN0cmluZ1wiID8gbnVsbCA6IGFbaSsrXSwgYVtpKytdKTtcblx0XHQvLyBpZiB0aGUgYXJnLWFmdGVyLW5leHQgaXMgYSBTdHJpbmcgb3IgRnVuY3Rpb24sIGNvbnRleHQgd2FzIE5PVCBvbWl0dGVkXG5cdFx0dmFyIGExID0gYVtpKzFdO1xuXHRcdGFyZ3MucHVzaCh0eXBlb2YgYTEgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgYTEgPT0gXCJmdW5jdGlvblwiID8gYVtpKytdIDogbnVsbCwgYVtpKytdKTtcblx0XHQvLyBhYnNvcmIgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG5cdFx0Zm9yKHZhciBsPWEubGVuZ3RoOyBpPGw7IGkrKyl7XHRhcmdzLnB1c2goYVtpXSk7IH1cblx0XHRyZXR1cm4gY29ubmVjdF8uYXBwbHkodGhpcywgYXJncyk7XG5cdH0sXG5cblx0ZGlzY29ubmVjdDpmdW5jdGlvbihoYW5kbGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmVtb3ZlIGEgbGluayBjcmVhdGVkIGJ5IGRvam8uY29ubmVjdC5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRSZW1vdmVzIHRoZSBjb25uZWN0aW9uIGJldHdlZW4gZXZlbnQgYW5kIHRoZSBtZXRob2QgcmVmZXJlbmNlZCBieSBoYW5kbGUuXG5cdFx0Ly8gaGFuZGxlOiBIYW5kbGVcblx0XHQvL1x0XHR0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBkb2pvLmNvbm5lY3QgY2FsbCB0aGF0IGNyZWF0ZWQgdGhlIGNvbm5lY3Rpb24uXG5cblx0XHRpZihoYW5kbGUpe1xuXHRcdFx0aGFuZGxlLnJlbW92ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRzdWJzY3JpYmU6ZnVuY3Rpb24odG9waWMsIGNvbnRleHQsIG1ldGhvZCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRBdHRhY2ggYSBsaXN0ZW5lciB0byBhIG5hbWVkIHRvcGljLiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gaXMgaW52b2tlZCB3aGVuZXZlciB0aGVcblx0XHQvL1x0XHRuYW1lZCB0b3BpYyBpcyBwdWJsaXNoZWQgKHNlZTogZG9qby5wdWJsaXNoKS5cblx0XHQvL1x0XHRSZXR1cm5zIGEgaGFuZGxlIHdoaWNoIGlzIG5lZWRlZCB0byB1bnN1YnNjcmliZSB0aGlzIGxpc3RlbmVyLlxuXHRcdC8vIHRvcGljOiBTdHJpbmdcblx0XHQvL1x0XHRUaGUgdG9waWMgdG8gd2hpY2ggdG8gc3Vic2NyaWJlLlxuXHRcdC8vIGNvbnRleHQ6IE9iamVjdD9cblx0XHQvL1x0XHRTY29wZSBpbiB3aGljaCBtZXRob2Qgd2lsbCBiZSBpbnZva2VkLCBvciBudWxsIGZvciBkZWZhdWx0IHNjb3BlLlxuXHRcdC8vIG1ldGhvZDogU3RyaW5nfEZ1bmN0aW9uXG5cdFx0Ly9cdFx0VGhlIG5hbWUgb2YgYSBmdW5jdGlvbiBpbiBjb250ZXh0LCBvciBhIGZ1bmN0aW9uIHJlZmVyZW5jZS4gVGhpcyBpcyB0aGUgZnVuY3Rpb24gdGhhdFxuXHRcdC8vXHRcdGlzIGludm9rZWQgd2hlbiB0b3BpYyBpcyBwdWJsaXNoZWQuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0ZG9qby5zdWJzY3JpYmUoXCJhbGVydHNcIiwgbnVsbCwgZnVuY3Rpb24oY2FwdGlvbiwgbWVzc2FnZSl7IGFsZXJ0KGNhcHRpb24gKyBcIlxcblwiICsgbWVzc2FnZSk7IH0pO1xuXHRcdC8vXHR8XHRkb2pvLnB1Ymxpc2goXCJhbGVydHNcIiwgWyBcInJlYWQgdGhpc1wiLCBcImhlbGxvIHdvcmxkXCIgXSk7XG5cdFx0cmV0dXJuIGh1Yi5zdWJzY3JpYmUodG9waWMsIGxhbmcuaGl0Y2goY29udGV4dCwgbWV0aG9kKSk7XG5cdH0sXG5cblx0cHVibGlzaDpmdW5jdGlvbih0b3BpYywgYXJncyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRJbnZva2UgYWxsIGxpc3RlbmVyIG1ldGhvZCBzdWJzY3JpYmVkIHRvIHRvcGljLlxuXHRcdC8vIHRvcGljOiBTdHJpbmdcblx0XHQvL1x0XHRUaGUgbmFtZSBvZiB0aGUgdG9waWMgdG8gcHVibGlzaC5cblx0XHQvLyBhcmdzOiBBcnJheT9cblx0XHQvL1x0XHRBbiBhcnJheSBvZiBhcmd1bWVudHMuIFRoZSBhcmd1bWVudHMgd2lsbCBiZSBhcHBsaWVkXG5cdFx0Ly9cdFx0dG8gZWFjaCB0b3BpYyBzdWJzY3JpYmVyIChhcyBmaXJzdCBjbGFzcyBwYXJhbWV0ZXJzLCB2aWEgYXBwbHkpLlxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdHxcdGRvam8uc3Vic2NyaWJlKFwiYWxlcnRzXCIsIG51bGwsIGZ1bmN0aW9uKGNhcHRpb24sIG1lc3NhZ2UpeyBhbGVydChjYXB0aW9uICsgXCJcXG5cIiArIG1lc3NhZ2UpOyB9O1xuXHRcdC8vXHR8XHRkb2pvLnB1Ymxpc2goXCJhbGVydHNcIiwgWyBcInJlYWQgdGhpc1wiLCBcImhlbGxvIHdvcmxkXCIgXSk7XG5cdFx0cmV0dXJuIGh1Yi5wdWJsaXNoLmFwcGx5KGh1YiwgW3RvcGljXS5jb25jYXQoYXJncykpO1xuXHR9LFxuXG5cdGNvbm5lY3RQdWJsaXNoZXI6ZnVuY3Rpb24odG9waWMsIG9iaiwgZXZlbnQpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0RW5zdXJlIHRoYXQgZXZlcnkgdGltZSBvYmouZXZlbnQoKSBpcyBjYWxsZWQsIGEgbWVzc2FnZSBpcyBwdWJsaXNoZWRcblx0XHQvL1x0XHRvbiB0aGUgdG9waWMuIFJldHVybnMgYSBoYW5kbGUgd2hpY2ggY2FuIGJlIHBhc3NlZCB0b1xuXHRcdC8vXHRcdGRvam8uZGlzY29ubmVjdCgpIHRvIGRpc2FibGUgc3Vic2VxdWVudCBhdXRvbWF0aWMgcHVibGljYXRpb24gb25cblx0XHQvL1x0XHR0aGUgdG9waWMuXG5cdFx0Ly8gdG9waWM6IFN0cmluZ1xuXHRcdC8vXHRcdFRoZSBuYW1lIG9mIHRoZSB0b3BpYyB0byBwdWJsaXNoLlxuXHRcdC8vIG9iajogT2JqZWN0P1xuXHRcdC8vXHRcdFRoZSBzb3VyY2Ugb2JqZWN0IGZvciB0aGUgZXZlbnQgZnVuY3Rpb24uIERlZmF1bHRzIHRvIGtlcm5lbC5nbG9iYWxcblx0XHQvL1x0XHRpZiBudWxsLlxuXHRcdC8vIGV2ZW50OiBTdHJpbmdcblx0XHQvL1x0XHRUaGUgbmFtZSBvZiB0aGUgZXZlbnQgZnVuY3Rpb24gaW4gb2JqLlxuXHRcdC8vXHRcdEkuZS4gaWRlbnRpZmllcyBhIHByb3BlcnR5IG9ialtldmVudF0uXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0ZG9qby5jb25uZWN0UHVibGlzaGVyKFwiL2FqYXgvc3RhcnRcIiwgZG9qbywgXCJ4aHJHZXRcIik7XG5cdFx0dmFyIHBmID0gZnVuY3Rpb24oKXsgY29ubmVjdC5wdWJsaXNoKHRvcGljLCBhcmd1bWVudHMpOyB9O1xuXHRcdHJldHVybiBldmVudCA/IGNvbm5lY3QuY29ubmVjdChvYmosIGV2ZW50LCBwZikgOiBjb25uZWN0LmNvbm5lY3Qob2JqLCBwZik7IC8vSGFuZGxlXG5cdH0sXG5cblx0aXNDb3B5S2V5OiBmdW5jdGlvbihlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENoZWNrcyBhbiBldmVudCBmb3IgdGhlIGNvcHkga2V5IChtZXRhIG9uIE1hYywgYW5kIGN0cmwgYW55d2hlcmUgZWxzZSlcblx0XHQvLyBlOiBFdmVudFxuXHRcdC8vXHRcdEV2ZW50IG9iamVjdCB0byBleGFtaW5lXG5cdFx0cmV0dXJuIGVbZXZ0Q29weUtleV07XHQvLyBCb29sZWFuXG5cdH1cbn07XG5cbmNvbm5lY3QudW5zdWJzY3JpYmUgPSBjb25uZWN0LmRpc2Nvbm5lY3Q7XG4vKj09PT09XG4gY29ubmVjdC51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKGhhbmRsZSl7XG5cdCAvLyBzdW1tYXJ5OlxuXHQgLy9cdFx0UmVtb3ZlIGEgdG9waWMgbGlzdGVuZXIuXG5cdCAvLyBoYW5kbGU6IEhhbmRsZVxuXHQgLy9cdFx0VGhlIGhhbmRsZSByZXR1cm5lZCBmcm9tIGEgY2FsbCB0byBzdWJzY3JpYmUuXG5cdCAvLyBleGFtcGxlOlxuXHQgLy9cdHxcdHZhciBhbGVydGVyID0gZG9qby5zdWJzY3JpYmUoXCJhbGVydHNcIiwgbnVsbCwgZnVuY3Rpb24oY2FwdGlvbiwgbWVzc2FnZSl7IGFsZXJ0KGNhcHRpb24gKyBcIlxcblwiICsgbWVzc2FnZSk7IH07XG5cdCAvL1x0fFx0Li4uXG5cdCAvL1x0fFx0ZG9qby51bnN1YnNjcmliZShhbGVydGVyKTtcbiB9O1xuID09PT09Ki9cblxuaGFzKFwiZXh0ZW5kLWRvam9cIikgJiYgbGFuZy5taXhpbihkb2pvLCBjb25uZWN0KTtcbnJldHVybiBjb25uZWN0O1xuXG59KTtcblxuXG4iLCJkZWZpbmUoW1wiLi9rZXJuZWxcIiwgXCIuLi9oYXNcIiwgXCIuL2xhbmdcIl0sIGZ1bmN0aW9uKGRvam8sIGhhcywgbGFuZyl7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9fYmFzZS9kZWNsYXJlXG5cblx0dmFyIG1peCA9IGxhbmcubWl4aW4sIG9wID0gT2JqZWN0LnByb3RvdHlwZSwgb3B0cyA9IG9wLnRvU3RyaW5nLFxuXHRcdHh0b3IsIGNvdW50ZXIgPSAwLCBjbmFtZSA9IFwiY29uc3RydWN0b3JcIjtcblxuXHRpZighaGFzKFwiY3NwLXJlc3RyaWN0aW9uc1wiKSl7XG5cdFx0Ly8gJ25ldyBGdW5jdGlvbigpJyBpcyBwcmVmZXJhYmxlIHdoZW4gYXZhaWxhYmxlIHNpbmNlIGl0IGRvZXMgbm90IGNyZWF0ZSBhIGNsb3N1cmVcblx0XHR4dG9yID0gbmV3IEZ1bmN0aW9uO1xuXHR9ZWxzZXtcblx0XHR4dG9yID0gZnVuY3Rpb24oKXt9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZXJyKG1zZywgY2xzKXsgdGhyb3cgbmV3IEVycm9yKFwiZGVjbGFyZVwiICsgKGNscyA/IFwiIFwiICsgY2xzIDogXCJcIikgKyBcIjogXCIgKyBtc2cpOyB9XG5cblx0Ly8gQzMgTWV0aG9kIFJlc29sdXRpb24gT3JkZXIgKHNlZSBodHRwOi8vd3d3LnB5dGhvbi5vcmcvZG93bmxvYWQvcmVsZWFzZXMvMi4zL21yby8pXG5cdGZ1bmN0aW9uIGMzbXJvKGJhc2VzLCBjbGFzc05hbWUpe1xuXHRcdHZhciByZXN1bHQgPSBbXSwgcm9vdHMgPSBbe2NsczogMCwgcmVmczogW119XSwgbmFtZU1hcCA9IHt9LCBjbHNDb3VudCA9IDEsXG5cdFx0XHRsID0gYmFzZXMubGVuZ3RoLCBpID0gMCwgaiwgbGluLCBiYXNlLCB0b3AsIHByb3RvLCByZWMsIG5hbWUsIHJlZnM7XG5cblx0XHQvLyBidWlsZCBhIGxpc3Qgb2YgYmFzZXMgbmFtaW5nIHRoZW0gaWYgbmVlZGVkXG5cdFx0Zm9yKDsgaSA8IGw7ICsraSl7XG5cdFx0XHRiYXNlID0gYmFzZXNbaV07XG5cdFx0XHRpZighYmFzZSl7XG5cdFx0XHRcdGVycihcIm1peGluICNcIiArIGkgKyBcIiBpcyB1bmtub3duLiBEaWQgeW91IHVzZSBkb2pvLnJlcXVpcmUgdG8gcHVsbCBpdCBpbj9cIiwgY2xhc3NOYW1lKTtcblx0XHRcdH1lbHNlIGlmKG9wdHMuY2FsbChiYXNlKSAhPSBcIltvYmplY3QgRnVuY3Rpb25dXCIpe1xuXHRcdFx0XHRlcnIoXCJtaXhpbiAjXCIgKyBpICsgXCIgaXMgbm90IGEgY2FsbGFibGUgY29uc3RydWN0b3IuXCIsIGNsYXNzTmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRsaW4gPSBiYXNlLl9tZXRhID8gYmFzZS5fbWV0YS5iYXNlcyA6IFtiYXNlXTtcblx0XHRcdHRvcCA9IDA7XG5cdFx0XHQvLyBhZGQgYmFzZXMgdG8gdGhlIG5hbWUgbWFwXG5cdFx0XHRmb3IoaiA9IGxpbi5sZW5ndGggLSAxOyBqID49IDA7IC0tail7XG5cdFx0XHRcdHByb3RvID0gbGluW2pdLnByb3RvdHlwZTtcblx0XHRcdFx0aWYoIXByb3RvLmhhc093blByb3BlcnR5KFwiZGVjbGFyZWRDbGFzc1wiKSl7XG5cdFx0XHRcdFx0cHJvdG8uZGVjbGFyZWRDbGFzcyA9IFwidW5pcU5hbWVfXCIgKyAoY291bnRlcisrKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuYW1lID0gcHJvdG8uZGVjbGFyZWRDbGFzcztcblx0XHRcdFx0aWYoIW5hbWVNYXAuaGFzT3duUHJvcGVydHkobmFtZSkpe1xuXHRcdFx0XHRcdG5hbWVNYXBbbmFtZV0gPSB7Y291bnQ6IDAsIHJlZnM6IFtdLCBjbHM6IGxpbltqXX07XG5cdFx0XHRcdFx0KytjbHNDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZWMgPSBuYW1lTWFwW25hbWVdO1xuXHRcdFx0XHRpZih0b3AgJiYgdG9wICE9PSByZWMpe1xuXHRcdFx0XHRcdHJlYy5yZWZzLnB1c2godG9wKTtcblx0XHRcdFx0XHQrK3RvcC5jb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b3AgPSByZWM7XG5cdFx0XHR9XG5cdFx0XHQrK3RvcC5jb3VudDtcblx0XHRcdHJvb3RzWzBdLnJlZnMucHVzaCh0b3ApO1xuXHRcdH1cblxuXHRcdC8vIHJlbW92ZSBjbGFzc2VzIHdpdGhvdXQgZXh0ZXJuYWwgcmVmZXJlbmNlcyByZWN1cnNpdmVseVxuXHRcdHdoaWxlKHJvb3RzLmxlbmd0aCl7XG5cdFx0XHR0b3AgPSByb290cy5wb3AoKTtcblx0XHRcdHJlc3VsdC5wdXNoKHRvcC5jbHMpO1xuXHRcdFx0LS1jbHNDb3VudDtcblx0XHRcdC8vIG9wdGltaXphdGlvbjogZm9sbG93IGEgc2luZ2xlLWxpbmtlZCBjaGFpblxuXHRcdFx0d2hpbGUocmVmcyA9IHRvcC5yZWZzLCByZWZzLmxlbmd0aCA9PSAxKXtcblx0XHRcdFx0dG9wID0gcmVmc1swXTtcblx0XHRcdFx0aWYoIXRvcCB8fCAtLXRvcC5jb3VudCl7XG5cdFx0XHRcdFx0Ly8gYnJhbmNoIG9yIGVuZCBvZiBjaGFpbiA9PiBkbyBub3QgZW5kIHRvIHJvb3RzXG5cdFx0XHRcdFx0dG9wID0gMDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQucHVzaCh0b3AuY2xzKTtcblx0XHRcdFx0LS1jbHNDb3VudDtcblx0XHRcdH1cblx0XHRcdGlmKHRvcCl7XG5cdFx0XHRcdC8vIGJyYW5jaFxuXHRcdFx0XHRmb3IoaSA9IDAsIGwgPSByZWZzLmxlbmd0aDsgaSA8IGw7ICsraSl7XG5cdFx0XHRcdFx0dG9wID0gcmVmc1tpXTtcblx0XHRcdFx0XHRpZighLS10b3AuY291bnQpe1xuXHRcdFx0XHRcdFx0cm9vdHMucHVzaCh0b3ApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihjbHNDb3VudCl7XG5cdFx0XHRlcnIoXCJjYW4ndCBidWlsZCBjb25zaXN0ZW50IGxpbmVhcml6YXRpb25cIiwgY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHQvLyBjYWxjdWxhdGUgdGhlIHN1cGVyY2xhc3Mgb2Zmc2V0XG5cdFx0YmFzZSA9IGJhc2VzWzBdO1xuXHRcdHJlc3VsdFswXSA9IGJhc2UgP1xuXHRcdFx0YmFzZS5fbWV0YSAmJiBiYXNlID09PSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIGJhc2UuX21ldGEuYmFzZXMubGVuZ3RoXSA/XG5cdFx0XHRcdGJhc2UuX21ldGEuYmFzZXMubGVuZ3RoIDogMSA6IDA7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5oZXJpdGVkKGFyZ3MsIGEsIGYsIGcpe1xuXHRcdHZhciBuYW1lLCBjaGFpbnMsIGJhc2VzLCBjYWxsZXIsIG1ldGEsIGJhc2UsIHByb3RvLCBvcGYsIHBvcyxcblx0XHRcdGNhY2hlID0gdGhpcy5faW5oZXJpdGVkID0gdGhpcy5faW5oZXJpdGVkIHx8IHt9O1xuXG5cdFx0Ly8gY3JhY2sgYXJndW1lbnRzXG5cdFx0aWYodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpe1xuXHRcdFx0bmFtZSA9IGFyZ3M7XG5cdFx0XHRhcmdzID0gYTtcblx0XHRcdGEgPSBmO1xuXHRcdFx0ZiA9IGc7XG5cdFx0fVxuXG5cdFx0aWYodHlwZW9mIGFyZ3MgPT09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHQvLyBzdXBwb3J0IHN0cmljdCBtb2RlXG5cdFx0XHRjYWxsZXIgPSBhcmdzO1xuXHRcdFx0YXJncyA9IGE7XG5cdFx0XHRhID0gZjtcblx0XHR9ZWxzZXtcblx0XHRcdHRyeXtcblx0XHRcdFx0Y2FsbGVyID0gYXJncy5jYWxsZWU7XG5cdFx0XHR9Y2F0Y2ggKGUpe1xuXHRcdFx0XHRpZihlIGluc3RhbmNlb2YgVHlwZUVycm9yKXtcblx0XHRcdFx0XHQvLyBjYWxsZXIgd2FzIGRlZmluZWQgaW4gYSBzdHJpY3QtbW9kZSBjb250ZXh0XG5cdFx0XHRcdFx0ZXJyKFwic3RyaWN0IG1vZGUgaW5oZXJpdGVkKCkgcmVxdWlyZXMgdGhlIGNhbGxlciBmdW5jdGlvbiB0byBiZSBwYXNzZWQgYmVmb3JlIGFyZ3VtZW50c1wiLCB0aGlzLmRlY2xhcmVkQ2xhc3MpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bmFtZSA9IG5hbWUgfHwgY2FsbGVyLm5vbTtcblx0XHRpZighbmFtZSl7XG5cdFx0XHRlcnIoXCJjYW4ndCBkZWR1Y2UgYSBuYW1lIHRvIGNhbGwgaW5oZXJpdGVkKClcIiwgdGhpcy5kZWNsYXJlZENsYXNzKTtcblx0XHR9XG5cdFx0ZiA9IGcgPSAwO1xuXG5cdFx0bWV0YSA9IHRoaXMuY29uc3RydWN0b3IuX21ldGE7XG5cdFx0YmFzZXMgPSBtZXRhLmJhc2VzO1xuXG5cdFx0cG9zID0gY2FjaGUucDtcblx0XHRpZihuYW1lICE9IGNuYW1lKXtcblx0XHRcdC8vIG1ldGhvZFxuXHRcdFx0aWYoY2FjaGUuYyAhPT0gY2FsbGVyKXtcblx0XHRcdFx0Ly8gY2FjaGUgYnVzdFxuXHRcdFx0XHRwb3MgPSAwO1xuXHRcdFx0XHRiYXNlID0gYmFzZXNbMF07XG5cdFx0XHRcdG1ldGEgPSBiYXNlLl9tZXRhO1xuXHRcdFx0XHRpZihtZXRhLmhpZGRlbltuYW1lXSAhPT0gY2FsbGVyKXtcblx0XHRcdFx0XHQvLyBlcnJvciBkZXRlY3Rpb25cblx0XHRcdFx0XHRjaGFpbnMgPSBtZXRhLmNoYWlucztcblx0XHRcdFx0XHRpZihjaGFpbnMgJiYgdHlwZW9mIGNoYWluc1tuYW1lXSA9PSBcInN0cmluZ1wiKXtcblx0XHRcdFx0XHRcdGVycihcImNhbGxpbmcgY2hhaW5lZCBtZXRob2Qgd2l0aCBpbmhlcml0ZWQ6IFwiICsgbmFtZSwgdGhpcy5kZWNsYXJlZENsYXNzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZmluZCBjYWxsZXJcblx0XHRcdFx0XHRkb3tcblx0XHRcdFx0XHRcdG1ldGEgPSBiYXNlLl9tZXRhO1xuXHRcdFx0XHRcdFx0cHJvdG8gPSBiYXNlLnByb3RvdHlwZTtcblx0XHRcdFx0XHRcdGlmKG1ldGEgJiYgKHByb3RvW25hbWVdID09PSBjYWxsZXIgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSkgfHwgbWV0YS5oaWRkZW5bbmFtZV0gPT09IGNhbGxlcikpe1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9d2hpbGUoYmFzZSA9IGJhc2VzWysrcG9zXSk7IC8vIGludGVudGlvbmFsIGFzc2lnbm1lbnRcblx0XHRcdFx0XHRwb3MgPSBiYXNlID8gcG9zIDogLTE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGZpbmQgbmV4dFxuXHRcdFx0YmFzZSA9IGJhc2VzWysrcG9zXTtcblx0XHRcdGlmKGJhc2Upe1xuXHRcdFx0XHRwcm90byA9IGJhc2UucHJvdG90eXBlO1xuXHRcdFx0XHRpZihiYXNlLl9tZXRhICYmIHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpKXtcblx0XHRcdFx0XHRmID0gcHJvdG9bbmFtZV07XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdG9wZiA9IG9wW25hbWVdO1xuXHRcdFx0XHRcdGRve1xuXHRcdFx0XHRcdFx0cHJvdG8gPSBiYXNlLnByb3RvdHlwZTtcblx0XHRcdFx0XHRcdGYgPSBwcm90b1tuYW1lXTtcblx0XHRcdFx0XHRcdGlmKGYgJiYgKGJhc2UuX21ldGEgPyBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKSA6IGYgIT09IG9wZikpe1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9d2hpbGUoYmFzZSA9IGJhc2VzWysrcG9zXSk7IC8vIGludGVudGlvbmFsIGFzc2lnbm1lbnRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZiA9IGJhc2UgJiYgZiB8fCBvcFtuYW1lXTtcblx0XHR9ZWxzZXtcblx0XHRcdC8vIGNvbnN0cnVjdG9yXG5cdFx0XHRpZihjYWNoZS5jICE9PSBjYWxsZXIpe1xuXHRcdFx0XHQvLyBjYWNoZSBidXN0XG5cdFx0XHRcdHBvcyA9IDA7XG5cdFx0XHRcdG1ldGEgPSBiYXNlc1swXS5fbWV0YTtcblx0XHRcdFx0aWYobWV0YSAmJiBtZXRhLmN0b3IgIT09IGNhbGxlcil7XG5cdFx0XHRcdFx0Ly8gZXJyb3IgZGV0ZWN0aW9uXG5cdFx0XHRcdFx0Y2hhaW5zID0gbWV0YS5jaGFpbnM7XG5cdFx0XHRcdFx0aWYoIWNoYWlucyB8fCBjaGFpbnMuY29uc3RydWN0b3IgIT09IFwibWFudWFsXCIpe1xuXHRcdFx0XHRcdFx0ZXJyKFwiY2FsbGluZyBjaGFpbmVkIGNvbnN0cnVjdG9yIHdpdGggaW5oZXJpdGVkXCIsIHRoaXMuZGVjbGFyZWRDbGFzcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGZpbmQgY2FsbGVyXG5cdFx0XHRcdFx0d2hpbGUoYmFzZSA9IGJhc2VzWysrcG9zXSl7IC8vIGludGVudGlvbmFsIGFzc2lnbm1lbnRcblx0XHRcdFx0XHRcdG1ldGEgPSBiYXNlLl9tZXRhO1xuXHRcdFx0XHRcdFx0aWYobWV0YSAmJiBtZXRhLmN0b3IgPT09IGNhbGxlcil7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3MgPSBiYXNlID8gcG9zIDogLTE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGZpbmQgbmV4dFxuXHRcdFx0d2hpbGUoYmFzZSA9IGJhc2VzWysrcG9zXSl7XHQvLyBpbnRlbnRpb25hbCBhc3NpZ25tZW50XG5cdFx0XHRcdG1ldGEgPSBiYXNlLl9tZXRhO1xuXHRcdFx0XHRmID0gbWV0YSA/IG1ldGEuY3RvciA6IGJhc2U7XG5cdFx0XHRcdGlmKGYpe1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmID0gYmFzZSAmJiBmO1xuXHRcdH1cblxuXHRcdC8vIGNhY2hlIHRoZSBmb3VuZCBzdXBlciBtZXRob2Rcblx0XHRjYWNoZS5jID0gZjtcblx0XHRjYWNoZS5wID0gcG9zO1xuXG5cdFx0Ly8gbm93IHdlIGhhdmUgdGhlIHJlc3VsdFxuXHRcdGlmKGYpe1xuXHRcdFx0cmV0dXJuIGEgPT09IHRydWUgPyBmIDogZi5hcHBseSh0aGlzLCBhIHx8IGFyZ3MpO1xuXHRcdH1cblx0XHQvLyBpbnRlbnRpb25hbGx5IG5vIHJldHVybiBpZiBhIHN1cGVyIG1ldGhvZCB3YXMgbm90IGZvdW5kXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRJbmhlcml0ZWQobmFtZSwgYXJncywgYSl7XG5cdFx0aWYodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpe1xuXHRcdFx0aWYgKHR5cGVvZiBhcmdzID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX19pbmhlcml0ZWQobmFtZSwgYXJncywgYSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fX2luaGVyaXRlZChuYW1lLCBhcmdzLCB0cnVlKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX19pbmhlcml0ZWQobmFtZSwgYXJncywgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9faW5oZXJpdGVkKG5hbWUsIHRydWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5oZXJpdGVkX19kZWJ1ZyhhcmdzLCBhMSwgYTIsIGEzKXtcblx0XHR2YXIgZiA9IHRoaXMuZ2V0SW5oZXJpdGVkKGFyZ3MsIGExLCBhMik7XG5cdFx0aWYoZil7XG5cdFx0XHRyZXR1cm4gZi5hcHBseSh0aGlzLCBhMyB8fCBhMiB8fCBhMSB8fCBhcmdzKTtcblx0XHR9XG5cdFx0Ly8gaW50ZW50aW9uYWxseSBubyByZXR1cm4gaWYgYSBzdXBlciBtZXRob2Qgd2FzIG5vdCBmb3VuZFxuXHR9XG5cblx0dmFyIGluaGVyaXRlZEltcGwgPSBkb2pvLmNvbmZpZy5pc0RlYnVnID8gaW5oZXJpdGVkX19kZWJ1ZyA6IGluaGVyaXRlZDtcblxuXHQvLyBlbXVsYXRpb24gb2YgXCJpbnN0YW5jZW9mXCJcblx0ZnVuY3Rpb24gaXNJbnN0YW5jZU9mKGNscyl7XG5cdFx0dmFyIGJhc2VzID0gdGhpcy5jb25zdHJ1Y3Rvci5fbWV0YS5iYXNlcztcblx0XHRmb3IodmFyIGkgPSAwLCBsID0gYmFzZXMubGVuZ3RoOyBpIDwgbDsgKytpKXtcblx0XHRcdGlmKGJhc2VzW2ldID09PSBjbHMpe1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBjbHM7XG5cdH1cblxuXHRmdW5jdGlvbiBtaXhPd24odGFyZ2V0LCBzb3VyY2Upe1xuXHRcdC8vIGFkZCBwcm9wcyBhZGRpbmcgbWV0YWRhdGEgZm9yIGluY29taW5nIGZ1bmN0aW9ucyBza2lwcGluZyBhIGNvbnN0cnVjdG9yXG5cdFx0Zm9yKHZhciBuYW1lIGluIHNvdXJjZSl7XG5cdFx0XHRpZihuYW1lICE9IGNuYW1lICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSl7XG5cdFx0XHRcdHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYoaGFzKFwiYnVnLWZvci1pbi1za2lwcy1zaGFkb3dlZFwiKSl7XG5cdFx0XHRmb3IodmFyIGV4dHJhTmFtZXM9IGxhbmcuX2V4dHJhTmFtZXMsIGk9IGV4dHJhTmFtZXMubGVuZ3RoOyBpOyl7XG5cdFx0XHRcdG5hbWUgPSBleHRyYU5hbWVzWy0taV07XG5cdFx0XHRcdGlmKG5hbWUgIT0gY25hbWUgJiYgc291cmNlLmhhc093blByb3BlcnR5KG5hbWUpKXtcblx0XHRcdFx0XHQgIHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIGltcGxlbWVudGF0aW9uIG9mIHNhZmUgbWl4aW4gZnVuY3Rpb25cblx0ZnVuY3Rpb24gc2FmZU1peGluKHRhcmdldCwgc291cmNlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdE1peCBpbiBwcm9wZXJ0aWVzIHNraXBwaW5nIGEgY29uc3RydWN0b3IgYW5kIGRlY29yYXRpbmcgZnVuY3Rpb25zXG5cdFx0Ly9cdFx0bGlrZSBpdCBpcyBkb25lIGJ5IGRlY2xhcmUoKS5cblx0XHQvLyB0YXJnZXQ6IE9iamVjdFxuXHRcdC8vXHRcdFRhcmdldCBvYmplY3QgdG8gYWNjZXB0IG5ldyBwcm9wZXJ0aWVzLlxuXHRcdC8vIHNvdXJjZTogT2JqZWN0XG5cdFx0Ly9cdFx0U291cmNlIG9iamVjdCBmb3IgbmV3IHByb3BlcnRpZXMuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0VGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIG1peCBpbiBwcm9wZXJ0aWVzIGxpa2UgbGFuZy5taXhpbiBkb2VzLFxuXHRcdC8vXHRcdGJ1dCBpdCBza2lwcyBhIGNvbnN0cnVjdG9yIHByb3BlcnR5IGFuZCBkZWNvcmF0ZXMgZnVuY3Rpb25zIGxpa2Vcblx0XHQvL1x0XHRkZWNsYXJlKCkgZG9lcy5cblx0XHQvL1xuXHRcdC8vXHRcdEl0IGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aCBjbGFzc2VzIGFuZCBvYmplY3RzIHByb2R1Y2VkIHdpdGhcblx0XHQvL1x0XHRkZWNsYXJlLiBGdW5jdGlvbnMgbWl4ZWQgaW4gd2l0aCBkb2pvLnNhZmVNaXhpbiBjYW4gdXNlXG5cdFx0Ly9cdFx0dGhpcy5pbmhlcml0ZWQoKSBsaWtlIG5vcm1hbCBtZXRob2RzLlxuXHRcdC8vXG5cdFx0Ly9cdFx0VGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGltcGxlbWVudCBleHRlbmQoKSBtZXRob2Qgb2YgYSBjb25zdHJ1Y3RvclxuXHRcdC8vXHRcdHByb2R1Y2VkIHdpdGggZGVjbGFyZSgpLlxuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0dmFyIEEgPSBkZWNsYXJlKG51bGwsIHtcblx0XHQvL1x0fFx0XHRtMTogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdGNvbnNvbGUubG9nKFwiQS5tMVwiKTtcblx0XHQvL1x0fFx0XHR9LFxuXHRcdC8vXHR8XHRcdG0yOiBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJBLm0yXCIpO1xuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cdHxcdHZhciBCID0gZGVjbGFyZShBLCB7XG5cdFx0Ly9cdHxcdFx0bTE6IGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMpO1xuXHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJCLm0xXCIpO1xuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cdHxcdEIuZXh0ZW5kKHtcblx0XHQvL1x0fFx0XHRtMjogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhcIkIubTJcIik7XG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1x0fFx0dmFyIHggPSBuZXcgQigpO1xuXHRcdC8vXHR8XHRkb2pvLnNhZmVNaXhpbih4LCB7XG5cdFx0Ly9cdHxcdFx0bTE6IGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMpO1xuXHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJYLm0xXCIpO1xuXHRcdC8vXHR8XHRcdH0sXG5cdFx0Ly9cdHxcdFx0bTI6IGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMpO1xuXHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJYLm0yXCIpO1xuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cdHxcdHgubTIoKTtcblx0XHQvL1x0fFx0Ly8gcHJpbnRzOlxuXHRcdC8vXHR8XHQvLyBBLm0xXG5cdFx0Ly9cdHxcdC8vIEIubTFcblx0XHQvL1x0fFx0Ly8gWC5tMVxuXG5cdFx0dmFyIG5hbWUsIHQ7XG5cdFx0Ly8gYWRkIHByb3BzIGFkZGluZyBtZXRhZGF0YSBmb3IgaW5jb21pbmcgZnVuY3Rpb25zIHNraXBwaW5nIGEgY29uc3RydWN0b3Jcblx0XHRmb3IobmFtZSBpbiBzb3VyY2Upe1xuXHRcdFx0dCA9IHNvdXJjZVtuYW1lXTtcblx0XHRcdGlmKCh0ICE9PSBvcFtuYW1lXSB8fCAhKG5hbWUgaW4gb3ApKSAmJiBuYW1lICE9IGNuYW1lKXtcblx0XHRcdFx0aWYob3B0cy5jYWxsKHQpID09IFwiW29iamVjdCBGdW5jdGlvbl1cIil7XG5cdFx0XHRcdFx0Ly8gbm9uLXRyaXZpYWwgZnVuY3Rpb24gbWV0aG9kID0+IGF0dGFjaCBpdHMgbmFtZVxuXHRcdFx0XHRcdHQubm9tID0gbmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0YXJnZXRbbmFtZV0gPSB0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihoYXMoXCJidWctZm9yLWluLXNraXBzLXNoYWRvd2VkXCIpICYmIHNvdXJjZSl7XG5cdFx0XHRmb3IodmFyIGV4dHJhTmFtZXM9IGxhbmcuX2V4dHJhTmFtZXMsIGk9IGV4dHJhTmFtZXMubGVuZ3RoOyBpOyl7XG5cdFx0XHRcdG5hbWUgPSBleHRyYU5hbWVzWy0taV07XG5cdFx0XHRcdHQgPSBzb3VyY2VbbmFtZV07XG5cdFx0XHRcdGlmKCh0ICE9PSBvcFtuYW1lXSB8fCAhKG5hbWUgaW4gb3ApKSAmJiBuYW1lICE9IGNuYW1lKXtcblx0XHRcdFx0XHRpZihvcHRzLmNhbGwodCkgPT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiKXtcblx0XHRcdFx0XHRcdC8vIG5vbi10cml2aWFsIGZ1bmN0aW9uIG1ldGhvZCA9PiBhdHRhY2ggaXRzIG5hbWVcblx0XHRcdFx0XHRcdCAgdC5ub20gPSBuYW1lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSB0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQoc291cmNlKXtcblx0XHRkZWNsYXJlLnNhZmVNaXhpbih0aGlzLnByb3RvdHlwZSwgc291cmNlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVN1YmNsYXNzKG1peGlucywgcHJvcHMpe1xuXHRcdC8vIGNyYWNrIHBhcmFtZXRlcnNcblx0XHRpZighKG1peGlucyBpbnN0YW5jZW9mIEFycmF5IHx8IHR5cGVvZiBtaXhpbnMgPT09ICdmdW5jdGlvbicpKXtcblx0XHRcdHByb3BzID0gbWl4aW5zO1xuXHRcdFx0bWl4aW5zID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHByb3BzID0gcHJvcHMgfHwge307XG5cdFx0bWl4aW5zID0gbWl4aW5zIHx8IFtdO1xuXG5cdFx0cmV0dXJuIGRlY2xhcmUoW3RoaXNdLmNvbmNhdChtaXhpbnMpLCBwcm9wcyk7XG5cdH1cblxuXHQvLyBjaGFpbmVkIGNvbnN0cnVjdG9yIGNvbXBhdGlibGUgd2l0aCB0aGUgbGVnYWN5IGRlY2xhcmUoKVxuXHRmdW5jdGlvbiBjaGFpbmVkQ29uc3RydWN0b3IoYmFzZXMsIGN0b3JTcGVjaWFsKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBhID0gYXJndW1lbnRzLCBhcmdzID0gYSwgYTAgPSBhWzBdLCBmLCBpLCBtLFxuXHRcdFx0XHRsID0gYmFzZXMubGVuZ3RoLCBwcmVBcmdzO1xuXG5cdFx0XHRpZighKHRoaXMgaW5zdGFuY2VvZiBhLmNhbGxlZSkpe1xuXHRcdFx0XHQvLyBub3QgY2FsbGVkIHZpYSBuZXcsIHNvIGZvcmNlIGl0XG5cdFx0XHRcdHJldHVybiBhcHBseU5ldyhhKTtcblx0XHRcdH1cblxuXHRcdFx0Ly90aGlzLl9pbmhlcml0ZWQgPSB7fTtcblx0XHRcdC8vIHBlcmZvcm0gdGhlIHNoYW1hbidzIHJpdHVhbHMgb2YgdGhlIG9yaWdpbmFsIGRlY2xhcmUoKVxuXHRcdFx0Ly8gMSkgY2FsbCB0d28gdHlwZXMgb2YgdGhlIHByZWFtYmxlXG5cdFx0XHRpZihjdG9yU3BlY2lhbCAmJiAoYTAgJiYgYTAucHJlYW1ibGUgfHwgdGhpcy5wcmVhbWJsZSkpe1xuXHRcdFx0XHQvLyBmdWxsIGJsb3duIHJpdHVhbFxuXHRcdFx0XHRwcmVBcmdzID0gbmV3IEFycmF5KGJhc2VzLmxlbmd0aCk7XG5cdFx0XHRcdC8vIHByZXBhcmUgcGFyYW1ldGVyc1xuXHRcdFx0XHRwcmVBcmdzWzBdID0gYTtcblx0XHRcdFx0Zm9yKGkgPSAwOzspe1xuXHRcdFx0XHRcdC8vIHByb2Nlc3MgdGhlIHByZWFtYmxlIG9mIHRoZSAxc3QgYXJndW1lbnRcblx0XHRcdFx0XHRhMCA9IGFbMF07XG5cdFx0XHRcdFx0aWYoYTApe1xuXHRcdFx0XHRcdFx0ZiA9IGEwLnByZWFtYmxlO1xuXHRcdFx0XHRcdFx0aWYoZil7XG5cdFx0XHRcdFx0XHRcdGEgPSBmLmFwcGx5KHRoaXMsIGEpIHx8IGE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHByb2Nlc3MgdGhlIHByZWFtYmxlIG9mIHRoaXMgY2xhc3Ncblx0XHRcdFx0XHRmID0gYmFzZXNbaV0ucHJvdG90eXBlO1xuXHRcdFx0XHRcdGYgPSBmLmhhc093blByb3BlcnR5KFwicHJlYW1ibGVcIikgJiYgZi5wcmVhbWJsZTtcblx0XHRcdFx0XHRpZihmKXtcblx0XHRcdFx0XHRcdGEgPSBmLmFwcGx5KHRoaXMsIGEpIHx8IGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIG9uZSBwZWN1bGlhcml0eSBvZiB0aGUgcHJlYW1ibGU6XG5cdFx0XHRcdFx0Ly8gaXQgaXMgY2FsbGVkIGlmIGl0IGlzIG5vdCBuZWVkZWQsXG5cdFx0XHRcdFx0Ly8gZS5nLiwgdGhlcmUgaXMgbm8gY29uc3RydWN0b3IgdG8gY2FsbFxuXHRcdFx0XHRcdC8vIGxldCdzIHdhdGNoIGZvciB0aGUgbGFzdCBjb25zdHJ1Y3RvclxuXHRcdFx0XHRcdC8vIChzZWUgdGlja2V0ICM5Nzk1KVxuXHRcdFx0XHRcdGlmKCsraSA9PSBsKXtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcmVBcmdzW2ldID0gYTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gMikgY2FsbCBhbGwgbm9uLXRyaXZpYWwgY29uc3RydWN0b3JzIHVzaW5nIHByZXBhcmVkIGFyZ3VtZW50c1xuXHRcdFx0Zm9yKGkgPSBsIC0gMTsgaSA+PSAwOyAtLWkpe1xuXHRcdFx0XHRmID0gYmFzZXNbaV07XG5cdFx0XHRcdG0gPSBmLl9tZXRhO1xuXHRcdFx0XHRmID0gbSA/IG0uY3RvciA6IGY7XG5cdFx0XHRcdGlmKGYpe1xuXHRcdFx0XHRcdGYuYXBwbHkodGhpcywgcHJlQXJncyA/IHByZUFyZ3NbaV0gOiBhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gMykgY29udGludWUgdGhlIG9yaWdpbmFsIHJpdHVhbDogY2FsbCB0aGUgcG9zdHNjcmlwdFxuXHRcdFx0ZiA9IHRoaXMucG9zdHNjcmlwdDtcblx0XHRcdGlmKGYpe1xuXHRcdFx0XHRmLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXG5cdC8vIGNoYWluZWQgY29uc3RydWN0b3IgY29tcGF0aWJsZSB3aXRoIHRoZSBsZWdhY3kgZGVjbGFyZSgpXG5cdGZ1bmN0aW9uIHNpbmdsZUNvbnN0cnVjdG9yKGN0b3IsIGN0b3JTcGVjaWFsKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBhID0gYXJndW1lbnRzLCB0ID0gYSwgYTAgPSBhWzBdLCBmO1xuXG5cdFx0XHRpZighKHRoaXMgaW5zdGFuY2VvZiBhLmNhbGxlZSkpe1xuXHRcdFx0XHQvLyBub3QgY2FsbGVkIHZpYSBuZXcsIHNvIGZvcmNlIGl0XG5cdFx0XHRcdHJldHVybiBhcHBseU5ldyhhKTtcblx0XHRcdH1cblxuXHRcdFx0Ly90aGlzLl9pbmhlcml0ZWQgPSB7fTtcblx0XHRcdC8vIHBlcmZvcm0gdGhlIHNoYW1hbidzIHJpdHVhbHMgb2YgdGhlIG9yaWdpbmFsIGRlY2xhcmUoKVxuXHRcdFx0Ly8gMSkgY2FsbCB0d28gdHlwZXMgb2YgdGhlIHByZWFtYmxlXG5cdFx0XHRpZihjdG9yU3BlY2lhbCl7XG5cdFx0XHRcdC8vIGZ1bGwgYmxvd24gcml0dWFsXG5cdFx0XHRcdGlmKGEwKXtcblx0XHRcdFx0XHQvLyBwcm9jZXNzIHRoZSBwcmVhbWJsZSBvZiB0aGUgMXN0IGFyZ3VtZW50XG5cdFx0XHRcdFx0ZiA9IGEwLnByZWFtYmxlO1xuXHRcdFx0XHRcdGlmKGYpe1xuXHRcdFx0XHRcdFx0dCA9IGYuYXBwbHkodGhpcywgdCkgfHwgdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZiA9IHRoaXMucHJlYW1ibGU7XG5cdFx0XHRcdGlmKGYpe1xuXHRcdFx0XHRcdC8vIHByb2Nlc3MgdGhlIHByZWFtYmxlIG9mIHRoaXMgY2xhc3Ncblx0XHRcdFx0XHRmLmFwcGx5KHRoaXMsIHQpO1xuXHRcdFx0XHRcdC8vIG9uZSBwZWN1bGlhcml0eSBvZiB0aGUgcHJlYW1ibGU6XG5cdFx0XHRcdFx0Ly8gaXQgaXMgY2FsbGVkIGV2ZW4gaWYgaXQgaXMgbm90IG5lZWRlZCxcblx0XHRcdFx0XHQvLyBlLmcuLCB0aGVyZSBpcyBubyBjb25zdHJ1Y3RvciB0byBjYWxsXG5cdFx0XHRcdFx0Ly8gbGV0J3Mgd2F0Y2ggZm9yIHRoZSBsYXN0IGNvbnN0cnVjdG9yXG5cdFx0XHRcdFx0Ly8gKHNlZSB0aWNrZXQgIzk3OTUpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIDIpIGNhbGwgYSBjb25zdHJ1Y3RvclxuXHRcdFx0aWYoY3Rvcil7XG5cdFx0XHRcdGN0b3IuYXBwbHkodGhpcywgYSk7XG5cdFx0XHR9XG5cdFx0XHQvLyAzKSBjb250aW51ZSB0aGUgb3JpZ2luYWwgcml0dWFsOiBjYWxsIHRoZSBwb3N0c2NyaXB0XG5cdFx0XHRmID0gdGhpcy5wb3N0c2NyaXB0O1xuXHRcdFx0aWYoZil7XG5cdFx0XHRcdGYuYXBwbHkodGhpcywgYSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIHBsYWluIHZhbmlsbGEgY29uc3RydWN0b3IgKGNhbiB1c2UgaW5oZXJpdGVkKCkgdG8gY2FsbCBpdHMgYmFzZSBjb25zdHJ1Y3Rvcilcblx0ZnVuY3Rpb24gc2ltcGxlQ29uc3RydWN0b3IoYmFzZXMpe1xuXHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGEgPSBhcmd1bWVudHMsIGkgPSAwLCBmLCBtO1xuXG5cdFx0XHRpZighKHRoaXMgaW5zdGFuY2VvZiBhLmNhbGxlZSkpe1xuXHRcdFx0XHQvLyBub3QgY2FsbGVkIHZpYSBuZXcsIHNvIGZvcmNlIGl0XG5cdFx0XHRcdHJldHVybiBhcHBseU5ldyhhKTtcblx0XHRcdH1cblxuXHRcdFx0Ly90aGlzLl9pbmhlcml0ZWQgPSB7fTtcblx0XHRcdC8vIHBlcmZvcm0gdGhlIHNoYW1hbidzIHJpdHVhbHMgb2YgdGhlIG9yaWdpbmFsIGRlY2xhcmUoKVxuXHRcdFx0Ly8gMSkgZG8gbm90IGNhbGwgdGhlIHByZWFtYmxlXG5cdFx0XHQvLyAyKSBjYWxsIHRoZSB0b3AgY29uc3RydWN0b3IgKGl0IGNhbiB1c2UgdGhpcy5pbmhlcml0ZWQoKSlcblx0XHRcdGZvcig7IGYgPSBiYXNlc1tpXTsgKytpKXsgLy8gaW50ZW50aW9uYWwgYXNzaWdubWVudFxuXHRcdFx0XHRtID0gZi5fbWV0YTtcblx0XHRcdFx0ZiA9IG0gPyBtLmN0b3IgOiBmO1xuXHRcdFx0XHRpZihmKXtcblx0XHRcdFx0XHRmLmFwcGx5KHRoaXMsIGEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyAzKSBjYWxsIHRoZSBwb3N0c2NyaXB0XG5cdFx0XHRmID0gdGhpcy5wb3N0c2NyaXB0O1xuXHRcdFx0aWYoZil7XG5cdFx0XHRcdGYuYXBwbHkodGhpcywgYSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoYWluKG5hbWUsIGJhc2VzLCByZXZlcnNlZCl7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgYiwgbSwgZiwgaSA9IDAsIHN0ZXAgPSAxO1xuXHRcdFx0aWYocmV2ZXJzZWQpe1xuXHRcdFx0XHRpID0gYmFzZXMubGVuZ3RoIC0gMTtcblx0XHRcdFx0c3RlcCA9IC0xO1xuXHRcdFx0fVxuXHRcdFx0Zm9yKDsgYiA9IGJhc2VzW2ldOyBpICs9IHN0ZXApeyAvLyBpbnRlbnRpb25hbCBhc3NpZ25tZW50XG5cdFx0XHRcdG0gPSBiLl9tZXRhO1xuXHRcdFx0XHRmID0gKG0gPyBtLmhpZGRlbiA6IGIucHJvdG90eXBlKVtuYW1lXTtcblx0XHRcdFx0aWYoZil7XG5cdFx0XHRcdFx0Zi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIGZvcmNlTmV3KGN0b3IpXG5cdC8vIHJldHVybiBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGN0b3IucHJvdG90eXBlIGJ1dFxuXHQvLyB3aXRob3V0IGFjdHVhbGx5IHJ1bm5pbmcgY3RvciBvbiB0aGUgb2JqZWN0LlxuXHRmdW5jdGlvbiBmb3JjZU5ldyhjdG9yKXtcblx0XHQvLyBjcmVhdGUgb2JqZWN0IHdpdGggY29ycmVjdCBwcm90b3R5cGUgdXNpbmcgYSBkby1ub3RoaW5nXG5cdFx0Ly8gY29uc3RydWN0b3Jcblx0XHR4dG9yLnByb3RvdHlwZSA9IGN0b3IucHJvdG90eXBlO1xuXHRcdHZhciB0ID0gbmV3IHh0b3I7XG5cdFx0eHRvci5wcm90b3R5cGUgPSBudWxsO1x0Ly8gY2xlYW4gdXBcblx0XHRyZXR1cm4gdDtcblx0fVxuXG5cdC8vIGFwcGx5TmV3KGFyZ3MpXG5cdC8vIGp1c3QgbGlrZSAnbmV3IGN0b3IoKScgZXhjZXB0IHRoYXQgdGhlIGNvbnN0cnVjdG9yIGFuZCBpdHMgYXJndW1lbnRzIGNvbWVcblx0Ly8gZnJvbSBhcmdzLCB3aGljaCBtdXN0IGJlIGFuIGFycmF5IG9yIGFuIGFyZ3VtZW50cyBvYmplY3Rcblx0ZnVuY3Rpb24gYXBwbHlOZXcoYXJncyl7XG5cdFx0Ly8gY3JlYXRlIGFuIG9iamVjdCB3aXRoIGN0b3IncyBwcm90b3R5cGUgYnV0IHdpdGhvdXRcblx0XHQvLyBjYWxsaW5nIGN0b3Igb24gaXQuXG5cdFx0dmFyIGN0b3IgPSBhcmdzLmNhbGxlZSwgdCA9IGZvcmNlTmV3KGN0b3IpO1xuXHRcdC8vIGV4ZWN1dGUgdGhlIHJlYWwgY29uc3RydWN0b3Igb24gdGhlIG5ldyBvYmplY3Rcblx0XHRjdG9yLmFwcGx5KHQsIGFyZ3MpO1xuXHRcdHJldHVybiB0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjbGFyZShjbGFzc05hbWUsIHN1cGVyY2xhc3MsIHByb3BzKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENyZWF0ZSBhIGZlYXR1cmUtcmljaCBjb25zdHJ1Y3RvciBmcm9tIGNvbXBhY3Qgbm90YXRpb24uXG5cdFx0Ly8gY2xhc3NOYW1lOiBTdHJpbmc/XG5cdFx0Ly9cdFx0VGhlIG9wdGlvbmFsIG5hbWUgb2YgdGhlIGNvbnN0cnVjdG9yIChsb29zZWx5LCBhIFwiY2xhc3NcIilcblx0XHQvL1x0XHRzdG9yZWQgaW4gdGhlIFwiZGVjbGFyZWRDbGFzc1wiIHByb3BlcnR5IGluIHRoZSBjcmVhdGVkIHByb3RvdHlwZS5cblx0XHQvL1x0XHRJdCB3aWxsIGJlIHVzZWQgYXMgYSBnbG9iYWwgbmFtZSBmb3IgYSBjcmVhdGVkIGNvbnN0cnVjdG9yLlxuXHRcdC8vIHN1cGVyY2xhc3M6IEZ1bmN0aW9ufEZ1bmN0aW9uW11cblx0XHQvL1x0XHRNYXkgYmUgbnVsbCwgYSBGdW5jdGlvbiwgb3IgYW4gQXJyYXkgb2YgRnVuY3Rpb25zLiBUaGlzIGFyZ3VtZW50XG5cdFx0Ly9cdFx0c3BlY2lmaWVzIGEgbGlzdCBvZiBiYXNlcyAodGhlIGxlZnQtbW9zdCBvbmUgaXMgdGhlIG1vc3QgZGVlcGVzdFxuXHRcdC8vXHRcdGJhc2UpLlxuXHRcdC8vIHByb3BzOiBPYmplY3Rcblx0XHQvL1x0XHRBbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgY29waWVkIHRvIHRoZSBjcmVhdGVkIHByb3RvdHlwZS5cblx0XHQvL1x0XHRBZGQgYW4gaW5zdGFuY2UtaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24gYnkgbWFraW5nIGl0IGEgcHJvcGVydHlcblx0XHQvL1x0XHRuYW1lZCBcImNvbnN0cnVjdG9yXCIuXG5cdFx0Ly8gcmV0dXJuczogZG9qby9fYmFzZS9kZWNsYXJlLl9fRGVjbGFyZUNyZWF0ZWRPYmplY3Rcblx0XHQvL1x0XHROZXcgY29uc3RydWN0b3IgZnVuY3Rpb24uXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0Q3JlYXRlIGEgY29uc3RydWN0b3IgdXNpbmcgYSBjb21wYWN0IG5vdGF0aW9uIGZvciBpbmhlcml0YW5jZSBhbmRcblx0XHQvL1x0XHRwcm90b3R5cGUgZXh0ZW5zaW9uLlxuXHRcdC8vXG5cdFx0Ly9cdFx0TWl4aW4gYW5jZXN0b3JzIHByb3ZpZGUgYSB0eXBlIG9mIG11bHRpcGxlIGluaGVyaXRhbmNlLlxuXHRcdC8vXHRcdFByb3RvdHlwZXMgb2YgbWl4aW4gYW5jZXN0b3JzIGFyZSBjb3BpZWQgdG8gdGhlIG5ldyBjbGFzczpcblx0XHQvL1x0XHRjaGFuZ2VzIHRvIG1peGluIHByb3RvdHlwZXMgd2lsbCBub3QgYWZmZWN0IGNsYXNzZXMgdG8gd2hpY2hcblx0XHQvL1x0XHR0aGV5IGhhdmUgYmVlbiBtaXhlZCBpbi5cblx0XHQvL1xuXHRcdC8vXHRcdEFuY2VzdG9ycyBjYW4gYmUgY29tcG91bmQgY2xhc3NlcyBjcmVhdGVkIGJ5IHRoaXMgdmVyc2lvbiBvZlxuXHRcdC8vXHRcdGRlY2xhcmUoKS4gSW4gY29tcGxleCBjYXNlcyBhbGwgYmFzZSBjbGFzc2VzIGFyZSBnb2luZyB0byBiZVxuXHRcdC8vXHRcdGxpbmVhcml6ZWQgYWNjb3JkaW5nIHRvIEMzIE1STyBhbGdvcml0aG1cblx0XHQvL1x0XHQoc2VlIGh0dHA6Ly93d3cucHl0aG9uLm9yZy9kb3dubG9hZC9yZWxlYXNlcy8yLjMvbXJvLyBmb3IgbW9yZVxuXHRcdC8vXHRcdGRldGFpbHMpLlxuXHRcdC8vXG5cdFx0Ly9cdFx0XCJjbGFzc05hbWVcIiBpcyBjYWNoZWQgaW4gXCJkZWNsYXJlZENsYXNzXCIgcHJvcGVydHkgb2YgdGhlIG5ldyBjbGFzcyxcblx0XHQvL1x0XHRpZiBpdCB3YXMgc3VwcGxpZWQuIFRoZSBpbW1lZGlhdGUgc3VwZXIgY2xhc3Mgd2lsbCBiZSBjYWNoZWQgaW5cblx0XHQvL1x0XHRcInN1cGVyY2xhc3NcIiBwcm9wZXJ0eSBvZiB0aGUgbmV3IGNsYXNzLlxuXHRcdC8vXG5cdFx0Ly9cdFx0TWV0aG9kcyBpbiBcInByb3BzXCIgd2lsbCBiZSBjb3BpZWQgYW5kIG1vZGlmaWVkOiBcIm5vbVwiIHByb3BlcnR5XG5cdFx0Ly9cdFx0KHRoZSBkZWNsYXJlZCBuYW1lIG9mIHRoZSBtZXRob2QpIHdpbGwgYmUgYWRkZWQgdG8gYWxsIGNvcGllZFxuXHRcdC8vXHRcdGZ1bmN0aW9ucyB0byBoZWxwIGlkZW50aWZ5IHRoZW0gZm9yIHRoZSBpbnRlcm5hbCBtYWNoaW5lcnkuIEJlXG5cdFx0Ly9cdFx0dmVyeSBjYXJlZnVsLCB3aGlsZSByZXVzaW5nIG1ldGhvZHM6IGlmIHlvdSB1c2UgdGhlIHNhbWVcblx0XHQvL1x0XHRmdW5jdGlvbiB1bmRlciBkaWZmZXJlbnQgbmFtZXMsIGl0IGNhbiBwcm9kdWNlIGVycm9ycyBpbiBzb21lXG5cdFx0Ly9cdFx0Y2FzZXMuXG5cdFx0Ly9cblx0XHQvL1x0XHRJdCBpcyBwb3NzaWJsZSB0byB1c2UgY29uc3RydWN0b3JzIGNyZWF0ZWQgXCJtYW51YWxseVwiICh3aXRob3V0XG5cdFx0Ly9cdFx0ZGVjbGFyZSgpKSBhcyBiYXNlcy4gVGhleSB3aWxsIGJlIGNhbGxlZCBhcyB1c3VhbCBkdXJpbmcgdGhlXG5cdFx0Ly9cdFx0Y3JlYXRpb24gb2YgYW4gaW5zdGFuY2UsIHRoZWlyIG1ldGhvZHMgd2lsbCBiZSBjaGFpbmVkLCBhbmQgZXZlblxuXHRcdC8vXHRcdGNhbGxlZCBieSBcInRoaXMuaW5oZXJpdGVkKClcIi5cblx0XHQvL1xuXHRcdC8vXHRcdFNwZWNpYWwgcHJvcGVydHkgXCItY2hhaW5zLVwiIGdvdmVybnMgaG93IHRvIGNoYWluIG1ldGhvZHMuIEl0IGlzXG5cdFx0Ly9cdFx0YSBkaWN0aW9uYXJ5LCB3aGljaCB1c2VzIG1ldGhvZCBuYW1lcyBhcyBrZXlzLCBhbmQgaGludCBzdHJpbmdzXG5cdFx0Ly9cdFx0YXMgdmFsdWVzLiBJZiBhIGhpbnQgc3RyaW5nIGlzIFwiYWZ0ZXJcIiwgdGhpcyBtZXRob2Qgd2lsbCBiZVxuXHRcdC8vXHRcdGNhbGxlZCBhZnRlciBtZXRob2RzIG9mIGl0cyBiYXNlIGNsYXNzZXMuIElmIGEgaGludCBzdHJpbmcgaXNcblx0XHQvL1x0XHRcImJlZm9yZVwiLCB0aGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgbWV0aG9kcyBvZiBpdHMgYmFzZVxuXHRcdC8vXHRcdGNsYXNzZXMuXG5cdFx0Ly9cblx0XHQvL1x0XHRJZiBcImNvbnN0cnVjdG9yXCIgaXMgbm90IG1lbnRpb25lZCBpbiBcIi1jaGFpbnMtXCIgcHJvcGVydHksIGl0IHdpbGxcblx0XHQvL1x0XHRiZSBjaGFpbmVkIHVzaW5nIHRoZSBsZWdhY3kgbW9kZTogdXNpbmcgXCJhZnRlclwiIGNoYWluaW5nLFxuXHRcdC8vXHRcdGNhbGxpbmcgcHJlYW1ibGUoKSBtZXRob2QgYmVmb3JlIGVhY2ggY29uc3RydWN0b3IsIGlmIGF2YWlsYWJsZSxcblx0XHQvL1x0XHRhbmQgY2FsbGluZyBwb3N0c2NyaXB0KCkgYWZ0ZXIgYWxsIGNvbnN0cnVjdG9ycyB3ZXJlIGV4ZWN1dGVkLlxuXHRcdC8vXHRcdElmIHRoZSBoaW50IGlzIFwiYWZ0ZXJcIiwgaXQgaXMgY2hhaW5lZCBhcyBhIHJlZ3VsYXIgbWV0aG9kLCBidXRcblx0XHQvL1x0XHRwb3N0c2NyaXB0KCkgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGNoYWluIG9mIGNvbnN0cnVjdG9ycy5cblx0XHQvL1x0XHRcImNvbnN0cnVjdG9yXCIgY2Fubm90IGJlIGNoYWluZWQgXCJiZWZvcmVcIiwgYnV0IGl0IGFsbG93c1xuXHRcdC8vXHRcdGEgc3BlY2lhbCBoaW50IHN0cmluZzogXCJtYW51YWxcIiwgd2hpY2ggbWVhbnMgdGhhdCBjb25zdHJ1Y3RvcnNcblx0XHQvL1x0XHRhcmUgbm90IGdvaW5nIHRvIGJlIGNoYWluZWQgaW4gYW55IHdheSwgYW5kIHByb2dyYW1tZXIgd2lsbCBjYWxsXG5cdFx0Ly9cdFx0dGhlbSBtYW51YWxseSB1c2luZyB0aGlzLmluaGVyaXRlZCgpLiBJbiB0aGUgbGF0dGVyIGNhc2Vcblx0XHQvL1x0XHRwb3N0c2NyaXB0KCkgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGNvbnN0cnVjdGlvbi5cblx0XHQvL1xuXHRcdC8vXHRcdEFsbCBjaGFpbmluZyBoaW50cyBhcmUgXCJpbmhlcml0ZWRcIiBmcm9tIGJhc2UgY2xhc3NlcyBhbmRcblx0XHQvL1x0XHRwb3RlbnRpYWxseSBjYW4gYmUgb3ZlcnJpZGRlbi4gQmUgdmVyeSBjYXJlZnVsIHdoZW4gb3ZlcnJpZGluZ1xuXHRcdC8vXHRcdGhpbnRzISBNYWtlIHN1cmUgdGhhdCBhbGwgY2hhaW5lZCBtZXRob2RzIGNhbiB3b3JrIGluIGEgcHJvcG9zZWRcblx0XHQvL1x0XHRtYW5uZXIgb2YgY2hhaW5pbmcuXG5cdFx0Ly9cblx0XHQvL1x0XHRPbmNlIGEgbWV0aG9kIHdhcyBjaGFpbmVkLCBpdCBpcyBpbXBvc3NpYmxlIHRvIHVuY2hhaW4gaXQuIFRoZVxuXHRcdC8vXHRcdG9ubHkgZXhjZXB0aW9uIGlzIFwiY29uc3RydWN0b3JcIi4gWW91IGRvbid0IG5lZWQgdG8gZGVmaW5lIGFcblx0XHQvL1x0XHRtZXRob2QgaW4gb3JkZXIgdG8gc3VwcGx5IGEgY2hhaW5pbmcgaGludC5cblx0XHQvL1xuXHRcdC8vXHRcdElmIGEgbWV0aG9kIGlzIGNoYWluZWQsIGl0IGNhbm5vdCB1c2UgdGhpcy5pbmhlcml0ZWQoKSBiZWNhdXNlXG5cdFx0Ly9cdFx0YWxsIG90aGVyIG1ldGhvZHMgaW4gdGhlIGhpZXJhcmNoeSB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5LlxuXHRcdC8vXG5cdFx0Ly9cdFx0VXN1YWxseSBjb25zdHJ1Y3RvcnMgYW5kIGluaXRpYWxpemVycyBvZiBhbnkga2luZCBhcmUgY2hhaW5lZFxuXHRcdC8vXHRcdHVzaW5nIFwiYWZ0ZXJcIiBhbmQgZGVzdHJ1Y3RvcnMgb2YgYW55IGtpbmQgYXJlIGNoYWluZWQgYXNcblx0XHQvL1x0XHRcImJlZm9yZVwiLiBOb3RlIHRoYXQgY2hhaW5pbmcgYXNzdW1lcyB0aGF0IGNoYWluZWQgbWV0aG9kcyBkbyBub3Rcblx0XHQvL1x0XHRyZXR1cm4gYW55IHZhbHVlOiBhbnkgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBkaXNjYXJkZWQuXG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHRkZWNsYXJlKFwibXkuY2xhc3Nlcy5iYXJcIiwgbXkuY2xhc3Nlcy5mb28sIHtcblx0XHQvL1x0fFx0XHQvLyBwcm9wZXJ0aWVzIHRvIGJlIGFkZGVkIHRvIHRoZSBjbGFzcyBwcm90b3R5cGVcblx0XHQvL1x0fFx0XHRzb21lVmFsdWU6IDIsXG5cdFx0Ly9cdHxcdFx0Ly8gaW5pdGlhbGl6YXRpb24gZnVuY3Rpb25cblx0XHQvL1x0fFx0XHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdHRoaXMubXlDb21wbGljYXRlZE9iamVjdCA9IG5ldyBSZWFsbHlDb21wbGljYXRlZE9iamVjdCgpO1xuXHRcdC8vXHR8XHRcdH0sXG5cdFx0Ly9cdHxcdFx0Ly8gb3RoZXIgZnVuY3Rpb25zXG5cdFx0Ly9cdHxcdFx0c29tZU1ldGhvZDogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdGRvU3R1ZmYoKTtcblx0XHQvL1x0fFx0XHR9XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0dmFyIE15QmFzZSA9IGRlY2xhcmUobnVsbCwge1xuXHRcdC8vXHR8XHRcdC8vIGNvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzLCBhbmQgbWV0aG9kcyBnbyBoZXJlXG5cdFx0Ly9cdHxcdFx0Ly8gLi4uXG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXHR8XHR2YXIgTXlDbGFzczEgPSBkZWNsYXJlKE15QmFzZSwge1xuXHRcdC8vXHR8XHRcdC8vIGNvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzLCBhbmQgbWV0aG9kcyBnbyBoZXJlXG5cdFx0Ly9cdHxcdFx0Ly8gLi4uXG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXHR8XHR2YXIgTXlDbGFzczIgPSBkZWNsYXJlKE15QmFzZSwge1xuXHRcdC8vXHR8XHRcdC8vIGNvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzLCBhbmQgbWV0aG9kcyBnbyBoZXJlXG5cdFx0Ly9cdHxcdFx0Ly8gLi4uXG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXHR8XHR2YXIgTXlEaWFtb25kID0gZGVjbGFyZShbTXlDbGFzczEsIE15Q2xhc3MyXSwge1xuXHRcdC8vXHR8XHRcdC8vIGNvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzLCBhbmQgbWV0aG9kcyBnbyBoZXJlXG5cdFx0Ly9cdHxcdFx0Ly8gLi4uXG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0dmFyIEYgPSBmdW5jdGlvbigpeyBjb25zb2xlLmxvZyhcInJhdyBjb25zdHJ1Y3RvclwiKTsgfTtcblx0XHQvL1x0fFx0Ri5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRjb25zb2xlLmxvZyhcInJhdyBtZXRob2RcIik7XG5cdFx0Ly9cdHxcdH07XG5cdFx0Ly9cdHxcdHZhciBBID0gZGVjbGFyZShGLCB7XG5cdFx0Ly9cdHxcdFx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhcIkEuY29uc3RydWN0b3JcIik7XG5cdFx0Ly9cdHxcdFx0fSxcblx0XHQvL1x0fFx0XHRtZXRob2Q6IGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhcImJlZm9yZSBjYWxsaW5nIEYubWV0aG9kLi4uXCIpO1xuXHRcdC8vXHR8XHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHQvL1x0fFx0XHRcdGNvbnNvbGUubG9nKFwiLi4uYmFjayBpbiBBXCIpO1xuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cdHxcdG5ldyBBKCkubWV0aG9kKCk7XG5cdFx0Ly9cdHxcdC8vIHdpbGwgcHJpbnQ6XG5cdFx0Ly9cdHxcdC8vIHJhdyBjb25zdHJ1Y3RvclxuXHRcdC8vXHR8XHQvLyBBLmNvbnN0cnVjdG9yXG5cdFx0Ly9cdHxcdC8vIGJlZm9yZSBjYWxsaW5nIEYubWV0aG9kLi4uXG5cdFx0Ly9cdHxcdC8vIHJhdyBtZXRob2Rcblx0XHQvL1x0fFx0Ly8gLi4uYmFjayBpbiBBXG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHR2YXIgQSA9IGRlY2xhcmUobnVsbCwge1xuXHRcdC8vXHR8XHRcdFwiLWNoYWlucy1cIjoge1xuXHRcdC8vXHR8XHRcdFx0ZGVzdHJveTogXCJiZWZvcmVcIlxuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cdHxcdHZhciBCID0gZGVjbGFyZShBLCB7XG5cdFx0Ly9cdHxcdFx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhcIkIuY29uc3RydWN0b3JcIik7XG5cdFx0Ly9cdHxcdFx0fSxcblx0XHQvL1x0fFx0XHRkZXN0cm95OiBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJCLmRlc3Ryb3lcIik7XG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1x0fFx0dmFyIEMgPSBkZWNsYXJlKEIsIHtcblx0XHQvL1x0fFx0XHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdGNvbnNvbGUubG9nKFwiQy5jb25zdHJ1Y3RvclwiKTtcblx0XHQvL1x0fFx0XHR9LFxuXHRcdC8vXHR8XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhcIkMuZGVzdHJveVwiKTtcblx0XHQvL1x0fFx0XHR9XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXHR8XHRuZXcgQygpLmRlc3Ryb3koKTtcblx0XHQvL1x0fFx0Ly8gcHJpbnRzOlxuXHRcdC8vXHR8XHQvLyBCLmNvbnN0cnVjdG9yXG5cdFx0Ly9cdHxcdC8vIEMuY29uc3RydWN0b3Jcblx0XHQvL1x0fFx0Ly8gQy5kZXN0cm95XG5cdFx0Ly9cdHxcdC8vIEIuZGVzdHJveVxuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0dmFyIEEgPSBkZWNsYXJlKG51bGwsIHtcblx0XHQvL1x0fFx0XHRcIi1jaGFpbnMtXCI6IHtcblx0XHQvL1x0fFx0XHRcdGNvbnN0cnVjdG9yOiBcIm1hbnVhbFwiXG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1x0fFx0dmFyIEIgPSBkZWNsYXJlKEEsIHtcblx0XHQvL1x0fFx0XHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdC8vIC4uLlxuXHRcdC8vXHR8XHRcdFx0Ly8gY2FsbCB0aGUgYmFzZSBjb25zdHJ1Y3RvciB3aXRoIG5ldyBwYXJhbWV0ZXJzXG5cdFx0Ly9cdHxcdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMsIFsxLCAyLCAzXSk7XG5cdFx0Ly9cdHxcdFx0XHQvLyAuLi5cblx0XHQvL1x0fFx0XHR9XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0dmFyIEEgPSBkZWNsYXJlKG51bGwsIHtcblx0XHQvL1x0fFx0XHRcIi1jaGFpbnMtXCI6IHtcblx0XHQvL1x0fFx0XHRcdG0xOiBcImJlZm9yZVwiXG5cdFx0Ly9cdHxcdFx0fSxcblx0XHQvL1x0fFx0XHRtMTogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdGNvbnNvbGUubG9nKFwiQS5tMVwiKTtcblx0XHQvL1x0fFx0XHR9LFxuXHRcdC8vXHR8XHRcdG0yOiBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJBLm0yXCIpO1xuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cdHxcdHZhciBCID0gZGVjbGFyZShBLCB7XG5cdFx0Ly9cdHxcdFx0XCItY2hhaW5zLVwiOiB7XG5cdFx0Ly9cdHxcdFx0XHRtMjogXCJhZnRlclwiXG5cdFx0Ly9cdHxcdFx0fSxcblx0XHQvL1x0fFx0XHRtMTogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdGNvbnNvbGUubG9nKFwiQi5tMVwiKTtcblx0XHQvL1x0fFx0XHR9LFxuXHRcdC8vXHR8XHRcdG0yOiBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJCLm0yXCIpO1xuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cdHxcdHZhciB4ID0gbmV3IEIoKTtcblx0XHQvL1x0fFx0eC5tMSgpO1xuXHRcdC8vXHR8XHQvLyBwcmludHM6XG5cdFx0Ly9cdHxcdC8vIEIubTFcblx0XHQvL1x0fFx0Ly8gQS5tMVxuXHRcdC8vXHR8XHR4Lm0yKCk7XG5cdFx0Ly9cdHxcdC8vIHByaW50czpcblx0XHQvL1x0fFx0Ly8gQS5tMlxuXHRcdC8vXHR8XHQvLyBCLm0yXG5cblx0XHQvLyBjcmFjayBwYXJhbWV0ZXJzXG5cdFx0aWYodHlwZW9mIGNsYXNzTmFtZSAhPSBcInN0cmluZ1wiKXtcblx0XHRcdHByb3BzID0gc3VwZXJjbGFzcztcblx0XHRcdHN1cGVyY2xhc3MgPSBjbGFzc05hbWU7XG5cdFx0XHRjbGFzc05hbWUgPSBcIlwiO1xuXHRcdH1cblx0XHRwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG5cdFx0dmFyIHByb3RvLCBpLCB0LCBjdG9yLCBuYW1lLCBiYXNlcywgY2hhaW5zLCBtaXhpbnMgPSAxLCBwYXJlbnRzID0gc3VwZXJjbGFzcztcblxuXHRcdC8vIGJ1aWxkIGEgcHJvdG90eXBlXG5cdFx0aWYob3B0cy5jYWxsKHN1cGVyY2xhc3MpID09IFwiW29iamVjdCBBcnJheV1cIil7XG5cdFx0XHQvLyBDMyBNUk9cblx0XHRcdGJhc2VzID0gYzNtcm8oc3VwZXJjbGFzcywgY2xhc3NOYW1lKTtcblx0XHRcdHQgPSBiYXNlc1swXTtcblx0XHRcdG1peGlucyA9IGJhc2VzLmxlbmd0aCAtIHQ7XG5cdFx0XHRzdXBlcmNsYXNzID0gYmFzZXNbbWl4aW5zXTtcblx0XHR9ZWxzZXtcblx0XHRcdGJhc2VzID0gWzBdO1xuXHRcdFx0aWYoc3VwZXJjbGFzcyl7XG5cdFx0XHRcdGlmKG9wdHMuY2FsbChzdXBlcmNsYXNzKSA9PSBcIltvYmplY3QgRnVuY3Rpb25dXCIpe1xuXHRcdFx0XHRcdHQgPSBzdXBlcmNsYXNzLl9tZXRhO1xuXHRcdFx0XHRcdGJhc2VzID0gYmFzZXMuY29uY2F0KHQgPyB0LmJhc2VzIDogc3VwZXJjbGFzcyk7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGVycihcImJhc2UgY2xhc3MgaXMgbm90IGEgY2FsbGFibGUgY29uc3RydWN0b3IuXCIsIGNsYXNzTmFtZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNlIGlmKHN1cGVyY2xhc3MgIT09IG51bGwpe1xuXHRcdFx0XHRlcnIoXCJ1bmtub3duIGJhc2UgY2xhc3MuIERpZCB5b3UgdXNlIGRvam8ucmVxdWlyZSB0byBwdWxsIGl0IGluP1wiLCBjbGFzc05hbWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihzdXBlcmNsYXNzKXtcblx0XHRcdGZvcihpID0gbWl4aW5zIC0gMTs7IC0taSl7XG5cdFx0XHRcdHByb3RvID0gZm9yY2VOZXcoc3VwZXJjbGFzcyk7XG5cdFx0XHRcdGlmKCFpKXtcblx0XHRcdFx0XHQvLyBzdG9wIGlmIG5vdGhpbmcgdG8gYWRkICh0aGUgbGFzdCBiYXNlKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG1peCBpbiBwcm9wZXJ0aWVzXG5cdFx0XHRcdHQgPSBiYXNlc1tpXTtcblx0XHRcdFx0KHQuX21ldGEgPyBtaXhPd24gOiBtaXgpKHByb3RvLCB0LnByb3RvdHlwZSk7XG5cdFx0XHRcdC8vIGNoYWluIGluIG5ldyBjb25zdHJ1Y3RvclxuXHRcdFx0XHRpZiAoaGFzKFwiY3NwLXJlc3RyaWN0aW9uc1wiKSkge1xuXHRcdFx0XHRcdGN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjdG9yID0gbmV3IEZ1bmN0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0b3Iuc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3M7XG5cdFx0XHRcdGN0b3IucHJvdG90eXBlID0gcHJvdG87XG5cdFx0XHRcdHN1cGVyY2xhc3MgPSBwcm90by5jb25zdHJ1Y3RvciA9IGN0b3I7XG5cdFx0XHR9XG5cdFx0fWVsc2V7XG5cdFx0XHRwcm90byA9IHt9O1xuXHRcdH1cblx0XHQvLyBhZGQgYWxsIHByb3BlcnRpZXNcblx0XHRkZWNsYXJlLnNhZmVNaXhpbihwcm90bywgcHJvcHMpO1xuXHRcdC8vIGFkZCBjb25zdHJ1Y3RvclxuXHRcdHQgPSBwcm9wcy5jb25zdHJ1Y3Rvcjtcblx0XHRpZih0ICE9PSBvcC5jb25zdHJ1Y3Rvcil7XG5cdFx0XHR0Lm5vbSA9IGNuYW1lO1xuXHRcdFx0cHJvdG8uY29uc3RydWN0b3IgPSB0O1xuXHRcdH1cblxuXHRcdC8vIGNvbGxlY3QgY2hhaW5zIGFuZCBmbGFnc1xuXHRcdGZvcihpID0gbWl4aW5zIC0gMTsgaTsgLS1pKXsgLy8gaW50ZW50aW9uYWwgYXNzaWdubWVudFxuXHRcdFx0dCA9IGJhc2VzW2ldLl9tZXRhO1xuXHRcdFx0aWYodCAmJiB0LmNoYWlucyl7XG5cdFx0XHRcdGNoYWlucyA9IG1peChjaGFpbnMgfHwge30sIHQuY2hhaW5zKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYocHJvdG9bXCItY2hhaW5zLVwiXSl7XG5cdFx0XHRjaGFpbnMgPSBtaXgoY2hhaW5zIHx8IHt9LCBwcm90b1tcIi1jaGFpbnMtXCJdKTtcblx0XHR9XG5cblx0XHRpZihzdXBlcmNsYXNzICYmIHN1cGVyY2xhc3MucHJvdG90eXBlICYmIHN1cGVyY2xhc3MucHJvdG90eXBlW1wiLWNoYWlucy1cIl0pIHtcblx0XHRcdGNoYWlucyA9IG1peChjaGFpbnMgfHwge30sIHN1cGVyY2xhc3MucHJvdG90eXBlW1wiLWNoYWlucy1cIl0pO1xuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGN0b3Jcblx0XHR0ID0gIWNoYWlucyB8fCAhY2hhaW5zLmhhc093blByb3BlcnR5KGNuYW1lKTtcblx0XHRiYXNlc1swXSA9IGN0b3IgPSAoY2hhaW5zICYmIGNoYWlucy5jb25zdHJ1Y3RvciA9PT0gXCJtYW51YWxcIikgPyBzaW1wbGVDb25zdHJ1Y3RvcihiYXNlcykgOlxuXHRcdFx0KGJhc2VzLmxlbmd0aCA9PSAxID8gc2luZ2xlQ29uc3RydWN0b3IocHJvcHMuY29uc3RydWN0b3IsIHQpIDogY2hhaW5lZENvbnN0cnVjdG9yKGJhc2VzLCB0KSk7XG5cblx0XHQvLyBhZGQgbWV0YSBpbmZvcm1hdGlvbiB0byB0aGUgY29uc3RydWN0b3Jcblx0XHRjdG9yLl9tZXRhICA9IHtiYXNlczogYmFzZXMsIGhpZGRlbjogcHJvcHMsIGNoYWluczogY2hhaW5zLFxuXHRcdFx0cGFyZW50czogcGFyZW50cywgY3RvcjogcHJvcHMuY29uc3RydWN0b3J9O1xuXHRcdGN0b3Iuc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3MgJiYgc3VwZXJjbGFzcy5wcm90b3R5cGU7XG5cdFx0Y3Rvci5leHRlbmQgPSBleHRlbmQ7XG5cdFx0Y3Rvci5jcmVhdGVTdWJjbGFzcyA9IGNyZWF0ZVN1YmNsYXNzO1xuXHRcdGN0b3IucHJvdG90eXBlID0gcHJvdG87XG5cdFx0cHJvdG8uY29uc3RydWN0b3IgPSBjdG9yO1xuXG5cdFx0Ly8gYWRkIFwic3RhbmRhcmRcIiBtZXRob2RzIHRvIHRoZSBwcm90b3R5cGVcblx0XHRwcm90by5nZXRJbmhlcml0ZWQgPSBnZXRJbmhlcml0ZWQ7XG5cdFx0cHJvdG8uaXNJbnN0YW5jZU9mID0gaXNJbnN0YW5jZU9mO1xuXHRcdHByb3RvLmluaGVyaXRlZCAgICA9IGluaGVyaXRlZEltcGw7XG5cdFx0cHJvdG8uX19pbmhlcml0ZWQgID0gaW5oZXJpdGVkO1xuXG5cdFx0Ly8gYWRkIG5hbWUgaWYgc3BlY2lmaWVkXG5cdFx0aWYoY2xhc3NOYW1lKXtcblx0XHRcdHByb3RvLmRlY2xhcmVkQ2xhc3MgPSBjbGFzc05hbWU7XG5cdFx0XHRsYW5nLnNldE9iamVjdChjbGFzc05hbWUsIGN0b3IpO1xuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGNoYWlucyBhbmQgYWRkIHRoZW0gdG8gdGhlIHByb3RvdHlwZVxuXHRcdGlmKGNoYWlucyl7XG5cdFx0XHRmb3IobmFtZSBpbiBjaGFpbnMpe1xuXHRcdFx0XHRpZihwcm90b1tuYW1lXSAmJiB0eXBlb2YgY2hhaW5zW25hbWVdID09IFwic3RyaW5nXCIgJiYgbmFtZSAhPSBjbmFtZSl7XG5cdFx0XHRcdFx0dCA9IHByb3RvW25hbWVdID0gY2hhaW4obmFtZSwgYmFzZXMsIGNoYWluc1tuYW1lXSA9PT0gXCJhZnRlclwiKTtcblx0XHRcdFx0XHR0Lm5vbSA9IG5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gY2hhaW5lZCBtZXRob2RzIGRvIG5vdCByZXR1cm4gdmFsdWVzXG5cdFx0Ly8gbm8gbmVlZCB0byBjaGFpbiBcImludmlzaWJsZVwiIGZ1bmN0aW9uc1xuXG5cdFx0cmV0dXJuIGN0b3I7XHQvLyBGdW5jdGlvblxuXHR9XG5cblx0Lyo9PT09PVxuXHRkZWNsYXJlLl9fRGVjbGFyZUNyZWF0ZWRPYmplY3QgPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRkb2pvL19iYXNlL2RlY2xhcmUoKSByZXR1cm5zIGEgY29uc3RydWN0b3IgYENgLiAgIGBuZXcgQygpYCByZXR1cm5zIGFuIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcblx0XHQvL1x0XHRtZXRob2RzLCBpbiBhZGRpdGlvbiB0byB0aGUgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBzcGVjaWZpZWQgdmlhIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIGRlY2xhcmUoKS5cblxuXHRcdGluaGVyaXRlZDogZnVuY3Rpb24obmFtZSwgY2FsbGVyLCBhcmdzLCBuZXdBcmdzKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYWxscyBhIHN1cGVyIG1ldGhvZC5cblx0XHRcdC8vIG5hbWU6IFN0cmluZz9cblx0XHRcdC8vXHRcdFRoZSBvcHRpb25hbCBtZXRob2QgbmFtZS4gU2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSBjYWxsZXInc1xuXHRcdFx0Ly9cdFx0bmFtZS4gVXN1YWxseSBcIm5hbWVcIiBpcyBzcGVjaWZpZWQgaW4gY29tcGxleCBkeW5hbWljIGNhc2VzLCB3aGVuXG5cdFx0XHQvL1x0XHR0aGUgY2FsbGluZyBtZXRob2Qgd2FzIGR5bmFtaWNhbGx5IGFkZGVkLCB1bmRlY29yYXRlZCBieVxuXHRcdFx0Ly9cdFx0ZGVjbGFyZSgpLCBhbmQgaXQgY2Fubm90IGJlIGRldGVybWluZWQuXG5cdFx0XHQvLyBjYWxsZXI6IEZ1bmN0aW9uP1xuXHRcdFx0Ly9cdFx0VGhlIHJlZmVyZW5jZSB0byB0aGUgY2FsbGluZyBmdW5jdGlvbi4gUmVxdWlyZWQgb25seSBpZiB0aGVcblx0XHRcdC8vXHRcdGNhbGwgdG8gXCJ0aGlzLmluaGVyaXRlZFwiIG9jY3VycyBmcm9tIHdpdGhpbiBzdHJpY3QtbW9kZSBjb2RlLlxuXHRcdFx0Ly9cdFx0SWYgdGhlIGNhbGxlciBpcyBvbWl0dGVkIHdpdGhpbiBzdHJpY3QtbW9kZSBjb2RlLCBhbiBlcnJvciB3aWxsXG5cdFx0XHQvL1x0XHRiZSB0aHJvd24uXG5cdFx0XHQvL1x0XHRUaGUgYmVzdCB3YXkgdG8gb2J0YWluIGEgcmVmZXJlbmNlIHRvIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGlzIHRvXG5cdFx0XHQvL1x0XHR1c2UgYSBuYW1lZCBmdW5jdGlvbiBleHByZXNzaW9uIChpLmUuIHBsYWNlIGEgZnVuY3Rpb24gbmFtZVxuXHRcdFx0Ly9cdFx0YWZ0ZXIgdGhlIFwiZnVuY3Rpb25cIiBrZXl3b3JkIGFuZCBiZWZvcmUgdGhlIG9wZW4gcGFyZW4sIGFzIGluXG5cdFx0XHQvL1x0XHRcImZ1bmN0aW9uIGZuKGEsIGIpXCIpLiBJZiB0aGUgZnVuY3Rpb24gaXMgcGFyc2VkIGFzIGFuIGV4cHJlc3Npb25cblx0XHRcdC8vXHRcdGFuZCBub3QgYSBzdGF0ZW1lbnQgKGkuZS4gaXQncyBub3QgYnkgaXRzZWxmIG9uIGl0cyBvd24gbGluZSksXG5cdFx0XHQvL1x0XHR0aGUgZnVuY3Rpb24gbmFtZSB3aWxsIG9ubHkgYmUgYWNjZXNzaWJsZSBhcyBhbiBpZGVudGlmaWVyIGZyb21cblx0XHRcdC8vXHRcdHdpdGhpbiB0aGUgYm9keSBvZiB0aGUgZnVuY3Rpb24uXG5cdFx0XHQvLyBhcmdzOiBBcmd1bWVudHNcblx0XHRcdC8vXHRcdFRoZSBjYWxsZXIgc3VwcGx5IHRoaXMgYXJndW1lbnQsIHdoaWNoIHNob3VsZCBiZSB0aGUgb3JpZ2luYWxcblx0XHRcdC8vXHRcdFwiYXJndW1lbnRzXCIuXG5cdFx0XHQvLyBuZXdBcmdzOiBPYmplY3Q/XG5cdFx0XHQvL1x0XHRJZiBcInRydWVcIiwgdGhlIGZvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgcmV0dXJuZWQgd2l0aG91dFxuXHRcdFx0Ly9cdFx0ZXhlY3V0aW5nIGl0LlxuXHRcdFx0Ly9cdFx0SWYgQXJyYXksIGl0IHdpbGwgYmUgdXNlZCB0byBjYWxsIGEgc3VwZXIgbWV0aG9kLiBPdGhlcndpc2Vcblx0XHRcdC8vXHRcdFwiYXJnc1wiIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRXaGF0ZXZlciBpcyByZXR1cm5lZCBieSBhIHN1cGVyIG1ldGhvZCwgb3IgYSBzdXBlciBtZXRob2QgaXRzZWxmLFxuXHRcdFx0Ly9cdFx0aWYgXCJ0cnVlXCIgd2FzIHNwZWNpZmllZCBhcyBuZXdBcmdzLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRUaGlzIG1ldGhvZCBpcyB1c2VkIGluc2lkZSBtZXRob2Qgb2YgY2xhc3NlcyBwcm9kdWNlZCB3aXRoXG5cdFx0XHQvL1x0XHRkZWNsYXJlKCkgdG8gY2FsbCBhIHN1cGVyIG1ldGhvZCAobmV4dCBpbiB0aGUgY2hhaW4pLiBJdCBpc1xuXHRcdFx0Ly9cdFx0dXNlZCBmb3IgbWFudWFsbHkgY29udHJvbGxlZCBjaGFpbmluZy4gQ29uc2lkZXIgdXNpbmcgdGhlIHJlZ3VsYXJcblx0XHRcdC8vXHRcdGNoYWluaW5nLCBiZWNhdXNlIGl0IGlzIGZhc3Rlci4gVXNlIFwidGhpcy5pbmhlcml0ZWQoKVwiIG9ubHkgaW5cblx0XHRcdC8vXHRcdGNvbXBsZXggY2FzZXMuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VGhpcyBtZXRob2QgY2Fubm90IG1lIGNhbGxlZCBmcm9tIGF1dG9tYXRpY2FsbHkgY2hhaW5lZFxuXHRcdFx0Ly9cdFx0Y29uc3RydWN0b3JzIGluY2x1ZGluZyB0aGUgY2FzZSBvZiBhIHNwZWNpYWwgKGxlZ2FjeSlcblx0XHRcdC8vXHRcdGNvbnN0cnVjdG9yIGNoYWluaW5nLiBJdCBjYW5ub3QgYmUgY2FsbGVkIGZyb20gY2hhaW5lZCBtZXRob2RzLlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdElmIFwidGhpcy5pbmhlcml0ZWQoKVwiIGNhbm5vdCBmaW5kIHRoZSBuZXh0LWluLWNoYWluIG1ldGhvZCwgaXRcblx0XHRcdC8vXHRcdGRvZXMgbm90aGluZyBhbmQgcmV0dXJucyBcInVuZGVmaW5lZFwiLiBUaGUgbGFzdCBtZXRob2QgaW4gY2hhaW5cblx0XHRcdC8vXHRcdGNhbiBiZSBhIGRlZmF1bHQgbWV0aG9kIGltcGxlbWVudGVkIGluIE9iamVjdCwgd2hpY2ggd2lsbCBiZVxuXHRcdFx0Ly9cdFx0Y2FsbGVkIGxhc3QuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0SWYgXCJuYW1lXCIgaXMgc3BlY2lmaWVkLCBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIG1ldGhvZCB0aGF0XG5cdFx0XHQvL1x0XHRyZWNlaXZlZCBcImFyZ3NcIiBpcyB0aGUgcGFyZW50IG1ldGhvZCBmb3IgdGhpcyBjYWxsLiBJdCBpcyBsb29rZWRcblx0XHRcdC8vXHRcdHVwIGluIHRoZSBjaGFpbiBsaXN0IGFuZCBpZiBpdCBpcyBmb3VuZCB0aGUgbmV4dC1pbi1jaGFpbiBtZXRob2Rcblx0XHRcdC8vXHRcdGlzIGNhbGxlZC4gSWYgaXQgaXMgbm90IGZvdW5kLCB0aGUgZmlyc3QtaW4tY2hhaW4gbWV0aG9kIGlzXG5cdFx0XHQvL1x0XHRjYWxsZWQuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0SWYgXCJuYW1lXCIgaXMgbm90IHNwZWNpZmllZCwgaXQgd2lsbCBiZSBkZXJpdmVkIGZyb20gdGhlIGNhbGxpbmdcblx0XHRcdC8vXHRcdG1ldGhvZCAodXNpbmcgYSBtZXRob2lkIHByb3BlcnR5IFwibm9tXCIpLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0dmFyIEIgPSBkZWNsYXJlKEEsIHtcblx0XHRcdC8vXHR8XHRcdG1ldGhvZDE6IGZ1bmN0aW9uKGEsIGIsIGMpe1xuXHRcdFx0Ly9cdHxcdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMpO1xuXHRcdFx0Ly9cdHxcdFx0fSxcblx0XHRcdC8vXHR8XHRcdG1ldGhvZDI6IGZ1bmN0aW9uKGEsIGIpe1xuXHRcdFx0Ly9cdHxcdFx0XHRyZXR1cm4gdGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzLCBbYSArIGJdKTtcblx0XHRcdC8vXHR8XHRcdH1cblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXHR8XHQvLyBuZXh0IG1ldGhvZCBpcyBub3QgaW4gdGhlIGNoYWluIGxpc3QgYmVjYXVzZSBpdCBpcyBhZGRlZFxuXHRcdFx0Ly9cdHxcdC8vIG1hbnVhbGx5IGFmdGVyIHRoZSBjbGFzcyB3YXMgY3JlYXRlZC5cblx0XHRcdC8vXHR8XHRCLnByb3RvdHlwZS5tZXRob2QzID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vXHR8XHRcdGNvbnNvbGUubG9nKFwiVGhpcyBpcyBhIGR5bmFtaWNhbGx5LWFkZGVkIG1ldGhvZC5cIik7XG5cdFx0XHQvL1x0fFx0XHR0aGlzLmluaGVyaXRlZChcIm1ldGhvZDNcIiwgYXJndW1lbnRzKTtcblx0XHRcdC8vXHR8XHR9O1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHR2YXIgQiA9IGRlY2xhcmUoQSwge1xuXHRcdFx0Ly9cdHxcdFx0bWV0aG9kOiBmdW5jdGlvbihhLCBiKXtcblx0XHRcdC8vXHR8XHRcdFx0dmFyIHN1cGVyID0gdGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzLCB0cnVlKTtcblx0XHRcdC8vXHR8XHRcdFx0Ly8gLi4uXG5cdFx0XHQvL1x0fFx0XHRcdGlmKCFzdXBlcil7XG5cdFx0XHQvL1x0fFx0XHRcdFx0Y29uc29sZS5sb2coXCJ0aGVyZSBpcyBubyBzdXBlciBtZXRob2RcIik7XG5cdFx0XHQvL1x0fFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHQvL1x0fFx0XHRcdH1cblx0XHRcdC8vXHR8XHRcdFx0cmV0dXJuIHN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHQvL1x0fFx0XHR9XG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdFwidXNlIHN0cmljdFwiO1xuXHRcdFx0Ly9cdHxcdC8vIGNsYXNzIGlzIGRlZmluZWQgaW4gc3RyaWN0LW1vZGUgY29kZSxcblx0XHRcdC8vXHR8XHQvLyBzbyBjYWxsZXIgbXVzdCBiZSBwYXNzZWQgYmVmb3JlIGFyZ3VtZW50cy5cblx0XHRcdC8vXHR8XHR2YXIgQiA9IGRlY2xhcmUoQSwge1xuXHRcdFx0Ly9cdHxcdFx0Ly8gdXNpbmcgYSBuYW1lZCBmdW5jdGlvbiBleHByZXNzaW9uIHdpdGggXCJmblwiIGFzIHRoZSBuYW1lLlxuXHRcdFx0Ly9cdHxcdFx0bWV0aG9kOiBmdW5jdGlvbiBmbihhLCBiKSB7XG5cdFx0XHQvL1x0fFx0XHRcdHRoaXMuaW5oZXJpdGVkKGZuLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly9cdHxcdFx0fVxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0cmV0dXJuXHR7fTtcdC8vIE9iamVjdFxuXHRcdH0sXG5cblx0XHRnZXRJbmhlcml0ZWQ6IGZ1bmN0aW9uKG5hbWUsIGNhbGxlciwgYXJncyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIHN1cGVyIG1ldGhvZC5cblx0XHRcdC8vIG5hbWU6IFN0cmluZz9cblx0XHRcdC8vXHRcdFRoZSBvcHRpb25hbCBtZXRob2QgbmFtZS4gU2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSBjYWxsZXInc1xuXHRcdFx0Ly9cdFx0bmFtZS4gVXN1YWxseSBcIm5hbWVcIiBpcyBzcGVjaWZpZWQgaW4gY29tcGxleCBkeW5hbWljIGNhc2VzLCB3aGVuXG5cdFx0XHQvL1x0XHR0aGUgY2FsbGluZyBtZXRob2Qgd2FzIGR5bmFtaWNhbGx5IGFkZGVkLCB1bmRlY29yYXRlZCBieVxuXHRcdFx0Ly9cdFx0ZGVjbGFyZSgpLCBhbmQgaXQgY2Fubm90IGJlIGRldGVybWluZWQuXG5cdFx0XHQvLyBjYWxsZXI6IEZ1bmN0aW9uP1xuXHRcdFx0Ly9cdFx0VGhlIGNhbGxlciBmdW5jdGlvbi4gVGhpcyBpcyByZXF1aXJlZCB3aGVuIHJ1bm5pbmcgaW5cblx0XHRcdC8vXHRcdHN0cmljdC1tb2RlIGNvZGUuIEEgcmVmZXJlbmNlIHRvIHRoZSBjYWxsZXIgZnVuY3Rpb25cblx0XHRcdC8vXHRcdGNhbiBiZSBvYnRhaW5lZCBieSB1c2luZyBhIG5hbWVkIGZ1bmN0aW9uIGV4cHJlc3Npb25cblx0XHRcdC8vXHRcdChlLmcuIGZ1bmN0aW9uIGZuKGEsYikgey4uLn0pLlxuXHRcdFx0Ly8gYXJnczogQXJndW1lbnRzXG5cdFx0XHQvL1x0XHRUaGUgY2FsbGVyIHN1cHBseSB0aGlzIGFyZ3VtZW50LCB3aGljaCBzaG91bGQgYmUgdGhlIG9yaWdpbmFsXG5cdFx0XHQvL1x0XHRcImFyZ3VtZW50c1wiLlxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdFJldHVybnMgYSBzdXBlciBtZXRob2QgKEZ1bmN0aW9uKSBvciBcInVuZGVmaW5lZFwiLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRUaGlzIG1ldGhvZCBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgXCJ0aGlzLmluaGVyaXRlZCgpXCIuXG5cdFx0XHQvL1x0XHRJdCB1c2VzIHRoZSBzYW1lIGFsZ29yaXRobSBidXQgaW5zdGVhZCBvZiBleGVjdXRpbmcgYSBzdXBlclxuXHRcdFx0Ly9cdFx0bWV0aG9kLCBpdCByZXR1cm5zIGl0LCBvciBcInVuZGVmaW5lZFwiIGlmIG5vdCBmb3VuZC5cblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdHZhciBCID0gZGVjbGFyZShBLCB7XG5cdFx0XHQvL1x0fFx0XHRtZXRob2Q6IGZ1bmN0aW9uKGEsIGIpe1xuXHRcdFx0Ly9cdHxcdFx0XHR2YXIgc3VwZXIgPSB0aGlzLmdldEluaGVyaXRlZChhcmd1bWVudHMpO1xuXHRcdFx0Ly9cdHxcdFx0XHQvLyAuLi5cblx0XHRcdC8vXHR8XHRcdFx0aWYoIXN1cGVyKXtcblx0XHRcdC8vXHR8XHRcdFx0XHRjb25zb2xlLmxvZyhcInRoZXJlIGlzIG5vIHN1cGVyIG1ldGhvZFwiKTtcblx0XHRcdC8vXHR8XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdC8vXHR8XHRcdFx0fVxuXHRcdFx0Ly9cdHxcdFx0XHRyZXR1cm4gc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdC8vXHR8XHRcdH1cblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0XCJ1c2Ugc3RyaWN0O1wiIC8vIGZpcnN0IGxpbmUgb2YgZnVuY3Rpb24gb3IgZmlsZVxuXHRcdFx0Ly9cdHxcdC8vLi4uXG5cdFx0XHQvL1x0fFx0dmFyIEIgPSBkZWNsYXJlKEEsIHtcblx0XHRcdC8vXHR8XHRcdC8vIFVzaW5nIGEgbmFtZWQgZnVuY3Rpb24gZXhwcmVzc2lvbiB3aXRoIFwiZm5cIiBhcyB0aGUgbmFtZSxcblx0XHRcdC8vXHR8XHRcdC8vIHNpbmNlIHdlJ3JlIGluIHN0cmljdCBtb2RlLlxuXHRcdFx0Ly9cdHxcdFx0bWV0aG9kOiBmdW5jdGlvbiBmbihhLCBiKXtcblx0XHRcdC8vXHR8XHRcdFx0dmFyIHN1cGVyID0gdGhpcy5nZXRJbmhlcml0ZWQoZm4sIGFyZ3VtZW50cyk7XG5cdFx0XHQvL1x0fFx0XHRcdGlmKHN1cGVyKXtcblx0XHRcdC8vXHR8XHRcdFx0XHRyZXR1cm4gc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdC8vXHR8XHRcdFx0fVxuXHRcdFx0Ly9cdHxcdFx0fVxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0cmV0dXJuXHR7fTtcdC8vIE9iamVjdFxuXHRcdH0sXG5cblx0XHRpc0luc3RhbmNlT2Y6IGZ1bmN0aW9uKGNscyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIHRoZSBpbmhlcml0YW5jZSBjaGFpbiB0byBzZWUgaWYgaXQgaXMgaW5oZXJpdGVkIGZyb20gdGhpc1xuXHRcdFx0Ly9cdFx0Y2xhc3MuXG5cdFx0XHQvLyBjbHM6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRDbGFzcyBjb25zdHJ1Y3Rvci5cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRcInRydWVcIiwgaWYgdGhpcyBvYmplY3QgaXMgaW5oZXJpdGVkIGZyb20gdGhpcyBjbGFzcywgXCJmYWxzZVwiXG5cdFx0XHQvL1x0XHRvdGhlcndpc2UuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoaXMgbWV0aG9kIGlzIHVzZWQgd2l0aCBpbnN0YW5jZXMgb2YgY2xhc3NlcyBwcm9kdWNlZCB3aXRoXG5cdFx0XHQvL1x0XHRkZWNsYXJlKCkgdG8gZGV0ZXJtaW5lIG9mIHRoZXkgc3VwcG9ydCBhIGNlcnRhaW4gaW50ZXJmYWNlIG9yXG5cdFx0XHQvL1x0XHRub3QuIEl0IG1vZGVscyBcImluc3RhbmNlb2ZcIiBvcGVyYXRvci5cblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdHZhciBBID0gZGVjbGFyZShudWxsLCB7XG5cdFx0XHQvL1x0fFx0XHQvLyBjb25zdHJ1Y3RvciwgcHJvcGVydGllcywgYW5kIG1ldGhvZHMgZ28gaGVyZVxuXHRcdFx0Ly9cdHxcdFx0Ly8gLi4uXG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1x0fFx0dmFyIEIgPSBkZWNsYXJlKG51bGwsIHtcblx0XHRcdC8vXHR8XHRcdC8vIGNvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzLCBhbmQgbWV0aG9kcyBnbyBoZXJlXG5cdFx0XHQvL1x0fFx0XHQvLyAuLi5cblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXHR8XHR2YXIgQyA9IGRlY2xhcmUoW0EsIEJdLCB7XG5cdFx0XHQvL1x0fFx0XHQvLyBjb25zdHJ1Y3RvciwgcHJvcGVydGllcywgYW5kIG1ldGhvZHMgZ28gaGVyZVxuXHRcdFx0Ly9cdHxcdFx0Ly8gLi4uXG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1x0fFx0dmFyIEQgPSBkZWNsYXJlKEEsIHtcblx0XHRcdC8vXHR8XHRcdC8vIGNvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzLCBhbmQgbWV0aG9kcyBnbyBoZXJlXG5cdFx0XHQvL1x0fFx0XHQvLyAuLi5cblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXHR8XG5cdFx0XHQvL1x0fFx0dmFyIGEgPSBuZXcgQSgpLCBiID0gbmV3IEIoKSwgYyA9IG5ldyBDKCksIGQgPSBuZXcgRCgpO1xuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhhLmlzSW5zdGFuY2VPZihBKSk7IC8vIHRydWVcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhiLmlzSW5zdGFuY2VPZihBKSk7IC8vIGZhbHNlXG5cdFx0XHQvL1x0fFx0Y29uc29sZS5sb2coYy5pc0luc3RhbmNlT2YoQSkpOyAvLyB0cnVlXG5cdFx0XHQvL1x0fFx0Y29uc29sZS5sb2coZC5pc0luc3RhbmNlT2YoQSkpOyAvLyB0cnVlXG5cdFx0XHQvL1x0fFxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGEuaXNJbnN0YW5jZU9mKEIpKTsgLy8gZmFsc2Vcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhiLmlzSW5zdGFuY2VPZihCKSk7IC8vIHRydWVcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhjLmlzSW5zdGFuY2VPZihCKSk7IC8vIHRydWVcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhkLmlzSW5zdGFuY2VPZihCKSk7IC8vIGZhbHNlXG5cdFx0XHQvL1x0fFxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGEuaXNJbnN0YW5jZU9mKEMpKTsgLy8gZmFsc2Vcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhiLmlzSW5zdGFuY2VPZihDKSk7IC8vIGZhbHNlXG5cdFx0XHQvL1x0fFx0Y29uc29sZS5sb2coYy5pc0luc3RhbmNlT2YoQykpOyAvLyB0cnVlXG5cdFx0XHQvL1x0fFx0Y29uc29sZS5sb2coZC5pc0luc3RhbmNlT2YoQykpOyAvLyBmYWxzZVxuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhhLmlzSW5zdGFuY2VPZihEKSk7IC8vIGZhbHNlXG5cdFx0XHQvL1x0fFx0Y29uc29sZS5sb2coYi5pc0luc3RhbmNlT2YoRCkpOyAvLyBmYWxzZVxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGMuaXNJbnN0YW5jZU9mKEQpKTsgLy8gZmFsc2Vcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhkLmlzSW5zdGFuY2VPZihEKSk7IC8vIHRydWVcblx0XHRcdHJldHVyblx0e307XHQvLyBPYmplY3Rcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbihzb3VyY2Upe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEFkZHMgYWxsIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb2Ygc291cmNlIHRvIGNvbnN0cnVjdG9yJ3Ncblx0XHRcdC8vXHRcdHByb3RvdHlwZSwgbWFraW5nIHRoZW0gYXZhaWxhYmxlIHRvIGFsbCBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoXG5cdFx0XHQvL1x0XHRjb25zdHJ1Y3Rvci4gVGhpcyBtZXRob2QgaXMgc3BlY2lmaWMgdG8gY29uc3RydWN0b3JzIGNyZWF0ZWQgd2l0aFxuXHRcdFx0Ly9cdFx0ZGVjbGFyZSgpLlxuXHRcdFx0Ly8gc291cmNlOiBPYmplY3Rcblx0XHRcdC8vXHRcdFNvdXJjZSBvYmplY3Qgd2hpY2ggcHJvcGVydGllcyBhcmUgZ29pbmcgdG8gYmUgY29waWVkIHRvIHRoZVxuXHRcdFx0Ly9cdFx0Y29uc3RydWN0b3IncyBwcm90b3R5cGUuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEFkZHMgc291cmNlIHByb3BlcnRpZXMgdG8gdGhlIGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLiBJdCBjYW5cblx0XHRcdC8vXHRcdG92ZXJyaWRlIGV4aXN0aW5nIHByb3BlcnRpZXMuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VGhpcyBtZXRob2QgaXMgc2ltaWxhciB0byBkb2pvLmV4dGVuZCBmdW5jdGlvbiwgYnV0IGl0IGlzIHNwZWNpZmljXG5cdFx0XHQvL1x0XHR0byBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgZGVjbGFyZSgpLiBJdCBpcyBpbXBsZW1lbnRlZFxuXHRcdFx0Ly9cdFx0dXNpbmcgZG9qby5zYWZlTWl4aW4sIGFuZCBpdCBza2lwcyBhIGNvbnN0cnVjdG9yIHByb3BlcnR5LFxuXHRcdFx0Ly9cdFx0YW5kIHByb3Blcmx5IGRlY29yYXRlcyBjb3BpZWQgZnVuY3Rpb25zLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0dmFyIEEgPSBkZWNsYXJlKG51bGwsIHtcblx0XHRcdC8vXHR8XHRcdG0xOiBmdW5jdGlvbigpe30sXG5cdFx0XHQvL1x0fFx0XHRzMTogXCJQb3Bva2F0ZXBldGxcIlxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cdHxcdEEuZXh0ZW5kKHtcblx0XHRcdC8vXHR8XHRcdG0xOiBmdW5jdGlvbigpe30sXG5cdFx0XHQvL1x0fFx0XHRtMjogZnVuY3Rpb24oKXt9LFxuXHRcdFx0Ly9cdHxcdFx0ZjE6IHRydWUsXG5cdFx0XHQvL1x0fFx0XHRkMTogNDJcblx0XHRcdC8vXHR8XHR9KTtcblx0XHR9LFxuXG5cdFx0Y3JlYXRlU3ViY2xhc3M6IGZ1bmN0aW9uKG1peGlucywgcHJvcHMpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENyZWF0ZSBhIHN1YmNsYXNzIG9mIHRoZSBkZWNsYXJlZCBjbGFzcyBmcm9tIGEgbGlzdCBvZiBiYXNlIGNsYXNzZXMuXG5cdFx0XHQvLyBtaXhpbnM6IEZ1bmN0aW9uW11cblx0XHRcdC8vXHRcdFNwZWNpZmllcyBhIGxpc3Qgb2YgYmFzZXMgKHRoZSBsZWZ0LW1vc3Qgb25lIGlzIHRoZSBtb3N0IGRlZXBlc3Rcblx0XHRcdC8vXHRcdGJhc2UpLlxuXHRcdFx0Ly8gcHJvcHM6IE9iamVjdD9cblx0XHRcdC8vXHRcdEFuIG9wdGlvbmFsIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgdG8gdGhlIGNyZWF0ZWQgcHJvdG90eXBlLlxuXHRcdFx0Ly8gcmV0dXJuczogZG9qby9fYmFzZS9kZWNsYXJlLl9fRGVjbGFyZUNyZWF0ZWRPYmplY3Rcblx0XHRcdC8vXHRcdE5ldyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0Q3JlYXRlIGEgY29uc3RydWN0b3IgdXNpbmcgYSBjb21wYWN0IG5vdGF0aW9uIGZvciBpbmhlcml0YW5jZSBhbmRcblx0XHRcdC8vXHRcdHByb3RvdHlwZSBleHRlbnNpb24uXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0TWl4aW4gYW5jZXN0b3JzIHByb3ZpZGUgYSB0eXBlIG9mIG11bHRpcGxlIGluaGVyaXRhbmNlLlxuXHRcdFx0Ly9cdFx0UHJvdG90eXBlcyBvZiBtaXhpbiBhbmNlc3RvcnMgYXJlIGNvcGllZCB0byB0aGUgbmV3IGNsYXNzOlxuXHRcdFx0Ly9cdFx0Y2hhbmdlcyB0byBtaXhpbiBwcm90b3R5cGVzIHdpbGwgbm90IGFmZmVjdCBjbGFzc2VzIHRvIHdoaWNoXG5cdFx0XHQvL1x0XHR0aGV5IGhhdmUgYmVlbiBtaXhlZCBpbi5cblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdHZhciBBID0gZGVjbGFyZShudWxsLCB7XG5cdFx0XHQvL1x0fFx0XHRtMTogZnVuY3Rpb24oKXt9LFxuXHRcdFx0Ly9cdHxcdFx0czE6IFwiYmFyXCJcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXHR8XHR2YXIgQiA9IGRlY2xhcmUobnVsbCwge1xuXHRcdFx0Ly9cdHxcdFx0bTI6IGZ1bmN0aW9uKCl7fSxcblx0XHRcdC8vXHR8XHRcdHMyOiBcImZvb1wiXG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1x0fFx0dmFyIEMgPSBkZWNsYXJlKG51bGwsIHtcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXHR8XHR2YXIgRDEgPSBBLmNyZWF0ZVN1YmNsYXNzKFtCLCBDXSwge1xuXHRcdFx0Ly9cdHxcdFx0bTE6IGZ1bmN0aW9uKCl7fSxcblx0XHRcdC8vXHR8XHRcdGQxOiA0MlxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cdHxcdHZhciBkMSA9IG5ldyBEMSgpO1xuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8XHQvLyB0aGlzIGlzIGVxdWl2YWxlbnQgdG86XG5cdFx0XHQvL1x0fFx0dmFyIEQyID0gZGVjbGFyZShbQSwgQiwgQ10sIHtcblx0XHRcdC8vXHR8XHRcdG0xOiBmdW5jdGlvbigpe30sXG5cdFx0XHQvL1x0fFx0XHRkMTogNDJcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXHR8XHR2YXIgZDIgPSBuZXcgRDIoKTtcblx0XHR9XG5cdH07XG5cdD09PT09Ki9cblxuXHQvLyBGb3IgYmFjay1jb21wYXQsIHJlbW92ZSBmb3IgMi4wXG5cdGRvam8uc2FmZU1peGluID0gZGVjbGFyZS5zYWZlTWl4aW4gPSBzYWZlTWl4aW47XG5cdGRvam8uZGVjbGFyZSA9IGRlY2xhcmU7XG5cblx0cmV0dXJuIGRlY2xhcmU7XG59KTtcbiIsImRlZmluZShbXCIuL2tlcm5lbFwiLCBcIi4uL29uXCIsIFwiLi4vaGFzXCIsIFwiLi4vZG9tLWdlb21ldHJ5XCJdLCBmdW5jdGlvbihkb2pvLCBvbiwgaGFzLCBkb20pe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vX2Jhc2UvZXZlbnRcblxuXHRpZihvbi5fZml4RXZlbnQpe1xuXHRcdHZhciBmaXhFdmVudCA9IG9uLl9maXhFdmVudDtcblx0XHRvbi5fZml4RXZlbnQgPSBmdW5jdGlvbihldnQsIHNlKXtcblx0XHRcdC8vIGFkZCBzb21lIGFkZGl0aW9uYWwgbm9ybWFsaXphdGlvbiBmb3IgYmFjay1jb21wYXQsIHRoaXMgaXNuJ3QgaW4gb24uanMgYmVjYXVzZSBpdCBpcyBzb21ld2hhdCBtb3JlIGV4cGVuc2l2ZVxuXHRcdFx0ZXZ0ID0gZml4RXZlbnQoZXZ0LCBzZSk7XG5cdFx0XHRpZihldnQpe1xuXHRcdFx0XHRkb20ubm9ybWFsaXplRXZlbnQoZXZ0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBldnQ7XG5cdFx0fTtcdFx0XG5cdH1cblx0XG5cdHZhciByZXQgPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGlzIG1vZHVsZSBkZWZpbmVzIGRvam8gRE9NIGV2ZW50IEFQSS4gICBVc3VhbGx5IHlvdSBzaG91bGQgdXNlIGRvam8vb24sIGFuZCBldnQuc3RvcFByb3BhZ2F0aW9uKCkgK1xuXHRcdC8vXHRcdGV2dC5wcmV2ZW50RGVmYXVsdCgpLCByYXRoZXIgdGhhbiB0aGlzIG1vZHVsZS5cblxuXHRcdGZpeDogZnVuY3Rpb24oLypFdmVudCovIGV2dCwgLypET01Ob2RlKi8gc2VuZGVyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRub3JtYWxpemVzIHByb3BlcnRpZXMgb24gdGhlIGV2ZW50IG9iamVjdCBpbmNsdWRpbmcgZXZlbnRcblx0XHRcdC8vXHRcdGJ1YmJsaW5nIG1ldGhvZHMsIGtleXN0cm9rZSBub3JtYWxpemF0aW9uLCBhbmQgeC95IHBvc2l0aW9uc1xuXHRcdFx0Ly8gZXZ0OiBFdmVudFxuXHRcdFx0Ly9cdFx0bmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdFx0Ly8gc2VuZGVyOiBET01Ob2RlXG5cdFx0XHQvL1x0XHRub2RlIHRvIHRyZWF0IGFzIFwiY3VycmVudFRhcmdldFwiXG5cdFx0XHRpZihvbi5fZml4RXZlbnQpe1xuXHRcdFx0XHRyZXR1cm4gb24uX2ZpeEV2ZW50KGV2dCwgc2VuZGVyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBldnQ7XHQvLyBFdmVudFxuXHRcdH0sXG5cdFxuXHRcdHN0b3A6IGZ1bmN0aW9uKC8qRXZlbnQqLyBldnQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdHByZXZlbnRzIHByb3BhZ2F0aW9uIGFuZCBjbG9iYmVycyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlXG5cdFx0XHQvL1x0XHRwYXNzZWQgZXZlbnRcblx0XHRcdC8vIGV2dDogRXZlbnRcblx0XHRcdC8vXHRcdFRoZSBldmVudCBvYmplY3QuIElmIG9taXR0ZWQsIHdpbmRvdy5ldmVudCBpcyB1c2VkIG9uIElFLlxuXHRcdFx0aWYoaGFzKFwiZG9tLWFkZGV2ZW50bGlzdGVuZXJcIikgfHwgKGV2dCAmJiBldnQucHJldmVudERlZmF1bHQpKXtcblx0XHRcdFx0ZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRldnQgPSBldnQgfHwgd2luZG93LmV2ZW50O1xuXHRcdFx0XHRldnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcblx0XHRcdFx0b24uX3ByZXZlbnREZWZhdWx0LmNhbGwoZXZ0KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0aWYoaGFzKFwiZXh0ZW5kLWRvam9cIikpe1xuXHRcdGRvam8uZml4RXZlbnQgPSByZXQuZml4O1xuXHRcdGRvam8uc3RvcEV2ZW50ID0gcmV0LnN0b3A7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufSk7XG4iLCJkZWZpbmUoW1wiLi9rZXJuZWxcIiwgXCIuL2NvbmZpZ1wiLCAvKj09PT09IFwiLi9kZWNsYXJlXCIsID09PT09Ki8gXCIuL2xhbmdcIiwgXCIuLi9FdmVudGVkXCIsIFwiLi9Db2xvclwiLCBcIi4uL2FzcGVjdFwiLCBcIi4uL3NuaWZmXCIsIFwiLi4vZG9tXCIsIFwiLi4vZG9tLXN0eWxlXCJdLFxuXHRmdW5jdGlvbihkb2pvLCBjb25maWcsIC8qPT09PT0gZGVjbGFyZSwgPT09PT0qLyBsYW5nLCBFdmVudGVkLCBDb2xvciwgYXNwZWN0LCBoYXMsIGRvbSwgc3R5bGUpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vX2Jhc2UvZnhcblx0Ly8gbm90ZXM6XG5cdC8vXHRcdEFuaW1hdGlvbiBsb29zZWx5IHBhY2thZ2UgYmFzZWQgb24gRGFuIFB1cGl1cycgd29yaywgY29udHJpYnV0ZWQgdW5kZXIgQ0xBOyBzZWVcblx0Ly9cdFx0aHR0cDovL3B1cGl1cy5jby51ay9qcy9Ub29sa2l0LkRyYXdpbmcuanNcblxuXHR2YXIgX21peGluID0gbGFuZy5taXhpbjtcblxuXHQvLyBNb2R1bGUgZXhwb3J0XG5cdHZhciBiYXNlZnggPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGlzIG1vZHVsZSBkZWZpbmVzIHRoZSBiYXNlIGRvam8vX2Jhc2UvZnggaW1wbGVtZW50YXRpb24uXG5cdH07XG5cblx0dmFyIF9MaW5lID0gYmFzZWZ4Ll9MaW5lID0gZnVuY3Rpb24oLyppbnQqLyBzdGFydCwgLyppbnQqLyBlbmQpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0T2JqZWN0IHVzZWQgdG8gZ2VuZXJhdGUgdmFsdWVzIGZyb20gYSBzdGFydCB2YWx1ZSB0byBhbiBlbmQgdmFsdWVcblx0XHQvLyBzdGFydDogaW50XG5cdFx0Ly9cdFx0QmVnaW5uaW5nIHZhbHVlIGZvciByYW5nZVxuXHRcdC8vIGVuZDogaW50XG5cdFx0Ly9cdFx0RW5kaW5nIHZhbHVlIGZvciByYW5nZVxuXHRcdHRoaXMuc3RhcnQgPSBzdGFydDtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0fTtcblxuXHRfTGluZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigvKmZsb2F0Ki8gbil7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRSZXR1cm5zIHRoZSBwb2ludCBvbiB0aGUgbGluZVxuXHRcdC8vIG46XG5cdFx0Ly9cdFx0YSBmbG9hdGluZyBwb2ludCBudW1iZXIgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxXG5cdFx0cmV0dXJuICgodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIG4pICsgdGhpcy5zdGFydDsgLy8gRGVjaW1hbFxuXHR9O1xuXG5cdHZhciBBbmltYXRpb24gPSBiYXNlZnguQW5pbWF0aW9uID0gZnVuY3Rpb24oYXJncyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRBIGdlbmVyaWMgYW5pbWF0aW9uIGNsYXNzIHRoYXQgZmlyZXMgY2FsbGJhY2tzIGludG8gaXRzIGhhbmRsZXJzXG5cdFx0Ly9cdFx0b2JqZWN0IGF0IHZhcmlvdXMgc3RhdGVzLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEEgZ2VuZXJpYyBhbmltYXRpb24gY2xhc3MgdGhhdCBmaXJlcyBjYWxsYmFja3MgaW50byBpdHMgaGFuZGxlcnNcblx0XHQvL1x0XHRvYmplY3QgYXQgdmFyaW91cyBzdGF0ZXMuIE5lYXJseSBhbGwgZG9qbyBhbmltYXRpb24gZnVuY3Rpb25zXG5cdFx0Ly9cdFx0cmV0dXJuIGFuIGluc3RhbmNlIG9mIHRoaXMgbWV0aG9kLCB1c3VhbGx5IHdpdGhvdXQgY2FsbGluZyB0aGVcblx0XHQvL1x0XHQucGxheSgpIG1ldGhvZCBiZWZvcmVoYW5kLiBUaGVyZWZvcmUsIHlvdSB3aWxsIGxpa2VseSBuZWVkIHRvXG5cdFx0Ly9cdFx0Y2FsbCAucGxheSgpIG9uIGluc3RhbmNlcyBvZiBgQW5pbWF0aW9uYCB3aGVuIG9uZSBpc1xuXHRcdC8vXHRcdHJldHVybmVkLlxuXHRcdC8vIGFyZ3M6IE9iamVjdFxuXHRcdC8vXHRcdFRoZSAnbWFnaWMgYXJndW1lbnQnLCBtaXhpbmcgYWxsIHRoZSBwcm9wZXJ0aWVzIGludG8gdGhpc1xuXHRcdC8vXHRcdGFuaW1hdGlvbiBpbnN0YW5jZS5cblxuXHRcdF9taXhpbih0aGlzLCBhcmdzKTtcblx0XHRpZihsYW5nLmlzQXJyYXkodGhpcy5jdXJ2ZSkpe1xuXHRcdFx0dGhpcy5jdXJ2ZSA9IG5ldyBfTGluZSh0aGlzLmN1cnZlWzBdLCB0aGlzLmN1cnZlWzFdKTtcblx0XHR9XG5cblx0fTtcblx0QW5pbWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFdmVudGVkKCk7XG5cblx0bGFuZy5leHRlbmQoQW5pbWF0aW9uLCB7XG5cdFx0Ly8gZHVyYXRpb246IEludGVnZXJcblx0XHQvL1x0XHRUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhlIGFuaW1hdGlvbiB3aWxsIHRha2UgdG8gcnVuXG5cdFx0ZHVyYXRpb246IDM1MCxcblxuXHQvKj09PT09XG5cdFx0Ly8gY3VydmU6IF9MaW5lfEFycmF5XG5cdFx0Ly9cdFx0QSB0d28gZWxlbWVudCBhcnJheSBvZiBzdGFydCBhbmQgZW5kIHZhbHVlcywgb3IgYSBgX0xpbmVgIGluc3RhbmNlIHRvIGJlXG5cdFx0Ly9cdFx0dXNlZCBpbiB0aGUgQW5pbWF0aW9uLlxuXHRcdGN1cnZlOiBudWxsLFxuXG5cdFx0Ly8gZWFzaW5nOiBGdW5jdGlvbj9cblx0XHQvL1x0XHRBIEZ1bmN0aW9uIHRvIGFkanVzdCB0aGUgYWNjZWxlcmF0aW9uIChvciBkZWNlbGVyYXRpb24pIG9mIHRoZSBwcm9ncmVzc1xuXHRcdC8vXHRcdGFjcm9zcyBhIF9MaW5lXG5cdFx0ZWFzaW5nOiBudWxsLFxuXHQ9PT09PSovXG5cblx0XHQvLyByZXBlYXQ6IEludGVnZXI/XG5cdFx0Ly9cdFx0VGhlIG51bWJlciBvZiB0aW1lcyB0byBsb29wIHRoZSBhbmltYXRpb25cblx0XHRyZXBlYXQ6IDAsXG5cblx0XHQvLyByYXRlOiBJbnRlZ2VyP1xuXHRcdC8vXHRcdHRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBhZHZhbmNpbmcgdG8gbmV4dCBmcmFtZVxuXHRcdC8vXHRcdCh1c2VkIGFzIGEgZnBzIHRpbWVyOiAxMDAwL3JhdGUgPSBmcHMpXG5cdFx0cmF0ZTogMjAgLyogNTAgZnBzICovLFxuXG5cdC8qPT09PT1cblx0XHQvLyBkZWxheTogSW50ZWdlcj9cblx0XHQvL1x0XHRUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgc3RhcnRpbmcgYW5pbWF0aW9uIGFmdGVyIGl0XG5cdFx0Ly9cdFx0aGFzIGJlZW4gLnBsYXkoKSdlZFxuXHRcdGRlbGF5OiBudWxsLFxuXG5cdFx0Ly8gYmVmb3JlQmVnaW46IEV2ZW50P1xuXHRcdC8vXHRcdFN5bnRoZXRpYyBldmVudCBmaXJlZCBiZWZvcmUgYSBBbmltYXRpb24gYmVnaW5zIHBsYXlpbmcgKHN5bmNocm9ub3VzKVxuXHRcdGJlZm9yZUJlZ2luOiBudWxsLFxuXG5cdFx0Ly8gb25CZWdpbjogRXZlbnQ/XG5cdFx0Ly9cdFx0U3ludGhldGljIGV2ZW50IGZpcmVkIGFzIGEgQW5pbWF0aW9uIGJlZ2lucyBwbGF5aW5nICh1c2VmdWw/KVxuXHRcdG9uQmVnaW46IG51bGwsXG5cblx0XHQvLyBvbkFuaW1hdGU6IEV2ZW50P1xuXHRcdC8vXHRcdFN5bnRoZXRpYyBldmVudCBmaXJlZCBhdCBlYWNoIGludGVydmFsIG9mIHRoZSBBbmltYXRpb25cblx0XHRvbkFuaW1hdGU6IG51bGwsXG5cblx0XHQvLyBvbkVuZDogRXZlbnQ/XG5cdFx0Ly9cdFx0U3ludGhldGljIGV2ZW50IGZpcmVkIGFmdGVyIHRoZSBmaW5hbCBmcmFtZSBvZiB0aGUgQW5pbWF0aW9uXG5cdFx0b25FbmQ6IG51bGwsXG5cblx0XHQvLyBvblBsYXk6IEV2ZW50P1xuXHRcdC8vXHRcdFN5bnRoZXRpYyBldmVudCBmaXJlZCBhbnkgdGltZSB0aGUgQW5pbWF0aW9uIGlzIHBsYXkoKSdlZFxuXHRcdG9uUGxheTogbnVsbCxcblxuXHRcdC8vIG9uUGF1c2U6IEV2ZW50P1xuXHRcdC8vXHRcdFN5bnRoZXRpYyBldmVudCBmaXJlZCB3aGVuIHRoZSBBbmltYXRpb24gaXMgcGF1c2VkXG5cdFx0b25QYXVzZTogbnVsbCxcblxuXHRcdC8vIG9uU3RvcDogRXZlbnRcblx0XHQvL1x0XHRTeW50aGV0aWMgZXZlbnQgZmlyZXMgd2hlbiB0aGUgQW5pbWF0aW9uIGlzIHN0b3BwZWRcblx0XHRvblN0b3A6IG51bGwsXG5cblx0PT09PT0qL1xuXG5cdFx0X3BlcmNlbnQ6IDAsXG5cdFx0X3N0YXJ0UmVwZWF0Q291bnQ6IDAsXG5cblx0XHRfZ2V0U3RlcDogZnVuY3Rpb24oKXtcblx0XHRcdHZhciBfcCA9IHRoaXMuX3BlcmNlbnQsXG5cdFx0XHRcdF9lID0gdGhpcy5lYXNpbmdcblx0XHRcdDtcblx0XHRcdHJldHVybiBfZSA/IF9lKF9wKSA6IF9wO1xuXHRcdH0sXG5cdFx0X2ZpcmU6IGZ1bmN0aW9uKC8qRXZlbnQqLyBldnQsIC8qQXJyYXk/Ki8gYXJncyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q29udmVuaWVuY2UgZnVuY3Rpb24uICBGaXJlIGV2ZW50IFwiZXZ0XCIgYW5kIHBhc3MgaXQgdGhlXG5cdFx0XHQvL1x0XHRhcmd1bWVudHMgc3BlY2lmaWVkIGluIFwiYXJnc1wiLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRDb252ZW5pZW5jZSBmdW5jdGlvbi4gIEZpcmUgZXZlbnQgXCJldnRcIiBhbmQgcGFzcyBpdCB0aGVcblx0XHRcdC8vXHRcdGFyZ3VtZW50cyBzcGVjaWZpZWQgaW4gXCJhcmdzXCIuXG5cdFx0XHQvL1x0XHRGaXJlcyB0aGUgY2FsbGJhY2sgaW4gdGhlIHNjb3BlIG9mIHRoaXMgQW5pbWF0aW9uXG5cdFx0XHQvL1x0XHRpbnN0YW5jZS5cblx0XHRcdC8vIGV2dDpcblx0XHRcdC8vXHRcdFRoZSBldmVudCB0byBmaXJlLlxuXHRcdFx0Ly8gYXJnczpcblx0XHRcdC8vXHRcdFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZXZlbnQuXG5cdFx0XHR2YXIgYSA9IGFyZ3N8fFtdO1xuXHRcdFx0aWYodGhpc1tldnRdKXtcblx0XHRcdFx0aWYoY29uZmlnLmRlYnVnQXRBbGxDb3N0cyl7XG5cdFx0XHRcdFx0dGhpc1tldnRdLmFwcGx5KHRoaXMsIGEpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHR0aGlzW2V2dF0uYXBwbHkodGhpcywgYSk7XG5cdFx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHRcdFx0Ly8gc3F1ZWxjaCBhbmQgbG9nIGJlY2F1c2Ugd2Ugc2hvdWxkbid0IGFsbG93IGV4Y2VwdGlvbnMgaW5cblx0XHRcdFx0XHRcdC8vIHN5bnRoZXRpYyBldmVudCBoYW5kbGVycyB0byBjYXVzZSB0aGUgaW50ZXJuYWwgdGltZXIgdG8gcnVuXG5cdFx0XHRcdFx0XHQvLyBhbXVjaywgcG90ZW50aWFsbHkgcGVnZ2luZyB0aGUgQ1BVLiBJJ20gbm90IGEgZmFuIG9mIHRoaXNcblx0XHRcdFx0XHRcdC8vIHNxdWVsY2gsIGJ1dCBob3BlZnVsbHkgbG9nZ2luZyB3aWxsIG1ha2UgaXQgY2xlYXIgd2hhdCdzXG5cdFx0XHRcdFx0XHQvLyBnb2luZyBvblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcImV4Y2VwdGlvbiBpbiBhbmltYXRpb24gaGFuZGxlciBmb3I6XCIsIGV2dCk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7IC8vIEFuaW1hdGlvblxuXHRcdH0sXG5cblx0XHRwbGF5OiBmdW5jdGlvbigvKmludD8qLyBkZWxheSwgLypCb29sZWFuPyovIGdvdG9TdGFydCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0U3RhcnQgdGhlIGFuaW1hdGlvbi5cblx0XHRcdC8vIGRlbGF5OlxuXHRcdFx0Ly9cdFx0SG93IG1hbnkgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGJlZm9yZSBzdGFydGluZy5cblx0XHRcdC8vIGdvdG9TdGFydDpcblx0XHRcdC8vXHRcdElmIHRydWUsIHN0YXJ0cyB0aGUgYW5pbWF0aW9uIGZyb20gdGhlIGJlZ2lubmluZzsgb3RoZXJ3aXNlLFxuXHRcdFx0Ly9cdFx0c3RhcnRzIGl0IGZyb20gaXRzIGN1cnJlbnQgcG9zaXRpb24uXG5cdFx0XHQvLyByZXR1cm5zOiBBbmltYXRpb25cblx0XHRcdC8vXHRcdFRoZSBpbnN0YW5jZSB0byBhbGxvdyBjaGFpbmluZy5cblxuXHRcdFx0dmFyIF90ID0gdGhpcztcblx0XHRcdGlmKF90Ll9kZWxheVRpbWVyKXsgX3QuX2NsZWFyVGltZXIoKTsgfVxuXHRcdFx0aWYoZ290b1N0YXJ0KXtcblx0XHRcdFx0X3QuX3N0b3BUaW1lcigpO1xuXHRcdFx0XHRfdC5fYWN0aXZlID0gX3QuX3BhdXNlZCA9IGZhbHNlO1xuXHRcdFx0XHRfdC5fcGVyY2VudCA9IDA7XG5cdFx0XHR9ZWxzZSBpZihfdC5fYWN0aXZlICYmICFfdC5fcGF1c2VkKXtcblx0XHRcdFx0cmV0dXJuIF90O1xuXHRcdFx0fVxuXG5cdFx0XHRfdC5fZmlyZShcImJlZm9yZUJlZ2luXCIsIFtfdC5ub2RlXSk7XG5cblx0XHRcdHZhciBkZSA9IGRlbGF5IHx8IF90LmRlbGF5LFxuXHRcdFx0XHRfcCA9IGxhbmcuaGl0Y2goX3QsIFwiX3BsYXlcIiwgZ290b1N0YXJ0KTtcblxuXHRcdFx0aWYoZGUgPiAwKXtcblx0XHRcdFx0X3QuX2RlbGF5VGltZXIgPSBzZXRUaW1lb3V0KF9wLCBkZSk7XG5cdFx0XHRcdHJldHVybiBfdDtcblx0XHRcdH1cblx0XHRcdF9wKCk7XG5cdFx0XHRyZXR1cm4gX3Q7XHQvLyBBbmltYXRpb25cblx0XHR9LFxuXG5cdFx0X3BsYXk6IGZ1bmN0aW9uKGdvdG9TdGFydCl7XG5cdFx0XHR2YXIgX3QgPSB0aGlzO1xuXHRcdFx0aWYoX3QuX2RlbGF5VGltZXIpeyBfdC5fY2xlYXJUaW1lcigpOyB9XG5cdFx0XHRfdC5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG5cdFx0XHRpZihfdC5fcGF1c2VkKXtcblx0XHRcdFx0X3QuX3N0YXJ0VGltZSAtPSBfdC5kdXJhdGlvbiAqIF90Ll9wZXJjZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRfdC5fYWN0aXZlID0gdHJ1ZTtcblx0XHRcdF90Ll9wYXVzZWQgPSBmYWxzZTtcblx0XHRcdHZhciB2YWx1ZSA9IF90LmN1cnZlLmdldFZhbHVlKF90Ll9nZXRTdGVwKCkpO1xuXHRcdFx0aWYoIV90Ll9wZXJjZW50KXtcblx0XHRcdFx0aWYoIV90Ll9zdGFydFJlcGVhdENvdW50KXtcblx0XHRcdFx0XHRfdC5fc3RhcnRSZXBlYXRDb3VudCA9IF90LnJlcGVhdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdC5fZmlyZShcIm9uQmVnaW5cIiwgW3ZhbHVlXSk7XG5cdFx0XHR9XG5cblx0XHRcdF90Ll9maXJlKFwib25QbGF5XCIsIFt2YWx1ZV0pO1xuXG5cdFx0XHRfdC5fY3ljbGUoKTtcblx0XHRcdHJldHVybiBfdDsgLy8gQW5pbWF0aW9uXG5cdFx0fSxcblxuXHRcdHBhdXNlOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFBhdXNlcyBhIHJ1bm5pbmcgYW5pbWF0aW9uLlxuXHRcdFx0dmFyIF90ID0gdGhpcztcblx0XHRcdGlmKF90Ll9kZWxheVRpbWVyKXsgX3QuX2NsZWFyVGltZXIoKTsgfVxuXHRcdFx0X3QuX3N0b3BUaW1lcigpO1xuXHRcdFx0aWYoIV90Ll9hY3RpdmUpeyByZXR1cm4gX3Q7IC8qQW5pbWF0aW9uKi8gfVxuXHRcdFx0X3QuX3BhdXNlZCA9IHRydWU7XG5cdFx0XHRfdC5fZmlyZShcIm9uUGF1c2VcIiwgW190LmN1cnZlLmdldFZhbHVlKF90Ll9nZXRTdGVwKCkpXSk7XG5cdFx0XHRyZXR1cm4gX3Q7IC8vIEFuaW1hdGlvblxuXHRcdH0sXG5cblx0XHRnb3RvUGVyY2VudDogZnVuY3Rpb24oLypEZWNpbWFsKi8gcGVyY2VudCwgLypCb29sZWFuPyovIGFuZFBsYXkpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFNldHMgdGhlIHByb2dyZXNzIG9mIHRoZSBhbmltYXRpb24uXG5cdFx0XHQvLyBwZXJjZW50OlxuXHRcdFx0Ly9cdFx0QSBwZXJjZW50YWdlIGluIGRlY2ltYWwgbm90YXRpb24gKGJldHdlZW4gYW5kIGluY2x1ZGluZyAwLjAgYW5kIDEuMCkuXG5cdFx0XHQvLyBhbmRQbGF5OlxuXHRcdFx0Ly9cdFx0SWYgdHJ1ZSwgcGxheSB0aGUgYW5pbWF0aW9uIGFmdGVyIHNldHRpbmcgdGhlIHByb2dyZXNzLlxuXHRcdFx0dmFyIF90ID0gdGhpcztcblx0XHRcdF90Ll9zdG9wVGltZXIoKTtcblx0XHRcdF90Ll9hY3RpdmUgPSBfdC5fcGF1c2VkID0gdHJ1ZTtcblx0XHRcdF90Ll9wZXJjZW50ID0gcGVyY2VudDtcblx0XHRcdGlmKGFuZFBsYXkpeyBfdC5wbGF5KCk7IH1cblx0XHRcdHJldHVybiBfdDsgLy8gQW5pbWF0aW9uXG5cdFx0fSxcblxuXHRcdHN0b3A6IGZ1bmN0aW9uKC8qYm9vbGVhbj8qLyBnb3RvRW5kKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRTdG9wcyBhIHJ1bm5pbmcgYW5pbWF0aW9uLlxuXHRcdFx0Ly8gZ290b0VuZDpcblx0XHRcdC8vXHRcdElmIHRydWUsIHRoZSBhbmltYXRpb24gd2lsbCBlbmQuXG5cdFx0XHR2YXIgX3QgPSB0aGlzO1xuXHRcdFx0aWYoX3QuX2RlbGF5VGltZXIpeyBfdC5fY2xlYXJUaW1lcigpOyB9XG5cdFx0XHRpZighX3QuX3RpbWVyKXsgcmV0dXJuIF90OyAvKiBBbmltYXRpb24gKi8gfVxuXHRcdFx0X3QuX3N0b3BUaW1lcigpO1xuXHRcdFx0aWYoZ290b0VuZCl7XG5cdFx0XHRcdF90Ll9wZXJjZW50ID0gMTtcblx0XHRcdH1cblx0XHRcdF90Ll9maXJlKFwib25TdG9wXCIsIFtfdC5jdXJ2ZS5nZXRWYWx1ZShfdC5fZ2V0U3RlcCgpKV0pO1xuXHRcdFx0X3QuX2FjdGl2ZSA9IF90Ll9wYXVzZWQgPSBmYWxzZTtcblx0XHRcdHJldHVybiBfdDsgLy8gQW5pbWF0aW9uXG5cdFx0fSxcblxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Y2xlYW51cCB0aGUgYW5pbWF0aW9uXG5cdFx0XHR0aGlzLnN0b3AoKTtcblx0XHR9LFxuXG5cdFx0c3RhdHVzOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgYSBzdHJpbmcgdG9rZW4gcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0YXR1cyBvZlxuXHRcdFx0Ly9cdFx0dGhlIGFuaW1hdGlvbiwgb25lIG9mOiBcInBhdXNlZFwiLCBcInBsYXlpbmdcIiwgXCJzdG9wcGVkXCJcblx0XHRcdGlmKHRoaXMuX2FjdGl2ZSl7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYXVzZWQgPyBcInBhdXNlZFwiIDogXCJwbGF5aW5nXCI7IC8vIFN0cmluZ1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFwic3RvcHBlZFwiOyAvLyBTdHJpbmdcblx0XHR9LFxuXG5cdFx0X2N5Y2xlOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIF90ID0gdGhpcztcblx0XHRcdGlmKF90Ll9hY3RpdmUpe1xuXHRcdFx0XHR2YXIgY3VyciA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuXHRcdFx0XHQvLyBBbGxvdyBkdXJhdGlvbnMgb2YgMCAoaW5zdGFudCkgYnkgc2V0dGluZyBzdGVwIHRvIDEgLSBzZWUgIzEzNzk4XG5cdFx0XHRcdHZhciBzdGVwID0gX3QuZHVyYXRpb24gPT09IDAgPyAxIDogKGN1cnIgLSBfdC5fc3RhcnRUaW1lKSAvIChfdC5kdXJhdGlvbik7XG5cblx0XHRcdFx0aWYoc3RlcCA+PSAxKXtcblx0XHRcdFx0XHRzdGVwID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdC5fcGVyY2VudCA9IHN0ZXA7XG5cblx0XHRcdFx0Ly8gUGVyZm9ybSBlYXNpbmdcblx0XHRcdFx0aWYoX3QuZWFzaW5nKXtcblx0XHRcdFx0XHRzdGVwID0gX3QuZWFzaW5nKHN0ZXApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3QuX2ZpcmUoXCJvbkFuaW1hdGVcIiwgW190LmN1cnZlLmdldFZhbHVlKHN0ZXApXSk7XG5cblx0XHRcdFx0aWYoX3QuX3BlcmNlbnQgPCAxKXtcblx0XHRcdFx0XHRfdC5fc3RhcnRUaW1lcigpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRfdC5fYWN0aXZlID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZihfdC5yZXBlYXQgPiAwKXtcblx0XHRcdFx0XHRcdF90LnJlcGVhdC0tO1xuXHRcdFx0XHRcdFx0X3QucGxheShudWxsLCB0cnVlKTtcblx0XHRcdFx0XHR9ZWxzZSBpZihfdC5yZXBlYXQgPT0gLTEpe1xuXHRcdFx0XHRcdFx0X3QucGxheShudWxsLCB0cnVlKTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdGlmKF90Ll9zdGFydFJlcGVhdENvdW50KXtcblx0XHRcdFx0XHRcdFx0X3QucmVwZWF0ID0gX3QuX3N0YXJ0UmVwZWF0Q291bnQ7XG5cdFx0XHRcdFx0XHRcdF90Ll9zdGFydFJlcGVhdENvdW50ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X3QuX3BlcmNlbnQgPSAwO1xuXHRcdFx0XHRcdF90Ll9maXJlKFwib25FbmRcIiwgW190Lm5vZGVdKTtcblx0XHRcdFx0XHQhX3QucmVwZWF0ICYmIF90Ll9zdG9wVGltZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIF90OyAvLyBBbmltYXRpb25cblx0XHR9LFxuXG5cdFx0X2NsZWFyVGltZXI6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2xlYXIgdGhlIHBsYXkgZGVsYXkgdGltZXJcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9kZWxheVRpbWVyKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9kZWxheVRpbWVyO1xuXHRcdH1cblxuXHR9KTtcblxuXHQvLyB0aGUgbG9jYWwgdGltZXIsIHN0dWJiZWQgaW50byBhbGwgQW5pbWF0aW9uIGluc3RhbmNlc1xuXHR2YXIgY3RyID0gMCxcblx0XHR0aW1lciA9IG51bGwsXG5cdFx0cnVubmVyID0ge1xuXHRcdFx0cnVuOiBmdW5jdGlvbigpe31cblx0XHR9O1xuXG5cdGxhbmcuZXh0ZW5kKEFuaW1hdGlvbiwge1xuXG5cdFx0X3N0YXJ0VGltZXI6IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZighdGhpcy5fdGltZXIpe1xuXHRcdFx0XHR0aGlzLl90aW1lciA9IGFzcGVjdC5hZnRlcihydW5uZXIsIFwicnVuXCIsIGxhbmcuaGl0Y2godGhpcywgXCJfY3ljbGVcIiksIHRydWUpO1xuXHRcdFx0XHRjdHIrKztcblx0XHRcdH1cblx0XHRcdGlmKCF0aW1lcil7XG5cdFx0XHRcdHRpbWVyID0gc2V0SW50ZXJ2YWwobGFuZy5oaXRjaChydW5uZXIsIFwicnVuXCIpLCB0aGlzLnJhdGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfc3RvcFRpbWVyOiBmdW5jdGlvbigpe1xuXHRcdFx0aWYodGhpcy5fdGltZXIpe1xuXHRcdFx0XHR0aGlzLl90aW1lci5yZW1vdmUoKTtcblx0XHRcdFx0dGhpcy5fdGltZXIgPSBudWxsO1xuXHRcdFx0XHRjdHItLTtcblx0XHRcdH1cblx0XHRcdGlmKGN0ciA8PSAwKXtcblx0XHRcdFx0Y2xlYXJJbnRlcnZhbCh0aW1lcik7XG5cdFx0XHRcdHRpbWVyID0gbnVsbDtcblx0XHRcdFx0Y3RyID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0fSk7XG5cblx0dmFyIF9tYWtlRmFkZWFibGUgPVxuXHRcdGhhcyhcImllXCIpID8gZnVuY3Rpb24obm9kZSl7XG5cdFx0XHQvLyBvbmx5IHNldCB0aGUgem9vbSBpZiB0aGUgXCJ0aWNrbGVcIiB2YWx1ZSB3b3VsZCBiZSB0aGUgc2FtZSBhcyB0aGVcblx0XHRcdC8vIGRlZmF1bHRcblx0XHRcdHZhciBucyA9IG5vZGUuc3R5bGU7XG5cdFx0XHQvLyBkb24ndCBzZXQgdGhlIHdpZHRoIHRvIGF1dG8gaWYgaXQgZGlkbid0IGFscmVhZHkgY2FzY2FkZSB0aGF0IHdheS5cblx0XHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gZiBhbnlvbmVzIGRlc2lnbnNcblx0XHRcdGlmKCFucy53aWR0aC5sZW5ndGggJiYgc3R5bGUuZ2V0KG5vZGUsIFwid2lkdGhcIikgPT0gXCJhdXRvXCIpe1xuXHRcdFx0XHRucy53aWR0aCA9IFwiYXV0b1wiO1xuXHRcdFx0fVxuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCl7fTtcblxuXHRiYXNlZnguX2ZhZGUgPSBmdW5jdGlvbigvKk9iamVjdCovIGFyZ3Mpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmV0dXJucyBhbiBhbmltYXRpb24gdGhhdCB3aWxsIGZhZGUgdGhlIG5vZGUgZGVmaW5lZCBieVxuXHRcdC8vXHRcdGFyZ3Mubm9kZSBmcm9tIHRoZSBzdGFydCB0byBlbmQgdmFsdWVzIHBhc3NlZCAoYXJncy5zdGFydFxuXHRcdC8vXHRcdGFyZ3MuZW5kKSAoZW5kIGlzIG1hbmRhdG9yeSwgc3RhcnQgaXMgb3B0aW9uYWwpXG5cblx0XHRhcmdzLm5vZGUgPSBkb20uYnlJZChhcmdzLm5vZGUpO1xuXHRcdHZhciBmQXJncyA9IF9taXhpbih7IHByb3BlcnRpZXM6IHt9IH0sIGFyZ3MpLFxuXHRcdFx0cHJvcHMgPSAoZkFyZ3MucHJvcGVydGllcy5vcGFjaXR5ID0ge30pO1xuXG5cdFx0cHJvcHMuc3RhcnQgPSAhKFwic3RhcnRcIiBpbiBmQXJncykgP1xuXHRcdFx0ZnVuY3Rpb24oKXtcblx0XHRcdFx0cmV0dXJuICtzdHlsZS5nZXQoZkFyZ3Mubm9kZSwgXCJvcGFjaXR5XCIpfHwwO1xuXHRcdFx0fSA6IGZBcmdzLnN0YXJ0O1xuXHRcdHByb3BzLmVuZCA9IGZBcmdzLmVuZDtcblxuXHRcdHZhciBhbmltID0gYmFzZWZ4LmFuaW1hdGVQcm9wZXJ0eShmQXJncyk7XG5cdFx0YXNwZWN0LmFmdGVyKGFuaW0sIFwiYmVmb3JlQmVnaW5cIiwgbGFuZy5wYXJ0aWFsKF9tYWtlRmFkZWFibGUsIGZBcmdzLm5vZGUpLCB0cnVlKTtcblxuXHRcdHJldHVybiBhbmltOyAvLyBBbmltYXRpb25cblx0fTtcblxuXHQvKj09PT09XG5cdHZhciBfX0ZhZGVBcmdzID0gZGVjbGFyZShudWxsLCB7XG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvL1x0XHRUaGUgbm9kZSByZWZlcmVuY2VkIGluIHRoZSBhbmltYXRpb25cblx0XHQvLyBkdXJhdGlvbjogSW50ZWdlcj9cblx0XHQvL1x0XHREdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cblx0XHQvLyBlYXNpbmc6IEZ1bmN0aW9uP1xuXHRcdC8vXHRcdEFuIGVhc2luZyBmdW5jdGlvbi5cblx0fSk7XG5cdD09PT09Ki9cblxuXHRiYXNlZnguZmFkZUluID0gZnVuY3Rpb24oLypfX0ZhZGVBcmdzKi8gYXJncyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRSZXR1cm5zIGFuIGFuaW1hdGlvbiB0aGF0IHdpbGwgZmFkZSBub2RlIGRlZmluZWQgaW4gJ2FyZ3MnIGZyb21cblx0XHQvL1x0XHRpdHMgY3VycmVudCBvcGFjaXR5IHRvIGZ1bGx5IG9wYXF1ZS5cblx0XHRyZXR1cm4gYmFzZWZ4Ll9mYWRlKF9taXhpbih7IGVuZDogMSB9LCBhcmdzKSk7IC8vIEFuaW1hdGlvblxuXHR9O1xuXG5cdGJhc2VmeC5mYWRlT3V0ID0gZnVuY3Rpb24oLypfX0ZhZGVBcmdzKi8gYXJncyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRSZXR1cm5zIGFuIGFuaW1hdGlvbiB0aGF0IHdpbGwgZmFkZSBub2RlIGRlZmluZWQgaW4gJ2FyZ3MnXG5cdFx0Ly9cdFx0ZnJvbSBpdHMgY3VycmVudCBvcGFjaXR5IHRvIGZ1bGx5IHRyYW5zcGFyZW50LlxuXHRcdHJldHVybiBiYXNlZnguX2ZhZGUoX21peGluKHsgZW5kOiAwIH0sIGFyZ3MpKTsgLy8gQW5pbWF0aW9uXG5cdH07XG5cblx0YmFzZWZ4Ll9kZWZhdWx0RWFzaW5nID0gZnVuY3Rpb24oLypEZWNpbWFsPyovIG4pe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhlIGRlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uIGZvciBBbmltYXRpb24ocylcblx0XHRyZXR1cm4gMC41ICsgKChNYXRoLnNpbigobiArIDEuNSkgKiBNYXRoLlBJKSkgLyAyKTtcdC8vIERlY2ltYWxcblx0fTtcblxuXHR2YXIgUHJvcExpbmUgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKXtcblx0XHQvLyBQcm9wTGluZSBpcyBhbiBpbnRlcm5hbCBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIG1vZGVsIHRoZSB2YWx1ZXMgb2Zcblx0XHQvLyBhbiBhIGdyb3VwIG9mIENTUyBwcm9wZXJ0aWVzIGFjcm9zcyBhbiBhbmltYXRpb24gbGlmZWN5Y2xlLiBJblxuXHRcdC8vIHBhcnRpY3VsYXIsIHRoZSBcImdldFZhbHVlXCIgZnVuY3Rpb24gaGFuZGxlcyBnZXR0aW5nIGludGVycG9sYXRlZFxuXHRcdC8vIHZhbHVlcyBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgZm9yIGEgcGFydGljdWxhciBDU1MgdmFsdWUuXG5cdFx0dGhpcy5fcHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG5cdFx0Zm9yKHZhciBwIGluIHByb3BlcnRpZXMpe1xuXHRcdFx0dmFyIHByb3AgPSBwcm9wZXJ0aWVzW3BdO1xuXHRcdFx0aWYocHJvcC5zdGFydCBpbnN0YW5jZW9mIENvbG9yKXtcblx0XHRcdFx0Ly8gY3JlYXRlIGEgcmV1c2FibGUgdGVtcCBjb2xvciBvYmplY3QgdG8ga2VlcCBpbnRlcm1lZGlhdGUgcmVzdWx0c1xuXHRcdFx0XHRwcm9wLnRlbXBDb2xvciA9IG5ldyBDb2xvcigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRQcm9wTGluZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbihyKXtcblx0XHR2YXIgcmV0ID0ge307XG5cdFx0Zm9yKHZhciBwIGluIHRoaXMuX3Byb3BlcnRpZXMpe1xuXHRcdFx0dmFyIHByb3AgPSB0aGlzLl9wcm9wZXJ0aWVzW3BdLFxuXHRcdFx0XHRzdGFydCA9IHByb3Auc3RhcnQ7XG5cdFx0XHRpZihzdGFydCBpbnN0YW5jZW9mIENvbG9yKXtcblx0XHRcdFx0cmV0W3BdID0gQ29sb3IuYmxlbmRDb2xvcnMoc3RhcnQsIHByb3AuZW5kLCByLCBwcm9wLnRlbXBDb2xvcikudG9Dc3MoKTtcblx0XHRcdH1lbHNlIGlmKCFsYW5nLmlzQXJyYXkoc3RhcnQpKXtcblx0XHRcdFx0cmV0W3BdID0gKChwcm9wLmVuZCAtIHN0YXJ0KSAqIHIpICsgc3RhcnQgKyAocCAhPSBcIm9wYWNpdHlcIiA/IHByb3AudW5pdHMgfHwgXCJweFwiIDogMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG5cblx0Lyo9PT09PVxuXHR2YXIgX19BbmltQXJncyA9IGRlY2xhcmUoX19GYWRlQXJncywge1xuXHRcdC8vIHByb3BlcnRpZXM6IE9iamVjdD9cblx0XHQvL1x0XHRBIGhhc2ggbWFwIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gT2JqZWN0cyBkZXNjcmliaW5nIHRoZSB0cmFuc2l0aW9uLFxuXHRcdC8vXHRcdHN1Y2ggYXMgdGhlIHByb3BlcnRpZXMgb2YgX0xpbmUgd2l0aCBhbiBhZGRpdGlvbmFsICd1bml0cycgcHJvcGVydHlcblx0XHRwcm9wZXJ0aWVzOiB7fVxuXG5cdFx0Ly9UT0RPQzogYWRkIGV2ZW50IGNhbGxiYWNrc1xuXHR9KTtcblx0PT09PT0qL1xuXG5cdGJhc2VmeC5hbmltYXRlUHJvcGVydHkgPSBmdW5jdGlvbigvKl9fQW5pbUFyZ3MqLyBhcmdzKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJldHVybnMgYW4gYW5pbWF0aW9uIHRoYXQgd2lsbCB0cmFuc2l0aW9uIHRoZSBwcm9wZXJ0aWVzIG9mXG5cdFx0Ly9cdFx0bm9kZSBkZWZpbmVkIGluIGBhcmdzYCBkZXBlbmRpbmcgaG93IHRoZXkgYXJlIGRlZmluZWQgaW5cblx0XHQvL1x0XHRgYXJncy5wcm9wZXJ0aWVzYFxuXHRcdC8vXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0Rm91bmRhdGlvbiBvZiBtb3N0IGBkb2pvL19iYXNlL2Z4YFxuXHRcdC8vXHRcdGFuaW1hdGlvbnMuIEl0IHRha2VzIGFuIG9iamVjdCBvZiBcInByb3BlcnRpZXNcIiBjb3JyZXNwb25kaW5nIHRvXG5cdFx0Ly9cdFx0c3R5bGUgcHJvcGVydGllcywgYW5kIGFuaW1hdGVzIHRoZW0gaW4gcGFyYWxsZWwgb3ZlciBhIHNldFxuXHRcdC8vXHRcdGR1cmF0aW9uLlxuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRBIHNpbXBsZSBhbmltYXRpb24gdGhhdCBjaGFuZ2VzIHRoZSB3aWR0aCBvZiB0aGUgc3BlY2lmaWVkIG5vZGUuXG5cdFx0Ly9cdHxcdGJhc2VmeC5hbmltYXRlUHJvcGVydHkoe1xuXHRcdC8vXHR8XHRcdG5vZGU6IFwibm9kZUlkXCIsXG5cdFx0Ly9cdHxcdFx0cHJvcGVydGllczogeyB3aWR0aDogNDAwIH0sXG5cdFx0Ly9cdHxcdH0pLnBsYXkoKTtcblx0XHQvL1x0XHREb2pvIGZpZ3VyZXMgb3V0IHRoZSBzdGFydCB2YWx1ZSBmb3IgdGhlIHdpZHRoIGFuZCBjb252ZXJ0cyB0aGVcblx0XHQvL1x0XHRpbnRlZ2VyIHNwZWNpZmllZCBmb3IgdGhlIHdpZHRoIHRvIHRoZSBtb3JlIGV4cHJlc3NpdmUgYnV0XG5cdFx0Ly9cdFx0dmVyYm9zZSBmb3JtIGB7IHdpZHRoOiB7IGVuZDogJzQwMCcsIHVuaXRzOiAncHgnIH0gfWAgd2hpY2ggeW91XG5cdFx0Ly9cdFx0Y2FuIGFsc28gc3BlY2lmeSBkaXJlY3RseS4gRGVmYXVsdHMgdG8gJ3B4JyBpZiBvbWl0dGVkLlxuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRBbmltYXRlIHdpZHRoLCBoZWlnaHQsIGFuZCBwYWRkaW5nIG92ZXIgMiBzZWNvbmRzLi4uIHRoZVxuXHRcdC8vXHRcdHBlZGFudGljIHdheTpcblx0XHQvL1x0fFx0YmFzZWZ4LmFuaW1hdGVQcm9wZXJ0eSh7IG5vZGU6IG5vZGUsIGR1cmF0aW9uOjIwMDAsXG5cdFx0Ly9cdHxcdFx0cHJvcGVydGllczoge1xuXHRcdC8vXHR8XHRcdFx0d2lkdGg6IHsgc3RhcnQ6ICcyMDAnLCBlbmQ6ICc0MDAnLCB1bml0czpcInB4XCIgfSxcblx0XHQvL1x0fFx0XHRcdGhlaWdodDogeyBzdGFydDonMjAwJywgZW5kOiAnNDAwJywgdW5pdHM6XCJweFwiIH0sXG5cdFx0Ly9cdHxcdFx0XHRwYWRkaW5nVG9wOiB7IHN0YXJ0Oic1JywgZW5kOic1MCcsIHVuaXRzOlwicHhcIiB9XG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHR9KS5wbGF5KCk7XG5cdFx0Ly9cdFx0Tm90ZSAncGFkZGluZ1RvcCcgaXMgdXNlZCBvdmVyICdwYWRkaW5nLXRvcCcuIE11bHRpLW5hbWUgQ1NTIHByb3BlcnRpZXNcblx0XHQvL1x0XHRhcmUgd3JpdHRlbiB1c2luZyBcIm1peGVkIGNhc2VcIiwgYXMgdGhlIGh5cGhlbiBpcyBpbGxlZ2FsIGFzIGFuIG9iamVjdCBrZXkuXG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFBsdWcgaW4gYSBkaWZmZXJlbnQgZWFzaW5nIGZ1bmN0aW9uIGFuZCByZWdpc3RlciBhIGNhbGxiYWNrIGZvclxuXHRcdC8vXHRcdHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLiBFYXNpbmcgZnVuY3Rpb25zIGFjY2VwdCB2YWx1ZXMgYmV0d2VlblxuXHRcdC8vXHRcdHplcm8gYW5kIG9uZSBhbmQgcmV0dXJuIGEgdmFsdWUgb24gdGhhdCBiYXNpcy4gSW4gdGhpcyBjYXNlLCBhblxuXHRcdC8vXHRcdGV4cG9uZW50aWFsLWluIGN1cnZlLlxuXHRcdC8vXHR8XHRiYXNlZnguYW5pbWF0ZVByb3BlcnR5KHtcblx0XHQvL1x0fFx0XHRub2RlOiBcIm5vZGVJZFwiLFxuXHRcdC8vXHR8XHRcdC8vIGRvam8gZmlndXJlcyBvdXQgdGhlIHN0YXJ0IHZhbHVlXG5cdFx0Ly9cdHxcdFx0cHJvcGVydGllczogeyB3aWR0aDogeyBlbmQ6IDQwMCB9IH0sXG5cdFx0Ly9cdHxcdFx0ZWFzaW5nOiBmdW5jdGlvbihuKXtcblx0XHQvL1x0fFx0XHRcdHJldHVybiAobj09MCkgPyAwIDogTWF0aC5wb3coMiwgMTAgKiAobiAtIDEpKTtcblx0XHQvL1x0fFx0XHR9LFxuXHRcdC8vXHR8XHRcdG9uRW5kOiBmdW5jdGlvbihub2RlKXtcblx0XHQvL1x0fFx0XHRcdC8vIGNhbGxlZCB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMuIFRoZSBhbmltYXRpb25cblx0XHQvL1x0fFx0XHRcdC8vIHRhcmdldCBpcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvblxuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSkucGxheSg1MDApOyAvLyBkZWxheSBwbGF5aW5nIGhhbGYgYSBzZWNvbmRcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0TGlrZSBhbGwgYEFuaW1hdGlvbmBzLCBhbmltYXRlUHJvcGVydHkgcmV0dXJucyBhIGhhbmRsZSB0byB0aGVcblx0XHQvL1x0XHRBbmltYXRpb24gaW5zdGFuY2UsIHdoaWNoIGZpcmVzIHRoZSBldmVudHMgY29tbW9uIHRvIERvam8gRlguIFVzZSBgYXNwZWN0LmFmdGVyYFxuXHRcdC8vXHRcdHRvIGFjY2VzcyB0aGVzZSBldmVudHMgb3V0c2lkZSBvZiB0aGUgQW5pbWF0aW9uIGRlZmluaXRpb246XG5cdFx0Ly9cdHxcdHZhciBhbmltID0gYmFzZWZ4LmFuaW1hdGVQcm9wZXJ0eSh7XG5cdFx0Ly9cdHxcdFx0bm9kZTpcInNvbWVJZFwiLFxuXHRcdC8vXHR8XHRcdHByb3BlcnRpZXM6e1xuXHRcdC8vXHR8XHRcdFx0d2lkdGg6NDAwLCBoZWlnaHQ6NTAwXG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1x0fFx0YXNwZWN0LmFmdGVyKGFuaW0sIFwib25FbmRcIiwgZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRjb25zb2xlLmxvZyhcImFuaW1hdGlvbiBlbmRlZFwiKTtcblx0XHQvL1x0fFx0fSwgdHJ1ZSk7XG5cdFx0Ly9cdHxcdC8vIHBsYXkgdGhlIGFuaW1hdGlvbiBub3c6XG5cdFx0Ly9cdHxcdGFuaW0ucGxheSgpO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRFYWNoIHByb3BlcnR5IGNhbiBiZSBhIGZ1bmN0aW9uIHdob3NlIHJldHVybiB2YWx1ZSBpcyBzdWJzdGl0dXRlZCBhbG9uZy5cblx0XHQvL1x0XHRBZGRpdGlvbmFsbHksIGVhY2ggbWVhc3VyZW1lbnQgKGVnOiBzdGFydCwgZW5kKSBjYW4gYmUgYSBmdW5jdGlvbi4gVGhlIG5vZGVcblx0XHQvL1x0XHRyZWZlcmVuY2UgaXMgcGFzc2VkIGRpcmVjdGx5IHRvIGNhbGxiYWNrcy5cblx0XHQvL1x0fFx0YmFzZWZ4LmFuaW1hdGVQcm9wZXJ0eSh7XG5cdFx0Ly9cdHxcdFx0bm9kZTpcIm1pbmVcIixcblx0XHQvL1x0fFx0XHRwcm9wZXJ0aWVzOntcblx0XHQvL1x0fFx0XHRcdGhlaWdodDpmdW5jdGlvbihub2RlKXtcblx0XHQvL1x0fFx0XHRcdFx0Ly8gc2hyaW5rIHRoaXMgbm9kZSBieSA1MCVcblx0XHQvL1x0fFx0XHRcdFx0cmV0dXJuIGRvbUdlb20ucG9zaXRpb24obm9kZSkuaCAvIDJcblx0XHQvL1x0fFx0XHRcdH0sXG5cdFx0Ly9cdHxcdFx0XHR3aWR0aDp7XG5cdFx0Ly9cdHxcdFx0XHRcdHN0YXJ0OmZ1bmN0aW9uKG5vZGUpeyByZXR1cm4gMTAwOyB9LFxuXHRcdC8vXHR8XHRcdFx0XHRlbmQ6ZnVuY3Rpb24obm9kZSl7IHJldHVybiAyMDA7IH1cblx0XHQvL1x0fFx0XHRcdH1cblx0XHQvL1x0fFx0XHR9XG5cdFx0Ly9cdHxcdH0pLnBsYXkoKTtcblx0XHQvL1xuXG5cdFx0dmFyIG4gPSBhcmdzLm5vZGUgPSBkb20uYnlJZChhcmdzLm5vZGUpO1xuXHRcdGlmKCFhcmdzLmVhc2luZyl7IGFyZ3MuZWFzaW5nID0gZG9qby5fZGVmYXVsdEVhc2luZzsgfVxuXG5cdFx0dmFyIGFuaW0gPSBuZXcgQW5pbWF0aW9uKGFyZ3MpO1xuXHRcdGFzcGVjdC5hZnRlcihhbmltLCBcImJlZm9yZUJlZ2luXCIsIGxhbmcuaGl0Y2goYW5pbSwgZnVuY3Rpb24oKXtcblx0XHRcdHZhciBwbSA9IHt9O1xuXHRcdFx0Zm9yKHZhciBwIGluIHRoaXMucHJvcGVydGllcyl7XG5cdFx0XHRcdC8vIE1ha2Ugc2hhbGxvdyBjb3B5IG9mIHByb3BlcnRpZXMgaW50byBwbSBiZWNhdXNlIHdlIG92ZXJ3cml0ZVxuXHRcdFx0XHQvLyBzb21lIHZhbHVlcyBiZWxvdy4gSW4gcGFydGljdWxhciBpZiBzdGFydC9lbmQgYXJlIGZ1bmN0aW9uc1xuXHRcdFx0XHQvLyB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSB0aGVtIG9yIHRoZSBmdW5jdGlvbnMgd29uJ3QgYmVcblx0XHRcdFx0Ly8gY2FsbGVkIGlmIHRoZSBhbmltYXRpb24gaXMgcmV1c2VkLlxuXHRcdFx0XHRpZihwID09IFwid2lkdGhcIiB8fCBwID09IFwiaGVpZ2h0XCIpe1xuXHRcdFx0XHRcdHRoaXMubm9kZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW3BdO1xuXHRcdFx0XHRpZihsYW5nLmlzRnVuY3Rpb24ocHJvcCkpe1xuXHRcdFx0XHRcdHByb3AgPSBwcm9wKG4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByb3AgPSBwbVtwXSA9IF9taXhpbih7fSwgKGxhbmcuaXNPYmplY3QocHJvcCkgPyBwcm9wOiB7IGVuZDogcHJvcCB9KSk7XG5cblx0XHRcdFx0aWYobGFuZy5pc0Z1bmN0aW9uKHByb3Auc3RhcnQpKXtcblx0XHRcdFx0XHRwcm9wLnN0YXJ0ID0gcHJvcC5zdGFydChuKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihsYW5nLmlzRnVuY3Rpb24ocHJvcC5lbmQpKXtcblx0XHRcdFx0XHRwcm9wLmVuZCA9IHByb3AuZW5kKG4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBpc0NvbG9yID0gKHAudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiY29sb3JcIikgPj0gMCk7XG5cdFx0XHRcdGZ1bmN0aW9uIGdldFN0eWxlKG5vZGUsIHApe1xuXHRcdFx0XHRcdC8vIGRvbVN0eWxlLmdldChub2RlLCBcImhlaWdodFwiKSBjYW4gcmV0dXJuIFwiYXV0b1wiIG9yIFwiXCIgb24gSUU7IHRoaXMgaXMgbW9yZSByZWxpYWJsZTpcblx0XHRcdFx0XHR2YXIgdiA9IHsgaGVpZ2h0OiBub2RlLm9mZnNldEhlaWdodCwgd2lkdGg6IG5vZGUub2Zmc2V0V2lkdGggfVtwXTtcblx0XHRcdFx0XHRpZih2ICE9PSB1bmRlZmluZWQpeyByZXR1cm4gdjsgfVxuXHRcdFx0XHRcdHYgPSBzdHlsZS5nZXQobm9kZSwgcCk7XG5cdFx0XHRcdFx0cmV0dXJuIChwID09IFwib3BhY2l0eVwiKSA/ICt2IDogKGlzQ29sb3IgPyB2IDogcGFyc2VGbG9hdCh2KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIShcImVuZFwiIGluIHByb3ApKXtcblx0XHRcdFx0XHRwcm9wLmVuZCA9IGdldFN0eWxlKG4sIHApO1xuXHRcdFx0XHR9ZWxzZSBpZighKFwic3RhcnRcIiBpbiBwcm9wKSl7XG5cdFx0XHRcdFx0cHJvcC5zdGFydCA9IGdldFN0eWxlKG4sIHApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoaXNDb2xvcil7XG5cdFx0XHRcdFx0cHJvcC5zdGFydCA9IG5ldyBDb2xvcihwcm9wLnN0YXJ0KTtcblx0XHRcdFx0XHRwcm9wLmVuZCA9IG5ldyBDb2xvcihwcm9wLmVuZCk7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHByb3Auc3RhcnQgPSAocCA9PSBcIm9wYWNpdHlcIikgPyArcHJvcC5zdGFydCA6IHBhcnNlRmxvYXQocHJvcC5zdGFydCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuY3VydmUgPSBuZXcgUHJvcExpbmUocG0pO1xuXHRcdH0pLCB0cnVlKTtcblx0XHRhc3BlY3QuYWZ0ZXIoYW5pbSwgXCJvbkFuaW1hdGVcIiwgbGFuZy5oaXRjaChzdHlsZSwgXCJzZXRcIiwgYW5pbS5ub2RlKSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIGFuaW07IC8vIEFuaW1hdGlvblxuXHR9O1xuXG5cdGJhc2VmeC5hbmltID0gZnVuY3Rpb24oXHQvKkRPTU5vZGV8U3RyaW5nKi9cdG5vZGUsXG5cdFx0XHRcdFx0XHRcdC8qT2JqZWN0Ki9cdFx0XHRwcm9wZXJ0aWVzLFxuXHRcdFx0XHRcdFx0XHQvKkludGVnZXI/Ki9cdFx0ZHVyYXRpb24sXG5cdFx0XHRcdFx0XHRcdC8qRnVuY3Rpb24/Ki9cdFx0ZWFzaW5nLFxuXHRcdFx0XHRcdFx0XHQvKkZ1bmN0aW9uPyovXHRcdG9uRW5kLFxuXHRcdFx0XHRcdFx0XHQvKkludGVnZXI/Ki9cdFx0ZGVsYXkpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0QSBzaW1wbGVyIGludGVyZmFjZSB0byBgYW5pbWF0ZVByb3BlcnR5KClgLCBhbHNvIHJldHVybnNcblx0XHQvL1x0XHRhbiBpbnN0YW5jZSBvZiBgQW5pbWF0aW9uYCBidXQgYmVnaW5zIHRoZSBhbmltYXRpb25cblx0XHQvL1x0XHRpbW1lZGlhdGVseSwgdW5saWtlIG5lYXJseSBldmVyeSBvdGhlciBEb2pvIGFuaW1hdGlvbiBBUEkuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0U2ltcGxlciAoYnV0IHNvbWV3aGF0IGxlc3MgcG93ZXJmdWwpIHZlcnNpb25cblx0XHQvL1x0XHRvZiBgYW5pbWF0ZVByb3BlcnR5YC4gIEl0IHVzZXMgZGVmYXVsdHMgZm9yIG1hbnkgYmFzaWMgcHJvcGVydGllc1xuXHRcdC8vXHRcdGFuZCBhbGxvd3MgZm9yIHBvc2l0aW9uYWwgcGFyYW1ldGVycyB0byBiZSB1c2VkIGluIHBsYWNlIG9mIHRoZVxuXHRcdC8vXHRcdHBhY2tlZCBcInByb3BlcnR5IGJhZ1wiIHdoaWNoIGlzIHVzZWQgZm9yIG90aGVyIERvam8gYW5pbWF0aW9uXG5cdFx0Ly9cdFx0bWV0aG9kcy5cblx0XHQvL1xuXHRcdC8vXHRcdFRoZSBgQW5pbWF0aW9uYCBvYmplY3QgcmV0dXJuZWQgd2lsbCBiZSBhbHJlYWR5IHBsYXlpbmcsIHNvXG5cdFx0Ly9cdFx0Y2FsbGluZyBwbGF5KCkgb24gaXQgYWdhaW4gaXMgKHVzdWFsbHkpIGEgbm8tb3AuXG5cdFx0Ly8gbm9kZTpcblx0XHQvL1x0XHRhIERPTSBub2RlIG9yIHRoZSBpZCBvZiBhIG5vZGUgdG8gYW5pbWF0ZSBDU1MgcHJvcGVydGllcyBvblxuXHRcdC8vIGR1cmF0aW9uOlxuXHRcdC8vXHRcdFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG92ZXIgd2hpY2ggdGhlIGFuaW1hdGlvblxuXHRcdC8vXHRcdHNob3VsZCBydW4uIERlZmF1bHRzIHRvIHRoZSBnbG9iYWwgYW5pbWF0aW9uIGRlZmF1bHQgZHVyYXRpb25cblx0XHQvL1x0XHQoMzUwbXMpLlxuXHRcdC8vIGVhc2luZzpcblx0XHQvL1x0XHRBbiBlYXNpbmcgZnVuY3Rpb24gb3ZlciB3aGljaCB0byBjYWxjdWxhdGUgYWNjZWxlcmF0aW9uXG5cdFx0Ly9cdFx0YW5kIGRlY2VsZXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIHRocm91Z2ggaXRzIGR1cmF0aW9uLlxuXHRcdC8vXHRcdEEgZGVmYXVsdCBlYXNpbmcgYWxnb3JpdGhtIGlzIHByb3ZpZGVkLCBidXQgeW91IG1heVxuXHRcdC8vXHRcdHBsdWcgaW4gYW55IHlvdSB3aXNoLiBBIGxhcmdlIHNlbGVjdGlvbiBvZiBlYXNpbmcgYWxnb3JpdGhtc1xuXHRcdC8vXHRcdGFyZSBhdmFpbGFibGUgaW4gYGRvam8vZngvZWFzaW5nYC5cblx0XHQvLyBvbkVuZDpcblx0XHQvL1x0XHRBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXNcblx0XHQvL1x0XHRydW5uaW5nLlxuXHRcdC8vIGRlbGF5OlxuXHRcdC8vXHRcdFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGJlZ2lubmluZyB0aGVcblx0XHQvL1x0XHRhbmltYXRpb24gYnkuIFRoZSBkZWZhdWx0IGlzIDAuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRGYWRlIG91dCBhIG5vZGVcblx0XHQvL1x0fFx0YmFzZWZ4LmFuaW0oXCJpZFwiLCB7IG9wYWNpdHk6IDAgfSk7XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRGYWRlIG91dCBhIG5vZGUgb3ZlciBhIGZ1bGwgc2Vjb25kXG5cdFx0Ly9cdHxcdGJhc2VmeC5hbmltKFwiaWRcIiwgeyBvcGFjaXR5OiAwIH0sIDEwMDApO1xuXHRcdHJldHVybiBiYXNlZnguYW5pbWF0ZVByb3BlcnR5KHsgLy8gQW5pbWF0aW9uXG5cdFx0XHRub2RlOiBub2RlLFxuXHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uIHx8IEFuaW1hdGlvbi5wcm90b3R5cGUuZHVyYXRpb24sXG5cdFx0XHRwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRvbkVuZDogb25FbmRcblx0XHR9KS5wbGF5KGRlbGF5IHx8IDApO1xuXHR9O1xuXG5cblx0aWYoaGFzKFwiZXh0ZW5kLWRvam9cIikpe1xuXHRcdF9taXhpbihkb2pvLCBiYXNlZngpO1xuXHRcdC8vIEFsaWFzIHRvIGRyb3AgY29tZSAyLjA6XG5cdFx0ZG9qby5fQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xuXHR9XG5cblx0cmV0dXJuIGJhc2VmeDtcbn0pO1xuIiwiZGVmaW5lKFtcIi4va2VybmVsXCIsIFwiLi4vanNvblwiXSwgZnVuY3Rpb24oZG9qbywganNvbil7XG5cbi8vIG1vZHVsZTpcbi8vXHRcdGRvam8vX2Jhc2UvanNvblxuXG4vKj09PT09XG5yZXR1cm4ge1xuXHQvLyBzdW1tYXJ5OlxuXHQvL1x0XHRUaGlzIG1vZHVsZSBkZWZpbmVzIHRoZSBkb2pvIEpTT04gQVBJLlxufTtcbj09PT09Ki9cblxuZG9qby5mcm9tSnNvbiA9IGZ1bmN0aW9uKC8qU3RyaW5nKi8ganMpe1xuXHQvLyBzdW1tYXJ5OlxuXHQvL1x0XHRQYXJzZXMgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24gYW5kIHJldHVybnMgYSBKYXZhU2NyaXB0IHZhbHVlLlxuXHQvLyBkZXNjcmlwdGlvbjpcblx0Ly9cdFx0VGhyb3dzIGZvciBpbnZhbGlkIEphdmFTY3JpcHQgZXhwcmVzc2lvbnMuIEl0IGRvZXMgbm90IHVzZSBhIHN0cmljdCBKU09OIHBhcnNlci4gSXRcblx0Ly9cdFx0YWx3YXlzIGRlbGVnYXRlcyB0byBldmFsKCkuIFRoZSBjb250ZW50IHBhc3NlZCB0byB0aGlzIG1ldGhvZCBtdXN0IHRoZXJlZm9yZSBjb21lXG5cdC8vXHRcdGZyb20gYSB0cnVzdGVkIHNvdXJjZS5cblx0Ly9cdFx0SXQgaXMgcmVjb21tZW5kIHRoYXQgeW91IHVzZSBkb2pvL2pzb24ncyBwYXJzZSBmdW5jdGlvbiBmb3IgYW5cblx0Ly9cdFx0aW1wbGVtZW50YXRpb24gdXNlcyB0aGUgKGZhc3RlcikgbmF0aXZlIEpTT04gcGFyc2Ugd2hlbiBhdmFpbGFibGUuXG5cdC8vIGpzOlxuXHQvL1x0XHRhIHN0cmluZyBsaXRlcmFsIG9mIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uLCBmb3IgaW5zdGFuY2U6XG5cdC8vXHRcdGAneyBcImZvb1wiOiBbIFwiYmFyXCIsIDEsIHsgXCJiYXpcIjogXCJ0aHVkXCIgfSBdIH0nYFxuXG5cdHJldHVybiBldmFsKFwiKFwiICsganMgKyBcIilcIik7IC8vIE9iamVjdFxufTtcblxuLyo9PT09PVxuZG9qby5fZXNjYXBlU3RyaW5nID0gZnVuY3Rpb24oKXtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0QWRkcyBlc2NhcGUgc2VxdWVuY2VzIGZvciBub24tdmlzdWFsIGNoYXJhY3RlcnMsIGRvdWJsZSBxdW90ZSBhbmRcblx0Ly9cdFx0YmFja3NsYXNoIGFuZCBzdXJyb3VuZHMgd2l0aCBkb3VibGUgcXVvdGVzIHRvIGZvcm0gYSB2YWxpZCBzdHJpbmdcblx0Ly9cdFx0bGl0ZXJhbC5cbn07XG49PT09PSovXG5kb2pvLl9lc2NhcGVTdHJpbmcgPSBqc29uLnN0cmluZ2lmeTsgLy8ganVzdCBkZWxlZ2F0ZSB0byBqc29uLnN0cmluZ2lmeVxuXG5kb2pvLnRvSnNvbkluZGVudFN0ciA9IFwiXFx0XCI7XG5kb2pvLnRvSnNvbiA9IGZ1bmN0aW9uKC8qT2JqZWN0Ki8gaXQsIC8qQm9vbGVhbj8qLyBwcmV0dHlQcmludCl7XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdFJldHVybnMgYSBbSlNPTl0oaHR0cDovL2pzb24ub3JnKSBzZXJpYWxpemF0aW9uIG9mIGFuIG9iamVjdC5cblx0Ly8gZGVzY3JpcHRpb246XG5cdC8vXHRcdFJldHVybnMgYSBbSlNPTl0oaHR0cDovL2pzb24ub3JnKSBzZXJpYWxpemF0aW9uIG9mIGFuIG9iamVjdC5cblx0Ly9cdFx0Tm90ZSB0aGF0IHRoaXMgZG9lc24ndCBjaGVjayBmb3IgaW5maW5pdGUgcmVjdXJzaW9uLCBzbyBkb24ndCBkbyB0aGF0IVxuXHQvL1x0XHRJdCBpcyByZWNvbW1lbmQgdGhhdCB5b3UgdXNlIGRvam8vanNvbidzIHN0cmluZ2lmeSBmdW5jdGlvbiBmb3IgYW4gbGlnaHRlclxuXHQvL1x0XHRhbmQgZmFzdGVyIGltcGxlbWVudGF0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgbmF0aXZlIEpTT04gQVBJIGFuZCB1c2VzIHRoZVxuXHQvL1x0XHRuYXRpdmUgSlNPTiBzZXJpYWxpemVyIHdoZW4gYXZhaWxhYmxlLlxuXHQvLyBpdDpcblx0Ly9cdFx0YW4gb2JqZWN0IHRvIGJlIHNlcmlhbGl6ZWQuIE9iamVjdHMgbWF5IGRlZmluZSB0aGVpciBvd25cblx0Ly9cdFx0c2VyaWFsaXphdGlvbiB2aWEgYSBzcGVjaWFsIFwiX19qc29uX19cIiBvciBcImpzb25cIiBmdW5jdGlvblxuXHQvL1x0XHRwcm9wZXJ0eS4gSWYgYSBzcGVjaWFsaXplZCBzZXJpYWxpemVyIGhhcyBiZWVuIGRlZmluZWQsIGl0IHdpbGxcblx0Ly9cdFx0YmUgdXNlZCBhcyBhIGZhbGxiYWNrLlxuXHQvL1x0XHROb3RlIHRoYXQgaW4gMS42LCB0b0pzb24gd291bGQgc2VyaWFsaXplIHVuZGVmaW5lZCwgYnV0IHRoaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFxuXHQvL1x0XHRzaW5jZSBpdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IG5hdGl2ZSBKU09OIHNlcmlhbGl6ZXIuXG5cdC8vIHByZXR0eVByaW50OlxuXHQvL1x0XHRpZiB0cnVlLCB3ZSBpbmRlbnQgb2JqZWN0cyBhbmQgYXJyYXlzIHRvIG1ha2UgdGhlIG91dHB1dCBwcmV0dGllci5cblx0Ly9cdFx0VGhlIHZhcmlhYmxlIGBkb2pvLnRvSnNvbkluZGVudFN0cmAgaXMgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZyAtLVxuXHQvL1x0XHR0byB1c2Ugc29tZXRoaW5nIG90aGVyIHRoYW4gdGhlIGRlZmF1bHQgKHRhYiksIGNoYW5nZSB0aGF0IHZhcmlhYmxlXG5cdC8vXHRcdGJlZm9yZSBjYWxsaW5nIGRvam8udG9Kc29uKCkuXG5cdC8vXHRcdE5vdGUgdGhhdCBpZiBuYXRpdmUgSlNPTiBzdXBwb3J0IGlzIGF2YWlsYWJsZSwgaXQgd2lsbCBiZSB1c2VkIGZvciBzZXJpYWxpemF0aW9uLFxuXHQvL1x0XHRhbmQgbmF0aXZlIGltcGxlbWVudGF0aW9ucyB2YXJ5IG9uIHRoZSBleGFjdCBzcGFjaW5nIHVzZWQgaW4gcHJldHR5IHByaW50aW5nLlxuXHQvLyByZXR1cm5zOlxuXHQvL1x0XHRBIEpTT04gc3RyaW5nIHNlcmlhbGl6YXRpb24gb2YgdGhlIHBhc3NlZC1pbiBvYmplY3QuXG5cdC8vIGV4YW1wbGU6XG5cdC8vXHRcdHNpbXBsZSBzZXJpYWxpemF0aW9uIG9mIGEgdHJpdmlhbCBvYmplY3Rcblx0Ly9cdFx0fFx0dmFyIGpzb25TdHIgPSBkb2pvLnRvSnNvbih7IGhvd2R5OiBcInN0cmFuZ2VyIVwiLCBpc1N0cmFuZ2U6IHRydWUgfSk7XG5cdC8vXHRcdHxcdGRvaC5pcygne1wiaG93ZHlcIjpcInN0cmFuZ2VyIVwiLFwiaXNTdHJhbmdlXCI6dHJ1ZX0nLCBqc29uU3RyKTtcblx0Ly8gZXhhbXBsZTpcblx0Ly9cdFx0YSBjdXN0b20gc2VyaWFsaXplciBmb3IgYW4gb2JqZWN0cyBvZiBhIHBhcnRpY3VsYXIgY2xhc3M6XG5cdC8vXHRcdHxcdGRvam8uZGVjbGFyZShcIkZ1cmJ5XCIsIG51bGwsIHtcblx0Ly9cdFx0fFx0XHRmdXJiaWVzOiBcImFyZSBzdHJhbmdlXCIsXG5cdC8vXHRcdHxcdFx0ZnVyYnlDb3VudDogMTAsXG5cdC8vXHRcdHxcdFx0X19qc29uX186IGZ1bmN0aW9uKCl7XG5cdC8vXHRcdHxcdFx0fSxcblx0Ly9cdFx0fFx0fSk7XG5cblx0Ly8gdXNlIGRvam8vanNvblxuXHRyZXR1cm4ganNvbi5zdHJpbmdpZnkoaXQsIGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuXHRcdGlmKHZhbHVlKXtcblx0XHRcdHZhciB0ZiA9IHZhbHVlLl9fanNvbl9ffHx2YWx1ZS5qc29uO1xuXHRcdFx0aWYodHlwZW9mIHRmID09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRcdHJldHVybiB0Zi5jYWxsKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LCBwcmV0dHlQcmludCAmJiBkb2pvLnRvSnNvbkluZGVudFN0cik7XHQvLyBTdHJpbmdcbn07XG5cbnJldHVybiBkb2pvO1xufSk7XG4iLCJkZWZpbmUoW1wiLi4vZ2xvYmFsXCIsIFwiLi4vaGFzXCIsIFwiLi9jb25maWdcIiwgXCJyZXF1aXJlXCIsIFwibW9kdWxlXCJdLCBmdW5jdGlvbihnbG9iYWwsIGhhcywgY29uZmlnLCByZXF1aXJlLCBtb2R1bGUpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vX2Jhc2Uva2VybmVsXG5cblx0Ly8gVGhpcyBtb2R1bGUgaXMgdGhlIGZvdW5kYXRpb25hbCBtb2R1bGUgb2YgdGhlIGRvam8gYm9vdCBzZXF1ZW5jZTsgaXQgZGVmaW5lcyB0aGUgZG9qbyBvYmplY3QuXG5cblx0dmFyXG5cdFx0Ly8gbG9vcCB2YXJpYWJsZXMgZm9yIHRoaXMgbW9kdWxlXG5cdFx0aSwgcCxcblxuXHRcdC8vIGNyZWF0ZSBkb2pvLCBkaWppdCwgYW5kIGRvam94XG5cdFx0Ly8gRklYTUU6IGluIDIuMCByZW1vdmUgZGlqaXQsIGRvam94IGJlaW5nIGNyZWF0ZWQgYnkgZG9qb1xuXHRcdGRpaml0ID0ge30sXG5cdFx0ZG9qb3ggPSB7fSxcblx0XHRkb2pvID0ge1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRoaXMgbW9kdWxlIGlzIHRoZSBmb3VuZGF0aW9uYWwgbW9kdWxlIG9mIHRoZSBkb2pvIGJvb3Qgc2VxdWVuY2U7IGl0IGRlZmluZXMgdGhlIGRvam8gb2JqZWN0LlxuXG5cdFx0XHQvLyBub3RpY2UgZG9qbyB0YWtlcyBvd25lcnNoaXAgb2YgdGhlIHZhbHVlIG9mIHRoZSBjb25maWcgbW9kdWxlXG5cdFx0XHRjb25maWc6Y29uZmlnLFxuXHRcdFx0Z2xvYmFsOmdsb2JhbCxcblx0XHRcdGRpaml0OmRpaml0LFxuXHRcdFx0ZG9qb3g6ZG9qb3hcblx0XHR9O1xuXG5cblx0Ly8gQ29uZmlndXJlIHRoZSBzY29wZSBtYXAuIEZvciBhIDEwMCUgQU1EIGFwcGxpY2F0aW9uLCB0aGUgc2NvcGUgbWFwIGlzIG5vdCBuZWVkZWQgb3RoZXIgdGhhbiB0byBwcm92aWRlXG5cdC8vIGEgX3Njb3BlTmFtZSBwcm9wZXJ0eSBmb3IgdGhlIGRvam8sIGRpaml0LCBhbmQgZG9qb3ggcm9vdCBvYmplY3Qgc28gdGhvc2UgcGFja2FnZXMgY2FuIGNyZWF0ZVxuXHQvLyB1bmlxdWUgbmFtZXMgaW4gdGhlIGdsb2JhbCBzcGFjZS5cblx0Ly9cblx0Ly8gQnVpbHQsIGxlZ2FjeSBtb2R1bGVzIHVzZSB0aGUgc2NvcGUgbWFwIHRvIGFsbG93IHRob3NlIG1vZHVsZXMgdG8gYmUgZXhwcmVzc2VkIGFzIGlmIGRvam8sIGRpaml0LCBhbmQgZG9qb3gsXG5cdC8vIHdoZXJlIGdsb2JhbCB3aGVuIGluIGZhY3QgdGhleSBhcmUgZWl0aGVyIGdsb2JhbCB1bmRlciBkaWZmZXJlbnQgbmFtZXMgb3Igbm90IGdsb2JhbCBhdCBhbGwuIEluIHYxLjYtLCB0aGVcblx0Ly8gY29uZmlnIHZhcmlhYmxlIFwic2NvcGVNYXBcIiB3YXMgdXNlZCB0byBtYXAgbmFtZXMgYXMgdXNlZCB3aXRoaW4gYSBtb2R1bGUgdG8gZ2xvYmFsIG5hbWVzLiBUaGlzIGhhcyBiZWVuXG5cdC8vIHN1YnN1bWVkIGJ5IHRoZSBBTUQgbWFwIGNvbmZpZ3VyYXRpb24gdmFyaWFibGUgd2hpY2ggY2FuIHJlbG9jYXRlIHBhY2thZ2VzIHRvIGRpZmZlcmVudCBuYW1lcy4gRm9yIGJhY2tjb21wYXQsXG5cdC8vIG9ubHkgdGhlIFwiKlwiIG1hcHBpbmcgaXMgc3VwcG9ydGVkLiBTZWUgaHR0cDovL2xpdmVkb2NzLmRvam90b29sa2l0Lm9yZy9kZXZlbG9wZXIvZGVzaWduL2xvYWRlciNsZWdhY3ktY3Jvc3MtZG9tYWluLW1vZGUgZm9yIGRldGFpbHMuXG5cdC8vXG5cdC8vIFRoZSBmb2xsb3dpbmcgY29tcHV0YXRpb25zIGNvbnRvcnQgdGhlIHBhY2thZ2VNYXAgZm9yIHRoaXMgZG9qbyBpbnN0YW5jZSBpbnRvIGEgc2NvcGVNYXAuXG5cdHZhciBzY29wZU1hcCA9XG5cdFx0XHQvLyBhIG1hcCBmcm9tIGEgbmFtZSB1c2VkIGluIGEgbGVnYWN5IG1vZHVsZSB0byB0aGUgKGdsb2JhbCB2YXJpYWJsZSBuYW1lLCBvYmplY3QgYWRkcmVzc2VkIGJ5IHRoYXQgbmFtZSlcblx0XHRcdC8vIGFsd2F5cyBtYXAgZG9qbywgZGlqaXQsIGFuZCBkb2pveFxuXHRcdFx0e1xuXHRcdFx0XHRkb2pvOltcImRvam9cIiwgZG9qb10sXG5cdFx0XHRcdGRpaml0OltcImRpaml0XCIsIGRpaml0XSxcblx0XHRcdFx0ZG9qb3g6W1wiZG9qb3hcIiwgZG9qb3hdXG5cdFx0XHR9LFxuXG5cdFx0cGFja2FnZU1hcCA9XG5cdFx0XHQvLyB0aGUgcGFja2FnZSBtYXAgZm9yIHRoaXMgZG9qbyBpbnN0YW5jZTsgbm90ZSwgYSBmb3JlaWduIGxvYWRlciBvciBubyBwYWNha2dlTWFwIHJlc3VsdHMgaW4gdGhlIGFib3ZlIGRlZmF1bHQgY29uZmlnXG5cdFx0XHQocmVxdWlyZS5tYXAgJiYgcmVxdWlyZS5tYXBbbW9kdWxlLmlkLm1hdGNoKC9bXlxcL10rLylbMF1dKSxcblxuXHRcdGl0ZW07XG5cblxuXHQvLyBwcm9jZXNzIGFsbCBtYXBwZWQgdG9wLWxldmVsIG5hbWVzIGZvciB0aGlzIGluc3RhbmNlIG9mIGRvam9cblx0Zm9yKHAgaW4gcGFja2FnZU1hcCl7XG5cdFx0aWYoc2NvcGVNYXBbcF0pe1xuXHRcdFx0Ly8gbWFwcGVkIGRvam8sIGRpaml0LCBvciBkb2pveFxuXHRcdFx0c2NvcGVNYXBbcF1bMF0gPSBwYWNrYWdlTWFwW3BdO1xuXHRcdH1lbHNle1xuXHRcdFx0Ly8gc29tZSBvdGhlciB0b3AtbGV2ZWwgbmFtZVxuXHRcdFx0c2NvcGVNYXBbcF0gPSBbcGFja2FnZU1hcFtwXSwge31dO1xuXHRcdH1cblx0fVxuXG5cdC8vIHB1Ymxpc2ggdGhvc2UgbmFtZXMgdG8gX3Njb3BlTmFtZSBhbmQsIG9wdGlvbmFsbHksIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG5cdGZvcihwIGluIHNjb3BlTWFwKXtcblx0XHRpdGVtID0gc2NvcGVNYXBbcF07XG5cdFx0aXRlbVsxXS5fc2NvcGVOYW1lID0gaXRlbVswXTtcblx0XHRpZighY29uZmlnLm5vR2xvYmFscyl7XG5cdFx0XHRnbG9iYWxbaXRlbVswXV0gPSBpdGVtWzFdO1xuXHRcdH1cblx0fVxuXHRkb2pvLnNjb3BlTWFwID0gc2NvcGVNYXA7XG5cblx0Lyo9PT09PSBkb2pvLl9fZG9jUGFyc2VyQ29uZmlndXJlU2NvcGVNYXAoc2NvcGVNYXApOyA9PT09PSovXG5cblx0Ly8gRklYTUU6IGRvam8uYmFzZVVybCBhbmQgZG9qby5jb25maWcuYmFzZVVybCBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXHRkb2pvLmJhc2VVcmwgPSBkb2pvLmNvbmZpZy5iYXNlVXJsID0gcmVxdWlyZS5iYXNlVXJsO1xuXHRkb2pvLmlzQXN5bmMgPSAhaGFzKFwiZG9qby1sb2FkZXJcIikgfHwgcmVxdWlyZS5hc3luYztcblx0ZG9qby5sb2NhbGUgPSBjb25maWcubG9jYWxlO1xuXG5cdHZhciByZXYgPSBcIiRSZXY6JFwiLm1hdGNoKC9bMC05YS1mXXs3LH0vKTtcblx0ZG9qby52ZXJzaW9uID0ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VmVyc2lvbiBudW1iZXIgb2YgdGhlIERvam8gVG9vbGtpdFxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEhhc2ggYWJvdXQgdGhlIHZlcnNpb24sIGluY2x1ZGluZ1xuXHRcdC8vXG5cdFx0Ly9cdFx0LSBtYWpvcjogSW50ZWdlcjogTWFqb3IgdmVyc2lvbi4gSWYgdG90YWwgdmVyc2lvbiBpcyBcIjEuMi4wYmV0YTFcIiwgd2lsbCBiZSAxXG5cdFx0Ly9cdFx0LSBtaW5vcjogSW50ZWdlcjogTWlub3IgdmVyc2lvbi4gSWYgdG90YWwgdmVyc2lvbiBpcyBcIjEuMi4wYmV0YTFcIiwgd2lsbCBiZSAyXG5cdFx0Ly9cdFx0LSBwYXRjaDogSW50ZWdlcjogUGF0Y2ggdmVyc2lvbi4gSWYgdG90YWwgdmVyc2lvbiBpcyBcIjEuMi4wYmV0YTFcIiwgd2lsbCBiZSAwXG5cdFx0Ly9cdFx0LSBmbGFnOiBTdHJpbmc6IERlc2NyaXB0b3IgZmxhZy4gSWYgdG90YWwgdmVyc2lvbiBpcyBcIjEuMi4wYmV0YTFcIiwgd2lsbCBiZSBcImJldGExXCJcblx0XHQvL1x0XHQtIHJldmlzaW9uOiBOdW1iZXI6IFRoZSBHaXQgcmV2IGZyb20gd2hpY2ggZG9qbyB3YXMgcHVsbGVkXG5cblx0XHRtYWpvcjogMSwgbWlub3I6IDE1LCBwYXRjaDogMCwgZmxhZzogXCJcIixcblx0XHRyZXZpc2lvbjogcmV2ID8gcmV2WzBdIDogTmFOLFxuXHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHYgPSBkb2pvLnZlcnNpb247XG5cdFx0XHRyZXR1cm4gdi5tYWpvciArIFwiLlwiICsgdi5taW5vciArIFwiLlwiICsgdi5wYXRjaCArIHYuZmxhZyArIFwiIChcIiArIHYucmV2aXNpb24gKyBcIilcIjtcdC8vIFN0cmluZ1xuXHRcdH1cblx0fTtcblxuXHQvLyBJZiBoYXMoXCJleHRlbmQtZG9qb1wiKSBpcyB0cnV0aHksIHRoZW4gYXMgYSBkb2pvIG1vZHVsZSBpcyBkZWZpbmVkIGl0IHNob3VsZCBwdXNoIGl0J3MgZGVmaW5pdGlvbnNcblx0Ly8gaW50byB0aGUgZG9qbyBvYmplY3QsIGFuZCBjb252ZXJzZWx5LiBJbiAyLjAsIGl0IHdpbGwgbGlrZWx5IGJlIHVudXN1YWwgdG8gYXVnbWVudCBhbm90aGVyIG9iamVjdFxuXHQvLyBhcyBhIHJlc3VsdCBvZiBkZWZpbmluZyBhIG1vZHVsZS4gVGhpcyBoYXMgZmVhdHVyZSBnaXZlcyBhIHdheSB0byBmb3JjZSAyLjAgYmVoYXZpb3IgYXMgdGhlIGNvZGVcblx0Ly8gaXMgbWlncmF0ZWQuIEFic2VudCBzcGVjaWZpYyBhZHZpY2Ugb3RoZXJ3aXNlLCBzZXQgZXh0ZW5kLWRvam8gdG8gdHJ1dGh5LlxuXHRoYXMuYWRkKFwiZXh0ZW5kLWRvam9cIiwgMSk7XG5cblx0aWYoIWhhcyhcImNzcC1yZXN0cmljdGlvbnNcIikpe1xuXHRcdChGdW5jdGlvbihcImRcIiwgXCJkLmV2YWwgPSBmdW5jdGlvbigpe3JldHVybiBkLmdsb2JhbC5ldmFsID8gZC5nbG9iYWwuZXZhbChhcmd1bWVudHNbMF0pIDogZXZhbChhcmd1bWVudHNbMF0pO31cIikpKGRvam8pO1xuXHR9XG5cdC8qPT09PT1cblx0ZG9qby5ldmFsID0gZnVuY3Rpb24oc2NyaXB0VGV4dCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRBIGxlZ2FjeSBtZXRob2QgY3JlYXRlZCBmb3IgdXNlIGV4Y2x1c2l2ZWx5IGJ5IGludGVybmFsIERvam8gbWV0aG9kcy4gRG8gbm90IHVzZSB0aGlzIG1ldGhvZFxuXHRcdC8vXHRcdGRpcmVjdGx5IHVubGVzcyB5b3UgdW5kZXJzdGFuZCBpdHMgcG9zc2libHktZGlmZmVyZW50IGltcGxpY2F0aW9ucyBvbiB0aGUgcGxhdGZvcm1zIHlvdXIgYXJlIHRhcmdldGluZy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRNYWtlcyBhbiBhdHRlbXB0IHRvIGV2YWx1YXRlIHNjcmlwdFRleHQgaW4gdGhlIGdsb2JhbCBzY29wZS4gVGhlIGZ1bmN0aW9uIHdvcmtzIGNvcnJlY3RseSBmb3IgYnJvd3NlcnNcblx0XHQvL1x0XHR0aGF0IHN1cHBvcnQgaW5kaXJlY3QgZXZhbC5cblx0XHQvL1xuXHRcdC8vXHRcdEFzIHVzdWFsLCBJRSBkb2VzIG5vdC4gT24gSUUsIHRoZSBvbmx5IHdheSB0byBpbXBsZW1lbnQgZ2xvYmFsIGV2YWwgaXMgdG9cblx0XHQvL1x0XHR1c2UgZXhlY1NjcmlwdC4gVW5mb3J0dW5hdGVseSwgZXhlY1NjcmlwdCBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZSBhbmQgYnJlYWtzIHNvbWUgY3VycmVudCB1c2FnZXMgb2YgZG9qby5ldmFsLlxuXHRcdC8vXHRcdFRoaXMgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUgdGVjaG5pcXVlIG9mIGV4ZWN1dGluZyBldmFsIGluIHRoZSBzY29wZSBvZiBhIGZ1bmN0aW9uIHRoYXQgaXMgYSBzaW5nbGUgc2NvcGVcblx0XHQvL1x0XHRmcmFtZSBiZWxvdyB0aGUgZ2xvYmFsIHNjb3BlOyB0aGVyZWJ5IGNvbWluZyBjbG9zZSB0byB0aGUgZ2xvYmFsIHNjb3BlLiBOb3RlIGNhcmVmdWxseSB0aGF0XG5cdFx0Ly9cblx0XHQvL1x0XHRkb2pvLmV2YWwoXCJ2YXIgcGkgPSAzLjE0O1wiKTtcblx0XHQvL1xuXHRcdC8vXHRcdHdpbGwgZGVmaW5lIGdsb2JhbCBwaSBpbiBub24tSUUgZW52aXJvbm1lbnRzLCBidXQgZGVmaW5lIHBpIG9ubHkgaW4gYSB0ZW1wb3JhcnkgbG9jYWwgc2NvcGUgZm9yIElFLiBJZiB5b3Ugd2FudFxuXHRcdC8vXHRcdHRvIGRlZmluZSBhIGdsb2JhbCB2YXJpYWJsZSB1c2luZyBkb2pvLmV2YWwsIHdyaXRlIHNvbWV0aGluZyBsaWtlXG5cdFx0Ly9cblx0XHQvL1x0XHRkb2pvLmV2YWwoXCJ3aW5kb3cucGkgPSAzLjE0O1wiKVxuXHRcdC8vIHNjcmlwdFRleHQ6XG5cdFx0Ly9cdFx0VGhlIHRleHQgdG8gZXZhbHVhdGlvbi5cblx0XHQvLyByZXR1cm5zOlxuXHRcdC8vXHRcdFRoZSByZXN1bHQgb2YgdGhlIGV2YWx1YXRpb24uIE9mdGVuIGB1bmRlZmluZWRgXG5cdH07XG5cdD09PT09Ki9cblxuXG5cdGlmKGhhcyhcImhvc3Qtcmhpbm9cIikpe1xuXHRcdGRvam8uZXhpdCA9IGZ1bmN0aW9uKGV4aXRjb2RlKXtcblx0XHRcdHF1aXQoZXhpdGNvZGUpO1xuXHRcdH07XG5cdH1lbHNle1xuXHRcdGRvam8uZXhpdCA9IGZ1bmN0aW9uKCl7XG5cdFx0fTtcblx0fVxuXG5cdGlmKCFoYXMoXCJob3N0LXdlYndvcmtlclwiKSl7XG5cdFx0Ly8gY29uc29sZSBpcyBpbW11dGFibGUgaW4gRkYzMCssIGh0dHBzOi8vYnVncy5kb2pvdG9vbGtpdC5vcmcvdGlja2V0LzE4MTAwXG5cdFx0aGFzLmFkZChcImRvam8tZ3VhcmFudGVlLWNvbnNvbGVcIixcblx0XHRcdC8vIGVuc3VyZSB0aGF0IGNvbnNvbGUubG9nLCBjb25zb2xlLndhcm4sIGV0Yy4gYXJlIGRlZmluZWRcblx0XHRcdDFcblx0XHQpO1xuXHR9XG5cblx0aWYoaGFzKFwiZG9qby1ndWFyYW50ZWUtY29uc29sZVwiKSl7XG5cdFx0Ly8gSUUgOSBidWc6IGh0dHBzOi8vYnVncy5kb2pvdG9vbGtpdC5vcmcvdGlja2V0LzE4MTk3XG5cdFx0aGFzLmFkZChcImNvbnNvbGUtYXMtb2JqZWN0XCIsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAmJiBjb25zb2xlICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJvYmplY3RcIjtcblx0XHR9KTtcblxuXHRcdHR5cGVvZiBjb25zb2xlICE9IFwidW5kZWZpbmVkXCIgfHwgKGNvbnNvbGUgPSB7fSk7ICAvLyBpbnRlbnRpb25hbCBhc3NpZ25tZW50XG5cdFx0Ly9cdEJlIGNhcmVmdWwgdG8gbGVhdmUgJ2xvZycgYWx3YXlzIGF0IHRoZSBlbmRcblx0XHR2YXIgY24gPSBbXG5cdFx0XHRcImFzc2VydFwiLCBcImNvdW50XCIsIFwiZGVidWdcIiwgXCJkaXJcIiwgXCJkaXJ4bWxcIiwgXCJlcnJvclwiLCBcImdyb3VwXCIsXG5cdFx0XHRcImdyb3VwRW5kXCIsIFwiaW5mb1wiLCBcInByb2ZpbGVcIiwgXCJwcm9maWxlRW5kXCIsIFwidGltZVwiLCBcInRpbWVFbmRcIixcblx0XHRcdFwidHJhY2VcIiwgXCJ3YXJuXCIsIFwibG9nXCJcblx0XHRdO1xuXHRcdHZhciB0bjtcblx0XHRpID0gMDtcblx0XHR3aGlsZSgodG4gPSBjbltpKytdKSl7XG5cdFx0XHRpZighY29uc29sZVt0bl0pe1xuXHRcdFx0XHQoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgdGNuID0gdG4gKyBcIlwiO1xuXHRcdFx0XHRcdGNvbnNvbGVbdGNuXSA9ICgnbG9nJyBpbiBjb25zb2xlKSA/IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHR2YXIgYSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRhLnVuc2hpZnQodGNuICsgXCI6XCIpO1xuXHRcdFx0XHRcdFx0Y29uc29sZVtcImxvZ1wiXShhLmpvaW4oXCIgXCIpKTtcblx0XHRcdFx0XHR9IDogZnVuY3Rpb24oKXt9O1xuXHRcdFx0XHRcdGNvbnNvbGVbdGNuXS5fZmFrZSA9IHRydWU7XG5cdFx0XHRcdH0pKCk7XG5cdFx0XHR9ZWxzZSBpZihoYXMoXCJjb25zb2xlLWFzLW9iamVjdFwiKSl7XG5cdFx0XHRcdGNvbnNvbGVbdG5dID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChjb25zb2xlW3RuXSwgY29uc29sZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aGFzLmFkZChcImRvam8tZGVidWctbWVzc2FnZXNcIixcblx0XHQvLyBpbmNsdWRlIGRvam8uZGVwcmVjYXRlZC9kb2pvLmV4cGVyaW1lbnRhbCBpbXBsZW1lbnRhdGlvbnNcblx0XHQhIWNvbmZpZy5pc0RlYnVnXG5cdCk7XG5cdGRvam8uZGVwcmVjYXRlZCA9IGRvam8uZXhwZXJpbWVudGFsID0gIGZ1bmN0aW9uKCl7fTtcblx0aWYoaGFzKFwiZG9qby1kZWJ1Zy1tZXNzYWdlc1wiKSl7XG5cdFx0ZG9qby5kZXByZWNhdGVkID0gZnVuY3Rpb24oLypTdHJpbmcqLyBiZWhhdmlvdXIsIC8qU3RyaW5nPyovIGV4dHJhLCAvKlN0cmluZz8qLyByZW1vdmFsKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRMb2cgYSBkZWJ1ZyBtZXNzYWdlIHRvIGluZGljYXRlIHRoYXQgYSBiZWhhdmlvciBoYXMgYmVlblxuXHRcdFx0Ly9cdFx0ZGVwcmVjYXRlZC5cblx0XHRcdC8vIGJlaGF2aW91cjogU3RyaW5nXG5cdFx0XHQvL1x0XHRUaGUgQVBJIG9yIGJlaGF2aW9yIGJlaW5nIGRlcHJlY2F0ZWQuIFVzdWFsbHkgaW4gdGhlIGZvcm1cblx0XHRcdC8vXHRcdG9mIFwibXlBcHAuc29tZUZ1bmN0aW9uKClcIi5cblx0XHRcdC8vIGV4dHJhOiBTdHJpbmc/XG5cdFx0XHQvL1x0XHRUZXh0IHRvIGFwcGVuZCB0byB0aGUgbWVzc2FnZS4gT2Z0ZW4gcHJvdmlkZXMgYWR2aWNlIG9uIGFcblx0XHRcdC8vXHRcdG5ldyBmdW5jdGlvbiBvciBmYWNpbGl0eSB0byBhY2hpZXZlIHRoZSBzYW1lIGdvYWwgZHVyaW5nXG5cdFx0XHQvL1x0XHR0aGUgZGVwcmVjYXRpb24gcGVyaW9kLlxuXHRcdFx0Ly8gcmVtb3ZhbDogU3RyaW5nP1xuXHRcdFx0Ly9cdFx0VGV4dCB0byBpbmRpY2F0ZSB3aGVuIGluIHRoZSBmdXR1cmUgdGhlIGJlaGF2aW9yIHdpbGwgYmVcblx0XHRcdC8vXHRcdHJlbW92ZWQuIFVzdWFsbHkgYSB2ZXJzaW9uIG51bWJlci5cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fCBkb2pvLmRlcHJlY2F0ZWQoXCJteUFwcC5nZXRUZW1wKClcIiwgXCJ1c2UgbXlBcHAuZ2V0TG9jYWxlVGVtcCgpIGluc3RlYWRcIiwgXCIxLjBcIik7XG5cblx0XHRcdHZhciBtZXNzYWdlID0gXCJERVBSRUNBVEVEOiBcIiArIGJlaGF2aW91cjtcblx0XHRcdGlmKGV4dHJhKXsgbWVzc2FnZSArPSBcIiBcIiArIGV4dHJhOyB9XG5cdFx0XHRpZihyZW1vdmFsKXsgbWVzc2FnZSArPSBcIiAtLSB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbjogXCIgKyByZW1vdmFsOyB9XG5cdFx0XHRjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cdFx0fTtcblxuXHRcdGRvam8uZXhwZXJpbWVudGFsID0gZnVuY3Rpb24oLyogU3RyaW5nICovIG1vZHVsZU5hbWUsIC8qIFN0cmluZz8gKi8gZXh0cmEpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdE1hcmtzIGNvZGUgYXMgZXhwZXJpbWVudGFsLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRUaGlzIGNhbiBiZSB1c2VkIHRvIG1hcmsgYSBmdW5jdGlvbiwgZmlsZSwgb3IgbW9kdWxlIGFzXG5cdFx0XHQvL1x0XHRleHBlcmltZW50YWwuXHQgRXhwZXJpbWVudGFsIGNvZGUgaXMgbm90IHJlYWR5IHRvIGJlIHVzZWQsIGFuZCB0aGVcblx0XHRcdC8vXHRcdEFQSXMgYXJlIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlLlx0RXhwZXJpbWVudGFsIGNvZGUgbWF5IGJlXG5cdFx0XHQvL1x0XHRjb21wbGV0ZWQgZGVsZXRlZCB3aXRob3V0IGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBkZXByZWNhdGlvblxuXHRcdFx0Ly9cdFx0cHJvY2Vzcy5cblx0XHRcdC8vIG1vZHVsZU5hbWU6IFN0cmluZ1xuXHRcdFx0Ly9cdFx0VGhlIG5hbWUgb2YgYSBtb2R1bGUsIG9yIHRoZSBuYW1lIG9mIGEgbW9kdWxlIGZpbGUgb3IgYSBzcGVjaWZpY1xuXHRcdFx0Ly9cdFx0ZnVuY3Rpb25cblx0XHRcdC8vIGV4dHJhOiBTdHJpbmc/XG5cdFx0XHQvL1x0XHRzb21lIGFkZGl0aW9uYWwgbWVzc2FnZSBmb3IgdGhlIHVzZXJcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fCBkb2pvLmV4cGVyaW1lbnRhbChcImRvam8uZGF0YS5SZXN1bHRcIik7XG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHwgZG9qby5leHBlcmltZW50YWwoXCJkb2pvLndlYXRoZXIudG9LZWx2aW4oKVwiLCBcIlBFTkRJTkcgYXBwcm92YWwgZnJvbSBOT0FBXCIpO1xuXG5cdFx0XHR2YXIgbWVzc2FnZSA9IFwiRVhQRVJJTUVOVEFMOiBcIiArIG1vZHVsZU5hbWUgKyBcIiAtLSBBUElzIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlLlwiO1xuXHRcdFx0aWYoZXh0cmEpeyBtZXNzYWdlICs9IFwiIFwiICsgZXh0cmE7IH1cblx0XHRcdGNvbnNvbGUud2FybihtZXNzYWdlKTtcblx0XHR9O1xuXHR9XG5cblx0aGFzLmFkZChcImRvam8tbW9kdWxlUGF0aHNcIixcblx0XHQvLyBjb25zdW1lIGRvam8ubW9kdWxlUGF0aHMgcHJvY2Vzc2luZ1xuXHRcdDFcblx0KTtcblx0aWYoaGFzKFwiZG9qby1tb2R1bGVQYXRoc1wiKSl7XG5cdFx0Ly8gbm90aWNlIHRoYXQgbW9kdWxlUGF0aHMgd29uJ3QgYmUgYXBwbGllZCB0byBhbnkgcmVxdWlyZSdzIGJlZm9yZSB0aGUgZG9qby9fYmFzZS9rZXJuZWwgZmFjdG9yeSBpcyBydW47XG5cdFx0Ly8gdGhpcyBpcyB0aGUgdjEuNi0gYmVoYXZpb3IuXG5cdFx0aWYoY29uZmlnLm1vZHVsZVBhdGhzKXtcblx0XHRcdGRvam8uZGVwcmVjYXRlZChcImRvam8ubW9kdWxlUGF0aHNcIiwgXCJ1c2UgcGF0aHMgY29uZmlndXJhdGlvblwiKTtcblx0XHRcdHZhciBwYXRocyA9IHt9O1xuXHRcdFx0Zm9yKHAgaW4gY29uZmlnLm1vZHVsZVBhdGhzKXtcblx0XHRcdFx0cGF0aHNbcC5yZXBsYWNlKC9cXC4vZywgXCIvXCIpXSA9IGNvbmZpZy5tb2R1bGVQYXRoc1twXTtcblx0XHRcdH1cblx0XHRcdHJlcXVpcmUoe3BhdGhzOnBhdGhzfSk7XG5cdFx0fVxuXHR9XG5cblx0aGFzLmFkZChcImRvam8tbW9kdWxlVXJsXCIsXG5cdFx0Ly8gaW5jbHVkZSBkb2pvLm1vZHVsZVVybFxuXHRcdDFcblx0KTtcblx0aWYoaGFzKFwiZG9qby1tb2R1bGVVcmxcIikpe1xuXHRcdGRvam8ubW9kdWxlVXJsID0gZnVuY3Rpb24oLypTdHJpbmcqL21vZHVsZSwgLypTdHJpbmc/Ki91cmwpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgYSBVUkwgcmVsYXRpdmUgdG8gYSBtb2R1bGUuXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdHZhciBwbmdQYXRoID0gZG9qby5tb2R1bGVVcmwoXCJhY21lXCIsXCJpbWFnZXMvc21hbGwucG5nXCIpO1xuXHRcdFx0Ly9cdHxcdGNvbnNvbGUuZGlyKHBuZ1BhdGgpOyAvLyBsaXN0IHRoZSBvYmplY3QgcHJvcGVydGllc1xuXHRcdFx0Ly9cdHxcdC8vIGNyZWF0ZSBhbiBpbWFnZSBhbmQgc2V0IGl0J3Mgc291cmNlIHRvIHBuZ1BhdGgncyB2YWx1ZTpcblx0XHRcdC8vXHR8XHR2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblx0XHRcdC8vXHR8XHRpbWcuc3JjID0gcG5nUGF0aDtcblx0XHRcdC8vXHR8XHQvLyBhZGQgb3VyIGltYWdlIHRvIHRoZSBkb2N1bWVudFxuXHRcdFx0Ly9cdHxcdGRvam8uYm9keSgpLmFwcGVuZENoaWxkKGltZyk7XG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0eW91IG1heSBkZS1yZWZlcmVuY2UgYXMgZmFyIGFzIHlvdSBsaWtlIGRvd24gdGhlIHBhY2thZ2Vcblx0XHRcdC8vXHRcdGhpZXJhcmNoeS4gIFRoaXMgaXMgc29tZXRpbWVzIGhhbmR5IHRvIGF2b2lkIGxlbmd0aHkgcmVsYXRpdmVcblx0XHRcdC8vXHRcdHVybHMgb3IgZm9yIGJ1aWxkaW5nIHBvcnRhYmxlIHN1Yi1wYWNrYWdlcy4gSW4gdGhpcyBleGFtcGxlLFxuXHRcdFx0Ly9cdFx0dGhlIGBhY21lLndpZGdldGAgYW5kIGBhY21lLnV0aWxgIGRpcmVjdG9yaWVzIG1heSBiZSBsb2NhdGVkXG5cdFx0XHQvL1x0XHR1bmRlciBkaWZmZXJlbnQgcm9vdHMgKHNlZSBgZG9qby5yZWdpc3Rlck1vZHVsZVBhdGhgKSBidXQgdGhlXG5cdFx0XHQvL1x0XHR0aGUgbW9kdWxlcyB3aGljaCByZWZlcmVuY2UgdGhlbSBjYW4gYmUgdW5hd2FyZSBvZiB0aGVpclxuXHRcdFx0Ly9cdFx0cmVsYXRpdmUgbG9jYXRpb25zIG9uIHRoZSBmaWxlc3lzdGVtOlxuXHRcdFx0Ly9cdHxcdC8vIHNvbWV3aGVyZSBpbiBhIGNvbmZpZ3VyYXRpb24gYmxvY2tcblx0XHRcdC8vXHR8XHRkb2pvLnJlZ2lzdGVyTW9kdWxlUGF0aChcImFjbWUud2lkZ2V0XCIsIFwiLi4vLi4vYWNtZS93aWRnZXRcIik7XG5cdFx0XHQvL1x0fFx0ZG9qby5yZWdpc3Rlck1vZHVsZVBhdGgoXCJhY21lLnV0aWxcIiwgXCIuLi8uLi91dGlsXCIpO1xuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8XHQvLyAuLi5cblx0XHRcdC8vXHR8XG5cdFx0XHQvL1x0fFx0Ly8gY29kZSBpbiBhIG1vZHVsZSB1c2luZyBhY21lIHJlc291cmNlc1xuXHRcdFx0Ly9cdHxcdHZhciB0bXBsdFBhdGggPSBkb2pvLm1vZHVsZVVybChcImFjbWUud2lkZ2V0XCIsXCJ0ZW1wbGF0ZXMvdGVtcGxhdGUuaHRtbFwiKTtcblx0XHRcdC8vXHR8XHR2YXIgZGF0YVBhdGggPSBkb2pvLm1vZHVsZVVybChcImFjbWUudXRpbFwiLFwicmVzb3VyY2VzL2RhdGEuanNvblwiKTtcblxuXHRcdFx0ZG9qby5kZXByZWNhdGVkKFwiZG9qby5tb2R1bGVVcmwoKVwiLCBcInVzZSByZXF1aXJlLnRvVXJsXCIsIFwiMi4wXCIpO1xuXG5cdFx0XHQvLyByZXF1aXJlLnRvVXJsIHJlcXVpcmVzIGEgZmlsZXR5cGU7IHRoZXJlZm9yZSwganVzdCBhcHBlbmQgdGhlIHN1ZmZpeCBcIi8qLipcIiB0byBndWFyYW50ZWUgYSBmaWxldHlwZSwgdGhlblxuXHRcdFx0Ly8gcmVtb3ZlIHRoZSBzdWZmaXggZnJvbSB0aGUgcmVzdWx0LiBUaGlzIHdheSBjbGllbnRzIGNhbiByZXF1ZXN0IGEgdXJsIHcvb3V0IGEgZmlsZXR5cGUuIFRoaXMgc2hvdWxkIGJlXG5cdFx0XHQvLyByYXJlLCBidXQgaXQgbWFpbnRhaW5zIGJhY2tjb21wYXQgZm9yIHRoZSB2MS54IGxpbmUgKG5vdGU6IGRvam8ubW9kdWxlVXJsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Mi4wKS5cblx0XHRcdC8vIE5vdGljZSAqIGlzIGFuIGlsbGVnYWwgZmlsZW5hbWUgc28gaXQgd29uJ3QgY29uZmxpY3Qgd2l0aCBhbnkgcmVhbCBwYXRoIG1hcCB0aGF0IG1heSBleGlzdCB0aGUgcGF0aHMgY29uZmlnLlxuXHRcdFx0dmFyIHJlc3VsdCA9IG51bGw7XG5cdFx0XHRpZihtb2R1bGUpe1xuXHRcdFx0XHRyZXN1bHQgPSByZXF1aXJlLnRvVXJsKG1vZHVsZS5yZXBsYWNlKC9cXC4vZywgXCIvXCIpICsgKHVybCA/IChcIi9cIiArIHVybCkgOiBcIlwiKSArIFwiLyouKlwiKS5yZXBsYWNlKC9cXC9cXCpcXC5cXCovLCBcIlwiKSArICh1cmwgPyBcIlwiIDogXCIvXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHR9XG5cblx0ZG9qby5faGFzUmVzb3VyY2UgPSB7fTsgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBsYXllcnMgYnVpbHQgd2l0aCAxLjYgdG9vbGluZ1xuXG5cdHJldHVybiBkb2pvO1xufSk7XG4iLCJkZWZpbmUoW1wiLi9rZXJuZWxcIiwgXCIuLi9oYXNcIiwgXCIuLi9zbmlmZlwiXSwgZnVuY3Rpb24oZG9qbywgaGFzKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL19iYXNlL2xhbmdcblxuXHRoYXMuYWRkKFwiYnVnLWZvci1pbi1za2lwcy1zaGFkb3dlZFwiLCBmdW5jdGlvbigpe1xuXHRcdC8vIGlmIHRydWUsIHRoZSBmb3ItaW4gaXRlcmF0b3Igc2tpcHMgb2JqZWN0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBPYmplY3QncyBwcm90b3R5cGUgKElFIDYgLSA/KVxuXHRcdGZvcih2YXIgaSBpbiB7dG9TdHJpbmc6IDF9KXtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRyZXR1cm4gMTtcblx0fSk7XG5cblx0Ly8gSGVscGVyIG1ldGhvZHNcblx0dmFyIF9leHRyYU5hbWVzID1cblx0XHRcdGhhcyhcImJ1Zy1mb3ItaW4tc2tpcHMtc2hhZG93ZWRcIikgP1xuXHRcdFx0XHRcImhhc093blByb3BlcnR5LnZhbHVlT2YuaXNQcm90b3R5cGVPZi5wcm9wZXJ0eUlzRW51bWVyYWJsZS50b0xvY2FsZVN0cmluZy50b1N0cmluZy5jb25zdHJ1Y3RvclwiLnNwbGl0KFwiLlwiKSA6IFtdLFxuXG5cdFx0X2V4dHJhTGVuID0gX2V4dHJhTmFtZXMubGVuZ3RoLFxuXG5cdFx0Z2V0UHJvcCA9IGZ1bmN0aW9uKC8qQXJyYXkqL3BhcnRzLCAvKkJvb2xlYW4qL2NyZWF0ZSwgLypPYmplY3QqL2NvbnRleHQpe1xuXHRcdFx0aWYoIWNvbnRleHQpe1xuXHRcdFx0XHRpZihwYXJ0c1swXSAmJiBkb2pvLnNjb3BlTWFwW3BhcnRzWzBdXSkge1xuXHRcdFx0XHRcdC8vIFZvb2RvbyBjb2RlIGZyb20gdGhlIG9sZCBkYXlzIHdoZXJlIFwiZG9qb1wiIG9yIFwiZGlqaXRcIiBtYXBzIHRvIHNvbWUgc3BlY2lhbCBvYmplY3Rcblx0XHRcdFx0XHQvLyByYXRoZXIgdGhhbiBqdXN0IHdpbmRvdy5kb2pvXG5cdFx0XHRcdFx0Y29udGV4dCA9IGRvam8uc2NvcGVNYXBbcGFydHMuc2hpZnQoKV1bMV07XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGNvbnRleHQgPSBkb2pvLmdsb2JhbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0cnl7XG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0dmFyIHAgPSBwYXJ0c1tpXTtcblx0XHRcdFx0XHRpZighKHAgaW4gY29udGV4dCkpe1xuXHRcdFx0XHRcdFx0aWYoY3JlYXRlKXtcblx0XHRcdFx0XHRcdFx0Y29udGV4dFtwXSA9IHt9O1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcdFx0Ly8gcmV0dXJuIHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dFtwXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29udGV4dDsgLy8gbWl4ZWRcblx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0Ly8gXCJwIGluIGNvbnRleHRcIiB0aHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gY29udGV4dCBpcyBhIG51bWJlciwgYm9vbGVhbiwgZXRjLiByYXRoZXIgdGhhbiBhbiBvYmplY3QsXG5cdFx0XHRcdC8vIHNvIGluIHRoYXQgY29ybmVyIGNhc2UganVzdCByZXR1cm4gdW5kZWZpbmVkIChieSBoYXZpbmcgbm8gcmV0dXJuIHN0YXRlbWVudClcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b3B0cyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cblx0XHRlZmZpY2llbnQgPSBmdW5jdGlvbihvYmosIG9mZnNldCwgc3RhcnRXaXRoKXtcblx0XHRcdHJldHVybiAoc3RhcnRXaXRofHxbXSkuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgb2Zmc2V0fHwwKSk7XG5cdFx0fSxcblxuXHRcdF9wYXR0ZXJuID0gL1xceyhbXlxcfV0rKVxcfS9nO1xuXG5cdC8vIE1vZHVsZSBleHBvcnRcblx0dmFyIGxhbmcgPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGlzIG1vZHVsZSBkZWZpbmVzIEphdmFzY3JpcHQgbGFuZ3VhZ2UgZXh0ZW5zaW9ucy5cblxuXHRcdC8vIF9leHRyYU5hbWVzOiBTdHJpbmdbXVxuXHRcdC8vXHRcdExpc3RzIHByb3BlcnR5IG5hbWVzIHRoYXQgbXVzdCBiZSBleHBsaWNpdGx5IHByb2Nlc3NlZCBkdXJpbmcgZm9yLWluIGl0ZXJhdGlvblxuXHRcdC8vXHRcdGluIGVudmlyb25tZW50cyB0aGF0IGhhdmUgaGFzKFwiYnVnLWZvci1pbi1za2lwcy1zaGFkb3dlZFwiKSB0cnVlLlxuXHRcdF9leHRyYU5hbWVzOl9leHRyYU5hbWVzLFxuXG5cdFx0X21peGluOiBmdW5jdGlvbihkZXN0LCBzb3VyY2UsIGNvcHlGdW5jKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDb3BpZXMvYWRkcyBhbGwgcHJvcGVydGllcyBvZiBzb3VyY2UgdG8gZGVzdDsgcmV0dXJucyBkZXN0LlxuXHRcdFx0Ly8gZGVzdDogT2JqZWN0XG5cdFx0XHQvL1x0XHRUaGUgb2JqZWN0IHRvIHdoaWNoIHRvIGNvcHkvYWRkIGFsbCBwcm9wZXJ0aWVzIGNvbnRhaW5lZCBpbiBzb3VyY2UuXG5cdFx0XHQvLyBzb3VyY2U6IE9iamVjdFxuXHRcdFx0Ly9cdFx0VGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGRyYXcgYWxsIHByb3BlcnRpZXMgdG8gY29weSBpbnRvIGRlc3QuXG5cdFx0XHQvLyBjb3B5RnVuYzogRnVuY3Rpb24/XG5cdFx0XHQvL1x0XHRUaGUgcHJvY2VzcyB1c2VkIHRvIGNvcHkvYWRkIGEgcHJvcGVydHkgaW4gc291cmNlOyBkZWZhdWx0cyB0byB0aGUgSmF2YXNjcmlwdCBhc3NpZ25tZW50IG9wZXJhdG9yLlxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdGRlc3QsIGFzIG1vZGlmaWVkXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEFsbCBwcm9wZXJ0aWVzLCBpbmNsdWRpbmcgZnVuY3Rpb25zIChzb21ldGltZXMgdGVybWVkIFwibWV0aG9kc1wiKSwgZXhjbHVkaW5nIGFueSBub24tc3RhbmRhcmQgZXh0ZW5zaW9uc1xuXHRcdFx0Ly9cdFx0Zm91bmQgaW4gT2JqZWN0LnByb3RvdHlwZSwgYXJlIGNvcGllZC9hZGRlZCB0byBkZXN0LiBDb3B5aW5nL2FkZGluZyBlYWNoIHBhcnRpY3VsYXIgcHJvcGVydHkgaXNcblx0XHRcdC8vXHRcdGRlbGVnYXRlZCB0byBjb3B5RnVuYyAoaWYgYW55KTsgY29weUZ1bmMgZGVmYXVsdHMgdG8gdGhlIEphdmFzY3JpcHQgYXNzaWdubWVudCBvcGVyYXRvciBpZiBub3QgcHJvdmlkZWQuXG5cdFx0XHQvL1x0XHROb3RpY2UgdGhhdCBieSBkZWZhdWx0LCBfbWl4aW4gZXhlY3V0ZXMgYSBzby1jYWxsZWQgXCJzaGFsbG93IGNvcHlcIiBhbmQgYWdncmVnYXRlIHR5cGVzIGFyZSBjb3BpZWQvYWRkZWQgYnkgcmVmZXJlbmNlLlxuXHRcdFx0dmFyIG5hbWUsIHMsIGksIGVtcHR5ID0ge307XG5cdFx0XHRmb3IobmFtZSBpbiBzb3VyY2Upe1xuXHRcdFx0XHQvLyB0aGUgKCEobmFtZSBpbiBlbXB0eSkgfHwgZW1wdHlbbmFtZV0gIT09IHMpIGNvbmRpdGlvbiBhdm9pZHMgY29weWluZyBwcm9wZXJ0aWVzIGluIFwic291cmNlXCJcblx0XHRcdFx0Ly8gaW5oZXJpdGVkIGZyb20gT2JqZWN0LnByb3RvdHlwZS5cdCBGb3IgZXhhbXBsZSwgaWYgZGVzdCBoYXMgYSBjdXN0b20gdG9TdHJpbmcoKSBtZXRob2QsXG5cdFx0XHRcdC8vIGRvbid0IG92ZXJ3cml0ZSBpdCB3aXRoIHRoZSB0b1N0cmluZygpIG1ldGhvZCB0aGF0IHNvdXJjZSBpbmhlcml0ZWQgZnJvbSBPYmplY3QucHJvdG90eXBlXG5cdFx0XHRcdHMgPSBzb3VyY2VbbmFtZV07XG5cdFx0XHRcdGlmKCEobmFtZSBpbiBkZXN0KSB8fCAoZGVzdFtuYW1lXSAhPT0gcyAmJiAoIShuYW1lIGluIGVtcHR5KSB8fCBlbXB0eVtuYW1lXSAhPT0gcykpKXtcblx0XHRcdFx0XHRkZXN0W25hbWVdID0gY29weUZ1bmMgPyBjb3B5RnVuYyhzKSA6IHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYoaGFzKFwiYnVnLWZvci1pbi1za2lwcy1zaGFkb3dlZFwiKSl7XG5cdFx0XHRcdGlmKHNvdXJjZSl7XG5cdFx0XHRcdFx0Zm9yKGkgPSAwOyBpIDwgX2V4dHJhTGVuOyArK2kpe1xuXHRcdFx0XHRcdFx0bmFtZSA9IF9leHRyYU5hbWVzW2ldO1xuXHRcdFx0XHRcdFx0cyA9IHNvdXJjZVtuYW1lXTtcblx0XHRcdFx0XHRcdGlmKCEobmFtZSBpbiBkZXN0KSB8fCAoZGVzdFtuYW1lXSAhPT0gcyAmJiAoIShuYW1lIGluIGVtcHR5KSB8fCBlbXB0eVtuYW1lXSAhPT0gcykpKXtcblx0XHRcdFx0XHRcdFx0ZGVzdFtuYW1lXSA9IGNvcHlGdW5jID8gY29weUZ1bmMocykgOiBzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGVzdDsgLy8gT2JqZWN0XG5cdFx0fSxcblxuXHRcdG1peGluOiBmdW5jdGlvbihkZXN0LCBzb3VyY2VzKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDb3BpZXMvYWRkcyBhbGwgcHJvcGVydGllcyBvZiBvbmUgb3IgbW9yZSBzb3VyY2VzIHRvIGRlc3Q7IHJldHVybnMgZGVzdC5cblx0XHRcdC8vIGRlc3Q6IE9iamVjdFxuXHRcdFx0Ly9cdFx0VGhlIG9iamVjdCB0byB3aGljaCB0byBjb3B5L2FkZCBhbGwgcHJvcGVydGllcyBjb250YWluZWQgaW4gc291cmNlLiBJZiBkZXN0IGlzIGZhbHN5LCB0aGVuXG5cdFx0XHQvL1x0XHRhIG5ldyBvYmplY3QgaXMgbWFudWZhY3R1cmVkIGJlZm9yZSBjb3B5aW5nL2FkZGluZyBwcm9wZXJ0aWVzIGJlZ2lucy5cblx0XHRcdC8vIHNvdXJjZXM6IE9iamVjdC4uLlxuXHRcdFx0Ly9cdFx0T25lIG9mIG1vcmUgb2JqZWN0cyBmcm9tIHdoaWNoIHRvIGRyYXcgYWxsIHByb3BlcnRpZXMgdG8gY29weSBpbnRvIGRlc3QuIHNvdXJjZXMgYXJlIHByb2Nlc3NlZFxuXHRcdFx0Ly9cdFx0bGVmdC10by1yaWdodCBhbmQgaWYgbW9yZSB0aGFuIG9uZSBvZiB0aGVzZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgcHJvcGVydHkgbmFtZSwgdGhlIHJpZ2h0LW1vc3Rcblx0XHRcdC8vXHRcdHZhbHVlIFwid2luc1wiLlxuXHRcdFx0Ly8gcmV0dXJuczogT2JqZWN0XG5cdFx0XHQvL1x0XHRkZXN0LCBhcyBtb2RpZmllZFxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRBbGwgcHJvcGVydGllcywgaW5jbHVkaW5nIGZ1bmN0aW9ucyAoc29tZXRpbWVzIHRlcm1lZCBcIm1ldGhvZHNcIiksIGV4Y2x1ZGluZyBhbnkgbm9uLXN0YW5kYXJkIGV4dGVuc2lvbnNcblx0XHRcdC8vXHRcdGZvdW5kIGluIE9iamVjdC5wcm90b3R5cGUsIGFyZSBjb3BpZWQvYWRkZWQgZnJvbSBzb3VyY2VzIHRvIGRlc3QuIHNvdXJjZXMgYXJlIHByb2Nlc3NlZCBsZWZ0IHRvIHJpZ2h0LlxuXHRcdFx0Ly9cdFx0VGhlIEphdmFzY3JpcHQgYXNzaWdubWVudCBvcGVyYXRvciBpcyB1c2VkIHRvIGNvcHkvYWRkIGVhY2ggcHJvcGVydHk7IHRoZXJlZm9yZSwgYnkgZGVmYXVsdCwgbWl4aW5cblx0XHRcdC8vXHRcdGV4ZWN1dGVzIGEgc28tY2FsbGVkIFwic2hhbGxvdyBjb3B5XCIgYW5kIGFnZ3JlZ2F0ZSB0eXBlcyBhcmUgY29waWVkL2FkZGVkIGJ5IHJlZmVyZW5jZS5cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRtYWtlIGEgc2hhbGxvdyBjb3B5IG9mIGFuIG9iamVjdFxuXHRcdFx0Ly9cdHxcdHZhciBjb3B5ID0gbGFuZy5taXhpbih7fSwgc291cmNlKTtcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRtYW55IGNsYXNzIGNvbnN0cnVjdG9ycyBvZnRlbiB0YWtlIGFuIG9iamVjdCB3aGljaCBzcGVjaWZpZXNcblx0XHRcdC8vXHRcdHZhbHVlcyB0byBiZSBjb25maWd1cmVkIG9uIHRoZSBvYmplY3QuIEluIHRoaXMgY2FzZSwgaXQgaXNcblx0XHRcdC8vXHRcdG9mdGVuIHNpbXBsZXN0IHRvIGNhbGwgYGxhbmcubWl4aW5gIG9uIHRoZSBgdGhpc2Agb2JqZWN0OlxuXHRcdFx0Ly9cdHxcdGRlY2xhcmUoXCJhY21lLkJhc2VcIiwgbnVsbCwge1xuXHRcdFx0Ly9cdHxcdFx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKHByb3BlcnRpZXMpe1xuXHRcdFx0Ly9cdHxcdFx0XHQvLyBwcm9wZXJ0eSBjb25maWd1cmF0aW9uOlxuXHRcdFx0Ly9cdHxcdFx0XHRsYW5nLm1peGluKHRoaXMsIHByb3BlcnRpZXMpO1xuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2codGhpcy5xdWlwKTtcblx0XHRcdC8vXHR8XHRcdFx0Ly9cdC4uLlxuXHRcdFx0Ly9cdHxcdFx0fSxcblx0XHRcdC8vXHR8XHRcdHF1aXA6IFwiSSB3YXNuJ3QgYm9ybiB5ZXN0ZXJkYXksIHlvdSBrbm93IC0gSSd2ZSBzZWVuIG1vdmllcy5cIixcblx0XHRcdC8vXHR8XHRcdC8vIC4uLlxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8XHQvLyBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIGNsYXNzIGFuZCBjb25maWd1cmUgaXRcblx0XHRcdC8vXHR8XHR2YXIgYiA9IG5ldyBhY21lLkJhc2Uoe3F1aXA6IFwiVGhhdCdzIHdoYXQgaXQgZG9lcyFcIiB9KTtcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRjb3B5IGluIHByb3BlcnRpZXMgZnJvbSBtdWx0aXBsZSBvYmplY3RzXG5cdFx0XHQvL1x0fFx0dmFyIGZsYXR0ZW5lZCA9IGxhbmcubWl4aW4oXG5cdFx0XHQvL1x0fFx0XHR7XG5cdFx0XHQvL1x0fFx0XHRcdG5hbWU6IFwiRnJ5bG9ja1wiLFxuXHRcdFx0Ly9cdHxcdFx0XHRicmFjZXM6IHRydWVcblx0XHRcdC8vXHR8XHRcdH0sXG5cdFx0XHQvL1x0fFx0XHR7XG5cdFx0XHQvL1x0fFx0XHRcdG5hbWU6IFwiQ2FybCBCcnV0YW5hbmFuYWRpbGV3c2tpXCJcblx0XHRcdC8vXHR8XHRcdH1cblx0XHRcdC8vXHR8XHQpO1xuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8XHQvLyB3aWxsIHByaW50IFwiQ2FybCBCcnV0YW5hbmFuYWRpbGV3c2tpXCJcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhmbGF0dGVuZWQubmFtZSk7XG5cdFx0XHQvL1x0fFx0Ly8gd2lsbCBwcmludCBcInRydWVcIlxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGZsYXR0ZW5lZC5icmFjZXMpO1xuXG5cdFx0XHRpZighZGVzdCl7IGRlc3QgPSB7fTsgfVxuXHRcdFx0Zm9yKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0XHRsYW5nLl9taXhpbihkZXN0LCBhcmd1bWVudHNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRlc3Q7IC8vIE9iamVjdFxuXHRcdH0sXG5cblx0XHRzZXRPYmplY3Q6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBjb250ZXh0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRTZXQgYSBwcm9wZXJ0eSBmcm9tIGEgZG90LXNlcGFyYXRlZCBzdHJpbmcsIHN1Y2ggYXMgXCJBLkIuQ1wiXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFVzZWZ1bCBmb3IgbG9uZ2VyIGFwaSBjaGFpbnMgd2hlcmUgeW91IGhhdmUgdG8gdGVzdCBlYWNoIG9iamVjdCBpblxuXHRcdFx0Ly9cdFx0dGhlIGNoYWluLCBvciB3aGVuIHlvdSBoYXZlIGFuIG9iamVjdCByZWZlcmVuY2UgaW4gc3RyaW5nIGZvcm1hdC5cblx0XHRcdC8vXHRcdE9iamVjdHMgYXJlIGNyZWF0ZWQgYXMgbmVlZGVkIGFsb25nIGBwYXRoYC4gUmV0dXJucyB0aGUgcGFzc2VkXG5cdFx0XHQvL1x0XHR2YWx1ZSBpZiBzZXR0aW5nIGlzIHN1Y2Nlc3NmdWwgb3IgYHVuZGVmaW5lZGAgaWYgbm90LlxuXHRcdFx0Ly8gbmFtZTogU3RyaW5nXG5cdFx0XHQvL1x0XHRQYXRoIHRvIGEgcHJvcGVydHksIGluIHRoZSBmb3JtIFwiQS5CLkNcIi5cblx0XHRcdC8vIHZhbHVlOiBhbnl0aGluZ1xuXHRcdFx0Ly9cdFx0dmFsdWUgb3Igb2JqZWN0IHRvIHBsYWNlIGF0IGxvY2F0aW9uIGdpdmVuIGJ5IG5hbWVcblx0XHRcdC8vIGNvbnRleHQ6IE9iamVjdD9cblx0XHRcdC8vXHRcdE9wdGlvbmFsLiBPYmplY3QgdG8gdXNlIGFzIHJvb3Qgb2YgcGF0aC4gRGVmYXVsdHMgdG9cblx0XHRcdC8vXHRcdGBkb2pvLmdsb2JhbGAuXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0c2V0IHRoZSB2YWx1ZSBvZiBgZm9vLmJhci5iYXpgLCByZWdhcmRsZXNzIG9mIHdoZXRoZXJcblx0XHRcdC8vXHRcdGludGVybWVkaWF0ZSBvYmplY3RzIGFscmVhZHkgZXhpc3Q6XG5cdFx0XHQvL1x0fCBsYW5nLnNldE9iamVjdChcImZvby5iYXIuYmF6XCIsIHZhbHVlKTtcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHR3aXRob3V0IGBsYW5nLnNldE9iamVjdGAsIHdlIG9mdGVuIHNlZSBjb2RlIGxpa2UgdGhpczpcblx0XHRcdC8vXHR8IC8vIGVuc3VyZSB0aGF0IGludGVybWVkaWF0ZSBvYmplY3RzIGFyZSBhdmFpbGFibGVcblx0XHRcdC8vXHR8IGlmKCFvYmpbXCJwYXJlbnRcIl0peyBvYmoucGFyZW50ID0ge307IH1cblx0XHRcdC8vXHR8IGlmKCFvYmoucGFyZW50W1wiY2hpbGRcIl0peyBvYmoucGFyZW50LmNoaWxkID0ge307IH1cblx0XHRcdC8vXHR8IC8vIG5vdyB3ZSBjYW4gc2FmZWx5IHNldCB0aGUgcHJvcGVydHlcblx0XHRcdC8vXHR8IG9iai5wYXJlbnQuY2hpbGQucHJvcCA9IFwic29tZSB2YWx1ZVwiO1xuXHRcdFx0Ly9cdFx0d2hlcmVhcyB3aXRoIGBsYW5nLnNldE9iamVjdGAsIHdlIGNhbiBzaG9ydGVuIHRoYXQgdG86XG5cdFx0XHQvL1x0fCBsYW5nLnNldE9iamVjdChcInBhcmVudC5jaGlsZC5wcm9wXCIsIFwic29tZSB2YWx1ZVwiLCBvYmopO1xuXG5cdFx0XHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KFwiLlwiKSwgcCA9IHBhcnRzLnBvcCgpLCBvYmogPSBnZXRQcm9wKHBhcnRzLCB0cnVlLCBjb250ZXh0KTtcblx0XHRcdHJldHVybiBvYmogJiYgcCA/IChvYmpbcF0gPSB2YWx1ZSkgOiB1bmRlZmluZWQ7IC8vIE9iamVjdFxuXHRcdH0sXG5cblx0XHRnZXRPYmplY3Q6IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZSwgY29udGV4dCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0R2V0IGEgcHJvcGVydHkgZnJvbSBhIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLCBzdWNoIGFzIFwiQS5CLkNcIlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRVc2VmdWwgZm9yIGxvbmdlciBhcGkgY2hhaW5zIHdoZXJlIHlvdSBoYXZlIHRvIHRlc3QgZWFjaCBvYmplY3QgaW5cblx0XHRcdC8vXHRcdHRoZSBjaGFpbiwgb3Igd2hlbiB5b3UgaGF2ZSBhbiBvYmplY3QgcmVmZXJlbmNlIGluIHN0cmluZyBmb3JtYXQuXG5cdFx0XHQvLyBuYW1lOiBTdHJpbmdcblx0XHRcdC8vXHRcdFBhdGggdG8gYW4gcHJvcGVydHksIGluIHRoZSBmb3JtIFwiQS5CLkNcIi5cblx0XHRcdC8vIGNyZWF0ZTogQm9vbGVhbj9cblx0XHRcdC8vXHRcdE9wdGlvbmFsLiBEZWZhdWx0cyB0byBgZmFsc2VgLiBJZiBgdHJ1ZWAsIE9iamVjdHMgd2lsbCBiZVxuXHRcdFx0Ly9cdFx0Y3JlYXRlZCBhdCBhbnkgcG9pbnQgYWxvbmcgdGhlICdwYXRoJyB0aGF0IGlzIHVuZGVmaW5lZC5cblx0XHRcdC8vIGNvbnRleHQ6IE9iamVjdD9cblx0XHRcdC8vXHRcdE9wdGlvbmFsLiBPYmplY3QgdG8gdXNlIGFzIHJvb3Qgb2YgcGF0aC4gRGVmYXVsdHMgdG9cblx0XHRcdC8vXHRcdCdkb2pvLmdsb2JhbCcuIE51bGwgbWF5IGJlIHBhc3NlZC5cblx0XHRcdHJldHVybiAhbmFtZSA/IGNvbnRleHQgOiBnZXRQcm9wKG5hbWUuc3BsaXQoXCIuXCIpLCBjcmVhdGUsIGNvbnRleHQpOyAvLyBPYmplY3Rcblx0XHR9LFxuXG5cdFx0ZXhpc3RzOiBmdW5jdGlvbihuYW1lLCBvYmope1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdGRldGVybWluZSBpZiBhbiBvYmplY3Qgc3VwcG9ydHMgYSBnaXZlbiBtZXRob2Rcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0dXNlZnVsIGZvciBsb25nZXIgYXBpIGNoYWlucyB3aGVyZSB5b3UgaGF2ZSB0byB0ZXN0IGVhY2ggb2JqZWN0IGluXG5cdFx0XHQvL1x0XHR0aGUgY2hhaW4uIFVzZWZ1bCBmb3Igb2JqZWN0IGFuZCBtZXRob2QgZGV0ZWN0aW9uLlxuXHRcdFx0Ly8gbmFtZTogU3RyaW5nXG5cdFx0XHQvL1x0XHRQYXRoIHRvIGFuIG9iamVjdCwgaW4gdGhlIGZvcm0gXCJBLkIuQ1wiLlxuXHRcdFx0Ly8gb2JqOiBPYmplY3Q/XG5cdFx0XHQvL1x0XHRPYmplY3QgdG8gdXNlIGFzIHJvb3Qgb2YgcGF0aC4gRGVmYXVsdHMgdG9cblx0XHRcdC8vXHRcdCdkb2pvLmdsb2JhbCcuIE51bGwgbWF5IGJlIHBhc3NlZC5cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fCAvLyBkZWZpbmUgYW4gb2JqZWN0XG5cdFx0XHQvL1x0fCB2YXIgZm9vID0ge1xuXHRcdFx0Ly9cdHxcdFx0YmFyOiB7IH1cblx0XHRcdC8vXHR8IH07XG5cdFx0XHQvL1x0fFxuXHRcdFx0Ly9cdHwgLy8gc2VhcmNoIHRoZSBnbG9iYWwgc2NvcGVcblx0XHRcdC8vXHR8IGxhbmcuZXhpc3RzKFwiZm9vLmJhclwiKTsgLy8gdHJ1ZVxuXHRcdFx0Ly9cdHwgbGFuZy5leGlzdHMoXCJmb28uYmFyLmJhelwiKTsgLy8gZmFsc2Vcblx0XHRcdC8vXHR8XG5cdFx0XHQvL1x0fCAvLyBzZWFyY2ggZnJvbSBhIHBhcnRpY3VsYXIgc2NvcGVcblx0XHRcdC8vXHR8IGxhbmcuZXhpc3RzKFwiYmFyXCIsIGZvbyk7IC8vIHRydWVcblx0XHRcdC8vXHR8IGxhbmcuZXhpc3RzKFwiYmFyLmJhelwiLCBmb28pOyAvLyBmYWxzZVxuXHRcdFx0cmV0dXJuIGxhbmcuZ2V0T2JqZWN0KG5hbWUsIGZhbHNlLCBvYmopICE9PSB1bmRlZmluZWQ7IC8vIEJvb2xlYW5cblx0XHR9LFxuXG5cdFx0Ly8gQ3JvY2tmb3JkIChpc2gpIGZ1bmN0aW9uc1xuXG5cdFx0aXNTdHJpbmc6IGZ1bmN0aW9uKGl0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm4gdHJ1ZSBpZiBpdCBpcyBhIFN0cmluZ1xuXHRcdFx0Ly8gaXQ6IGFueXRoaW5nXG5cdFx0XHQvL1x0XHRJdGVtIHRvIHRlc3QuXG5cdFx0XHRyZXR1cm4gKHR5cGVvZiBpdCA9PSBcInN0cmluZ1wiIHx8IGl0IGluc3RhbmNlb2YgU3RyaW5nKTsgLy8gQm9vbGVhblxuXHRcdH0sXG5cblx0XHRpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGl0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm4gdHJ1ZSBpZiBpdCBpcyBhbiBBcnJheS5cblx0XHRcdC8vIGl0OiBhbnl0aGluZ1xuXHRcdFx0Ly9cdFx0SXRlbSB0byB0ZXN0LlxuXHRcdFx0cmV0dXJuIG9wdHMuY2FsbChpdCkgPT0gXCJbb2JqZWN0IEFycmF5XVwiOyAvLyBCb29sZWFuXG5cdFx0fSxcblxuXHRcdGlzRnVuY3Rpb246IGZ1bmN0aW9uKGl0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm4gdHJ1ZSBpZiBpdCBpcyBhIEZ1bmN0aW9uXG5cdFx0XHQvLyBpdDogYW55dGhpbmdcblx0XHRcdC8vXHRcdEl0ZW0gdG8gdGVzdC5cblx0XHRcdHJldHVybiBvcHRzLmNhbGwoaXQpID09PSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG5cdFx0fSxcblxuXHRcdGlzT2JqZWN0OiBmdW5jdGlvbihpdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0cnVlIGlmIGl0IGlzIGEgSmF2YVNjcmlwdCBvYmplY3QgKG9yIGFuIEFycmF5LCBhIEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRvciBudWxsKVxuXHRcdFx0Ly8gaXQ6IGFueXRoaW5nXG5cdFx0XHQvL1x0XHRJdGVtIHRvIHRlc3QuXG5cdFx0XHRyZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHQoaXQgPT09IG51bGwgfHwgdHlwZW9mIGl0ID09IFwib2JqZWN0XCIgfHwgbGFuZy5pc0FycmF5KGl0KSB8fCBsYW5nLmlzRnVuY3Rpb24oaXQpKTsgLy8gQm9vbGVhblxuXHRcdH0sXG5cblx0XHRpc0FycmF5TGlrZTogZnVuY3Rpb24oaXQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdHNpbWlsYXIgdG8gaXNBcnJheSgpIGJ1dCBtb3JlIHBlcm1pc3NpdmVcblx0XHRcdC8vIGl0OiBhbnl0aGluZ1xuXHRcdFx0Ly9cdFx0SXRlbSB0byB0ZXN0LlxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdElmIGl0IHdhbGtzIGxpa2UgYSBkdWNrIGFuZCBxdWFja3MgbGlrZSBhIGR1Y2ssIHJldHVybiBgdHJ1ZWBcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0RG9lc24ndCBzdHJvbmdseSB0ZXN0IGZvciBcImFycmF5bmVzc1wiLiAgSW5zdGVhZCwgc2V0dGxlcyBmb3IgXCJpc24ndFxuXHRcdFx0Ly9cdFx0YSBzdHJpbmcgb3IgbnVtYmVyIGFuZCBoYXMgYSBsZW5ndGggcHJvcGVydHlcIi4gQXJndW1lbnRzIG9iamVjdHNcblx0XHRcdC8vXHRcdGFuZCBET00gY29sbGVjdGlvbnMgd2lsbCByZXR1cm4gdHJ1ZSB3aGVuIHBhc3NlZCB0b1xuXHRcdFx0Ly9cdFx0aXNBcnJheUxpa2UoKSwgYnV0IHdpbGwgcmV0dXJuIGZhbHNlIHdoZW4gcGFzc2VkIHRvXG5cdFx0XHQvL1x0XHRpc0FycmF5KCkuXG5cdFx0XHRyZXR1cm4gISFpdCAmJiAvLyBCb29sZWFuXG5cdFx0XHRcdC8vIGtlZXAgb3V0IGJ1aWx0LWluIGNvbnN0cnVjdG9ycyAoTnVtYmVyLCBTdHJpbmcsIC4uLikgd2hpY2ggaGF2ZSBsZW5ndGhcblx0XHRcdFx0Ly8gcHJvcGVydGllc1xuXHRcdFx0XHQhbGFuZy5pc1N0cmluZyhpdCkgJiYgIWxhbmcuaXNGdW5jdGlvbihpdCkgJiZcblx0XHRcdFx0IShpdC50YWdOYW1lICYmIGl0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSAnZm9ybScpICYmXG5cdFx0XHRcdChsYW5nLmlzQXJyYXkoaXQpIHx8IGlzRmluaXRlKGl0Lmxlbmd0aCkpO1xuXHRcdH0sXG5cblx0XHRpc0FsaWVuOiBmdW5jdGlvbihpdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0cnVlIGlmIGl0IGlzIGEgYnVpbHQtaW4gZnVuY3Rpb24gb3Igc29tZSBvdGhlciBraW5kIG9mXG5cdFx0XHQvL1x0XHRvZGRiYWxsIHRoYXQgKnNob3VsZCogcmVwb3J0IGFzIGEgZnVuY3Rpb24gYnV0IGRvZXNuJ3Rcblx0XHRcdHJldHVybiBpdCAmJiAhbGFuZy5pc0Z1bmN0aW9uKGl0KSAmJiAvXFx7XFxzKlxcW25hdGl2ZSBjb2RlXFxdXFxzKlxcfS8udGVzdChTdHJpbmcoaXQpKTsgLy8gQm9vbGVhblxuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uKGN0b3IsIHByb3BzKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBZGRzIGFsbCBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIHByb3BzIHRvIGNvbnN0cnVjdG9yJ3Ncblx0XHRcdC8vXHRcdHByb3RvdHlwZSwgbWFraW5nIHRoZW0gYXZhaWxhYmxlIHRvIGFsbCBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoXG5cdFx0XHQvL1x0XHRjb25zdHJ1Y3Rvci5cblx0XHRcdC8vIGN0b3I6IE9iamVjdFxuXHRcdFx0Ly9cdFx0VGFyZ2V0IGNvbnN0cnVjdG9yIHRvIGV4dGVuZC5cblx0XHRcdC8vIHByb3BzOiBPYmplY3Rcblx0XHRcdC8vXHRcdE9uZSBvciBtb3JlIG9iamVjdHMgdG8gbWl4IGludG8gY3Rvci5wcm90b3R5cGVcblx0XHRcdGZvcih2YXIgaT0xLCBsPWFyZ3VtZW50cy5sZW5ndGg7IGk8bDsgaSsrKXtcblx0XHRcdFx0bGFuZy5fbWl4aW4oY3Rvci5wcm90b3R5cGUsIGFyZ3VtZW50c1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3RvcjsgLy8gT2JqZWN0XG5cdFx0fSxcblxuXHRcdF9oaXRjaEFyZ3M6IGZ1bmN0aW9uKHNjb3BlLCBtZXRob2Qpe1xuXHRcdFx0dmFyIHByZSA9IGxhbmcuX3RvQXJyYXkoYXJndW1lbnRzLCAyKTtcblx0XHRcdHZhciBuYW1lZCA9IGxhbmcuaXNTdHJpbmcobWV0aG9kKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0XHQvLyBhcnJheWlmeSBhcmd1bWVudHNcblx0XHRcdFx0dmFyIGFyZ3MgPSBsYW5nLl90b0FycmF5KGFyZ3VtZW50cyk7XG5cdFx0XHRcdC8vIGxvY2F0ZSBvdXIgbWV0aG9kXG5cdFx0XHRcdHZhciBmID0gbmFtZWQgPyAoc2NvcGV8fGRvam8uZ2xvYmFsKVttZXRob2RdIDogbWV0aG9kO1xuXHRcdFx0XHQvLyBpbnZva2Ugd2l0aCBjb2xsZWN0ZWQgYXJnc1xuXHRcdFx0XHRyZXR1cm4gZiAmJiBmLmFwcGx5KHNjb3BlIHx8IHRoaXMsIHByZS5jb25jYXQoYXJncykpOyAvLyBtaXhlZFxuXHRcdFx0fTsgLy8gRnVuY3Rpb25cblx0XHR9LFxuXG5cdFx0aGl0Y2g6IGZ1bmN0aW9uKHNjb3BlLCBtZXRob2Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBldmVyIGV4ZWN1dGUgaW4gdGhlIGdpdmVuIHNjb3BlLlxuXHRcdFx0Ly9cdFx0VGhpcyBhbGxvd3MgZm9yIGVhc3kgdXNlIG9mIG9iamVjdCBtZW1iZXIgZnVuY3Rpb25zXG5cdFx0XHQvL1x0XHRpbiBjYWxsYmFja3MgYW5kIG90aGVyIHBsYWNlcyBpbiB3aGljaCB0aGUgXCJ0aGlzXCIga2V5d29yZCBtYXlcblx0XHRcdC8vXHRcdG90aGVyd2lzZSBub3QgcmVmZXJlbmNlIHRoZSBleHBlY3RlZCBzY29wZS5cblx0XHRcdC8vXHRcdEFueSBudW1iZXIgb2YgZGVmYXVsdCBwb3NpdGlvbmFsIGFyZ3VtZW50cyBtYXkgYmUgcGFzc2VkIGFzIHBhcmFtZXRlcnNcblx0XHRcdC8vXHRcdGJleW9uZCBcIm1ldGhvZFwiLlxuXHRcdFx0Ly9cdFx0RWFjaCBvZiB0aGVzZSB2YWx1ZXMgd2lsbCBiZSB1c2VkIHRvIFwicGxhY2Vob2xkXCIgKHNpbWlsYXIgdG8gY3VycnkpXG5cdFx0XHQvL1x0XHRmb3IgdGhlIGhpdGNoZWQgZnVuY3Rpb24uXG5cdFx0XHQvLyBzY29wZTogT2JqZWN0XG5cdFx0XHQvL1x0XHRUaGUgc2NvcGUgdG8gdXNlIHdoZW4gbWV0aG9kIGV4ZWN1dGVzLiBJZiBtZXRob2QgaXMgYSBzdHJpbmcsXG5cdFx0XHQvL1x0XHRzY29wZSBpcyBhbHNvIHRoZSBvYmplY3QgY29udGFpbmluZyBtZXRob2QuXG5cdFx0XHQvLyBtZXRob2Q6IEZ1bmN0aW9ufFN0cmluZy4uLlxuXHRcdFx0Ly9cdFx0QSBmdW5jdGlvbiB0byBiZSBoaXRjaGVkIHRvIHNjb3BlLCBvciB0aGUgbmFtZSBvZiB0aGUgbWV0aG9kIGluXG5cdFx0XHQvL1x0XHRzY29wZSB0byBiZSBoaXRjaGVkLlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHRsYW5nLmhpdGNoKGZvbywgXCJiYXJcIikoKTtcblx0XHRcdC8vXHRcdHJ1bnMgZm9vLmJhcigpIGluIHRoZSBzY29wZSBvZiBmb29cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0bGFuZy5oaXRjaChmb28sIG15RnVuY3Rpb24pO1xuXHRcdFx0Ly9cdFx0cmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcnVucyBteUZ1bmN0aW9uIGluIHRoZSBzY29wZSBvZiBmb29cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRFeHBhbnNpb24gb24gdGhlIGRlZmF1bHQgcG9zaXRpb25hbCBhcmd1bWVudHMgcGFzc2VkIGFsb25nIGZyb21cblx0XHRcdC8vXHRcdGhpdGNoLiBQYXNzZWQgYXJncyBhcmUgbWl4ZWQgZmlyc3QsIGFkZGl0aW9uYWwgYXJncyBhZnRlci5cblx0XHRcdC8vXHR8XHR2YXIgZm9vID0geyBiYXI6IGZ1bmN0aW9uKGEsIGIsIGMpeyBjb25zb2xlLmxvZyhhLCBiLCBjKTsgfSB9O1xuXHRcdFx0Ly9cdHxcdHZhciBmbiA9IGxhbmcuaGl0Y2goZm9vLCBcImJhclwiLCAxLCAyKTtcblx0XHRcdC8vXHR8XHRmbigzKTsgLy8gbG9ncyBcIjEsIDIsIDNcIlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHR2YXIgZm9vID0geyBiYXI6IDIgfTtcblx0XHRcdC8vXHR8XHRsYW5nLmhpdGNoKGZvbywgZnVuY3Rpb24oKXsgdGhpcy5iYXIgPSAxMDsgfSkoKTtcblx0XHRcdC8vXHRcdGV4ZWN1dGUgYW4gYW5vbnltb3VzIGZ1bmN0aW9uIGluIHNjb3BlIG9mIGZvb1xuXHRcdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA+IDIpe1xuXHRcdFx0XHRyZXR1cm4gbGFuZy5faGl0Y2hBcmdzLmFwcGx5KGRvam8sIGFyZ3VtZW50cyk7IC8vIEZ1bmN0aW9uXG5cdFx0XHR9XG5cdFx0XHRpZighbWV0aG9kKXtcblx0XHRcdFx0bWV0aG9kID0gc2NvcGU7XG5cdFx0XHRcdHNjb3BlID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmKGxhbmcuaXNTdHJpbmcobWV0aG9kKSl7XG5cdFx0XHRcdHNjb3BlID0gc2NvcGUgfHwgZG9qby5nbG9iYWw7XG5cdFx0XHRcdGlmKCFzY29wZVttZXRob2RdKXsgdGhyb3coWydsYW5nLmhpdGNoOiBzY29wZVtcIicsIG1ldGhvZCwgJ1wiXSBpcyBudWxsIChzY29wZT1cIicsIHNjb3BlLCAnXCIpJ10uam9pbignJykpOyB9XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gc2NvcGVbbWV0aG9kXS5hcHBseShzY29wZSwgYXJndW1lbnRzIHx8IFtdKTsgfTsgLy8gRnVuY3Rpb25cblx0XHRcdH1cblx0XHRcdHJldHVybiAhc2NvcGUgPyBtZXRob2QgOiBmdW5jdGlvbigpeyByZXR1cm4gbWV0aG9kLmFwcGx5KHNjb3BlLCBhcmd1bWVudHMgfHwgW10pOyB9OyAvLyBGdW5jdGlvblxuXHRcdH0sXG5cblx0XHRkZWxlZ2F0ZTogKGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBib29kbWFuL2Nyb2NrZm9yZCBkZWxlZ2F0aW9uIHcvIGNvcm5mb3JkIG9wdGltaXphdGlvblxuXHRcdFx0ZnVuY3Rpb24gVE1QKCl7fVxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG9iaiwgcHJvcHMpe1xuXHRcdFx0XHRUTVAucHJvdG90eXBlID0gb2JqO1xuXHRcdFx0XHR2YXIgdG1wID0gbmV3IFRNUCgpO1xuXHRcdFx0XHRUTVAucHJvdG90eXBlID0gbnVsbDtcblx0XHRcdFx0aWYocHJvcHMpe1xuXHRcdFx0XHRcdGxhbmcuX21peGluKHRtcCwgcHJvcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0bXA7IC8vIE9iamVjdFxuXHRcdFx0fTtcblx0XHR9KSgpLFxuXHRcdC8qPT09PT1cblx0XHRkZWxlZ2F0ZTogZnVuY3Rpb24ob2JqLCBwcm9wcyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIG5ldyBvYmplY3Qgd2hpY2ggXCJsb29rc1wiIHRvIG9iaiBmb3IgcHJvcGVydGllcyB3aGljaCBpdFxuXHRcdFx0Ly9cdFx0ZG9lcyBub3QgaGF2ZSBhIHZhbHVlIGZvci4gT3B0aW9uYWxseSB0YWtlcyBhIGJhZyBvZiBwcm9wZXJ0aWVzIHRvXG5cdFx0XHQvL1x0XHRzZWVkIHRoZSByZXR1cm5lZCBvYmplY3Qgd2l0aCBpbml0aWFsbHkuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoaXMgaXMgYSBzbWFsbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQm9vZG1hbi9Dcm9ja2ZvcmQgZGVsZWdhdGlvblxuXHRcdFx0Ly9cdFx0cGF0dGVybiBpbiBKYXZhU2NyaXB0LiBBbiBpbnRlcm1lZGlhdGUgb2JqZWN0IGNvbnN0cnVjdG9yIG1lZGlhdGVzXG5cdFx0XHQvL1x0XHR0aGUgcHJvdG90eXBlIGNoYWluIGZvciB0aGUgcmV0dXJuZWQgb2JqZWN0LCB1c2luZyBpdCB0byBkZWxlZ2F0ZVxuXHRcdFx0Ly9cdFx0ZG93biB0byBvYmogZm9yIHByb3BlcnR5IGxvb2t1cCB3aGVuIG9iamVjdC1sb2NhbCBsb29rdXAgZmFpbHMuXG5cdFx0XHQvL1x0XHRUaGlzIGNhbiBiZSB0aG91Z2h0IG9mIHNpbWlsYXJseSB0byBFUzQncyBcIndyYXBcIiwgc2F2ZSB0aGF0IGl0IGRvZXNcblx0XHRcdC8vXHRcdG5vdCBhY3Qgb24gdHlwZXMgYnV0IHJhdGhlciBvbiBwdXJlIG9iamVjdHMuXG5cdFx0XHQvLyBvYmo6IE9iamVjdFxuXHRcdFx0Ly9cdFx0VGhlIG9iamVjdCB0byBkZWxlZ2F0ZSB0byBmb3IgcHJvcGVydGllcyBub3QgZm91bmQgZGlyZWN0bHkgb24gdGhlXG5cdFx0XHQvL1x0XHRyZXR1cm4gb2JqZWN0IG9yIGluIHByb3BzLlxuXHRcdFx0Ly8gcHJvcHM6IE9iamVjdC4uLlxuXHRcdFx0Ly9cdFx0YW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIHJldHVybmVkIG9iamVjdFxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdGFuIE9iamVjdCBvZiBhbm9ueW1vdXMgdHlwZVxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHR2YXIgZm9vID0geyBiYXI6IFwiYmF6XCIgfTtcblx0XHRcdC8vXHR8XHR2YXIgdGhpbmdlciA9IGxhbmcuZGVsZWdhdGUoZm9vLCB7IHRodWQ6IFwieHl6enlcIn0pO1xuXHRcdFx0Ly9cdHxcdHRoaW5nZXIuYmFyID09IFwiYmF6XCI7IC8vIGRlbGVnYXRlZCB0byBmb29cblx0XHRcdC8vXHR8XHRmb28udGh1ZCA9PSB1bmRlZmluZWQ7IC8vIGJ5IGRlZmluaXRpb25cblx0XHRcdC8vXHR8XHR0aGluZ2VyLnRodWQgPT0gXCJ4eXp6eVwiOyAvLyBtaXhlZCBpbiBmcm9tIHByb3BzXG5cdFx0XHQvL1x0fFx0Zm9vLmJhciA9IFwidGhvbmtcIjtcblx0XHRcdC8vXHR8XHR0aGluZ2VyLmJhciA9PSBcInRob25rXCI7IC8vIHN0aWxsIGRlbGVnYXRlZCB0byBmb28ncyBiYXJcblx0XHR9LFxuXHRcdD09PT09Ki9cblxuXHRcdF90b0FycmF5OiBoYXMoXCJpZVwiKSA/XG5cdFx0XHQoZnVuY3Rpb24oKXtcblx0XHRcdFx0ZnVuY3Rpb24gc2xvdyhvYmosIG9mZnNldCwgc3RhcnRXaXRoKXtcblx0XHRcdFx0XHR2YXIgYXJyID0gc3RhcnRXaXRofHxbXTtcblx0XHRcdFx0XHRmb3IodmFyIHggPSBvZmZzZXQgfHwgMDsgeCA8IG9iai5sZW5ndGg7IHgrKyl7XG5cdFx0XHRcdFx0XHRhcnIucHVzaChvYmpbeF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gYXJyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihvYmope1xuXHRcdFx0XHRcdHJldHVybiAoKG9iai5pdGVtKSA/IHNsb3cgOiBlZmZpY2llbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KSgpIDogZWZmaWNpZW50LFxuXHRcdC8qPT09PT1cblx0XHQgX3RvQXJyYXk6IGZ1bmN0aW9uKG9iaiwgb2Zmc2V0LCBzdGFydFdpdGgpe1xuXHRcdFx0IC8vIHN1bW1hcnk6XG5cdFx0XHQgLy9cdFx0Q29udmVydHMgYW4gYXJyYXktbGlrZSBvYmplY3QgKGkuZS4gYXJndW1lbnRzLCBET01Db2xsZWN0aW9uKSB0byBhblxuXHRcdFx0IC8vXHRcdGFycmF5LiBSZXR1cm5zIGEgbmV3IEFycmF5IHdpdGggdGhlIGVsZW1lbnRzIG9mIG9iai5cblx0XHRcdCAvLyBvYmo6IE9iamVjdFxuXHRcdFx0IC8vXHRcdHRoZSBvYmplY3QgdG8gXCJhcnJheWlmeVwiLiBXZSBleHBlY3QgdGhlIG9iamVjdCB0byBoYXZlLCBhdCBhXG5cdFx0XHQgLy9cdFx0bWluaW11bSwgYSBsZW5ndGggcHJvcGVydHkgd2hpY2ggY29ycmVzcG9uZHMgdG8gaW50ZWdlci1pbmRleGVkXG5cdFx0XHQgLy9cdFx0cHJvcGVydGllcy5cblx0XHRcdCAvLyBvZmZzZXQ6IE51bWJlcj9cblx0XHRcdCAvL1x0XHR0aGUgbG9jYXRpb24gaW4gb2JqIHRvIHN0YXJ0IGl0ZXJhdGluZyBmcm9tLiBEZWZhdWx0cyB0byAwLlxuXHRcdFx0IC8vXHRcdE9wdGlvbmFsLlxuXHRcdFx0IC8vIHN0YXJ0V2l0aDogQXJyYXk/XG5cdFx0XHQgLy9cdFx0QW4gYXJyYXkgdG8gcGFjayB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iai4gSWYgcHJvdmlkZWQsXG5cdFx0XHQgLy9cdFx0cHJvcGVydGllcyBpbiBvYmogYXJlIGFwcGVuZGVkIGF0IHRoZSBlbmQgb2Ygc3RhcnRXaXRoIGFuZFxuXHRcdFx0IC8vXHRcdHN0YXJ0V2l0aCBpcyB0aGUgcmV0dXJuZWQgYXJyYXkuXG5cdFx0IH0sXG5cdFx0ID09PT09Ki9cblxuXHRcdHBhcnRpYWw6IGZ1bmN0aW9uKC8qRnVuY3Rpb258U3RyaW5nKi8gbWV0aG9kIC8qLCAuLi4qLyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0c2ltaWxhciB0byBoaXRjaCgpIGV4Y2VwdCB0aGF0IHRoZSBzY29wZSBvYmplY3QgaXMgbGVmdCB0byBiZVxuXHRcdFx0Ly9cdFx0d2hhdGV2ZXIgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IGV2ZW50dWFsbHkgYmVjb21lcy5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0Q2FsbGluZyBsYW5nLnBhcnRpYWwgaXMgdGhlIGZ1bmN0aW9uYWwgZXF1aXZhbGVudCBvZiBjYWxsaW5nOlxuXHRcdFx0Ly9cdFx0fFx0bGFuZy5oaXRjaChudWxsLCBmdW5jTmFtZSwgLi4uKTtcblx0XHRcdC8vIG1ldGhvZDpcblx0XHRcdC8vXHRcdFRoZSBmdW5jdGlvbiB0byBcIndyYXBcIlxuXHRcdFx0dmFyIGFyciA9IFsgbnVsbCBdO1xuXHRcdFx0cmV0dXJuIGxhbmcuaGl0Y2guYXBwbHkoZG9qbywgYXJyLmNvbmNhdChsYW5nLl90b0FycmF5KGFyZ3VtZW50cykpKTsgLy8gRnVuY3Rpb25cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uKC8qYW55dGhpbmcqLyBzcmMpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENsb25lcyBvYmplY3RzIChpbmNsdWRpbmcgRE9NIG5vZGVzKSBhbmQgYWxsIGNoaWxkcmVuLlxuXHRcdFx0Ly9cdFx0V2FybmluZzogZG8gbm90IGNsb25lIGN5Y2xpYyBzdHJ1Y3R1cmVzLlxuXHRcdFx0Ly8gc3JjOlxuXHRcdFx0Ly9cdFx0VGhlIG9iamVjdCB0byBjbG9uZVxuXHRcdFx0aWYoIXNyYyB8fCB0eXBlb2Ygc3JjICE9IFwib2JqZWN0XCIgfHwgbGFuZy5pc0Z1bmN0aW9uKHNyYykpe1xuXHRcdFx0XHQvLyBudWxsLCB1bmRlZmluZWQsIGFueSBub24tb2JqZWN0LCBvciBmdW5jdGlvblxuXHRcdFx0XHRyZXR1cm4gc3JjO1x0Ly8gYW55dGhpbmdcblx0XHRcdH1cblx0XHRcdGlmKHNyYy5ub2RlVHlwZSAmJiBcImNsb25lTm9kZVwiIGluIHNyYyl7XG5cdFx0XHRcdC8vIERPTSBOb2RlXG5cdFx0XHRcdHJldHVybiBzcmMuY2xvbmVOb2RlKHRydWUpOyAvLyBOb2RlXG5cdFx0XHR9XG5cdFx0XHRpZihzcmMgaW5zdGFuY2VvZiBEYXRlKXtcblx0XHRcdFx0Ly8gRGF0ZVxuXHRcdFx0XHRyZXR1cm4gbmV3IERhdGUoc3JjLmdldFRpbWUoKSk7XHQvLyBEYXRlXG5cdFx0XHR9XG5cdFx0XHRpZihzcmMgaW5zdGFuY2VvZiBSZWdFeHApe1xuXHRcdFx0XHQvLyBSZWdFeHBcblx0XHRcdFx0cmV0dXJuIG5ldyBSZWdFeHAoc3JjKTsgICAvLyBSZWdFeHBcblx0XHRcdH1cblx0XHRcdHZhciByLCBpLCBsO1xuXHRcdFx0aWYobGFuZy5pc0FycmF5KHNyYykpe1xuXHRcdFx0XHQvLyBhcnJheVxuXHRcdFx0XHRyID0gW107XG5cdFx0XHRcdGZvcihpID0gMCwgbCA9IHNyYy5sZW5ndGg7IGkgPCBsOyArK2kpe1xuXHRcdFx0XHRcdGlmKGkgaW4gc3JjKXtcblx0XHRcdFx0XHRcdHJbaV0gPSBsYW5nLmNsb25lKHNyY1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHdlIGRvbid0IGNsb25lIGZ1bmN0aW9ucyBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuXHRcdFx0XHQvL1x0XHR9ZWxzZSBpZihkLmlzRnVuY3Rpb24oc3JjKSl7XG5cdFx0XHRcdC8vXHRcdFx0Ly8gZnVuY3Rpb25cblx0XHRcdFx0Ly9cdFx0XHRyID0gZnVuY3Rpb24oKXsgcmV0dXJuIHNyYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIGdlbmVyaWMgb2JqZWN0c1xuXHRcdFx0XHRyID0gc3JjLmNvbnN0cnVjdG9yID8gbmV3IHNyYy5jb25zdHJ1Y3RvcigpIDoge307XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbGFuZy5fbWl4aW4ociwgc3JjLCBsYW5nLmNsb25lKTtcblx0XHR9LFxuXG5cblx0XHR0cmltOiBTdHJpbmcucHJvdG90eXBlLnRyaW0gP1xuXHRcdFx0ZnVuY3Rpb24oc3RyKXsgcmV0dXJuIHN0ci50cmltKCk7IH0gOlxuXHRcdFx0ZnVuY3Rpb24oc3RyKXsgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzXFxzKi8sICcnKS5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTsgfSxcblx0XHQvKj09PT09XG5cdFx0IHRyaW06IGZ1bmN0aW9uKHN0cil7XG5cdFx0XHQgLy8gc3VtbWFyeTpcblx0XHRcdCAvL1x0XHRUcmltcyB3aGl0ZXNwYWNlIGZyb20gYm90aCBzaWRlcyBvZiB0aGUgc3RyaW5nXG5cdFx0XHQgLy8gc3RyOiBTdHJpbmdcblx0XHRcdCAvL1x0XHRTdHJpbmcgdG8gYmUgdHJpbW1lZFxuXHRcdFx0IC8vIHJldHVybnM6IFN0cmluZ1xuXHRcdFx0IC8vXHRcdFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nXG5cdFx0XHQgLy8gZGVzY3JpcHRpb246XG5cdFx0XHQgLy9cdFx0VGhpcyB2ZXJzaW9uIG9mIHRyaW0oKSB3YXMgc2VsZWN0ZWQgZm9yIGluY2x1c2lvbiBpbnRvIHRoZSBiYXNlIGR1ZVxuXHRcdFx0IC8vXHRcdHRvIGl0cyBjb21wYWN0IHNpemUgYW5kIHJlbGF0aXZlbHkgZ29vZCBwZXJmb3JtYW5jZVxuXHRcdFx0IC8vXHRcdChzZWUgW1N0ZXZlbiBMZXZpdGhhbidzIGJsb2ddKGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9mYXN0ZXItdHJpbS1qYXZhc2NyaXB0KVxuXHRcdFx0IC8vXHRcdFVzZXMgU3RyaW5nLnByb3RvdHlwZS50cmltIGluc3RlYWQsIGlmIGF2YWlsYWJsZS5cblx0XHRcdCAvL1x0XHRUaGUgZmFzdGVzdCBidXQgbG9uZ2VzdCB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb24gaXMgbG9jYXRlZCBhdFxuXHRcdFx0IC8vXHRcdGxhbmcuc3RyaW5nLnRyaW0oKVxuXHRcdCB9LFxuXHRcdCA9PT09PSovXG5cblx0XHRyZXBsYWNlOiBmdW5jdGlvbih0bXBsLCBtYXAsIHBhdHRlcm4pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFBlcmZvcm1zIHBhcmFtZXRlcml6ZWQgc3Vic3RpdHV0aW9ucyBvbiBhIHN0cmluZy4gVGhyb3dzIGFuXG5cdFx0XHQvL1x0XHRleGNlcHRpb24gaWYgYW55IHBhcmFtZXRlciBpcyB1bm1hdGNoZWQuXG5cdFx0XHQvLyB0bXBsOiBTdHJpbmdcblx0XHRcdC8vXHRcdFN0cmluZyB0byBiZSB1c2VkIGFzIGEgdGVtcGxhdGUuXG5cdFx0XHQvLyBtYXA6IE9iamVjdHxGdW5jdGlvblxuXHRcdFx0Ly9cdFx0SWYgYW4gb2JqZWN0LCBpdCBpcyB1c2VkIGFzIGEgZGljdGlvbmFyeSB0byBsb29rIHVwIHN1YnN0aXR1dGlvbnMuXG5cdFx0XHQvL1x0XHRJZiBhIGZ1bmN0aW9uLCBpdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHN1YnN0aXR1dGlvbiB3aXRoIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuXHRcdFx0Ly9cdFx0YSB3aG9sZSBtYXRjaCwgYSBuYW1lLCBhbiBvZmZzZXQsIGFuZCB0aGUgd2hvbGUgdGVtcGxhdGVcblx0XHRcdC8vXHRcdHN0cmluZyAoc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBsYWNlXG5cdFx0XHQvL1x0XHRmb3IgbW9yZSBkZXRhaWxzKS5cblx0XHRcdC8vIHBhdHRlcm46IFJlZ0V4P1xuXHRcdFx0Ly9cdFx0T3B0aW9uYWwgcmVndWxhciBleHByZXNzaW9uIG9iamVjdHMgdGhhdCBvdmVycmlkZXMgdGhlIGRlZmF1bHQgcGF0dGVybi5cblx0XHRcdC8vXHRcdE11c3QgYmUgZ2xvYmFsIGFuZCBtYXRjaCBvbmUgaXRlbS4gVGhlIGRlZmF1bHQgaXM6IC9cXHsoW15cXH1dKylcXH0vZyxcblx0XHRcdC8vXHRcdHdoaWNoIG1hdGNoZXMgcGF0dGVybnMgbGlrZSB0aGF0OiBcInt4eHh9XCIsIHdoZXJlIFwieHh4XCIgaXMgYW55IHNlcXVlbmNlXG5cdFx0XHQvL1x0XHRvZiBjaGFyYWN0ZXJzLCB3aGljaCBkb2Vzbid0IGluY2x1ZGUgXCJ9XCIuXG5cdFx0XHQvLyByZXR1cm5zOiBTdHJpbmdcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIHN1YnN0aXR1dGVkIHN0cmluZy5cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0Ly8gdXNlcyBhIGRpY3Rpb25hcnkgZm9yIHN1YnN0aXR1dGlvbnM6XG5cdFx0XHQvL1x0fFx0bGFuZy5yZXBsYWNlKFwiSGVsbG8sIHtuYW1lLmZpcnN0fSB7bmFtZS5sYXN0fSBBS0Ege25pY2t9IVwiLFxuXHRcdFx0Ly9cdHxcdFx0e1xuXHRcdFx0Ly9cdHxcdFx0XHRuaWNrOiBcIkJvYlwiLFxuXHRcdFx0Ly9cdHxcdFx0XHRuYW1lOiB7XG5cdFx0XHQvL1x0fFx0XHRcdFx0Zmlyc3Q6XHRcIlJvYmVydFwiLFxuXHRcdFx0Ly9cdHxcdFx0XHRcdG1pZGRsZTogXCJYXCIsXG5cdFx0XHQvL1x0fFx0XHRcdFx0bGFzdDpcdFx0XCJDcmluZ2VseVwiXG5cdFx0XHQvL1x0fFx0XHRcdH1cblx0XHRcdC8vXHR8XHRcdH0pO1xuXHRcdFx0Ly9cdHxcdC8vIHJldHVybnM6IEhlbGxvLCBSb2JlcnQgQ3JpbmdlbHkgQUtBIEJvYiFcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0Ly8gdXNlcyBhbiBhcnJheSBmb3Igc3Vic3RpdHV0aW9uczpcblx0XHRcdC8vXHR8XHRsYW5nLnJlcGxhY2UoXCJIZWxsbywgezB9IHsyfSFcIixcblx0XHRcdC8vXHR8XHRcdFtcIlJvYmVydFwiLCBcIlhcIiwgXCJDcmluZ2VseVwiXSk7XG5cdFx0XHQvL1x0fFx0Ly8gcmV0dXJuczogSGVsbG8sIFJvYmVydCBDcmluZ2VseSFcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0Ly8gdXNlcyBhIGZ1bmN0aW9uIGZvciBzdWJzdGl0dXRpb25zOlxuXHRcdFx0Ly9cdHxcdGZ1bmN0aW9uIHN1bShhKXtcblx0XHRcdC8vXHR8XHRcdHZhciB0ID0gMDtcblx0XHRcdC8vXHR8XHRcdGFycmF5Zm9yRWFjaChhLCBmdW5jdGlvbih4KXsgdCArPSB4OyB9KTtcblx0XHRcdC8vXHR8XHRcdHJldHVybiB0O1xuXHRcdFx0Ly9cdHxcdH1cblx0XHRcdC8vXHR8XHRsYW5nLnJlcGxhY2UoXG5cdFx0XHQvL1x0fFx0XHRcIntjb3VudH0gcGF5bWVudHMgYXZlcmFnaW5nIHthdmd9IFVTRCBwZXIgcGF5bWVudC5cIixcblx0XHRcdC8vXHR8XHRcdGxhbmcuaGl0Y2goXG5cdFx0XHQvL1x0fFx0XHRcdHsgcGF5bWVudHM6IFsxMSwgMTYsIDEyXSB9LFxuXHRcdFx0Ly9cdHxcdFx0XHRmdW5jdGlvbihfLCBrZXkpe1xuXHRcdFx0Ly9cdHxcdFx0XHRcdHN3aXRjaChrZXkpe1xuXHRcdFx0Ly9cdHxcdFx0XHRcdFx0Y2FzZSBcImNvdW50XCI6IHJldHVybiB0aGlzLnBheW1lbnRzLmxlbmd0aDtcblx0XHRcdC8vXHR8XHRcdFx0XHRcdGNhc2UgXCJtaW5cIjpcdFx0cmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIHRoaXMucGF5bWVudHMpO1xuXHRcdFx0Ly9cdHxcdFx0XHRcdFx0Y2FzZSBcIm1heFwiOlx0XHRyZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgdGhpcy5wYXltZW50cyk7XG5cdFx0XHQvL1x0fFx0XHRcdFx0XHRjYXNlIFwic3VtXCI6XHRcdHJldHVybiBzdW0odGhpcy5wYXltZW50cyk7XG5cdFx0XHQvL1x0fFx0XHRcdFx0XHRjYXNlIFwiYXZnXCI6XHRcdHJldHVybiBzdW0odGhpcy5wYXltZW50cykgLyB0aGlzLnBheW1lbnRzLmxlbmd0aDtcblx0XHRcdC8vXHR8XHRcdFx0XHR9XG5cdFx0XHQvL1x0fFx0XHRcdH1cblx0XHRcdC8vXHR8XHRcdClcblx0XHRcdC8vXHR8XHQpO1xuXHRcdFx0Ly9cdHxcdC8vIHByaW50czogMyBwYXltZW50cyBhdmVyYWdpbmcgMTMgVVNEIHBlciBwYXltZW50LlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHQvLyB1c2VzIGFuIGFsdGVybmF0aXZlIFBIUC1saWtlIHBhdHRlcm4gZm9yIHN1YnN0aXR1dGlvbnM6XG5cdFx0XHQvL1x0fFx0bGFuZy5yZXBsYWNlKFwiSGVsbG8sICR7MH0gJHsyfSFcIixcblx0XHRcdC8vXHR8XHRcdFtcIlJvYmVydFwiLCBcIlhcIiwgXCJDcmluZ2VseVwiXSwgL1xcJFxceyhbXlxcfV0rKVxcfS9nKTtcblx0XHRcdC8vXHR8XHQvLyByZXR1cm5zOiBIZWxsbywgUm9iZXJ0IENyaW5nZWx5IVxuXG5cdFx0XHRyZXR1cm4gdG1wbC5yZXBsYWNlKHBhdHRlcm4gfHwgX3BhdHRlcm4sIGxhbmcuaXNGdW5jdGlvbihtYXApID9cblx0XHRcdFx0bWFwIDogZnVuY3Rpb24oXywgayl7IHJldHVybiBsYW5nLmdldE9iamVjdChrLCBmYWxzZSwgbWFwKTsgfSk7XG5cdFx0fVxuXHR9O1xuXG5cdGhhcyhcImV4dGVuZC1kb2pvXCIpICYmIGxhbmcubWl4aW4oZG9qbywgbGFuZyk7XG5cblx0cmV0dXJuIGxhbmc7XG59KTtcbiIsImRlZmluZShbXCIuL2tlcm5lbFwiLCBcIi4vbGFuZ1wiLCBcIi4uL3NuaWZmXCJdLCBmdW5jdGlvbihkb2pvLCBsYW5nLCBoYXMpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vX2Jhc2Uvc25pZmZcblxuXHQvKj09PT09XG5cdHJldHVybiB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHREZXByZWNhdGVkLiAgIE5ldyBjb2RlIHNob3VsZCB1c2UgZG9qby9zbmlmZi5cblx0XHQvL1x0XHRUaGlzIG1vZHVsZSBwb3B1bGF0ZXMgdGhlIGRvam8gYnJvd3NlciB2ZXJzaW9uIHNuaWZmaW5nIHByb3BlcnRpZXMgbGlrZSBkb2pvLmlzSUUuXG5cdH07XG5cdD09PT09Ki9cblxuXHRpZighaGFzKFwiaG9zdC1icm93c2VyXCIpKXtcblx0XHRyZXR1cm4gaGFzO1xuXHR9XG5cblx0Ly8gbm8gaWRlYSB3aGF0IHRoaXMgaXMgZm9yLCBvciBpZiBpdCdzIHVzZWRcblx0ZG9qby5fbmFtZSA9IFwiYnJvd3NlclwiO1xuXG5cdGxhbmcubWl4aW4oZG9qbywge1xuXHRcdC8vIGlzQnJvd3NlcjogQm9vbGVhblxuXHRcdC8vXHRcdFRydWUgaWYgdGhlIGNsaWVudCBpcyBhIHdlYi1icm93c2VyXG5cdFx0aXNCcm93c2VyOiB0cnVlLFxuXG5cdFx0Ly8gaXNGRjogTnVtYmVyfHVuZGVmaW5lZFxuXHRcdC8vXHRcdFZlcnNpb24gYXMgYSBOdW1iZXIgaWYgY2xpZW50IGlzIEZpcmVGb3guIHVuZGVmaW5lZCBvdGhlcndpc2UuIENvcnJlc3BvbmRzIHRvXG5cdFx0Ly9cdFx0bWFqb3IgZGV0ZWN0ZWQgRmlyZUZveCB2ZXJzaW9uICgxLjUsIDIsIDMsIGV0Yy4pXG5cdFx0aXNGRjogaGFzKFwiZmZcIiksXG5cblx0XHQvLyBpc0lFOiBOdW1iZXJ8dW5kZWZpbmVkXG5cdFx0Ly9cdFx0VmVyc2lvbiBhcyBhIE51bWJlciBpZiBjbGllbnQgaXMgTVNJRShQQykuIHVuZGVmaW5lZCBvdGhlcndpc2UuIENvcnJlc3BvbmRzIHRvXG5cdFx0Ly9cdFx0bWFqb3IgZGV0ZWN0ZWQgSUUgdmVyc2lvbiAoNiwgNywgOCwgZXRjLilcblx0XHRpc0lFOiBoYXMoXCJpZVwiKSxcblxuXHRcdC8vIGlzS2h0bWw6IE51bWJlcnx1bmRlZmluZWRcblx0XHQvL1x0XHRWZXJzaW9uIGFzIGEgTnVtYmVyIGlmIGNsaWVudCBpcyBhIEtIVE1MIGJyb3dzZXIuIHVuZGVmaW5lZCBvdGhlcndpc2UuIENvcnJlc3BvbmRzIHRvIG1ham9yXG5cdFx0Ly9cdFx0ZGV0ZWN0ZWQgdmVyc2lvbi5cblx0XHRpc0todG1sOiBoYXMoXCJraHRtbFwiKSxcblxuXHRcdC8vIGlzV2ViS2l0OiBOdW1iZXJ8dW5kZWZpbmVkXG5cdFx0Ly9cdFx0VmVyc2lvbiBhcyBhIE51bWJlciBpZiBjbGllbnQgaXMgYSBXZWJLaXQtZGVyaXZlZCBicm93c2VyIChLb25xdWVyb3IsXG5cdFx0Ly9cdFx0U2FmYXJpLCBDaHJvbWUsIGV0Yy4pLiB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuXHRcdGlzV2ViS2l0OiBoYXMoXCJ3ZWJraXRcIiksXG5cblx0XHQvLyBpc01vemlsbGE6IE51bWJlcnx1bmRlZmluZWRcblx0XHQvL1x0XHRWZXJzaW9uIGFzIGEgTnVtYmVyIGlmIGNsaWVudCBpcyBhIE1vemlsbGEtYmFzZWQgYnJvd3NlciAoRmlyZWZveCxcblx0XHQvL1x0XHRTZWFNb25rZXkpLiB1bmRlZmluZWQgb3RoZXJ3aXNlLiBDb3JyZXNwb25kcyB0byBtYWpvciBkZXRlY3RlZCB2ZXJzaW9uLlxuXHRcdGlzTW96aWxsYTogaGFzKFwibW96aWxsYVwiKSxcblx0XHQvLyBpc01vejogTnVtYmVyfHVuZGVmaW5lZFxuXHRcdC8vXHRcdFZlcnNpb24gYXMgYSBOdW1iZXIgaWYgY2xpZW50IGlzIGEgTW96aWxsYS1iYXNlZCBicm93c2VyIChGaXJlZm94LFxuXHRcdC8vXHRcdFNlYU1vbmtleSkuIHVuZGVmaW5lZCBvdGhlcndpc2UuIENvcnJlc3BvbmRzIHRvIG1ham9yIGRldGVjdGVkIHZlcnNpb24uXG5cdFx0aXNNb3o6IGhhcyhcIm1vemlsbGFcIiksXG5cblx0XHQvLyBpc09wZXJhOiBOdW1iZXJ8dW5kZWZpbmVkXG5cdFx0Ly9cdFx0VmVyc2lvbiBhcyBhIE51bWJlciBpZiBjbGllbnQgaXMgT3BlcmEuIHVuZGVmaW5lZCBvdGhlcndpc2UuIENvcnJlc3BvbmRzIHRvXG5cdFx0Ly9cdFx0bWFqb3IgZGV0ZWN0ZWQgdmVyc2lvbi5cblx0XHRpc09wZXJhOiBoYXMoXCJvcGVyYVwiKSxcblxuXHRcdC8vIGlzU2FmYXJpOiBOdW1iZXJ8dW5kZWZpbmVkXG5cdFx0Ly9cdFx0VmVyc2lvbiBhcyBhIE51bWJlciBpZiBjbGllbnQgaXMgU2FmYXJpIG9yIGlQaG9uZS4gdW5kZWZpbmVkIG90aGVyd2lzZS5cblx0XHRpc1NhZmFyaTogaGFzKFwic2FmYXJpXCIpLFxuXG5cdFx0Ly8gaXNDaHJvbWU6IE51bWJlcnx1bmRlZmluZWRcblx0XHQvL1x0XHRWZXJzaW9uIGFzIGEgTnVtYmVyIGlmIGNsaWVudCBpcyBDaHJvbWUgYnJvd3Nlci4gdW5kZWZpbmVkIG90aGVyd2lzZS5cblx0XHRpc0Nocm9tZTogaGFzKFwiY2hyb21lXCIpLFxuXG5cdFx0Ly8gaXNNYWM6IEJvb2xlYW5cblx0XHQvL1x0XHRUcnVlIGlmIHRoZSBjbGllbnQgcnVucyBvbiBNYWNcblx0XHRpc01hYzogaGFzKFwibWFjXCIpLFxuXG5cdFx0Ly8gaXNJb3M6IE51bWJlcnx1bmRlZmluZWRcblx0XHQvL1x0XHRWZXJzaW9uIGFzIGEgTnVtYmVyIGlmIGNsaWVudCBpcyBpUGhvbmUsIGlQb2QsIG9yIGlQYWQuIHVuZGVmaW5lZCBvdGhlcndpc2UuXG5cdFx0aXNJb3M6IGhhcyhcImlvc1wiKSxcblxuXHRcdC8vIGlzQW5kcm9pZDogTnVtYmVyfHVuZGVmaW5lZFxuXHRcdC8vXHRcdFZlcnNpb24gYXMgYSBOdW1iZXIgaWYgY2xpZW50IGlzIGFuZHJvaWQgYnJvd3Nlci4gdW5kZWZpbmVkIG90aGVyd2lzZS5cblx0XHRpc0FuZHJvaWQ6IGhhcyhcImFuZHJvaWRcIiksXG5cblx0XHQvLyBpc1dpaTogQm9vbGVhblxuXHRcdC8vXHRcdFRydWUgaWYgY2xpZW50IGlzIFdpaVxuXHRcdGlzV2lpOiBoYXMoXCJ3aWlcIiksXG5cblx0XHQvLyBpc1F1aXJrczogQm9vbGVhblxuXHRcdC8vXHRcdFBhZ2UgaXMgaW4gcXVpcmtzIG1vZGUuXG5cdFx0aXNRdWlya3M6IGhhcyhcInF1aXJrc1wiKSxcblxuXHRcdC8vIGlzQWlyOiBCb29sZWFuXG5cdFx0Ly9cdFx0VHJ1ZSBpZiBjbGllbnQgaXMgQWRvYmUgQWlyXG5cdFx0aXNBaXI6IGhhcyhcImFpclwiKVxuXHR9KTtcblxuXHRyZXR1cm4gaGFzO1xufSk7XG4iLCJkZWZpbmUoW1wiLi9rZXJuZWxcIiwgXCIuL2xhbmdcIiwgXCIuLi9zbmlmZlwiXSwgZnVuY3Rpb24oZG9qbywgbGFuZywgaGFzKXtcbi8vIG1vZHVsZTpcbi8vXHRcdGRvam8vX2Jhc2Uvd2luZG93XG5cbnZhciByZXQgPSB7XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdEFQSSB0byBzYXZlL3NldC9yZXN0b3JlIHRoZSBnbG9iYWwvZG9jdW1lbnQgc2NvcGUuXG5cblx0Z2xvYmFsOiBkb2pvLmdsb2JhbCxcblx0Lyo9PT09PVxuXHQgZ2xvYmFsOiB7XG5cdFx0IC8vIHN1bW1hcnk6XG5cdFx0IC8vXHRcdEFsaWFzIGZvciB0aGUgY3VycmVudCB3aW5kb3cuICdnbG9iYWwnIGNhbiBiZSBtb2RpZmllZFxuXHRcdCAvL1x0XHRmb3IgdGVtcG9yYXJ5IGNvbnRleHQgc2hpZnRpbmcuIFNlZSBhbHNvIHdpdGhHbG9iYWwoKS5cblx0XHQgLy8gZGVzY3JpcHRpb246XG5cdFx0IC8vXHRcdFVzZSB0aGlzIHJhdGhlciB0aGFuIHJlZmVycmluZyB0byAnd2luZG93JyB0byBlbnN1cmUgeW91ciBjb2RlIHJ1bnNcblx0XHQgLy9cdFx0Y29ycmVjdGx5IGluIG1hbmFnZWQgY29udGV4dHMuXG5cdCB9LFxuXHQgPT09PT0qL1xuXG5cdGRvYzogZG9qby5nbG9iYWxbXCJkb2N1bWVudFwiXSB8fCBudWxsLFxuXHQvKj09PT09XG5cdGRvYzoge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0QWxpYXMgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50LiAnZG9jJyBjYW4gYmUgbW9kaWZpZWRcblx0XHQvL1x0XHRmb3IgdGVtcG9yYXJ5IGNvbnRleHQgc2hpZnRpbmcuIFNlZSBhbHNvIHdpdGhEb2MoKS5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRVc2UgdGhpcyByYXRoZXIgdGhhbiByZWZlcnJpbmcgdG8gJ3dpbmRvdy5kb2N1bWVudCcgdG8gZW5zdXJlIHlvdXIgY29kZSBydW5zXG5cdFx0Ly9cdFx0Y29ycmVjdGx5IGluIG1hbmFnZWQgY29udGV4dHMuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0bi5hcHBlbmRDaGlsZChkb2pvLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG5cdH0sXG5cdD09PT09Ki9cblxuXHRib2R5OiBmdW5jdGlvbigvKkRvY3VtZW50PyovIGRvYyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRSZXR1cm4gdGhlIGJvZHkgZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIGRvY3VtZW50IG9yIG9mIGRvam8vX2Jhc2Uvd2luZG93Ojpkb2MuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0d2luLmJvZHkoKS5hcHBlbmRDaGlsZChkb2pvLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG5cblx0XHQvLyBOb3RlOiBkb2N1bWVudC5ib2R5IGlzIG5vdCBkZWZpbmVkIGZvciBhIHN0cmljdCB4aHRtbCBkb2N1bWVudFxuXHRcdC8vIFdvdWxkIGxpa2UgdG8gbWVtb2l6ZSB0aGlzLCBidXQgZG9qby5kb2MgY2FuIGNoYW5nZSB2aSBkb2pvLndpdGhEb2MoKS5cblx0XHRkb2MgPSBkb2MgfHwgZG9qby5kb2M7XG5cdFx0cmV0dXJuIGRvYy5ib2R5IHx8IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJvZHlcIilbMF07IC8vIE5vZGVcblx0fSxcblxuXHRzZXRDb250ZXh0OiBmdW5jdGlvbigvKk9iamVjdCovIGdsb2JhbE9iamVjdCwgLypEb2N1bWVudEVsZW1lbnQqLyBnbG9iYWxEb2N1bWVudCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRjaGFuZ2VzIHRoZSBiZWhhdmlvciBvZiBtYW55IGNvcmUgRG9qbyBmdW5jdGlvbnMgdGhhdCBkZWFsIHdpdGhcblx0XHQvL1x0XHRuYW1lc3BhY2UgYW5kIERPTSBsb29rdXAsIGNoYW5naW5nIHRoZW0gdG8gd29yayBpbiBhIG5ldyBnbG9iYWxcblx0XHQvL1x0XHRjb250ZXh0IChlLmcuLCBhbiBpZnJhbWUpLiBUaGUgdmFyaWJsZXMgZG9qby5nbG9iYWwgYW5kIGRvam8uZG9jXG5cdFx0Ly9cdFx0YXJlIG1vZGlmaWVkIGFzIGEgcmVzdWx0IG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBhbmQgdGhlIHJlc3VsdCBvZlxuXHRcdC8vXHRcdGBkb2pvLmJvZHkoKWAgbGlrZXdpc2UgZGlmZmVycy5cblx0XHRkb2pvLmdsb2JhbCA9IHJldC5nbG9iYWwgPSBnbG9iYWxPYmplY3Q7XG5cdFx0ZG9qby5kb2MgPSByZXQuZG9jID0gZ2xvYmFsRG9jdW1lbnQ7XG5cdH0sXG5cblx0d2l0aEdsb2JhbDogZnVuY3Rpb24oXHQvKk9iamVjdCovIGdsb2JhbE9iamVjdCxcblx0XHRcdFx0XHRcdFx0LypGdW5jdGlvbiovIGNhbGxiYWNrLFxuXHRcdFx0XHRcdFx0XHQvKk9iamVjdD8qLyB0aGlzT2JqZWN0LFxuXHRcdFx0XHRcdFx0XHQvKkFycmF5PyovIGNiQXJndW1lbnRzKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEludm9rZSBjYWxsYmFjayB3aXRoIGdsb2JhbE9iamVjdCBhcyBkb2pvLmdsb2JhbCBhbmRcblx0XHQvL1x0XHRnbG9iYWxPYmplY3QuZG9jdW1lbnQgYXMgZG9qby5kb2MuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0SW52b2tlIGNhbGxiYWNrIHdpdGggZ2xvYmFsT2JqZWN0IGFzIGRvam8uZ2xvYmFsIGFuZFxuXHRcdC8vXHRcdGdsb2JhbE9iamVjdC5kb2N1bWVudCBhcyBkb2pvLmRvYy4gSWYgcHJvdmlkZWQsIGdsb2JhbE9iamVjdFxuXHRcdC8vXHRcdHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIGNvbnRleHQgb2Ygb2JqZWN0IHRoaXNPYmplY3Rcblx0XHQvL1x0XHRXaGVuIGNhbGxiYWNrKCkgcmV0dXJucyBvciB0aHJvd3MgYW4gZXJyb3IsIHRoZSBkb2pvLmdsb2JhbFxuXHRcdC8vXHRcdGFuZCBkb2pvLmRvYyB3aWxsIGJlIHJlc3RvcmVkIHRvIGl0cyBwcmV2aW91cyBzdGF0ZS5cblxuXHRcdHZhciBvbGRHbG9iID0gZG9qby5nbG9iYWw7XG5cdFx0dHJ5e1xuXHRcdFx0ZG9qby5nbG9iYWwgPSByZXQuZ2xvYmFsID0gZ2xvYmFsT2JqZWN0O1xuXHRcdFx0cmV0dXJuIHJldC53aXRoRG9jLmNhbGwobnVsbCwgZ2xvYmFsT2JqZWN0LmRvY3VtZW50LCBjYWxsYmFjaywgdGhpc09iamVjdCwgY2JBcmd1bWVudHMpO1xuXHRcdH1maW5hbGx5e1xuXHRcdFx0ZG9qby5nbG9iYWwgPSByZXQuZ2xvYmFsID0gb2xkR2xvYjtcblx0XHR9XG5cdH0sXG5cblx0d2l0aERvYzogZnVuY3Rpb24oXHQvKkRvY3VtZW50RWxlbWVudCovIGRvY3VtZW50T2JqZWN0LFxuXHRcdFx0XHRcdFx0LypGdW5jdGlvbiovIGNhbGxiYWNrLFxuXHRcdFx0XHRcdFx0LypPYmplY3Q/Ki8gdGhpc09iamVjdCxcblx0XHRcdFx0XHRcdC8qQXJyYXk/Ki8gY2JBcmd1bWVudHMpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0SW52b2tlIGNhbGxiYWNrIHdpdGggZG9jdW1lbnRPYmplY3QgYXMgZG9qby9fYmFzZS93aW5kb3c6OmRvYy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRJbnZva2UgY2FsbGJhY2sgd2l0aCBkb2N1bWVudE9iamVjdCBhcyBkb2pvL19iYXNlL3dpbmRvdzo6ZG9jLiBJZiBwcm92aWRlZCxcblx0XHQvL1x0XHRjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBjb250ZXh0IG9mIG9iamVjdCB0aGlzT2JqZWN0XG5cdFx0Ly9cdFx0V2hlbiBjYWxsYmFjaygpIHJldHVybnMgb3IgdGhyb3dzIGFuIGVycm9yLCB0aGUgZG9qby9fYmFzZS93aW5kb3c6OmRvYyB3aWxsXG5cdFx0Ly9cdFx0YmUgcmVzdG9yZWQgdG8gaXRzIHByZXZpb3VzIHN0YXRlLlxuXG5cdFx0dmFyIG9sZERvYyA9IHJldC5kb2MsXG5cdFx0XHRvbGRRID0gaGFzKFwicXVpcmtzXCIpLFxuXHRcdFx0b2xkSUUgPSBoYXMoXCJpZVwiKSwgaXNJRSwgbW9kZSwgcHdpbjtcblxuXHRcdHRyeXtcblx0XHRcdGRvam8uZG9jID0gcmV0LmRvYyA9IGRvY3VtZW50T2JqZWN0O1xuXHRcdFx0Ly8gdXBkYXRlIGRvam8uaXNRdWlya3MgYW5kIHRoZSB2YWx1ZSBvZiB0aGUgaGFzIGZlYXR1cmUgXCJxdWlya3NcIi5cblx0XHRcdC8vIHJlbW92ZSBzZXR0aW5nIGRvam8uaXNRdWlya3MgYW5kIGRvam8uaXNJRSBmb3IgMi4wXG5cdFx0XHRkb2pvLmlzUXVpcmtzID0gaGFzLmFkZChcInF1aXJrc1wiLCBkb2pvLmRvYy5jb21wYXRNb2RlID09IFwiQmFja0NvbXBhdFwiLCB0cnVlLCB0cnVlKTsgLy8gbm8gbmVlZCB0byBjaGVjayBmb3IgUXVpcmtzTW9kZSB3aGljaCB3YXMgT3BlcmEgNyBvbmx5XG5cblx0XHRcdGlmKGhhcyhcImllXCIpKXtcblx0XHRcdFx0aWYoKHB3aW4gPSBkb2N1bWVudE9iamVjdC5wYXJlbnRXaW5kb3cpICYmIHB3aW4ubmF2aWdhdG9yKXtcblx0XHRcdFx0XHQvLyByZS1ydW4gSUUgZGV0ZWN0aW9uIGxvZ2ljIGFuZCB1cGRhdGUgZG9qby5pc0lFIC8gaGFzKFwiaWVcIilcblx0XHRcdFx0XHQvLyAodGhlIG9ubHkgdGltZSBwYXJlbnRXaW5kb3cvbmF2aWdhdG9yIHdvdWxkbid0IGV4aXN0IGlzIGlmIHdlIHdlcmUgbm90XG5cdFx0XHRcdFx0Ly8gcGFzc2VkIGFuIGFjdHVhbCBsZWdpdGltYXRlIGRvY3VtZW50IG9iamVjdClcblx0XHRcdFx0XHRpc0lFID0gcGFyc2VGbG9hdChwd2luLm5hdmlnYXRvci5hcHBWZXJzaW9uLnNwbGl0KFwiTVNJRSBcIilbMV0pIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRtb2RlID0gZG9jdW1lbnRPYmplY3QuZG9jdW1lbnRNb2RlO1xuXHRcdFx0XHRcdGlmKG1vZGUgJiYgbW9kZSAhPSA1ICYmIE1hdGguZmxvb3IoaXNJRSkgIT0gbW9kZSl7XG5cdFx0XHRcdFx0XHRpc0lFID0gbW9kZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9qby5pc0lFID0gaGFzLmFkZChcImllXCIsIGlzSUUsIHRydWUsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXNPYmplY3QgJiYgdHlwZW9mIGNhbGxiYWNrID09IFwic3RyaW5nXCIpe1xuXHRcdFx0XHRjYWxsYmFjayA9IHRoaXNPYmplY3RbY2FsbGJhY2tdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc09iamVjdCwgY2JBcmd1bWVudHMgfHwgW10pO1xuXHRcdH1maW5hbGx5e1xuXHRcdFx0ZG9qby5kb2MgPSByZXQuZG9jID0gb2xkRG9jO1xuXHRcdFx0ZG9qby5pc1F1aXJrcyA9IGhhcy5hZGQoXCJxdWlya3NcIiwgb2xkUSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRkb2pvLmlzSUUgPSBoYXMuYWRkKFwiaWVcIiwgb2xkSUUsIHRydWUsIHRydWUpO1xuXHRcdH1cblx0fVxufTtcblxuaGFzKFwiZXh0ZW5kLWRvam9cIikgJiYgbGFuZy5taXhpbihkb2pvLCByZXQpO1xuXG5yZXR1cm4gcmV0O1xuXG59KTtcbiIsImRlZmluZShbXG5cdFwiLi9rZXJuZWxcIixcblx0XCIuL3NuaWZmXCIsXG5cdFwicmVxdWlyZVwiLFxuXHRcIi4uL2lvLXF1ZXJ5XCIsXG5cdC8qPT09PT0gXCIuL2RlY2xhcmVcIiwgPT09PT0qL1xuXHRcIi4uL2RvbVwiLFxuXHRcIi4uL2RvbS1mb3JtXCIsXG5cdFwiLi9EZWZlcnJlZFwiLFxuXHRcIi4vY29uZmlnXCIsXG5cdFwiLi9qc29uXCIsXG5cdFwiLi9sYW5nXCIsXG5cdFwiLi9hcnJheVwiLFxuXHRcIi4uL29uXCIsXG5cdFwiLi4vYXNwZWN0XCIsXG5cdFwiLi4vcmVxdWVzdC93YXRjaFwiLFxuXHRcIi4uL3JlcXVlc3QveGhyXCIsXG5cdFwiLi4vcmVxdWVzdC91dGlsXCJcbl0sIGZ1bmN0aW9uKGRvam8sIGhhcywgcmVxdWlyZSwgaW9xLCAvKj09PT09IGRlY2xhcmUsID09PT09Ki8gZG9tLCBkb21Gb3JtLCBEZWZlcnJlZCwgY29uZmlnLCBqc29uLCBsYW5nLCBhcnJheSwgb24sIGFzcGVjdCwgd2F0Y2gsIF94aHIsIHV0aWwpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vX2Jhc2UveGhyXG5cblx0Lyo9PT09PVxuXHRkb2pvLl94aHJPYmogPSBmdW5jdGlvbigpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0ZG9lcyB0aGUgd29yayBvZiBwb3J0YWJseSBnZW5lcmF0aW5nIGEgbmV3IFhNTEhUVFBSZXF1ZXN0IG9iamVjdC5cblx0fTtcblx0PT09PT0qL1xuXHRkb2pvLl94aHJPYmogPSBfeGhyLl9jcmVhdGU7XG5cblx0dmFyIGNmZyA9IGRvam8uY29uZmlnO1xuXG5cdC8vIG1peCBpbiBpby1xdWVyeSBhbmQgZG9tLWZvcm1cblx0ZG9qby5vYmplY3RUb1F1ZXJ5ID0gaW9xLm9iamVjdFRvUXVlcnk7XG5cdGRvam8ucXVlcnlUb09iamVjdCA9IGlvcS5xdWVyeVRvT2JqZWN0O1xuXHRkb2pvLmZpZWxkVG9PYmplY3QgPSBkb21Gb3JtLmZpZWxkVG9PYmplY3Q7XG5cdGRvam8uZm9ybVRvT2JqZWN0ID0gZG9tRm9ybS50b09iamVjdDtcblx0ZG9qby5mb3JtVG9RdWVyeSA9IGRvbUZvcm0udG9RdWVyeTtcblx0ZG9qby5mb3JtVG9Kc29uID0gZG9tRm9ybS50b0pzb247XG5cblx0Ly8gbmVlZCB0byBibG9jayBhc3luYyBjYWxsYmFja3MgZnJvbSBzbmF0Y2hpbmcgdGhpcyB0aHJlYWQgYXMgdGhlIHJlc3VsdFxuXHQvLyBvZiBhbiBhc3luYyBjYWxsYmFjayBtaWdodCBjYWxsIGFub3RoZXIgc3luYyBYSFIsIHRoaXMgaGFuZ3Mga2h0bWwgZm9yZXZlclxuXHQvLyBtdXN0IGNoZWNrZWQgYnkgd2F0Y2hJbkZsaWdodCgpXG5cblx0ZG9qby5fYmxvY2tBc3luYyA9IGZhbHNlO1xuXG5cdC8vIE1PVzogcmVtb3ZlIGRvam8uX2NvbnRlbnRIYW5kbGVycyBhbGlhcyBpbiAyLjBcblx0dmFyIGhhbmRsZXJzID0gZG9qby5fY29udGVudEhhbmRsZXJzID0gZG9qby5jb250ZW50SGFuZGxlcnMgPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRBIG1hcCBvZiBhdmFpbGFibGUgWEhSIHRyYW5zcG9ydCBoYW5kbGUgdHlwZXMuIE5hbWUgbWF0Y2hlcyB0aGVcblx0XHQvL1x0XHRgaGFuZGxlQXNgIGF0dHJpYnV0ZSBwYXNzZWQgdG8gWEhSIGNhbGxzLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEEgbWFwIG9mIGF2YWlsYWJsZSBYSFIgdHJhbnNwb3J0IGhhbmRsZSB0eXBlcy4gTmFtZSBtYXRjaGVzIHRoZVxuXHRcdC8vXHRcdGBoYW5kbGVBc2AgYXR0cmlidXRlIHBhc3NlZCB0byBYSFIgY2FsbHMuIEVhY2ggY29udGVudEhhbmRsZXIgaXNcblx0XHQvL1x0XHRjYWxsZWQsIHBhc3NpbmcgdGhlIHhociBvYmplY3QgZm9yIG1hbmlwdWxhdGlvbi4gVGhlIHJldHVybiB2YWx1ZVxuXHRcdC8vXHRcdGZyb20gdGhlIGNvbnRlbnRIYW5kbGVyIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBgbG9hZGAgb3IgYGhhbmRsZWBcblx0XHQvL1x0XHRmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGUgb3JpZ2luYWwgeGhyIGNhbGwuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRDcmVhdGluZyBhIGN1c3RvbSBjb250ZW50LWhhbmRsZXI6XG5cdFx0Ly9cdHxcdHhoci5jb250ZW50SGFuZGxlcnMubWFrZUNhcHMgPSBmdW5jdGlvbih4aHIpe1xuXHRcdC8vXHR8XHRcdHJldHVybiB4aHIucmVzcG9uc2VUZXh0LnRvVXBwZXJDYXNlKCk7XG5cdFx0Ly9cdHxcdH1cblx0XHQvL1x0fFx0Ly8gYW5kIGxhdGVyOlxuXHRcdC8vXHR8XHRkb2pvLnhockdldCh7XG5cdFx0Ly9cdHxcdFx0dXJsOlwiZm9vLnR4dFwiLFxuXHRcdC8vXHR8XHRcdGhhbmRsZUFzOlwibWFrZUNhcHNcIixcblx0XHQvL1x0fFx0XHRsb2FkOiBmdW5jdGlvbihkYXRhKXsgLyogZGF0YSBpcyBhIHRvVXBwZXIgdmVyc2lvbiBvZiBmb28udHh0ICovIH1cblx0XHQvL1x0fFx0fSk7XG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oeGhyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBIGNvbnRlbnRIYW5kbGVyIHdoaWNoIHNpbXBseSByZXR1cm5zIHRoZSBwbGFpbnRleHQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0cmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XG5cdFx0fSxcblx0XHRcImpzb25cIjogZnVuY3Rpb24oeGhyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBIGNvbnRlbnRIYW5kbGVyIHdoaWNoIHJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCBjcmVhdGVkIGZyb20gdGhlIHJlc3BvbnNlIGRhdGFcblx0XHRcdHJldHVybiBqc29uLmZyb21Kc29uKHhoci5yZXNwb25zZVRleHQgfHwgbnVsbCk7XG5cdFx0fSxcblx0XHRcImpzb24tY29tbWVudC1maWx0ZXJlZFwiOiBmdW5jdGlvbih4aHIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEEgY29udGVudEhhbmRsZXIgd2hpY2ggZXhwZWN0cyBjb21tZW50LWZpbHRlcmVkIEpTT04uXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEEgY29udGVudEhhbmRsZXIgd2hpY2ggZXhwZWN0cyBjb21tZW50LWZpbHRlcmVkIEpTT04uXG5cdFx0XHQvL1x0XHR0aGUganNvbi1jb21tZW50LWZpbHRlcmVkIG9wdGlvbiB3YXMgaW1wbGVtZW50ZWQgdG8gcHJldmVudFxuXHRcdFx0Ly9cdFx0XCJKYXZhU2NyaXB0IEhpamFja2luZ1wiLCBidXQgaXQgaXMgbGVzcyBzZWN1cmUgdGhhbiBzdGFuZGFyZCBKU09OLiBVc2Vcblx0XHRcdC8vXHRcdHN0YW5kYXJkIEpTT04gaW5zdGVhZC4gSlNPTiBwcmVmaXhpbmcgY2FuIGJlIHVzZWQgdG8gc3VidmVydCBoaWphY2tpbmcuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0V2lsbCB0aHJvdyBhIG5vdGljZSBzdWdnZXN0aW5nIHRvIHVzZSBhcHBsaWNhdGlvbi9qc29uIG1pbWV0eXBlLCBhc1xuXHRcdFx0Ly9cdFx0anNvbi1jb21tZW50aW5nIGNhbiBpbnRyb2R1Y2Ugc2VjdXJpdHkgaXNzdWVzLiBUbyBkZWNyZWFzZSB0aGUgY2hhbmNlcyBvZiBoaWphY2tpbmcsXG5cdFx0XHQvL1x0XHR1c2UgdGhlIHN0YW5kYXJkIGBqc29uYCBjb250ZW50SGFuZGxlciwgYW5kIHByZWZpeCB5b3VyIFwiSlNPTlwiIHdpdGg6IHt9JiZcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHR1c2UgZGpDb25maWcudXNlQ29tbWVudGVkSnNvbiA9IHRydWUgdG8gdHVybiBvZmYgdGhlIG5vdGljZVxuXHRcdFx0aWYoIWNvbmZpZy51c2VDb21tZW50ZWRKc29uKXtcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiQ29uc2lkZXIgdXNpbmcgdGhlIHN0YW5kYXJkIG1pbWV0eXBlOmFwcGxpY2F0aW9uL2pzb24uXCJcblx0XHRcdFx0XHQrIFwiIGpzb24tY29tbWVudGluZyBjYW4gaW50cm9kdWNlIHNlY3VyaXR5IGlzc3Vlcy4gVG9cIlxuXHRcdFx0XHRcdCsgXCIgZGVjcmVhc2UgdGhlIGNoYW5jZXMgb2YgaGlqYWNraW5nLCB1c2UgdGhlIHN0YW5kYXJkIHRoZSAnanNvbicgaGFuZGxlciBhbmRcIlxuXHRcdFx0XHRcdCsgXCIgcHJlZml4IHlvdXIganNvbiB3aXRoOiB7fSYmXFxuXCJcblx0XHRcdFx0XHQrIFwiVXNlIGRqQ29uZmlnLnVzZUNvbW1lbnRlZEpzb249dHJ1ZSB0byB0dXJuIG9mZiB0aGlzIG1lc3NhZ2UuXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdmFsdWUgPSB4aHIucmVzcG9uc2VUZXh0O1xuXHRcdFx0dmFyIGNTdGFydElkeCA9IHZhbHVlLmluZGV4T2YoXCJcXC8qXCIpO1xuXHRcdFx0dmFyIGNFbmRJZHggPSB2YWx1ZS5sYXN0SW5kZXhPZihcIipcXC9cIik7XG5cdFx0XHRpZihjU3RhcnRJZHggPT0gLTEgfHwgY0VuZElkeCA9PSAtMSl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkpTT04gd2FzIG5vdCBjb21tZW50IGZpbHRlcmVkXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGpzb24uZnJvbUpzb24odmFsdWUuc3Vic3RyaW5nKGNTdGFydElkeCsyLCBjRW5kSWR4KSk7XG5cdFx0fSxcblx0XHRcImphdmFzY3JpcHRcIjogZnVuY3Rpb24oeGhyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBIGNvbnRlbnRIYW5kbGVyIHdoaWNoIGV2YWx1YXRlcyB0aGUgcmVzcG9uc2UgZGF0YSwgZXhwZWN0aW5nIGl0IHRvIGJlIHZhbGlkIEphdmFTY3JpcHRcblxuXHRcdFx0Ly8gRklYTUU6IHRyeSBNb3ogYW5kIElFIHNwZWNpZmljIGV2YWwgdmFyaWFudHM/XG5cdFx0XHRyZXR1cm4gZG9qby5ldmFsKHhoci5yZXNwb25zZVRleHQpO1xuXHRcdH0sXG5cdFx0XCJ4bWxcIjogZnVuY3Rpb24oeGhyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBIGNvbnRlbnRIYW5kbGVyIHJldHVybmluZyBhbiBYTUwgRG9jdW1lbnQgcGFyc2VkIGZyb20gdGhlIHJlc3BvbnNlIGRhdGFcblx0XHRcdHZhciByZXN1bHQgPSB4aHIucmVzcG9uc2VYTUw7XG5cblx0XHRcdGlmKHJlc3VsdCAmJiBoYXMoXCJkb20tcXNhMi4xXCIpICYmICFyZXN1bHQucXVlcnlTZWxlY3RvckFsbCAmJiBoYXMoXCJkb20tcGFyc2VyXCIpKXtcblx0XHRcdFx0Ly8gaHR0cDovL2J1Z3MuZG9qb3Rvb2xraXQub3JnL3RpY2tldC8xNTYzMVxuXHRcdFx0XHQvLyBJRTkgc3VwcG9ydHMgYSBDU1MzIHF1ZXJ5U2VsZWN0b3JBbGwgaW1wbGVtZW50YXRpb24sIGJ1dCB0aGUgRE9NIGltcGxlbWVudGF0aW9uXG5cdFx0XHRcdC8vIHJldHVybmVkIGJ5IElFOSB4aHIucmVzcG9uc2VYTUwgZG9lcyBub3QuIE1hbnVhbGx5IGNyZWF0ZSB0aGUgWE1MIERPTSB0byBnYWluXG5cdFx0XHRcdC8vIHRoZSBmdWxsZXItZmVhdHVyZWQgaW1wbGVtZW50YXRpb24gYW5kIGF2b2lkIGJ1Z3MgY2F1c2VkIGJ5IHRoZSBpbmNvbnNpc3RlbmN5XG5cdFx0XHRcdHJlc3VsdCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCwgXCJhcHBsaWNhdGlvbi94bWxcIik7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGhhcyhcImllXCIpKXtcblx0XHRcdFx0aWYoKCFyZXN1bHQgfHwgIXJlc3VsdC5kb2N1bWVudEVsZW1lbnQpKXtcblx0XHRcdFx0XHQvL1dBUk5JTkc6IHRoaXMgYnJhbmNoIHVzZWQgYnkgdGhlIHhtbCBoYW5kbGluZyBpbiBkb2pvLmlvLmlmcmFtZSxcblx0XHRcdFx0XHQvL3NvIGJlIHN1cmUgdG8gdGVzdCBkb2pvLmlvLmlmcmFtZSBpZiBtYWtpbmcgY2hhbmdlcyBiZWxvdy5cblx0XHRcdFx0XHR2YXIgbXMgPSBmdW5jdGlvbihuKXsgcmV0dXJuIFwiTVNYTUxcIiArIG4gKyBcIi5ET01Eb2N1bWVudFwiOyB9O1xuXHRcdFx0XHRcdHZhciBkcCA9IFtcIk1pY3Jvc29mdC5YTUxET01cIiwgbXMoNiksIG1zKDQpLCBtcygzKSwgbXMoMildO1xuXHRcdFx0XHRcdGFycmF5LnNvbWUoZHAsIGZ1bmN0aW9uKHApe1xuXHRcdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0XHR2YXIgZG9tID0gbmV3IEFjdGl2ZVhPYmplY3QocCk7XG5cdFx0XHRcdFx0XHRcdGRvbS5hc3luYyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRkb20ubG9hZFhNTCh4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gZG9tO1xuXHRcdFx0XHRcdFx0fWNhdGNoKGUpeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0OyAvLyBET01Eb2N1bWVudFxuXHRcdH0sXG5cdFx0XCJqc29uLWNvbW1lbnQtb3B0aW9uYWxcIjogZnVuY3Rpb24oeGhyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBIGNvbnRlbnRIYW5kbGVyIHdoaWNoIGNoZWNrcyB0aGUgcHJlc2VuY2Ugb2YgY29tbWVudC1maWx0ZXJlZCBKU09OIGFuZFxuXHRcdFx0Ly9cdFx0YWx0ZXJuYXRlcyBiZXR3ZWVuIHRoZSBganNvbmAgYW5kIGBqc29uLWNvbW1lbnQtZmlsdGVyZWRgIGNvbnRlbnRIYW5kbGVycy5cblx0XHRcdGlmKHhoci5yZXNwb25zZVRleHQgJiYgL15bXntcXFtdKlxcL1xcKi8udGVzdCh4aHIucmVzcG9uc2VUZXh0KSl7XG5cdFx0XHRcdHJldHVybiBoYW5kbGVyc1tcImpzb24tY29tbWVudC1maWx0ZXJlZFwiXSh4aHIpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHJldHVybiBoYW5kbGVyc1tcImpzb25cIl0oeGhyKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Lyo9PT09PVxuXG5cdC8vIGt3YXJncyBmdW5jdGlvbiBwYXJhbWV0ZXIgZGVmaW5pdGlvbnMuICAgQXNzaWduaW5nIHRvIGRvam8gbmFtZXNwYWNlIHJhdGhlciB0aGFuIG1ha2luZyB0aGVtIGxvY2FsIHZhcmlhYmxlc1xuXHQvLyBiZWNhdXNlIHRoZXkgYXJlIHVzZWQgYnkgZG9qby9pbyBtb2R1bGVzIHRvb1xuXG5cdGRvam8uX19Jb0FyZ3MgPSBkZWNsYXJlKG51bGwsIHtcblx0XHQvLyB1cmw6IFN0cmluZ1xuXHRcdC8vXHRcdFVSTCB0byBzZXJ2ZXIgZW5kcG9pbnQuXG5cdFx0Ly8gY29udGVudDogT2JqZWN0P1xuXHRcdC8vXHRcdENvbnRhaW5zIHByb3BlcnRpZXMgd2l0aCBzdHJpbmcgdmFsdWVzLiBUaGVzZVxuXHRcdC8vXHRcdHByb3BlcnRpZXMgd2lsbCBiZSBzZXJpYWxpemVkIGFzIG5hbWUxPXZhbHVlMiBhbmRcblx0XHQvL1x0XHRwYXNzZWQgaW4gdGhlIHJlcXVlc3QuXG5cdFx0Ly8gdGltZW91dDogSW50ZWdlcj9cblx0XHQvL1x0XHRNaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIHJlc3BvbnNlLiBJZiB0aGlzIHRpbWVcblx0XHQvL1x0XHRwYXNzZXMsIHRoZSB0aGVuIGVycm9yIGNhbGxiYWNrcyBhcmUgY2FsbGVkLlxuXHRcdC8vIGZvcm06IERPTU5vZGU/XG5cdFx0Ly9cdFx0RE9NIG5vZGUgZm9yIGEgZm9ybS4gVXNlZCB0byBleHRyYWN0IHRoZSBmb3JtIHZhbHVlc1xuXHRcdC8vXHRcdGFuZCBzZW5kIHRvIHRoZSBzZXJ2ZXIuXG5cdFx0Ly8gcHJldmVudENhY2hlOiBCb29sZWFuP1xuXHRcdC8vXHRcdERlZmF1bHQgaXMgZmFsc2UuIElmIHRydWUsIHRoZW4gYVxuXHRcdC8vXHRcdFwiZG9qby5wcmV2ZW50Q2FjaGVcIiBwYXJhbWV0ZXIgaXMgc2VudCBpbiB0aGUgcmVxdWVzdFxuXHRcdC8vXHRcdHdpdGggYSB2YWx1ZSB0aGF0IGNoYW5nZXMgd2l0aCBlYWNoIHJlcXVlc3Rcblx0XHQvL1x0XHQodGltZXN0YW1wKS4gVXNlZnVsIG9ubHkgd2l0aCBHRVQtdHlwZSByZXF1ZXN0cy5cblx0XHQvLyBoYW5kbGVBczogU3RyaW5nP1xuXHRcdC8vXHRcdEFjY2VwdGFibGUgdmFsdWVzIGRlcGVuZCBvbiB0aGUgdHlwZSBvZiBJT1xuXHRcdC8vXHRcdHRyYW5zcG9ydCAoc2VlIHNwZWNpZmljIElPIGNhbGxzIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cblx0XHQvLyByYXdCb2R5OiBTdHJpbmc/XG5cdFx0Ly9cdFx0U2V0cyB0aGUgcmF3IGJvZHkgZm9yIGFuIEhUVFAgcmVxdWVzdC4gSWYgdGhpcyBpcyB1c2VkLCB0aGVuIHRoZSBjb250ZW50XG5cdFx0Ly9cdFx0cHJvcGVydHkgaXMgaWdub3JlZC4gVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvciBIVFRQIG1ldGhvZHMgdGhhdCBoYXZlXG5cdFx0Ly9cdFx0YSBib2R5IHRvIHRoZWlyIHJlcXVlc3RzLCBsaWtlIFBVVCBvciBQT1NULiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIGluc3RlYWRcblx0XHQvL1x0XHRvZiBwb3N0RGF0YSBhbmQgcHV0RGF0YSBmb3IgZG9qby9fYmFzZS94aHIucmF3WGhyUG9zdCBhbmQgZG9qby9fYmFzZS94aHIucmF3WGhyUHV0IHJlc3BlY3RpdmVseS5cblx0XHQvLyBpb1B1Ymxpc2g6IEJvb2xlYW4/XG5cdFx0Ly9cdFx0U2V0IHRoaXMgZXhwbGljaXRseSB0byBmYWxzZSB0byBwcmV2ZW50IHB1Ymxpc2hpbmcgb2YgdG9waWNzIHJlbGF0ZWQgdG9cblx0XHQvL1x0XHRJTyBvcGVyYXRpb25zLiBPdGhlcndpc2UsIGlmIGRqQ29uZmlnLmlvUHVibGlzaCBpcyBzZXQgdG8gdHJ1ZSwgdG9waWNzXG5cdFx0Ly9cdFx0d2lsbCBiZSBwdWJsaXNoZWQgdmlhIGRvam8vdG9waWMucHVibGlzaCgpIGZvciBkaWZmZXJlbnQgcGhhc2VzIG9mIGFuIElPIG9wZXJhdGlvbi5cblx0XHQvL1x0XHRTZWUgZG9qby9tYWluLl9fSW9QdWJsaXNoIGZvciBhIGxpc3Qgb2YgdG9waWNzIHRoYXQgYXJlIHB1Ymxpc2hlZC5cblxuXHRcdGxvYWQ6IGZ1bmN0aW9uKHJlc3BvbnNlLCBpb0FyZ3Mpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRoaXMgZnVuY3Rpb24gd2lsbCBiZVxuXHRcdFx0Ly9cdFx0Y2FsbGVkIG9uIGEgc3VjY2Vzc2Z1bCBIVFRQIHJlc3BvbnNlIGNvZGUuXG5cdCBcdFx0Ly8gaW9BcmdzOiBkb2pvL21haW4uX19Jb0NhbGxiYWNrQXJnc1xuXHRcdFx0Ly9cdFx0UHJvdmlkZXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdC5cblx0XHRcdC8vIHJlc3BvbnNlOiBPYmplY3Rcblx0XHRcdC8vXHRcdFRoZSByZXNwb25zZSBpbiB0aGUgZm9ybWF0IGFzIGRlZmluZWQgd2l0aCBoYW5kbGVBcy5cblx0XHR9LFxuXG5cdFx0ZXJyb3I6IGZ1bmN0aW9uKHJlc3BvbnNlLCBpb0FyZ3Mpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRoaXMgZnVuY3Rpb24gd2lsbFxuXHRcdFx0Ly9cdFx0YmUgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgZmFpbHMgZHVlIHRvIGEgbmV0d29yayBvciBzZXJ2ZXIgZXJyb3IsIHRoZSB1cmxcblx0XHRcdC8vXHRcdGlzIGludmFsaWQsIGV0Yy4gSXQgd2lsbCBhbHNvIGJlIGNhbGxlZCBpZiB0aGUgbG9hZCBvciBoYW5kbGUgY2FsbGJhY2sgdGhyb3dzIGFuXG5cdFx0XHQvL1x0XHRleGNlcHRpb24sIHVubGVzcyBkakNvbmZpZy5kZWJ1Z0F0QWxsQ29zdHMgaXMgdHJ1ZS5cdCBUaGlzIGFsbG93cyBkZXBsb3llZCBhcHBsaWNhdGlvbnNcblx0XHRcdC8vXHRcdHRvIGNvbnRpbnVlIHRvIHJ1biBldmVuIHdoZW4gYSBsb2dpYyBlcnJvciBoYXBwZW5zIGluIHRoZSBjYWxsYmFjaywgd2hpbGUgbWFraW5nXG5cdFx0XHQvL1x0XHRpdCBlYXNpZXIgdG8gdHJvdWJsZXNob290IHdoaWxlIGluIGRlYnVnIG1vZGUuXG5cdFx0XHQvLyBpb0FyZ3M6IGRvam8vbWFpbi5fX0lvQ2FsbGJhY2tBcmdzXG5cdFx0XHQvL1x0XHRQcm92aWRlcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZXF1ZXN0LlxuXHRcdFx0Ly8gcmVzcG9uc2U6IE9iamVjdFxuXHRcdFx0Ly9cdFx0VGhlIHJlc3BvbnNlIGluIHRoZSBmb3JtYXQgYXMgZGVmaW5lZCB3aXRoIGhhbmRsZUFzLlxuXHRcdH0sXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKGxvYWRPckVycm9yLCByZXNwb25zZSwgaW9BcmdzKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdCBcdFx0Ly9cdFx0VGhpcyBmdW5jdGlvbiB3aWxsXG5cdCBcdFx0Ly9cdFx0YmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgcmVxdWVzdCwgd2hldGhlciBvciBub3QgYW4gZXJyb3Igb2NjdXJzLlxuXHRcdFx0Ly8gbG9hZE9yRXJyb3I6IFN0cmluZ1xuXHRcdFx0Ly9cdFx0UHJvdmlkZXMgYSBzdHJpbmcgdGhhdCB0ZWxscyB5b3Ugd2hldGhlciB0aGlzIGZ1bmN0aW9uXG5cdFx0XHQvL1x0XHR3YXMgY2FsbGVkIGJlY2F1c2Ugb2Ygc3VjY2VzcyAobG9hZCkgb3IgZmFpbHVyZSAoZXJyb3IpLlxuXHRcdFx0Ly8gcmVzcG9uc2U6IE9iamVjdFxuXHRcdFx0Ly9cdFx0VGhlIHJlc3BvbnNlIGluIHRoZSBmb3JtYXQgYXMgZGVmaW5lZCB3aXRoIGhhbmRsZUFzLlxuXHRcdFx0Ly8gaW9BcmdzOiBkb2pvL21haW4uX19Jb0NhbGxiYWNrQXJnc1xuXHRcdFx0Ly9cdFx0UHJvdmlkZXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdC5cblx0XHR9XG5cdH0pO1xuXG5cdGRvam8uX19Jb0NhbGxiYWNrQXJncyA9IGRlY2xhcmUobnVsbCwge1xuXHRcdC8vIGFyZ3M6IE9iamVjdFxuXHRcdC8vXHRcdHRoZSBvcmlnaW5hbCBvYmplY3QgYXJndW1lbnQgdG8gdGhlIElPIGNhbGwuXG5cdFx0Ly8geGhyOiBYTUxIdHRwUmVxdWVzdFxuXHRcdC8vXHRcdEZvciBYTUxIdHRwUmVxdWVzdCBjYWxscyBvbmx5LCB0aGVcblx0XHQvL1x0XHRYTUxIdHRwUmVxdWVzdCBvYmplY3QgdGhhdCB3YXMgdXNlZCBmb3IgdGhlXG5cdFx0Ly9cdFx0cmVxdWVzdC5cblx0XHQvLyB1cmw6IFN0cmluZ1xuXHRcdC8vXHRcdFRoZSBmaW5hbCBVUkwgdXNlZCBmb3IgdGhlIGNhbGwuIE1hbnkgdGltZXMgaXRcblx0XHQvL1x0XHR3aWxsIGJlIGRpZmZlcmVudCB0aGFuIHRoZSBvcmlnaW5hbCBhcmdzLnVybFxuXHRcdC8vXHRcdHZhbHVlLlxuXHRcdC8vIHF1ZXJ5OiBTdHJpbmdcblx0XHQvL1x0XHRGb3Igbm9uLUdFVCByZXF1ZXN0cywgdGhlXG5cdFx0Ly9cdFx0bmFtZTE9dmFsdWUxJm5hbWUyPXZhbHVlMiBwYXJhbWV0ZXJzIHNlbnQgdXAgaW5cblx0XHQvL1x0XHR0aGUgcmVxdWVzdC5cblx0XHQvLyBoYW5kbGVBczogU3RyaW5nXG5cdFx0Ly9cdFx0VGhlIGZpbmFsIGluZGljYXRvciBvbiBob3cgdGhlIHJlc3BvbnNlIHdpbGwgYmVcblx0XHQvL1x0XHRoYW5kbGVkLlxuXHRcdC8vIGlkOiBTdHJpbmdcblx0XHQvL1x0XHRGb3IgZG9qby9pby9zY3JpcHQgY2FsbHMgb25seSwgdGhlIGludGVybmFsXG5cdFx0Ly9cdFx0c2NyaXB0IElEIHVzZWQgZm9yIHRoZSByZXF1ZXN0LlxuXHRcdC8vIGNhbkRlbGV0ZTogQm9vbGVhblxuXHRcdC8vXHRcdEZvciBkb2pvL2lvL3NjcmlwdCBjYWxscyBvbmx5LCBpbmRpY2F0ZXNcblx0XHQvL1x0XHR3aGV0aGVyIHRoZSBzY3JpcHQgdGFnIHRoYXQgcmVwcmVzZW50cyB0aGVcblx0XHQvL1x0XHRyZXF1ZXN0IGNhbiBiZSBkZWxldGVkIGFmdGVyIGNhbGxiYWNrcyBoYXZlXG5cdFx0Ly9cdFx0YmVlbiBjYWxsZWQuIFVzZWQgaW50ZXJuYWxseSB0byBrbm93IHdoZW5cblx0XHQvL1x0XHRjbGVhbnVwIGNhbiBoYXBwZW4gb24gSlNPTlAtdHlwZSByZXF1ZXN0cy5cblx0XHQvLyBqc29uOiBPYmplY3Rcblx0XHQvL1x0XHRGb3IgZG9qby9pby9zY3JpcHQgY2FsbHMgb25seTogaG9sZHMgdGhlIEpTT05cblx0XHQvL1x0XHRyZXNwb25zZSBmb3IgSlNPTlAtdHlwZSByZXF1ZXN0cy4gVXNlZFxuXHRcdC8vXHRcdGludGVybmFsbHkgdG8gaG9sZCBvbiB0byB0aGUgSlNPTiByZXNwb25zZXMuXG5cdFx0Ly9cdFx0WW91IHNob3VsZCBub3QgbmVlZCB0byBhY2Nlc3MgaXQgZGlyZWN0bHkgLS1cblx0XHQvL1x0XHR0aGUgc2FtZSBvYmplY3Qgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgc3VjY2Vzc1xuXHRcdC8vXHRcdGNhbGxiYWNrcyBkaXJlY3RseS5cblx0fSk7XG5cblx0ZG9qby5fX0lvUHVibGlzaCA9IGRlY2xhcmUobnVsbCwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhpcyBpcyBhIGxpc3Qgb2YgSU8gdG9waWNzIHRoYXQgY2FuIGJlIHB1Ymxpc2hlZFxuXHRcdC8vXHRcdGlmIGRqQ29uZmlnLmlvUHVibGlzaCBpcyBzZXQgdG8gdHJ1ZS4gSU8gdG9waWNzIGNhbiBiZVxuXHRcdC8vXHRcdHB1Ymxpc2hlZCBmb3IgYW55IElucHV0L091dHB1dCwgbmV0d29yayBvcGVyYXRpb24uIFNvLFxuXHRcdC8vXHRcdGRvam8ueGhyLCBkb2pvLmlvLnNjcmlwdCBhbmQgZG9qby5pby5pZnJhbWUgY2FuIGFsbFxuXHRcdC8vXHRcdHRyaWdnZXIgdGhlc2UgdG9waWNzIHRvIGJlIHB1Ymxpc2hlZC5cblx0XHQvLyBzdGFydDogU3RyaW5nXG5cdFx0Ly9cdFx0XCIvZG9qby9pby9zdGFydFwiIGlzIHNlbnQgd2hlbiB0aGVyZSBhcmUgbm8gb3V0c3RhbmRpbmcgSU9cblx0XHQvL1x0XHRyZXF1ZXN0cywgYW5kIGEgbmV3IElPIHJlcXVlc3QgaXMgc3RhcnRlZC4gTm8gYXJndW1lbnRzXG5cdFx0Ly9cdFx0YXJlIHBhc3NlZCB3aXRoIHRoaXMgdG9waWMuXG5cdFx0Ly8gc2VuZDogU3RyaW5nXG5cdFx0Ly9cdFx0XCIvZG9qby9pby9zZW5kXCIgaXMgc2VudCB3aGVuZXZlciBhIG5ldyBJTyByZXF1ZXN0IGlzIHN0YXJ0ZWQuXG5cdFx0Ly9cdFx0SXQgcGFzc2VzIHRoZSBkb2pvLkRlZmVycmVkIGZvciB0aGUgcmVxdWVzdCB3aXRoIHRoZSB0b3BpYy5cblx0XHQvLyBsb2FkOiBTdHJpbmdcblx0XHQvL1x0XHRcIi9kb2pvL2lvL2xvYWRcIiBpcyBzZW50IHdoZW5ldmVyIGFuIElPIHJlcXVlc3QgaGFzIGxvYWRlZFxuXHRcdC8vXHRcdHN1Y2Nlc3NmdWxseS4gSXQgcGFzc2VzIHRoZSByZXNwb25zZSBhbmQgdGhlIGRvam8uRGVmZXJyZWRcblx0XHQvL1x0XHRmb3IgdGhlIHJlcXVlc3Qgd2l0aCB0aGUgdG9waWMuXG5cdFx0Ly8gZXJyb3I6IFN0cmluZ1xuXHRcdC8vXHRcdFwiL2Rvam8vaW8vZXJyb3JcIiBpcyBzZW50IHdoZW5ldmVyIGFuIElPIHJlcXVlc3QgaGFzIGVycm9yZWQuXG5cdFx0Ly9cdFx0SXQgcGFzc2VzIHRoZSBlcnJvciBhbmQgdGhlIGRvam8uRGVmZXJyZWRcblx0XHQvL1x0XHRmb3IgdGhlIHJlcXVlc3Qgd2l0aCB0aGUgdG9waWMuXG5cdFx0Ly8gZG9uZTogU3RyaW5nXG5cdFx0Ly9cdFx0XCIvZG9qby9pby9kb25lXCIgaXMgc2VudCB3aGVuZXZlciBhbiBJTyByZXF1ZXN0IGhhcyBjb21wbGV0ZWQsXG5cdFx0Ly9cdFx0ZWl0aGVyIGJ5IGxvYWRpbmcgb3IgYnkgZXJyb3JpbmcuIEl0IHBhc3NlcyB0aGUgZXJyb3IgYW5kXG5cdFx0Ly9cdFx0dGhlIGRvam8uRGVmZXJyZWQgZm9yIHRoZSByZXF1ZXN0IHdpdGggdGhlIHRvcGljLlxuXHRcdC8vIHN0b3A6IFN0cmluZ1xuXHRcdC8vXHRcdFwiL2Rvam8vaW8vc3RvcFwiIGlzIHNlbnQgd2hlbiBhbGwgb3V0c3RhbmRpbmcgSU8gcmVxdWVzdHMgaGF2ZVxuXHRcdC8vXHRcdGZpbmlzaGVkLiBObyBhcmd1bWVudHMgYXJlIHBhc3NlZCB3aXRoIHRoaXMgdG9waWMuXG5cdH0pO1xuXHQ9PT09PSovXG5cblxuXHRkb2pvLl9pb1NldEFyZ3MgPSBmdW5jdGlvbigvKmRvam8vbWFpbi5fX0lvQXJncyovYXJncyxcblx0XHRcdC8qRnVuY3Rpb24qL2NhbmNlbGxlcixcblx0XHRcdC8qRnVuY3Rpb24qL29rSGFuZGxlcixcblx0XHRcdC8qRnVuY3Rpb24qL2VyckhhbmRsZXIpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0c2V0cyB1cCB0aGUgRGVmZXJyZWQgYW5kIGlvQXJncyBwcm9wZXJ0eSBvbiB0aGUgRGVmZXJyZWQgc28gaXRcblx0XHQvL1x0XHRjYW4gYmUgdXNlZCBpbiBhbiBpbyBjYWxsLlxuXHRcdC8vIGFyZ3M6XG5cdFx0Ly9cdFx0VGhlIGFyZ3Mgb2JqZWN0IHBhc3NlZCBpbnRvIHRoZSBwdWJsaWMgaW8gY2FsbC4gUmVjb2duaXplZCBwcm9wZXJ0aWVzIG9uXG5cdFx0Ly9cdFx0dGhlIGFyZ3Mgb2JqZWN0IGFyZTpcblx0XHQvLyBjYW5jZWxsZXI6XG5cdFx0Ly9cdFx0VGhlIGNhbmNlbGxlciBmdW5jdGlvbiB1c2VkIGZvciB0aGUgRGVmZXJyZWQgb2JqZWN0LiBUaGUgZnVuY3Rpb25cblx0XHQvL1x0XHR3aWxsIHJlY2VpdmUgb25lIGFyZ3VtZW50LCB0aGUgRGVmZXJyZWQgb2JqZWN0IHRoYXQgaXMgcmVsYXRlZCB0byB0aGVcblx0XHQvL1x0XHRjYW5jZWxsZXIuXG5cdFx0Ly8gb2tIYW5kbGVyOlxuXHRcdC8vXHRcdFRoZSBmaXJzdCBPSyBjYWxsYmFjayB0byBiZSByZWdpc3RlcmVkIHdpdGggRGVmZXJyZWQuIEl0IGhhcyB0aGUgb3Bwb3J0dW5pdHlcblx0XHQvL1x0XHR0byB0cmFuc2Zvcm0gdGhlIE9LIHJlc3BvbnNlLiBJdCB3aWxsIHJlY2VpdmUgb25lIGFyZ3VtZW50IC0tIHRoZSBEZWZlcnJlZFxuXHRcdC8vXHRcdG9iamVjdCByZXR1cm5lZCBmcm9tIHRoaXMgZnVuY3Rpb24uXG5cdFx0Ly8gZXJySGFuZGxlcjpcblx0XHQvL1x0XHRUaGUgZmlyc3QgZXJyb3IgY2FsbGJhY2sgdG8gYmUgcmVnaXN0ZXJlZCB3aXRoIERlZmVycmVkLiBJdCBoYXMgdGhlIG9wcG9ydHVuaXR5XG5cdFx0Ly9cdFx0dG8gZG8gY2xlYW51cCBvbiBhbiBlcnJvci4gSXQgd2lsbCByZWNlaXZlIHR3byBhcmd1bWVudHM6IGVycm9yICh0aGVcblx0XHQvL1x0XHRFcnJvciBvYmplY3QpIGFuZCBkZmQsIHRoZSBEZWZlcnJlZCBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGlzIGZ1bmN0aW9uLlxuXG5cdFx0dmFyIGlvQXJncyA9IHthcmdzOiBhcmdzLCB1cmw6IGFyZ3MudXJsfTtcblxuXHRcdC8vR2V0IHZhbHVlcyBmcm9tIGZvcm0gaWYgcmVxdWVzdGVkLlxuXHRcdHZhciBmb3JtT2JqZWN0ID0gbnVsbDtcblx0XHRpZihhcmdzLmZvcm0pe1xuXHRcdFx0dmFyIGZvcm0gPSBkb20uYnlJZChhcmdzLmZvcm0pO1xuXHRcdFx0Ly9JRSByZXF1aXJlcyBnb2luZyB0aHJvdWdoIGdldEF0dHJpYnV0ZU5vZGUgaW5zdGVhZCBvZiBqdXN0IGdldEF0dHJpYnV0ZSBpbiBzb21lIGZvcm0gY2FzZXMsXG5cdFx0XHQvL3NvIHVzZSBpdCBmb3IgYWxsLiBTZWUgIzI4NDRcblx0XHRcdHZhciBhY3RuTm9kZSA9IGZvcm0uZ2V0QXR0cmlidXRlTm9kZShcImFjdGlvblwiKTtcblx0XHRcdGlvQXJncy51cmwgPSBpb0FyZ3MudXJsIHx8IChhY3RuTm9kZSA/IGFjdG5Ob2RlLnZhbHVlIDogKGRvam8uZG9jID8gZG9qby5kb2MuVVJMIDogbnVsbCkpO1xuXHRcdFx0Zm9ybU9iamVjdCA9IGRvbUZvcm0udG9PYmplY3QoZm9ybSk7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IHVwIHRoZSBxdWVyeSBwYXJhbXNcblx0XHR2YXIgbWlBcmdzID0ge307XG5cblx0XHRpZihmb3JtT2JqZWN0KXtcblx0XHRcdC8vIHBvdGVudGlhbGx5IG92ZXItcmlkZSB1cmwtcHJvdmlkZWQgcGFyYW1zIHcvIGZvcm0gdmFsdWVzXG5cdFx0XHRsYW5nLm1peGluKG1pQXJncywgZm9ybU9iamVjdCk7XG5cdFx0fVxuXHRcdGlmKGFyZ3MuY29udGVudCl7XG5cdFx0XHQvLyBzdHVmZiBpbiBjb250ZW50IG92ZXItcmlkZXMgd2hhdCdzIHNldCBieSBmb3JtXG5cdFx0XHRsYW5nLm1peGluKG1pQXJncywgYXJncy5jb250ZW50KTtcblx0XHR9XG5cdFx0aWYoYXJncy5wcmV2ZW50Q2FjaGUpe1xuXHRcdFx0bWlBcmdzW1wiZG9qby5wcmV2ZW50Q2FjaGVcIl0gPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcblx0XHR9XG5cdFx0aW9BcmdzLnF1ZXJ5ID0gaW9xLm9iamVjdFRvUXVlcnkobWlBcmdzKTtcblxuXHRcdC8vIC4uIGFuZCB0aGUgcmVhbCB3b3JrIG9mIGdldHRpbmcgdGhlIGRlZmVycmVkIGluIG9yZGVyLCBldGMuXG5cdFx0aW9BcmdzLmhhbmRsZUFzID0gYXJncy5oYW5kbGVBcyB8fCBcInRleHRcIjtcblx0XHR2YXIgZCA9IG5ldyBEZWZlcnJlZChmdW5jdGlvbihkZmQpe1xuXHRcdFx0ZGZkLmNhbmNlbGVkID0gdHJ1ZTtcblx0XHRcdGNhbmNlbGxlciAmJiBjYW5jZWxsZXIoZGZkKTtcblxuXHRcdFx0dmFyIGVyciA9IGRmZC5pb0FyZ3MuZXJyb3I7XG5cdFx0XHRpZighZXJyKXtcblx0XHRcdFx0ZXJyID0gbmV3IEVycm9yKFwicmVxdWVzdCBjYW5jZWxsZWRcIik7XG5cdFx0XHRcdGVyci5kb2pvVHlwZT1cImNhbmNlbFwiO1xuXHRcdFx0XHRkZmQuaW9BcmdzLmVycm9yID0gZXJyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVycjtcblx0XHR9KTtcblx0XHRkLmFkZENhbGxiYWNrKG9rSGFuZGxlcik7XG5cblx0XHQvL1N1cHBvcnQgc3BlY2lmeWluZyBsb2FkLCBlcnJvciBhbmQgaGFuZGxlIGNhbGxiYWNrIGZ1bmN0aW9ucyBmcm9tIHRoZSBhcmdzLlxuXHRcdC8vRm9yIHRob3NlIGNhbGxiYWNrcywgdGhlIFwidGhpc1wiIG9iamVjdCB3aWxsIGJlIHRoZSBhcmdzIG9iamVjdC5cblx0XHQvL1RoZSBjYWxsYmFja3Mgd2lsbCBnZXQgdGhlIGRlZmVycmVkIHJlc3VsdCB2YWx1ZSBhcyB0aGVcblx0XHQvL2ZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgaW9BcmdzIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuXHRcdHZhciBsZCA9IGFyZ3MubG9hZDtcblx0XHRpZihsZCAmJiBsYW5nLmlzRnVuY3Rpb24obGQpKXtcblx0XHRcdGQuYWRkQ2FsbGJhY2soZnVuY3Rpb24odmFsdWUpe1xuXHRcdFx0XHRyZXR1cm4gbGQuY2FsbChhcmdzLCB2YWx1ZSwgaW9BcmdzKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHR2YXIgZXJyID0gYXJncy5lcnJvcjtcblx0XHRpZihlcnIgJiYgbGFuZy5pc0Z1bmN0aW9uKGVycikpe1xuXHRcdFx0ZC5hZGRFcnJiYWNrKGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdFx0cmV0dXJuIGVyci5jYWxsKGFyZ3MsIHZhbHVlLCBpb0FyZ3MpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHZhciBoYW5kbGUgPSBhcmdzLmhhbmRsZTtcblx0XHRpZihoYW5kbGUgJiYgbGFuZy5pc0Z1bmN0aW9uKGhhbmRsZSkpe1xuXHRcdFx0ZC5hZGRCb3RoKGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdFx0cmV0dXJuIGhhbmRsZS5jYWxsKGFyZ3MsIHZhbHVlLCBpb0FyZ3MpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0YWNoIGVycm9yIGhhbmRsZXIgbGFzdCAobm90IGluY2x1ZGluZyB0b3BpYyBwdWJsaXNoaW5nKVxuXHRcdC8vIHRvIGNhdGNoIGFueSBlcnJvcnMgdGhhdCBtYXkgaGF2ZSBiZWVuIGdlbmVyYXRlZCBmcm9tIGxvYWRcblx0XHQvLyBvciBoYW5kbGUgZnVuY3Rpb25zLlxuXHRcdGQuYWRkRXJyYmFjayhmdW5jdGlvbihlcnJvcil7XG5cdFx0XHRyZXR1cm4gZXJySGFuZGxlcihlcnJvciwgZCk7XG5cdFx0fSk7XG5cblx0XHQvL1BsdWcgaW4gdG9waWMgcHVibGlzaGluZywgaWYgZG9qby5wdWJsaXNoIGlzIGxvYWRlZC5cblx0XHRpZihjZmcuaW9QdWJsaXNoICYmIGRvam8ucHVibGlzaCAmJiBpb0FyZ3MuYXJncy5pb1B1Ymxpc2ggIT09IGZhbHNlKXtcblx0XHRcdGQuYWRkQ2FsbGJhY2tzKFxuXHRcdFx0XHRmdW5jdGlvbihyZXMpe1xuXHRcdFx0XHRcdGRvam8ucHVibGlzaChcIi9kb2pvL2lvL2xvYWRcIiwgW2QsIHJlc10pO1xuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uKHJlcyl7XG5cdFx0XHRcdFx0ZG9qby5wdWJsaXNoKFwiL2Rvam8vaW8vZXJyb3JcIiwgW2QsIHJlc10pO1xuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0XHRkLmFkZEJvdGgoZnVuY3Rpb24ocmVzKXtcblx0XHRcdFx0ZG9qby5wdWJsaXNoKFwiL2Rvam8vaW8vZG9uZVwiLCBbZCwgcmVzXSk7XG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRkLmlvQXJncyA9IGlvQXJncztcblxuXHRcdC8vIEZJWE1FOiBuZWVkIHRvIHdpcmUgdXAgdGhlIHhociBvYmplY3QncyBhYm9ydCBtZXRob2QgdG8gc29tZXRoaW5nXG5cdFx0Ly8gYW5hbG9nb3VzIGluIHRoZSBEZWZlcnJlZFxuXHRcdHJldHVybiBkO1xuXHR9O1xuXG5cdHZhciBfZGVmZXJyZWRPayA9IGZ1bmN0aW9uKC8qRGVmZXJyZWQqL2RmZCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRva0hhbmRsZXIgZnVuY3Rpb24gZm9yIGRvam8uX2lvU2V0QXJncyBjYWxsLlxuXG5cdFx0dmFyIHJldCA9IGhhbmRsZXJzW2RmZC5pb0FyZ3MuaGFuZGxlQXNdKGRmZC5pb0FyZ3MueGhyKTtcblx0XHRyZXR1cm4gcmV0ID09PSB1bmRlZmluZWQgPyBudWxsIDogcmV0O1xuXHR9O1xuXHR2YXIgX2RlZmVyRXJyb3IgPSBmdW5jdGlvbigvKkVycm9yKi9lcnJvciwgLypEZWZlcnJlZCovZGZkKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdGVyckhhbmRsZXIgZnVuY3Rpb24gZm9yIGRvam8uX2lvU2V0QXJncyBjYWxsLlxuXG5cdFx0aWYoIWRmZC5pb0FyZ3MuYXJncy5mYWlsT2spe1xuXHRcdFx0Y29uc29sZS5lcnJvcihlcnJvcik7XG5cdFx0fVxuXHRcdHJldHVybiBlcnJvcjtcblx0fTtcblxuXHQvL1VzZSBhIHNlcGFyYXRlIGNvdW50IGZvciBrbm93aW5nIGlmIHdlIGFyZSBzdGFydGluZy9zdG9wcGluZyBpbyBjYWxscy5cblx0dmFyIF9jaGVja1B1YkNvdW50ID0gZnVuY3Rpb24oZGZkKXtcblx0XHRpZihfcHViQ291bnQgPD0gMCl7XG5cdFx0XHRfcHViQ291bnQgPSAwO1xuXHRcdFx0aWYoY2ZnLmlvUHVibGlzaCAmJiBkb2pvLnB1Ymxpc2ggJiYgKCFkZmQgfHwgZGZkICYmIGRmZC5pb0FyZ3MuYXJncy5pb1B1Ymxpc2ggIT09IGZhbHNlKSl7XG5cdFx0XHRcdGRvam8ucHVibGlzaChcIi9kb2pvL2lvL3N0b3BcIik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBfcHViQ291bnQgPSAwO1xuXHRhc3BlY3QuYWZ0ZXIod2F0Y2gsIFwiX29uQWN0aW9uXCIsIGZ1bmN0aW9uKCl7XG5cdFx0X3B1YkNvdW50IC09IDE7XG5cdH0pO1xuXHRhc3BlY3QuYWZ0ZXIod2F0Y2gsIFwiX29uSW5GbGlnaHRcIiwgX2NoZWNrUHViQ291bnQpO1xuXG5cdGRvam8uX2lvQ2FuY2VsQWxsID0gd2F0Y2guY2FuY2VsQWxsO1xuXHQvKj09PT09XG5cdGRvam8uX2lvQ2FuY2VsQWxsID0gZnVuY3Rpb24oKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENhbmNlbHMgYWxsIHBlbmRpbmcgSU8gcmVxdWVzdHMsIHJlZ2FyZGxlc3Mgb2YgSU8gdHlwZVxuXHRcdC8vXHRcdCh4aHIsIHNjcmlwdCwgaWZyYW1lKS5cblx0fTtcblx0PT09PT0qL1xuXG5cdGRvam8uX2lvTm90aWZ5U3RhcnQgPSBmdW5jdGlvbigvKkRlZmVycmVkKi9kZmQpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0SWYgZG9qby5wdWJsaXNoIGlzIGF2YWlsYWJsZSwgcHVibGlzaCB0b3BpY3Ncblx0XHQvL1x0XHRhYm91dCB0aGUgc3RhcnQgb2YgYSByZXF1ZXN0IHF1ZXVlIGFuZC9vciB0aGVcblx0XHQvL1x0XHR0aGUgYmVnaW5uaW5nIG9mIHJlcXVlc3QuXG5cdFx0Ly9cblx0XHQvL1x0XHRVc2VkIGJ5IElPIHRyYW5zcG9ydHMuIEFuIElPIHRyYW5zcG9ydCBzaG91bGRcblx0XHQvL1x0XHRjYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSBtYWtpbmcgdGhlIG5ldHdvcmsgY29ubmVjdGlvbi5cblx0XHRpZihjZmcuaW9QdWJsaXNoICYmIGRvam8ucHVibGlzaCAmJiBkZmQuaW9BcmdzLmFyZ3MuaW9QdWJsaXNoICE9PSBmYWxzZSl7XG5cdFx0XHRpZighX3B1YkNvdW50KXtcblx0XHRcdFx0ZG9qby5wdWJsaXNoKFwiL2Rvam8vaW8vc3RhcnRcIik7XG5cdFx0XHR9XG5cdFx0XHRfcHViQ291bnQgKz0gMTtcblx0XHRcdGRvam8ucHVibGlzaChcIi9kb2pvL2lvL3NlbmRcIiwgW2RmZF0pO1xuXHRcdH1cblx0fTtcblxuXHRkb2pvLl9pb1dhdGNoID0gZnVuY3Rpb24oZGZkLCB2YWxpZENoZWNrLCBpb0NoZWNrLCByZXNIYW5kbGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0V2F0Y2hlcyB0aGUgaW8gcmVxdWVzdCByZXByZXNlbnRlZCBieSBkZmQgdG8gc2VlIGlmIGl0IGNvbXBsZXRlcy5cblx0XHQvLyBkZmQ6IERlZmVycmVkXG5cdFx0Ly9cdFx0VGhlIERlZmVycmVkIG9iamVjdCB0byB3YXRjaC5cblx0XHQvLyB2YWxpZENoZWNrOiBGdW5jdGlvblxuXHRcdC8vXHRcdEZ1bmN0aW9uIHVzZWQgdG8gY2hlY2sgaWYgdGhlIElPIHJlcXVlc3QgaXMgc3RpbGwgdmFsaWQuIEdldHMgdGhlIGRmZFxuXHRcdC8vXHRcdG9iamVjdCBhcyBpdHMgb25seSBhcmd1bWVudC5cblx0XHQvLyBpb0NoZWNrOiBGdW5jdGlvblxuXHRcdC8vXHRcdEZ1bmN0aW9uIHVzZWQgdG8gY2hlY2sgaWYgYmFzaWMgSU8gY2FsbCB3b3JrZWQuIEdldHMgdGhlIGRmZFxuXHRcdC8vXHRcdG9iamVjdCBhcyBpdHMgb25seSBhcmd1bWVudC5cblx0XHQvLyByZXNIYW5kbGU6IEZ1bmN0aW9uXG5cdFx0Ly9cdFx0RnVuY3Rpb24gdXNlZCB0byBwcm9jZXNzIHJlc3BvbnNlLiBHZXRzIHRoZSBkZmRcblx0XHQvL1x0XHRvYmplY3QgYXMgaXRzIG9ubHkgYXJndW1lbnQuXG5cblx0XHR2YXIgYXJncyA9IGRmZC5pb0FyZ3Mub3B0aW9ucyA9IGRmZC5pb0FyZ3MuYXJncztcblx0XHRsYW5nLm1peGluKGRmZCwge1xuXHRcdFx0cmVzcG9uc2U6IGRmZC5pb0FyZ3MsXG5cdFx0XHRpc1ZhbGlkOiBmdW5jdGlvbihyZXNwb25zZSl7XG5cdFx0XHRcdHJldHVybiB2YWxpZENoZWNrKGRmZCk7XG5cdFx0XHR9LFxuXHRcdFx0aXNSZWFkeTogZnVuY3Rpb24ocmVzcG9uc2Upe1xuXHRcdFx0XHRyZXR1cm4gaW9DaGVjayhkZmQpO1xuXHRcdFx0fSxcblx0XHRcdGhhbmRsZVJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSl7XG5cdFx0XHRcdHJldHVybiByZXNIYW5kbGUoZGZkKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR3YXRjaChkZmQpO1xuXG5cdFx0X2NoZWNrUHViQ291bnQoZGZkKTtcblx0fTtcblxuXHR2YXIgX2RlZmF1bHRDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5cblx0ZG9qby5faW9BZGRRdWVyeVRvVXJsID0gZnVuY3Rpb24oLypkb2pvLl9fSW9DYWxsYmFja0FyZ3MqL2lvQXJncyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRBZGRzIHF1ZXJ5IHBhcmFtcyBkaXNjb3ZlcmVkIGJ5IHRoZSBpbyBkZWZlcnJlZCBjb25zdHJ1Y3Rpb24gdG8gdGhlIFVSTC5cblx0XHQvL1x0XHRPbmx5IHVzZSB0aGlzIGZvciBvcGVyYXRpb25zIHdoaWNoIGFyZSBmdW5kYW1lbnRhbGx5IEdFVC10eXBlIG9wZXJhdGlvbnMuXG5cdFx0aWYoaW9BcmdzLnF1ZXJ5Lmxlbmd0aCl7XG5cdFx0XHRpb0FyZ3MudXJsICs9IChpb0FyZ3MudXJsLmluZGV4T2YoXCI/XCIpID09IC0xID8gXCI/XCIgOiBcIiZcIikgKyBpb0FyZ3MucXVlcnk7XG5cdFx0XHRpb0FyZ3MucXVlcnkgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHQvKj09PT09XG5cdGRvam8uX19YaHJBcmdzID0gZGVjbGFyZShkb2pvLl9fSW9BcmdzLCB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRJbiBhZGRpdGlvbiB0byB0aGUgcHJvcGVydGllcyBsaXN0ZWQgZm9yIHRoZSBkb2pvLl9Jb0FyZ3MgdHlwZSxcblx0XHQvL1x0XHR0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQgZm9yIGRvam8ueGhyKiBtZXRob2RzLlxuXHRcdC8vIGhhbmRsZUFzOiBTdHJpbmc/XG5cdFx0Ly9cdFx0QWNjZXB0YWJsZSB2YWx1ZXMgYXJlOiB0ZXh0IChkZWZhdWx0KSwganNvbiwganNvbi1jb21tZW50LW9wdGlvbmFsLFxuXHRcdC8vXHRcdGpzb24tY29tbWVudC1maWx0ZXJlZCwgamF2YXNjcmlwdCwgeG1sLiBTZWUgYGRvam8vX2Jhc2UveGhyLmNvbnRlbnRIYW5kbGVyc2Bcblx0IFx0Ly8gc3luYzogQm9vbGVhbj9cblx0XHQvL1x0XHRmYWxzZSBpcyBkZWZhdWx0LiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVxdWVzdCBzaG91bGRcblx0XHQvL1x0XHRiZSBhIHN5bmNocm9ub3VzIChibG9ja2luZykgcmVxdWVzdC5cblx0XHQvLyBoZWFkZXJzOiBPYmplY3Q/XG5cdFx0Ly9cdFx0QWRkaXRpb25hbCBIVFRQIGhlYWRlcnMgdG8gc2VuZCBpbiB0aGUgcmVxdWVzdC5cblx0XHQvLyBmYWlsT2s6IEJvb2xlYW4/XG5cdFx0Ly9cdFx0ZmFsc2UgaXMgZGVmYXVsdC4gSW5kaWNhdGVzIHdoZXRoZXIgYSByZXF1ZXN0IHNob3VsZCBiZVxuXHRcdC8vXHRcdGFsbG93ZWQgdG8gZmFpbCAoYW5kIHRoZXJlZm9yZSBubyBjb25zb2xlIGVycm9yIG1lc3NhZ2UgaW5cblx0XHQvL1x0XHR0aGUgZXZlbnQgb2YgYSBmYWlsdXJlKVxuXHRcdC8vIGNvbnRlbnRUeXBlOiBTdHJpbmd8Qm9vbGVhblxuXHRcdC8vXHRcdFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgaXMgZGVmYXVsdC4gU2V0IHRvIGZhbHNlIHRvXG5cdFx0Ly9cdFx0cHJldmVudCBhIENvbnRlbnQtVHlwZSBoZWFkZXIgZnJvbSBiZWluZyBzZW50LCBvciB0byBhIHN0cmluZ1xuXHRcdC8vXHRcdHRvIHNlbmQgYSBkaWZmZXJlbnQgQ29udGVudC1UeXBlLlxuXHQgfSk7XG5cdD09PT09Ki9cblxuXHRkb2pvLnhociA9IGZ1bmN0aW9uKC8qU3RyaW5nKi8gbWV0aG9kLCAvKmRvam8uX19YaHJBcmdzKi8gYXJncywgLypCb29sZWFuPyovIGhhc0JvZHkpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0RGVwcmVjYXRlZC4gICBVc2UgZG9qby9yZXF1ZXN0IGluc3RlYWQuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0U2VuZHMgYW4gSFRUUCByZXF1ZXN0IHdpdGggdGhlIGdpdmVuIG1ldGhvZC5cblx0XHQvL1x0XHRTZWUgYWxzbyBkb2pvLnhockdldCgpLCB4aHJQb3N0KCksIHhoclB1dCgpIGFuZCBkb2pvLnhockRlbGV0ZSgpIGZvciBzaG9ydGN1dHNcblx0XHQvL1x0XHRmb3IgdGhvc2UgSFRUUCBtZXRob2RzLiBUaGVyZSBhcmUgYWxzbyBtZXRob2RzIGZvciBcInJhd1wiIFBVVCBhbmQgUE9TVCBtZXRob2RzXG5cdFx0Ly9cdFx0dmlhIGRvam8ucmF3WGhyUHV0KCkgYW5kIGRvam8ucmF3WGhyUG9zdCgpIHJlc3BlY3RpdmVseS5cblx0XHQvLyBtZXRob2Q6XG5cdFx0Ly9cdFx0SFRUUCBtZXRob2QgdG8gYmUgdXNlZCwgc3VjaCBhcyBHRVQsIFBPU1QsIFBVVCwgREVMRVRFLiBTaG91bGQgYmUgdXBwZXJjYXNlLlxuXHRcdC8vIGhhc0JvZHk6XG5cdFx0Ly9cdFx0SWYgdGhlIHJlcXVlc3QgaGFzIGFuIEhUVFAgYm9keSwgdGhlbiBwYXNzIHRydWUgZm9yIGhhc0JvZHkuXG5cblx0XHR2YXIgckRmZDtcblx0XHQvL01ha2UgdGhlIERlZmVycmVkIG9iamVjdCBmb3IgdGhpcyB4aHIgcmVxdWVzdC5cblx0XHR2YXIgZGZkID0gZG9qby5faW9TZXRBcmdzKGFyZ3MsIGZ1bmN0aW9uKGRmZCl7XG5cdFx0XHRyRGZkICYmIHJEZmQuY2FuY2VsKCk7XG5cdFx0fSwgX2RlZmVycmVkT2ssIF9kZWZlckVycm9yKTtcblx0XHR2YXIgaW9BcmdzID0gZGZkLmlvQXJncztcblxuXHRcdC8vQWxsb3cgZm9yIHNwZWNpZnlpbmcgdGhlIEhUVFAgYm9keSBjb21wbGV0ZWx5LlxuXHRcdGlmKFwicG9zdERhdGFcIiBpbiBhcmdzKXtcblx0XHRcdGlvQXJncy5xdWVyeSA9IGFyZ3MucG9zdERhdGE7XG5cdFx0fWVsc2UgaWYoXCJwdXREYXRhXCIgaW4gYXJncyl7XG5cdFx0XHRpb0FyZ3MucXVlcnkgPSBhcmdzLnB1dERhdGE7XG5cdFx0fWVsc2UgaWYoXCJyYXdCb2R5XCIgaW4gYXJncyl7XG5cdFx0XHRpb0FyZ3MucXVlcnkgPSBhcmdzLnJhd0JvZHk7XG5cdFx0fWVsc2UgaWYoKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmICFoYXNCb2R5KSB8fCBcIlBPU1R8UFVUXCIuaW5kZXhPZihtZXRob2QudG9VcHBlckNhc2UoKSkgPT09IC0xKXtcblx0XHRcdC8vQ2hlY2sgZm9yIGhhc0JvZHkgYmVpbmcgcGFzc2VkLiBJZiBubyBoYXNCb2R5LFxuXHRcdFx0Ly90aGVuIG9ubHkgYXBwZW5kIHF1ZXJ5IHN0cmluZyBpZiBub3QgYSBQT1NUIG9yIFBVVCByZXF1ZXN0LlxuXHRcdFx0ZG9qby5faW9BZGRRdWVyeVRvVXJsKGlvQXJncyk7XG5cdFx0fVxuXG5cdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRtZXRob2Q6IG1ldGhvZCxcblx0XHRcdGhhbmRsZUFzOiBcInRleHRcIixcblx0XHRcdHRpbWVvdXQ6IGFyZ3MudGltZW91dCxcblx0XHRcdHdpdGhDcmVkZW50aWFsczogYXJncy53aXRoQ3JlZGVudGlhbHMsXG5cdFx0XHRpb0FyZ3M6IGlvQXJnc1xuXHRcdH07XG5cblx0XHRpZih0eXBlb2YgYXJncy5oZWFkZXJzICE9PSAndW5kZWZpbmVkJyl7XG5cdFx0XHRvcHRpb25zLmhlYWRlcnMgPSBhcmdzLmhlYWRlcnM7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZiBhcmdzLmNvbnRlbnRUeXBlICE9PSAndW5kZWZpbmVkJyl7XG5cdFx0XHRpZighb3B0aW9ucy5oZWFkZXJzKXtcblx0XHRcdFx0b3B0aW9ucy5oZWFkZXJzID0ge307XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gYXJncy5jb250ZW50VHlwZTtcblx0XHR9XG5cdFx0aWYodHlwZW9mIGlvQXJncy5xdWVyeSAhPT0gJ3VuZGVmaW5lZCcpe1xuXHRcdFx0b3B0aW9ucy5kYXRhID0gaW9BcmdzLnF1ZXJ5O1xuXHRcdH1cblx0XHRpZih0eXBlb2YgYXJncy5zeW5jICE9PSAndW5kZWZpbmVkJyl7XG5cdFx0XHRvcHRpb25zLnN5bmMgPSBhcmdzLnN5bmM7XG5cdFx0fVxuXG5cdFx0ZG9qby5faW9Ob3RpZnlTdGFydChkZmQpO1xuXHRcdHRyeXtcblx0XHRcdHJEZmQgPSBfeGhyKGlvQXJncy51cmwsIG9wdGlvbnMsIHRydWUpO1xuXHRcdH1jYXRjaChlKXtcblx0XHRcdC8vIElmIFhIUiBjcmVhdGlvbiBmYWlscywgZG9qby9yZXF1ZXN0L3hociB0aHJvd3Ncblx0XHRcdC8vIFdoZW4gdGhpcyBoYXBwZW5zLCBjYW5jZWwgdGhlIGRlZmVycmVkXG5cdFx0XHRkZmQuY2FuY2VsKCk7XG5cdFx0XHRyZXR1cm4gZGZkO1xuXHRcdH1cblxuXHRcdC8vIHN5bmMgaW9BcmdzXG5cdFx0ZGZkLmlvQXJncy54aHIgPSByRGZkLnJlc3BvbnNlLnhocjtcblxuXHRcdHJEZmQudGhlbihmdW5jdGlvbigpe1xuXHRcdFx0ZGZkLnJlc29sdmUoZGZkKTtcblx0XHR9KS5vdGhlcndpc2UoZnVuY3Rpb24oZXJyb3Ipe1xuXHRcdFx0aW9BcmdzLmVycm9yID0gZXJyb3I7XG5cdFx0XHRpZihlcnJvci5yZXNwb25zZSl7XG5cdFx0XHRcdGVycm9yLnN0YXR1cyA9IGVycm9yLnJlc3BvbnNlLnN0YXR1cztcblx0XHRcdFx0ZXJyb3IucmVzcG9uc2VUZXh0ID0gZXJyb3IucmVzcG9uc2UudGV4dDtcblx0XHRcdFx0ZXJyb3IueGhyID0gZXJyb3IucmVzcG9uc2UueGhyO1xuXHRcdFx0fVxuXHRcdFx0ZGZkLnJlamVjdChlcnJvcik7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGRmZDsgLy8gZG9qby9fYmFzZS9EZWZlcnJlZFxuXHR9O1xuXG5cdGRvam8ueGhyR2V0ID0gZnVuY3Rpb24oLypkb2pvLl9fWGhyQXJncyovIGFyZ3Mpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0U2VuZHMgYW4gSFRUUCBHRVQgcmVxdWVzdCB0byB0aGUgc2VydmVyLlxuXHRcdHJldHVybiBkb2pvLnhocihcIkdFVFwiLCBhcmdzKTsgLy8gZG9qby9fYmFzZS9EZWZlcnJlZFxuXHR9O1xuXG5cdGRvam8ucmF3WGhyUG9zdCA9IGRvam8ueGhyUG9zdCA9IGZ1bmN0aW9uKC8qZG9qby5fX1hockFyZ3MqLyBhcmdzKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNlbmRzIGFuIEhUVFAgUE9TVCByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIuIEluIGFkZGl0aW9uIHRvIHRoZSBwcm9wZXJ0aWVzXG5cdFx0Ly9cdFx0bGlzdGVkIGZvciB0aGUgZG9qby5fX1hockFyZ3MgdHlwZSwgdGhlIGZvbGxvd2luZyBwcm9wZXJ0eSBpcyBhbGxvd2VkOlxuXHRcdC8vIHBvc3REYXRhOlxuXHRcdC8vXHRcdFN0cmluZy4gU2VuZCByYXcgZGF0YSBpbiB0aGUgYm9keSBvZiB0aGUgUE9TVCByZXF1ZXN0LlxuXHRcdHJldHVybiBkb2pvLnhocihcIlBPU1RcIiwgYXJncywgdHJ1ZSk7IC8vIGRvam8vX2Jhc2UvRGVmZXJyZWRcblx0fTtcblxuXHRkb2pvLnJhd1hoclB1dCA9IGRvam8ueGhyUHV0ID0gZnVuY3Rpb24oLypkb2pvLl9fWGhyQXJncyovIGFyZ3Mpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0U2VuZHMgYW4gSFRUUCBQVVQgcmVxdWVzdCB0byB0aGUgc2VydmVyLiBJbiBhZGRpdGlvbiB0byB0aGUgcHJvcGVydGllc1xuXHRcdC8vXHRcdGxpc3RlZCBmb3IgdGhlIGRvam8uX19YaHJBcmdzIHR5cGUsIHRoZSBmb2xsb3dpbmcgcHJvcGVydHkgaXMgYWxsb3dlZDpcblx0XHQvLyBwdXREYXRhOlxuXHRcdC8vXHRcdFN0cmluZy4gU2VuZCByYXcgZGF0YSBpbiB0aGUgYm9keSBvZiB0aGUgUFVUIHJlcXVlc3QuXG5cdFx0cmV0dXJuIGRvam8ueGhyKFwiUFVUXCIsIGFyZ3MsIHRydWUpOyAvLyBkb2pvL19iYXNlL0RlZmVycmVkXG5cdH07XG5cblx0ZG9qby54aHJEZWxldGUgPSBmdW5jdGlvbigvKmRvam8uX19YaHJBcmdzKi8gYXJncyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZW5kcyBhbiBIVFRQIERFTEVURSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIuXG5cdFx0cmV0dXJuIGRvam8ueGhyKFwiREVMRVRFXCIsIGFyZ3MpOyAvLyBkb2pvL19iYXNlL0RlZmVycmVkXG5cdH07XG5cblx0Lypcblx0ZG9qby53cmFwRm9ybSA9IGZ1bmN0aW9uKGZvcm1Ob2RlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEEgcmVwbGFjZW1lbnQgZm9yIEZvcm1CaW5kLCBidXQgbm90IGltcGxlbWVudGVkIHlldC5cblxuXHRcdC8vIEZJWE1FOiBuZWVkIHRvIHRoaW5rIGhhcmRlciBhYm91dCB3aGF0IGV4dGVuc2lvbnMgdG8gdGhpcyB3ZSBtaWdodFxuXHRcdC8vIHdhbnQuIFdoYXQgc2hvdWxkIHdlIGFsbG93IGZvbGtzIHRvIGRvIHcvIHRoaXM/IFdoYXQgZXZlbnRzIHRvXG5cdFx0Ly8gc2V0L3NlbmQ/XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiZG9qby53cmFwRm9ybSBub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cdCovXG5cblx0ZG9qby5faXNEb2N1bWVudE9rID0gZnVuY3Rpb24oeCl7XG5cdFx0cmV0dXJuIHV0aWwuY2hlY2tTdGF0dXMoeC5zdGF0dXMpO1xuXHR9O1xuXG5cdGRvam8uX2dldFRleHQgPSBmdW5jdGlvbih1cmwpe1xuXHRcdHZhciByZXN1bHQ7XG5cdFx0ZG9qby54aHJHZXQoe3VybDp1cmwsIHN5bmM6dHJ1ZSwgbG9hZDpmdW5jdGlvbih0ZXh0KXtcblx0XHRcdHJlc3VsdCA9IHRleHQ7XG5cdFx0fX0pO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gQWRkIGFsaWFzZXMgZm9yIHN0YXRpYyBmdW5jdGlvbnMgdG8gZG9qby54aHIgc2luY2UgZG9qby54aHIgaXMgd2hhdCdzIHJldHVybmVkIGZyb20gdGhpcyBtb2R1bGVcblx0bGFuZy5taXhpbihkb2pvLnhociwge1xuXHRcdF94aHJPYmo6IGRvam8uX3hock9iaixcblx0XHRmaWVsZFRvT2JqZWN0OiBkb21Gb3JtLmZpZWxkVG9PYmplY3QsXG5cdFx0Zm9ybVRvT2JqZWN0OiBkb21Gb3JtLnRvT2JqZWN0LFxuXHRcdG9iamVjdFRvUXVlcnk6IGlvcS5vYmplY3RUb1F1ZXJ5LFxuXHRcdGZvcm1Ub1F1ZXJ5OiBkb21Gb3JtLnRvUXVlcnksXG5cdFx0Zm9ybVRvSnNvbjogZG9tRm9ybS50b0pzb24sXG5cdFx0cXVlcnlUb09iamVjdDogaW9xLnF1ZXJ5VG9PYmplY3QsXG5cdFx0Y29udGVudEhhbmRsZXJzOiBoYW5kbGVycyxcblx0XHRfaW9TZXRBcmdzOiBkb2pvLl9pb1NldEFyZ3MsXG5cdFx0X2lvQ2FuY2VsQWxsOiBkb2pvLl9pb0NhbmNlbEFsbCxcblx0XHRfaW9Ob3RpZnlTdGFydDogZG9qby5faW9Ob3RpZnlTdGFydCxcblx0XHRfaW9XYXRjaDogZG9qby5faW9XYXRjaCxcblx0XHRfaW9BZGRRdWVyeVRvVXJsOiBkb2pvLl9pb0FkZFF1ZXJ5VG9VcmwsXG5cdFx0X2lzRG9jdW1lbnRPazogZG9qby5faXNEb2N1bWVudE9rLFxuXHRcdF9nZXRUZXh0OiBkb2pvLl9nZXRUZXh0LFxuXHRcdGdldDogZG9qby54aHJHZXQsXG5cdFx0cG9zdDogZG9qby54aHJQb3N0LFxuXHRcdHB1dDogZG9qby54aHJQdXQsXG5cdFx0ZGVsOiBkb2pvLnhockRlbGV0ZVx0Ly8gYmVjYXVzZSBcImRlbGV0ZVwiIGlzIGEgcmVzZXJ2ZWQgd29yZFxuXHR9KTtcblxuXHRyZXR1cm4gZG9qby54aHI7XG59KTtcbiIsImRlZmluZShbXSwgZnVuY3Rpb24oKXtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vYXNwZWN0XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciB1bmRlZmluZWQ7XG5cdGZ1bmN0aW9uIGFkdmlzZShkaXNwYXRjaGVyLCB0eXBlLCBhZHZpY2UsIHJlY2VpdmVBcmd1bWVudHMpe1xuXHRcdHZhciBwcmV2aW91cyA9IGRpc3BhdGNoZXJbdHlwZV07XG5cdFx0dmFyIGFyb3VuZCA9IHR5cGUgPT0gXCJhcm91bmRcIjtcblx0XHR2YXIgc2lnbmFsO1xuXHRcdGlmKGFyb3VuZCl7XG5cdFx0XHR2YXIgYWR2aXNlZCA9IGFkdmljZShmdW5jdGlvbigpe1xuXHRcdFx0XHRyZXR1cm4gcHJldmlvdXMuYWR2aWNlKHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9KTtcblx0XHRcdHNpZ25hbCA9IHtcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmKGFkdmlzZWQpe1xuXHRcdFx0XHRcdFx0YWR2aXNlZCA9IGRpc3BhdGNoZXIgPSBhZHZpY2UgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0YWR2aWNlOiBmdW5jdGlvbih0YXJnZXQsIGFyZ3Mpe1xuXHRcdFx0XHRcdHJldHVybiBhZHZpc2VkID9cblx0XHRcdFx0XHRcdGFkdmlzZWQuYXBwbHkodGFyZ2V0LCBhcmdzKSA6ICAvLyBjYWxsZWQgdGhlIGFkdmlzZWQgZnVuY3Rpb25cblx0XHRcdFx0XHRcdHByZXZpb3VzLmFkdmljZSh0YXJnZXQsIGFyZ3MpOyAvLyBjYW5jZWxsZWQsIHNraXAgdG8gbmV4dCBvbmVcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9ZWxzZXtcblx0XHRcdC8vIGNyZWF0ZSB0aGUgcmVtb3ZlIGhhbmRsZXJcblx0XHRcdHNpZ25hbCA9IHtcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmKHNpZ25hbC5hZHZpY2Upe1xuXHRcdFx0XHRcdFx0dmFyIHByZXZpb3VzID0gc2lnbmFsLnByZXZpb3VzO1xuXHRcdFx0XHRcdFx0dmFyIG5leHQgPSBzaWduYWwubmV4dDtcblx0XHRcdFx0XHRcdGlmKCFuZXh0ICYmICFwcmV2aW91cyl7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBkaXNwYXRjaGVyW3R5cGVdO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdGlmKHByZXZpb3VzKXtcblx0XHRcdFx0XHRcdFx0XHRwcmV2aW91cy5uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdFx0ZGlzcGF0Y2hlclt0eXBlXSA9IG5leHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYobmV4dCl7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHJlbW92ZSB0aGUgYWR2aWNlIHRvIHNpZ25hbCB0aGF0IHRoaXMgc2lnbmFsIGhhcyBiZWVuIHJlbW92ZWRcblx0XHRcdFx0XHRcdGRpc3BhdGNoZXIgPSBhZHZpY2UgPSBzaWduYWwuYWR2aWNlID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGlkOiBkaXNwYXRjaGVyLm5leHRJZCsrLFxuXHRcdFx0XHRhZHZpY2U6IGFkdmljZSxcblx0XHRcdFx0cmVjZWl2ZUFyZ3VtZW50czogcmVjZWl2ZUFyZ3VtZW50c1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0aWYocHJldmlvdXMgJiYgIWFyb3VuZCl7XG5cdFx0XHRpZih0eXBlID09IFwiYWZ0ZXJcIil7XG5cdFx0XHRcdC8vIGFkZCB0aGUgbGlzdGVuZXIgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuXHRcdFx0XHQvLyBub3RlIHRoYXQgd2UgaGFkIHRvIGNoYW5nZSB0aGlzIGxvb3AgYSBsaXR0bGUgYml0IHRvIHdvcmthcm91bmQgYSBiaXphcnJlIElFMTAgSklUIGJ1Z1xuXHRcdFx0XHR3aGlsZShwcmV2aW91cy5uZXh0ICYmIChwcmV2aW91cyA9IHByZXZpb3VzLm5leHQpKXt9XG5cdFx0XHRcdHByZXZpb3VzLm5leHQgPSBzaWduYWw7XG5cdFx0XHRcdHNpZ25hbC5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdFx0fWVsc2UgaWYodHlwZSA9PSBcImJlZm9yZVwiKXtcblx0XHRcdFx0Ly8gYWRkIHRvIGJlZ2lubmluZ1xuXHRcdFx0XHRkaXNwYXRjaGVyW3R5cGVdID0gc2lnbmFsO1xuXHRcdFx0XHRzaWduYWwubmV4dCA9IHByZXZpb3VzO1xuXHRcdFx0XHRwcmV2aW91cy5wcmV2aW91cyA9IHNpZ25hbDtcblx0XHRcdH1cblx0XHR9ZWxzZXtcblx0XHRcdC8vIGFyb3VuZCBvciBmaXJzdCBvbmUganVzdCByZXBsYWNlc1xuXHRcdFx0ZGlzcGF0Y2hlclt0eXBlXSA9IHNpZ25hbDtcblx0XHR9XG5cdFx0cmV0dXJuIHNpZ25hbDtcblx0fVxuXHRmdW5jdGlvbiBhc3BlY3QodHlwZSl7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgbWV0aG9kTmFtZSwgYWR2aWNlLCByZWNlaXZlQXJndW1lbnRzKXtcblx0XHRcdHZhciBleGlzdGluZyA9IHRhcmdldFttZXRob2ROYW1lXSwgZGlzcGF0Y2hlcjtcblx0XHRcdGlmKCFleGlzdGluZyB8fCBleGlzdGluZy50YXJnZXQgIT0gdGFyZ2V0KXtcblx0XHRcdFx0Ly8gbm8gZGlzcGF0Y2hlciBpbiBwbGFjZVxuXHRcdFx0XHR0YXJnZXRbbWV0aG9kTmFtZV0gPSBkaXNwYXRjaGVyID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgZXhlY3V0aW9uSWQgPSBkaXNwYXRjaGVyLm5leHRJZDtcblx0XHRcdFx0XHQvLyBiZWZvcmUgYWR2aWNlXG5cdFx0XHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0dmFyIGJlZm9yZSA9IGRpc3BhdGNoZXIuYmVmb3JlO1xuXHRcdFx0XHRcdHdoaWxlKGJlZm9yZSl7XG5cdFx0XHRcdFx0XHRpZihiZWZvcmUuYWR2aWNlKXtcblx0XHRcdFx0XHRcdFx0YXJncyA9IGJlZm9yZS5hZHZpY2UuYXBwbHkodGhpcywgYXJncykgfHwgYXJncztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJlZm9yZSA9IGJlZm9yZS5uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBhcm91bmQgYWR2aWNlXG5cdFx0XHRcdFx0aWYoZGlzcGF0Y2hlci5hcm91bmQpe1xuXHRcdFx0XHRcdFx0dmFyIHJlc3VsdHMgPSBkaXNwYXRjaGVyLmFyb3VuZC5hZHZpY2UodGhpcywgYXJncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGFmdGVyIGFkdmljZVxuXHRcdFx0XHRcdHZhciBhZnRlciA9IGRpc3BhdGNoZXIuYWZ0ZXI7XG5cdFx0XHRcdFx0d2hpbGUoYWZ0ZXIgJiYgYWZ0ZXIuaWQgPCBleGVjdXRpb25JZCl7XG5cdFx0XHRcdFx0XHRpZihhZnRlci5hZHZpY2Upe1xuXHRcdFx0XHRcdFx0XHRpZihhZnRlci5yZWNlaXZlQXJndW1lbnRzKXtcblx0XHRcdFx0XHRcdFx0XHR2YXIgbmV3UmVzdWx0cyA9IGFmdGVyLmFkdmljZS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0XHRcdFx0XHQvLyBjaGFuZ2UgdGhlIHJldHVybiB2YWx1ZSBvbmx5IGlmIGEgbmV3IHZhbHVlIHdhcyByZXR1cm5lZFxuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMgPSBuZXdSZXN1bHRzID09PSB1bmRlZmluZWQgPyByZXN1bHRzIDogbmV3UmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cyA9IGFmdGVyLmFkdmljZS5jYWxsKHRoaXMsIHJlc3VsdHMsIGFyZ3MpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhZnRlciA9IGFmdGVyLm5leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZihleGlzdGluZyl7XG5cdFx0XHRcdFx0ZGlzcGF0Y2hlci5hcm91bmQgPSB7YWR2aWNlOiBmdW5jdGlvbih0YXJnZXQsIGFyZ3Mpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nLmFwcGx5KHRhcmdldCwgYXJncyk7XG5cdFx0XHRcdFx0fX07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGlzcGF0Y2hlci50YXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHRcdGRpc3BhdGNoZXIubmV4dElkID0gZGlzcGF0Y2hlci5uZXh0SWQgfHwgMDtcblx0XHRcdH1cblx0XHRcdHZhciByZXN1bHRzID0gYWR2aXNlKChkaXNwYXRjaGVyIHx8IGV4aXN0aW5nKSwgdHlwZSwgYWR2aWNlLCByZWNlaXZlQXJndW1lbnRzKTtcblx0XHRcdGFkdmljZSA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXHR9XG5cblx0Ly8gVE9ET0M6IGFmdGVyL2JlZm9yZS9hcm91bmQgcmV0dXJuIG9iamVjdFxuXG5cdHZhciBhZnRlciA9IGFzcGVjdChcImFmdGVyXCIpO1xuXHQvKj09PT09XG5cdGFmdGVyID0gZnVuY3Rpb24odGFyZ2V0LCBtZXRob2ROYW1lLCBhZHZpY2UsIHJlY2VpdmVBcmd1bWVudHMpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhlIFwiYWZ0ZXJcIiBleHBvcnQgb2YgdGhlIGFzcGVjdCBtb2R1bGUgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGF0dGFjaFxuXHRcdC8vXHRcdFwiYWZ0ZXJcIiBhZHZpY2UgdG8gYSBtZXRob2QuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZCBhZnRlciB0aGUgb3JpZ2luYWwgbWV0aG9kXG5cdFx0Ly9cdFx0aXMgZXhlY3V0ZWQuIEJ5IGRlZmF1bHQgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggYSBzaW5nbGUgYXJndW1lbnQsIHRoZSByZXR1cm5cblx0XHQvL1x0XHR2YWx1ZSBvZiB0aGUgb3JpZ2luYWwgbWV0aG9kLCBvciB0aGUgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgbGFzdCBleGVjdXRlZCBhZHZpY2UgKGlmIGEgcHJldmlvdXMgb25lIGV4aXN0cykuXG5cdFx0Ly9cdFx0VGhlIGZvdXJ0aCAob3B0aW9uYWwpIGFyZ3VtZW50IGNhbiBiZSBzZXQgdG8gdHJ1ZSB0byBzbyB0aGUgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG9yaWdpbmFsXG5cdFx0Ly9cdFx0YXJndW1lbnRzIChmcm9tIHdoZW4gdGhlIG9yaWdpbmFsIG1ldGhvZCB3YXMgY2FsbGVkKSByYXRoZXIgdGhhbiB0aGUgcmV0dXJuIHZhbHVlLlxuXHRcdC8vXHRcdElmIHRoZXJlIGFyZSBtdWx0aXBsZSBcImFmdGVyXCIgYWR2aXNvcnMsIHRoZXkgYXJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgcmVnaXN0ZXJlZC5cblx0XHQvLyB0YXJnZXQ6IE9iamVjdFxuXHRcdC8vXHRcdFRoaXMgaXMgdGhlIHRhcmdldCBvYmplY3Rcblx0XHQvLyBtZXRob2ROYW1lOiBTdHJpbmdcblx0XHQvL1x0XHRUaGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gYXR0YWNoIHRvLlxuXHRcdC8vIGFkdmljZTogRnVuY3Rpb25cblx0XHQvL1x0XHRUaGlzIGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciB0aGUgb3JpZ2luYWwgbWV0aG9kXG5cdFx0Ly8gcmVjZWl2ZUFyZ3VtZW50czogQm9vbGVhbj9cblx0XHQvL1x0XHRJZiB0aGlzIGlzIHNldCB0byB0cnVlLCB0aGUgYWR2aWNlIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBvcmlnaW5hbCBhcmd1bWVudHMgKGZyb20gd2hlbiB0aGUgb3JpZ2luYWwgbWVodG9kXG5cdFx0Ly9cdFx0d2FzIGNhbGxlZCkgcmF0aGVyIHRoYW4gdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgb3JpZ2luYWwvcHJldmlvdXMgbWV0aG9kLlxuXHRcdC8vIHJldHVybnM6XG5cdFx0Ly9cdFx0QSBzaWduYWwgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBhZHZpY2UuIElmIHJlbW92ZSgpIGlzIGNhbGxlZCBvbiB0aGlzIHNpZ25hbCBvYmplY3QsIGl0IHdpbGxcblx0XHQvL1x0XHRzdG9wIHRoZSBhZHZpY2UgZnVuY3Rpb24gZnJvbSBiZWluZyBleGVjdXRlZC5cblx0fTtcblx0PT09PT0qL1xuXG5cdHZhciBiZWZvcmUgPSBhc3BlY3QoXCJiZWZvcmVcIik7XG5cdC8qPT09PT1cblx0YmVmb3JlID0gZnVuY3Rpb24odGFyZ2V0LCBtZXRob2ROYW1lLCBhZHZpY2Upe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhlIFwiYmVmb3JlXCIgZXhwb3J0IG9mIHRoZSBhc3BlY3QgbW9kdWxlIGlzIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhdHRhY2hcblx0XHQvL1x0XHRcImJlZm9yZVwiIGFkdmljZSB0byBhIG1ldGhvZC4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZSB0aGUgb3JpZ2luYWwgbWV0aG9kXG5cdFx0Ly9cdFx0aXMgZXhlY3V0ZWQuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgYXJndW1lbnRzIHVzZWQgdG8gY2FsbCB0aGUgbWV0aG9kLlxuXHRcdC8vXHRcdFRoaXMgZnVuY3Rpb24gbWF5IG9wdGlvbmFsbHkgcmV0dXJuIGFuIGFycmF5IGFzIHRoZSBuZXcgYXJndW1lbnRzIHRvIHVzZSB0byBjYWxsXG5cdFx0Ly9cdFx0dGhlIG9yaWdpbmFsIG1ldGhvZCAob3IgdGhlIHByZXZpb3VzLCBuZXh0LXRvLWV4ZWN1dGUgYmVmb3JlIGFkdmljZSwgaWYgb25lIGV4aXN0cykuXG5cdFx0Ly9cdFx0SWYgdGhlIGJlZm9yZSBtZXRob2QgZG9lc24ndCByZXR1cm4gYW55dGhpbmcgKHJldHVybnMgdW5kZWZpbmVkKSB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0Ly9cdFx0d2lsbCBiZSBwcmVzZXJ2ZWQuXG5cdFx0Ly9cdFx0SWYgdGhlcmUgYXJlIG11bHRpcGxlIFwiYmVmb3JlXCIgYWR2aXNvcnMsIHRoZXkgYXJlIGV4ZWN1dGVkIGluIHRoZSByZXZlcnNlIG9yZGVyIHRoZXkgd2VyZSByZWdpc3RlcmVkLlxuXHRcdC8vIHRhcmdldDogT2JqZWN0XG5cdFx0Ly9cdFx0VGhpcyBpcyB0aGUgdGFyZ2V0IG9iamVjdFxuXHRcdC8vIG1ldGhvZE5hbWU6IFN0cmluZ1xuXHRcdC8vXHRcdFRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBhdHRhY2ggdG8uXG5cdFx0Ly8gYWR2aWNlOiBGdW5jdGlvblxuXHRcdC8vXHRcdFRoaXMgaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGJlZm9yZSB0aGUgb3JpZ2luYWwgbWV0aG9kXG5cdH07XG5cdD09PT09Ki9cblxuXHR2YXIgYXJvdW5kID0gYXNwZWN0KFwiYXJvdW5kXCIpO1xuXHQvKj09PT09XG5cdCBhcm91bmQgPSBmdW5jdGlvbih0YXJnZXQsIG1ldGhvZE5hbWUsIGFkdmljZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGUgXCJhcm91bmRcIiBleHBvcnQgb2YgdGhlIGFzcGVjdCBtb2R1bGUgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGF0dGFjaFxuXHRcdC8vXHRcdFwiYXJvdW5kXCIgYWR2aWNlIHRvIGEgbWV0aG9kLiBUaGUgYWR2aXNvciBmdW5jdGlvbiBpcyBpbW1lZGlhdGVseSBleGVjdXRlZCB3aGVuXG5cdFx0Ly9cdFx0dGhlIGFyb3VuZCgpIGlzIGNhbGxlZCwgaXMgcGFzc2VkIGEgc2luZ2xlIGFyZ3VtZW50IHRoYXQgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZVxuXHRcdC8vXHRcdGNhbGxlZCB0byBjb250aW51ZSBleGVjdXRpb24gb2YgdGhlIG9yaWdpbmFsIG1ldGhvZCAob3IgdGhlIG5leHQgYXJvdW5kIGFkdmlzb3IpLlxuXHRcdC8vXHRcdFRoZSBhZHZpc29yIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBmdW5jdGlvbiwgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXJcblx0XHQvL1x0XHR0aGUgbWV0aG9kIGlzIGNhbGxlZC4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgYXJndW1lbnRzIHVzZWQgdG8gY2FsbCB0aGUgbWV0aG9kLlxuXHRcdC8vXHRcdFdoYXRldmVyIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB3aWxsIGJlIHJldHVybmVkIGFzIHRoZSByZXN1bHQgb2YgdGhlIG1ldGhvZCBjYWxsICh1bmxlc3MgYWZ0ZXIgYWR2aXNlIGNoYW5nZXMgaXQpLlxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0SWYgdGhlcmUgYXJlIG11bHRpcGxlIFwiYXJvdW5kXCIgYWR2aXNvcnMsIHRoZSBtb3N0IHJlY2VudCBvbmUgaXMgZXhlY3V0ZWQgZmlyc3QsXG5cdFx0Ly9cdFx0d2hpY2ggY2FuIHRoZW4gZGVsZWdhdGUgdG8gdGhlIG5leHQgb25lIGFuZCBzbyBvbi4gRm9yIGV4YW1wbGU6XG5cdFx0Ly9cdFx0fFx0YXJvdW5kKG9iaiwgXCJmb29cIiwgZnVuY3Rpb24ob3JpZ2luYWxGb28pe1xuXHRcdC8vXHRcdHxcdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdFx0fFx0XHRcdHZhciBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdC8vXHRcdHxcdFx0XHR2YXIgcmVzdWx0cyA9IG9yaWdpbmFsRm9vLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGNhbGwgdGhlIG9yaWdpbmFsXG5cdFx0Ly9cdFx0fFx0XHRcdHZhciBlbmQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHQvL1x0XHR8XHRcdFx0Y29uc29sZS5sb2coXCJmb28gZXhlY3V0aW9uIHRvb2sgXCIgKyAoZW5kIC0gc3RhcnQpICsgXCIgbXNcIik7XG5cdFx0Ly9cdFx0fFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdC8vXHRcdHxcdFx0fTtcblx0XHQvL1x0XHR8XHR9KTtcblx0XHQvLyB0YXJnZXQ6IE9iamVjdFxuXHRcdC8vXHRcdFRoaXMgaXMgdGhlIHRhcmdldCBvYmplY3Rcblx0XHQvLyBtZXRob2ROYW1lOiBTdHJpbmdcblx0XHQvL1x0XHRUaGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gYXR0YWNoIHRvLlxuXHRcdC8vIGFkdmljZTogRnVuY3Rpb25cblx0XHQvL1x0XHRUaGlzIGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhcm91bmQgdGhlIG9yaWdpbmFsIG1ldGhvZFxuXHR9O1xuXHQ9PT09PSovXG5cblx0cmV0dXJuIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdHByb3ZpZGVzIGFzcGVjdCBvcmllbnRlZCBwcm9ncmFtbWluZyBmdW5jdGlvbmFsaXR5LCBhbGxvd2luZyBmb3Jcblx0XHQvL1x0XHRvbmUgdG8gYWRkIGJlZm9yZSwgYXJvdW5kLCBvciBhZnRlciBhZHZpY2Ugb24gZXhpc3RpbmcgbWV0aG9kcy5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHRkZWZpbmUoW1wiZG9qby9hc3BlY3RcIl0sIGZ1bmN0aW9uKGFzcGVjdCl7XG5cdFx0Ly9cdHxcdFx0dmFyIHNpZ25hbCA9IGFzcGVjdC5hZnRlcih0YXJnZXRPYmplY3QsIFwibWV0aG9kTmFtZVwiLCBmdW5jdGlvbihzb21lQXJndW1lbnQpe1xuXHRcdC8vXHR8XHRcdFx0dGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIHRhcmdldE9iamVjdC5tZXRob2ROYW1lKCkgaXMgY2FsbGVkLCBhZnRlciB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gaXMgY2FsbGVkXG5cdFx0Ly9cdHxcdFx0fSk7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRUaGUgcmV0dXJuZWQgc2lnbmFsIG9iamVjdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIGFkdmljZS5cblx0XHQvL1x0fFx0c2lnbmFsLnJlbW92ZSgpOyAvLyB0aGlzIHdpbGwgc3RvcCB0aGUgYWR2aWNlIGZyb20gYmVpbmcgZXhlY3V0ZWQgYW55bW9yZVxuXHRcdC8vXHR8XHRhc3BlY3QuYmVmb3JlKHRhcmdldE9iamVjdCwgXCJtZXRob2ROYW1lXCIsIGZ1bmN0aW9uKHNvbWVBcmd1bWVudCl7XG5cdFx0Ly9cdHxcdFx0Ly8gdGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIHRhcmdldE9iamVjdC5tZXRob2ROYW1lKCkgaXMgY2FsbGVkLCBiZWZvcmUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGlzIGNhbGxlZFxuXHRcdC8vXHR8XHQgfSk7XG5cblx0XHRiZWZvcmU6IGJlZm9yZSxcblx0XHRhcm91bmQ6IGFyb3VuZCxcblx0XHRhZnRlcjogYWZ0ZXJcblx0fTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vX2Jhc2Uva2VybmVsXCIsIFwiLi90ZXh0XCJdLCBmdW5jdGlvbihkb2pvKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL2NhY2hlXG5cblx0Ly8gZG9qby5jYWNoZSBpcyBkZWZpbmVkIGluIGRvam8vdGV4dFxuXHRyZXR1cm4gZG9qby5jYWNoZTtcbn0pO1xuIiwiZGVmaW5lKFtcImV4cG9ydHNcIiwgXCIuL3NuaWZmXCIsIFwiLi9fYmFzZS9sYW5nXCIsIFwiLi9kb21cIiwgXCIuL2RvbS1zdHlsZVwiLCBcIi4vZG9tLXByb3BcIl0sXG5cdFx0ZnVuY3Rpb24oZXhwb3J0cywgaGFzLCBsYW5nLCBkb20sIHN0eWxlLCBwcm9wKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL2RvbS1hdHRyXG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdFRoaXMgbW9kdWxlIGRlZmluZXMgdGhlIGNvcmUgZG9qbyBET00gYXR0cmlidXRlcyBBUEkuXG5cblx0Ly8gVE9ET0M6IHN1bW1hcnkgbm90IHNob3dpbmcgdXAgaW4gb3V0cHV0IHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Nub3Zlci9qcy1kb2MtcGFyc2UvaXNzdWVzLzQyXG5cblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0Ly8gRWxlbWVudCBhdHRyaWJ1dGUgRnVuY3Rpb25zXG5cdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0Ly8gVGhpcyBtb2R1bGUgd2lsbCBiZSBvYnNvbGV0ZSBzb29uLiBVc2UgZG9qby9wcm9wIGluc3RlYWQuXG5cblx0Ly8gZG9qby9kb20tYXR0ci5nZXQoKSBzaG91bGQgY29uZm9ybSB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1Db3JlL1xuXG5cdC8vIGF0dHJpYnV0ZS1yZWxhdGVkIGZ1bmN0aW9ucyAodG8gYmUgb2Jzb2xldGUgc29vbilcblx0dmFyIGZvcmNlUHJvcE5hbWVzID0ge1xuXHRcdFx0aW5uZXJIVE1MOlx0MSxcblx0XHRcdHRleHRDb250ZW50OjEsXG5cdFx0XHRjbGFzc05hbWU6XHQxLFxuXHRcdFx0aHRtbEZvcjpcdGhhcyhcImllXCIpID8gMSA6IDAsXG5cdFx0XHR2YWx1ZTpcdFx0MVxuXHRcdH0sXG5cdFx0YXR0ck5hbWVzID0ge1xuXHRcdFx0Ly8gb3JpZ2luYWwgYXR0cmlidXRlIG5hbWVzXG5cdFx0XHRjbGFzc25hbWU6IFwiY2xhc3NcIixcblx0XHRcdGh0bWxmb3I6IFwiZm9yXCIsXG5cdFx0XHQvLyBmb3IgSUVcblx0XHRcdHRhYmluZGV4OiBcInRhYkluZGV4XCIsXG5cdFx0XHRyZWFkb25seTogXCJyZWFkT25seVwiXG5cdFx0fTtcblxuXHRmdW5jdGlvbiBfaGFzQXR0cihub2RlLCBuYW1lKXtcblx0XHR2YXIgYXR0ciA9IG5vZGUuZ2V0QXR0cmlidXRlTm9kZSAmJiBub2RlLmdldEF0dHJpYnV0ZU5vZGUobmFtZSk7XG5cdFx0cmV0dXJuICEhYXR0ciAmJiBhdHRyLnNwZWNpZmllZDsgLy8gQm9vbGVhblxuXHR9XG5cdFxuXHQvLyBUaGVyZSBpcyBhIGRpZmZlcmVuY2UgaW4gdGhlIHByZXNlbmNlIG9mIGNlcnRhaW4gcHJvcGVydGllcyBhbmQgdGhlaXIgZGVmYXVsdCB2YWx1ZXNcblx0Ly8gYmV0d2VlbiBicm93c2Vycy4gRm9yIGV4YW1wbGUsIG9uIElFIFwiZGlzYWJsZWRcIiBpcyBwcmVzZW50IG9uIGFsbCBlbGVtZW50cyxcblx0Ly8gYnV0IGl0IGlzIHZhbHVlIGlzIFwiZmFsc2VcIjsgXCJ0YWJJbmRleFwiIG9mIDxkaXY+IHJldHVybnMgMCBieSBkZWZhdWx0IG9uIElFLCB5ZXQgb3RoZXIgYnJvd3NlcnNcblx0Ly8gY2FuIHJldHVybiAtMS5cblxuXHRleHBvcnRzLmhhcyA9IGZ1bmN0aW9uIGhhc0F0dHIoLypET01Ob2RlfFN0cmluZyovIG5vZGUsIC8qU3RyaW5nKi8gbmFtZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRSZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3RlZCBhdHRyaWJ1dGUgaXMgc3BlY2lmaWVkIG9uIHRoZVxuXHRcdC8vXHRcdGdpdmVuIGVsZW1lbnQsIGFuZCBmYWxzZSBvdGhlcndpc2UuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvL1x0XHRpZCBvciByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdG8gY2hlY2tcblx0XHQvLyBuYW1lOiBTdHJpbmdcblx0XHQvL1x0XHR0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG5cdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXHRcdC8vXHRcdHRydWUgaWYgdGhlIHJlcXVlc3RlZCBhdHRyaWJ1dGUgaXMgc3BlY2lmaWVkIG9uIHRoZVxuXHRcdC8vXHRcdGdpdmVuIGVsZW1lbnQsIGFuZCBmYWxzZSBvdGhlcndpc2VcblxuXHRcdHZhciBsYyA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gISFmb3JjZVByb3BOYW1lc1twcm9wLm5hbWVzW2xjXSB8fCBuYW1lXSB8fCBfaGFzQXR0cihkb20uYnlJZChub2RlKSwgYXR0ck5hbWVzW2xjXSB8fCBuYW1lKTtcdC8vIEJvb2xlYW5cblx0fTtcblxuXHRleHBvcnRzLmdldCA9IGZ1bmN0aW9uIGdldEF0dHIoLypET01Ob2RlfFN0cmluZyovIG5vZGUsIC8qU3RyaW5nKi8gbmFtZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRHZXRzIGFuIGF0dHJpYnV0ZSBvbiBhbiBIVE1MIGVsZW1lbnQuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0SGFuZGxlcyBub3JtYWxpemVkIGdldHRpbmcgb2YgYXR0cmlidXRlcyBvbiBET00gTm9kZXMuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvL1x0XHRpZCBvciByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdG8gZ2V0IHRoZSBhdHRyaWJ1dGUgb25cblx0XHQvLyBuYW1lOiBTdHJpbmdcblx0XHQvL1x0XHR0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGdldC5cblx0XHQvLyByZXR1cm5zOlxuXHRcdC8vXHRcdHRoZSB2YWx1ZSBvZiB0aGUgcmVxdWVzdGVkIGF0dHJpYnV0ZSBvciBudWxsIGlmIHRoYXQgYXR0cmlidXRlIGRvZXMgbm90IGhhdmUgYSBzcGVjaWZpZWQgb3Jcblx0XHQvL1x0XHRkZWZhdWx0IHZhbHVlO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0Ly8gZ2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBcImZvb1wiIGF0dHJpYnV0ZSBvbiBhIG5vZGVcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1hdHRyXCIsIFwiZG9qby9kb21cIl0sIGZ1bmN0aW9uKGRvbUF0dHIsIGRvbSl7XG5cdFx0Ly9cdHxcdFx0ZG9tQXR0ci5nZXQoZG9tLmJ5SWQoXCJub2RlSWRcIiksIFwiZm9vXCIpO1xuXHRcdC8vXHR8XHRcdC8vIG9yIHdlIGNhbiBqdXN0IHBhc3MgdGhlIGlkOlxuXHRcdC8vXHR8XHRcdGRvbUF0dHIuZ2V0KFwibm9kZUlkXCIsIFwiZm9vXCIpO1xuXHRcdC8vXHR8XHR9KTtcdFxuXHRcdC8vXHR8XHRcblxuXHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHR2YXIgbGMgPSBuYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRwcm9wTmFtZSA9IHByb3AubmFtZXNbbGNdIHx8IG5hbWUsXG5cdFx0XHRmb3JjZVByb3AgPSBmb3JjZVByb3BOYW1lc1twcm9wTmFtZV0sXG5cdFx0XHR2YWx1ZSA9IG5vZGVbcHJvcE5hbWVdO1x0XHQvLyBzaG91bGQgd2UgYWNjZXNzIHRoaXMgYXR0cmlidXRlIHZpYSBhIHByb3BlcnR5IG9yIHZpYSBnZXRBdHRyaWJ1dGUoKT9cblxuXHRcdGlmKGZvcmNlUHJvcCAmJiB0eXBlb2YgdmFsdWUgIT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0XHQvLyBub2RlJ3MgcHJvcGVydHlcblx0XHRcdHJldHVybiB2YWx1ZTtcdC8vIEFueXRoaW5nXG5cdFx0fVxuXHRcdFxuXHRcdGlmKHByb3BOYW1lID09IFwidGV4dENvbnRlbnRcIil7XG5cdFx0XHRyZXR1cm4gcHJvcC5nZXQobm9kZSwgcHJvcE5hbWUpO1xuXHRcdH1cblx0XHRcblx0XHRpZihwcm9wTmFtZSAhPSBcImhyZWZcIiAmJiAodHlwZW9mIHZhbHVlID09IFwiYm9vbGVhblwiIHx8IGxhbmcuaXNGdW5jdGlvbih2YWx1ZSkpKXtcblx0XHRcdC8vIG5vZGUncyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHZhbHVlO1x0Ly8gQW55dGhpbmdcblx0XHR9XG5cdFx0Ly8gbm9kZSdzIGF0dHJpYnV0ZVxuXHRcdC8vIHdlIG5lZWQgX2hhc0F0dHIoKSBoZXJlIHRvIGd1YXJkIGFnYWluc3QgSUUgcmV0dXJuaW5nIGEgZGVmYXVsdCB2YWx1ZVxuXHRcdHZhciBhdHRyTmFtZSA9IGF0dHJOYW1lc1tsY10gfHwgbmFtZTtcblx0XHRyZXR1cm4gX2hhc0F0dHIobm9kZSwgYXR0ck5hbWUpID8gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpIDogbnVsbDsgLy8gQW55dGhpbmdcblx0fTtcblxuXHRleHBvcnRzLnNldCA9IGZ1bmN0aW9uIHNldEF0dHIoLypET01Ob2RlfFN0cmluZyovIG5vZGUsIC8qU3RyaW5nfE9iamVjdCovIG5hbWUsIC8qU3RyaW5nPyovIHZhbHVlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNldHMgYW4gYXR0cmlidXRlIG9uIGFuIEhUTUwgZWxlbWVudC5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRIYW5kbGVzIG5vcm1hbGl6ZWQgc2V0dGluZyBvZiBhdHRyaWJ1dGVzIG9uIERPTSBOb2Rlcy5cblx0XHQvL1xuXHRcdC8vXHRcdFdoZW4gcGFzc2luZyBmdW5jdGlvbnMgYXMgdmFsdWVzLCBub3RlIHRoYXQgdGhleSB3aWxsIG5vdCBiZVxuXHRcdC8vXHRcdGRpcmVjdGx5IGFzc2lnbmVkIHRvIHNsb3RzIG9uIHRoZSBub2RlLCBidXQgcmF0aGVyIHRoZSBkZWZhdWx0XG5cdFx0Ly9cdFx0YmVoYXZpb3Igd2lsbCBiZSByZW1vdmVkIGFuZCB0aGUgbmV3IGJlaGF2aW9yIHdpbGwgYmUgYWRkZWRcblx0XHQvL1x0XHR1c2luZyBgZG9qby5jb25uZWN0KClgLCBtZWFuaW5nIHRoYXQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0aWVzXG5cdFx0Ly9cdFx0d2lsbCBiZSBub3JtYWxpemVkIGFuZCB0aGF0IHNvbWUgY2F2ZWF0cyB3aXRoIHJlZ2FyZHMgdG9cblx0XHQvL1x0XHRub24tc3RhbmRhcmQgYmVoYXZpb3JzIGZvciBvbnN1Ym1pdCBhcHBseS4gTmFtZWx5IHRoYXQgeW91XG5cdFx0Ly9cdFx0c2hvdWxkIGNhbmNlbCBmb3JtIHN1Ym1pc3Npb24gdXNpbmcgYGRvam8uc3RvcEV2ZW50KClgIG9uIHRoZVxuXHRcdC8vXHRcdHBhc3NlZCBldmVudCBvYmplY3QgaW5zdGVhZCBvZiByZXR1cm5pbmcgYSBib29sZWFuIHZhbHVlIGZyb21cblx0XHQvL1x0XHR0aGUgaGFuZGxlciBpdHNlbGYuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvL1x0XHRpZCBvciByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgb25cblx0XHQvLyBuYW1lOiBTdHJpbmd8T2JqZWN0XG5cdFx0Ly9cdFx0dGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBzZXQsIG9yIGEgaGFzaCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gc2V0LlxuXHRcdC8vIHZhbHVlOiBTdHJpbmc/XG5cdFx0Ly9cdFx0dGhlIHZhbHVlIHRvIHNldCBmb3IgdGhlIGF0dHJpYnV0ZSwgaWYgdGhlIG5hbWUgaXMgYSBzdHJpbmcuXG5cdFx0Ly8gcmV0dXJuczpcblx0XHQvL1x0XHR0aGUgRE9NIG5vZGVcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdHxcdC8vIHVzZSBhdHRyKCkgdG8gc2V0IHRoZSB0YWIgaW5kZXhcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1hdHRyXCJdLCBmdW5jdGlvbihkb21BdHRyKXtcblx0XHQvL1x0fFx0XHRkb21BdHRyLnNldChcIm5vZGVJZFwiLCBcInRhYkluZGV4XCIsIDMpO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFNldCBtdWx0aXBsZSB2YWx1ZXMgYXQgb25jZSwgaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWF0dHJcIl0sXG5cdFx0Ly9cdHxcdGZ1bmN0aW9uKGRvbUF0dHIpe1xuXHRcdC8vXHR8XHRcdGRvbUF0dHIuc2V0KFwiZm9ybUlkXCIsIHtcblx0XHQvL1x0fFx0XHRcdFwiZm9vXCI6IFwiYmFyXCIsXG5cdFx0Ly9cdHxcdFx0XHRcInRhYkluZGV4XCI6IC0xLFxuXHRcdC8vXHR8XHRcdFx0XCJtZXRob2RcIjogXCJQT1NUXCJcblx0XHQvL1x0fFx0XHR9XG5cdFx0Ly9cdHxcdH0pO1xuXG5cdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMil7IC8vIGlubGluZSdkIHR5cGUgY2hlY2tcblx0XHRcdC8vIHRoZSBvYmplY3QgZm9ybSBvZiBzZXR0ZXI6IHRoZSAybmQgYXJndW1lbnQgaXMgYSBkaWN0aW9uYXJ5XG5cdFx0XHRmb3IodmFyIHggaW4gbmFtZSl7XG5cdFx0XHRcdGV4cG9ydHMuc2V0KG5vZGUsIHgsIG5hbWVbeF0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5vZGU7IC8vIERvbU5vZGVcblx0XHR9XG5cdFx0dmFyIGxjID0gbmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0cHJvcE5hbWUgPSBwcm9wLm5hbWVzW2xjXSB8fCBuYW1lLFxuXHRcdFx0Zm9yY2VQcm9wID0gZm9yY2VQcm9wTmFtZXNbcHJvcE5hbWVdO1xuXHRcdGlmKHByb3BOYW1lID09IFwic3R5bGVcIiAmJiB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIil7IC8vIGlubGluZSdkIHR5cGUgY2hlY2tcblx0XHRcdC8vIHNwZWNpYWwgY2FzZTogc2V0dGluZyBhIHN0eWxlXG5cdFx0XHRzdHlsZS5zZXQobm9kZSwgdmFsdWUpO1xuXHRcdFx0cmV0dXJuIG5vZGU7IC8vIERvbU5vZGVcblx0XHR9XG5cdFx0aWYoZm9yY2VQcm9wIHx8IHR5cGVvZiB2YWx1ZSA9PSBcImJvb2xlYW5cIiB8fCBsYW5nLmlzRnVuY3Rpb24odmFsdWUpKXtcblx0XHRcdHJldHVybiBwcm9wLnNldChub2RlLCBuYW1lLCB2YWx1ZSk7XG5cdFx0fVxuXHRcdC8vIG5vZGUncyBhdHRyaWJ1dGVcblx0XHRub2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZXNbbGNdIHx8IG5hbWUsIHZhbHVlKTtcblx0XHRyZXR1cm4gbm9kZTsgLy8gRG9tTm9kZVxuXHR9O1xuXG5cdGV4cG9ydHMucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlQXR0cigvKkRPTU5vZGV8U3RyaW5nKi8gbm9kZSwgLypTdHJpbmcqLyBuYW1lKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gYW4gSFRNTCBlbGVtZW50LlxuXHRcdC8vIG5vZGU6IERPTU5vZGV8U3RyaW5nXG5cdFx0Ly9cdFx0aWQgb3IgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRvIHJlbW92ZSB0aGUgYXR0cmlidXRlIGZyb21cblx0XHQvLyBuYW1lOiBTdHJpbmdcblx0XHQvL1x0XHR0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHJlbW92ZVxuXG5cdFx0ZG9tLmJ5SWQobm9kZSkucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lc1tuYW1lLnRvTG93ZXJDYXNlKCldIHx8IG5hbWUpO1xuXHR9O1xuXG5cdGV4cG9ydHMuZ2V0Tm9kZVByb3AgPSBmdW5jdGlvbiBnZXROb2RlUHJvcCgvKkRvbU5vZGV8U3RyaW5nKi8gbm9kZSwgLypTdHJpbmcqLyBuYW1lKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJldHVybnMgYW4gZWZmZWN0aXZlIHZhbHVlIG9mIGEgcHJvcGVydHkgb3IgYW4gYXR0cmlidXRlLlxuXHRcdC8vIG5vZGU6IERPTU5vZGV8U3RyaW5nXG5cdFx0Ly9cdFx0aWQgb3IgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRvIHJlbW92ZSB0aGUgYXR0cmlidXRlIGZyb21cblx0XHQvLyBuYW1lOiBTdHJpbmdcblx0XHQvL1x0XHR0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG5cdFx0Ly8gcmV0dXJuczpcblx0XHQvL1x0XHR0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuXG5cdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdHZhciBsYyA9IG5hbWUudG9Mb3dlckNhc2UoKSwgcHJvcE5hbWUgPSBwcm9wLm5hbWVzW2xjXSB8fCBuYW1lO1xuXHRcdGlmKChwcm9wTmFtZSBpbiBub2RlKSAmJiBwcm9wTmFtZSAhPSBcImhyZWZcIil7XG5cdFx0XHQvLyBub2RlJ3MgcHJvcGVydHlcblx0XHRcdHJldHVybiBub2RlW3Byb3BOYW1lXTtcdC8vIEFueXRoaW5nXG5cdFx0fVxuXHRcdC8vIG5vZGUncyBhdHRyaWJ1dGVcblx0XHR2YXIgYXR0ck5hbWUgPSBhdHRyTmFtZXNbbGNdIHx8IG5hbWU7XG5cdFx0cmV0dXJuIF9oYXNBdHRyKG5vZGUsIGF0dHJOYW1lKSA/IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSA6IG51bGw7IC8vIEFueXRoaW5nXG5cdH07XG59KTtcbiIsImRlZmluZShbXCIuL19iYXNlL2xhbmdcIiwgXCIuL19iYXNlL2FycmF5XCIsIFwiLi9kb21cIl0sIGZ1bmN0aW9uKGxhbmcsIGFycmF5LCBkb20pe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vZG9tLWNsYXNzXG5cblx0dmFyIGNsYXNzTmFtZSA9IFwiY2xhc3NOYW1lXCI7XG5cblx0LyogUGFydCBJIG9mIGNsYXNzTGlzdC1iYXNlZCBpbXBsZW1lbnRhdGlvbiBpcyBwcmVzZXJ2ZWQgaGVyZSBmb3IgcG9zdGVyaXR5XG5cdHZhciBjbGFzc0xpc3QgPSBcImNsYXNzTGlzdFwiO1xuXHRoYXMuYWRkKFwiZG9tLWNsYXNzTGlzdFwiLCBmdW5jdGlvbigpe1xuXHRcdHJldHVybiBjbGFzc0xpc3QgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG5cdH0pO1xuXHQqL1xuXG5cdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdC8vIChDU1MpIENsYXNzIEZ1bmN0aW9uc1xuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdHZhciBjbHMsIC8vIGV4cG9ydHMgb2JqZWN0XG5cdFx0c3BhY2VzID0gL1xccysvLCBhMSA9IFtcIlwiXTtcblxuXHRmdW5jdGlvbiBzdHIyYXJyYXkocyl7XG5cdFx0aWYodHlwZW9mIHMgPT0gXCJzdHJpbmdcIiB8fCBzIGluc3RhbmNlb2YgU3RyaW5nKXtcblx0XHRcdGlmKHMgJiYgIXNwYWNlcy50ZXN0KHMpKXtcblx0XHRcdFx0YTFbMF0gPSBzO1xuXHRcdFx0XHRyZXR1cm4gYTE7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IHMuc3BsaXQoc3BhY2VzKTtcblx0XHRcdGlmKGEubGVuZ3RoICYmICFhWzBdKXtcblx0XHRcdFx0YS5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYoYS5sZW5ndGggJiYgIWFbYS5sZW5ndGggLSAxXSl7XG5cdFx0XHRcdGEucG9wKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9XG5cdFx0Ly8gYXNzdW1lZCB0byBiZSBhbiBhcnJheVxuXHRcdGlmKCFzKXtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5LmZpbHRlcihzLCBmdW5jdGlvbih4KXsgcmV0dXJuIHg7IH0pO1xuXHR9XG5cblx0LyogUGFydCBJSSBvZiBjbGFzc0xpc3QtYmFzZWQgaW1wbGVtZW50YXRpb24gaXMgcHJlc2VydmVkIGhlcmUgZm9yIHBvc3Rlcml0eVxuXHRpZihoYXMoXCJkb20tY2xhc3NMaXN0XCIpKXtcblx0XHQvLyBuZXcgY2xhc3NMaXN0IHZlcnNpb25cblx0XHRjbHMgPSB7XG5cdFx0XHRjb250YWluczogZnVuY3Rpb24gY29udGFpbnNDbGFzcyhub2RlLCBjbGFzc1N0cil7XG5cdFx0XHRcdHZhciBjbHNsc3QgPSBjbGFzc1N0ciAmJiBkb20uYnlJZChub2RlKVtjbGFzc0xpc3RdO1xuXHRcdFx0XHRyZXR1cm4gY2xzbHN0ICYmIGNsc2xzdC5jb250YWlucyhjbGFzc1N0cik7IC8vIEJvb2xlYW5cblx0XHRcdH0sXG5cblx0XHRcdGFkZDogZnVuY3Rpb24gYWRkQ2xhc3Mobm9kZSwgY2xhc3NTdHIpe1xuXHRcdFx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0XHRcdGNsYXNzU3RyID0gc3RyMmFycmF5KGNsYXNzU3RyKTtcblx0XHRcdFx0Zm9yKHZhciBpID0gMCwgbGVuID0gY2xhc3NTdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpe1xuXHRcdFx0XHRcdG5vZGVbY2xhc3NMaXN0XS5hZGQoY2xhc3NTdHJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzU3RyKXtcblx0XHRcdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdFx0XHRpZihjbGFzc1N0ciA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0XHRub2RlW2NsYXNzTmFtZV0gPSBcIlwiO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRjbGFzc1N0ciA9IHN0cjJhcnJheShjbGFzc1N0cik7XG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMCwgbGVuID0gY2xhc3NTdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpe1xuXHRcdFx0XHRcdFx0bm9kZVtjbGFzc0xpc3RdLnJlbW92ZShjbGFzc1N0cltpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRyZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlQ2xhc3Mobm9kZSwgYWRkQ2xhc3NTdHIsIHJlbW92ZUNsYXNzU3RyKXtcblx0XHRcdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdFx0XHRpZihyZW1vdmVDbGFzc1N0ciA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0XHRub2RlW2NsYXNzTmFtZV0gPSBcIlwiO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRyZW1vdmVDbGFzc1N0ciA9IHN0cjJhcnJheShyZW1vdmVDbGFzc1N0cik7XG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMCwgbGVuID0gcmVtb3ZlQ2xhc3NTdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpe1xuXHRcdFx0XHRcdFx0bm9kZVtjbGFzc0xpc3RdLnJlbW92ZShyZW1vdmVDbGFzc1N0cltpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGFkZENsYXNzU3RyID0gc3RyMmFycmF5KGFkZENsYXNzU3RyKTtcblx0XHRcdFx0Zm9yKGkgPSAwLCBsZW4gPSBhZGRDbGFzc1N0ci5sZW5ndGg7IGkgPCBsZW47ICsraSl7XG5cdFx0XHRcdFx0bm9kZVtjbGFzc0xpc3RdLmFkZChhZGRDbGFzc1N0cltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlQ2xhc3Mobm9kZSwgY2xhc3NTdHIsIGNvbmRpdGlvbil7XG5cdFx0XHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHRcdFx0aWYoY29uZGl0aW9uID09PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRcdGNsYXNzU3RyID0gc3RyMmFycmF5KGNsYXNzU3RyKTtcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwLCBsZW4gPSBjbGFzc1N0ci5sZW5ndGg7IGkgPCBsZW47ICsraSl7XG5cdFx0XHRcdFx0XHRub2RlW2NsYXNzTGlzdF0udG9nZ2xlKGNsYXNzU3RyW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGNsc1tjb25kaXRpb24gPyBcImFkZFwiIDogXCJyZW1vdmVcIl0obm9kZSwgY2xhc3NTdHIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb25kaXRpb247ICAgLy8gQm9vbGVhblxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQqL1xuXG5cdC8vIHJlZ3VsYXIgRE9NIHZlcnNpb25cblx0dmFyIGZha2VOb2RlID0ge307ICAvLyBmb3IgZWZmZWN0aXZlIHJlcGxhY2VtZW50XG5cdGNscyA9IHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoaXMgbW9kdWxlIGRlZmluZXMgdGhlIGNvcmUgZG9qbyBET00gY2xhc3MgQVBJLlxuXG5cdFx0Y29udGFpbnM6IGZ1bmN0aW9uIGNvbnRhaW5zQ2xhc3MoLypEb21Ob2RlfFN0cmluZyovIG5vZGUsIC8qU3RyaW5nKi8gY2xhc3NTdHIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHNwZWNpZmllZCBjbGFzc2VzIGFyZSBhIHBvcnRpb24gb2YgdGhlXG5cdFx0XHQvL1x0XHRjbGFzcyBsaXN0IGN1cnJlbnRseSBhcHBsaWVkIHRvIHRoZSBub2RlLlxuXHRcdFx0Ly8gbm9kZTogU3RyaW5nfERPTU5vZGVcblx0XHRcdC8vXHRcdFN0cmluZyBJRCBvciBEb21Ob2RlIHJlZmVyZW5jZSB0byBjaGVjayB0aGUgY2xhc3MgZm9yLlxuXHRcdFx0Ly8gY2xhc3NTdHI6IFN0cmluZ1xuXHRcdFx0Ly9cdFx0QSBzdHJpbmcgY2xhc3MgbmFtZSB0byBsb29rIGZvci5cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHREbyBzb21ldGhpbmcgaWYgYSBub2RlIHdpdGggaWQ9XCJzb21lTm9kZVwiIGhhcyBjbGFzcz1cImFTaWxseUNsYXNzTmFtZVwiIHByZXNlbnRcblx0XHRcdC8vXHR8XHRpZihkb21DbGFzcy5jb250YWlucyhcInNvbWVOb2RlXCIsXCJhU2lsbHlDbGFzc05hbWVcIikpeyAuLi4gfVxuXG5cdFx0XHRyZXR1cm4gKChcIiBcIiArIGRvbS5ieUlkKG5vZGUpW2NsYXNzTmFtZV0gKyBcIiBcIikuaW5kZXhPZihcIiBcIiArIGNsYXNzU3RyICsgXCIgXCIpID49IDApOyAvLyBCb29sZWFuXG5cdFx0fSxcblxuXHRcdGFkZDogZnVuY3Rpb24gYWRkQ2xhc3MoLypEb21Ob2RlfFN0cmluZyovIG5vZGUsIC8qU3RyaW5nfEFycmF5Ki8gY2xhc3NTdHIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEFkZHMgdGhlIHNwZWNpZmllZCBjbGFzc2VzIHRvIHRoZSBlbmQgb2YgdGhlIGNsYXNzIGxpc3Qgb24gdGhlXG5cdFx0XHQvL1x0XHRwYXNzZWQgbm9kZS4gV2lsbCBub3QgcmUtYXBwbHkgZHVwbGljYXRlIGNsYXNzZXMuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gbm9kZTogU3RyaW5nfERPTU5vZGVcblx0XHRcdC8vXHRcdFN0cmluZyBJRCBvciBEb21Ob2RlIHJlZmVyZW5jZSB0byBhZGQgYSBjbGFzcyBzdHJpbmcgdG9vXG5cdFx0XHQvL1xuXHRcdFx0Ly8gY2xhc3NTdHI6IFN0cmluZ3xBcnJheVxuXHRcdFx0Ly9cdFx0QSBTdHJpbmcgY2xhc3MgbmFtZSB0byBhZGQsIG9yIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIGNsYXNzIG5hbWVzLFxuXHRcdFx0Ly9cdFx0b3IgYW4gYXJyYXkgb2YgY2xhc3MgbmFtZXMuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdEFkZCBhIGNsYXNzIHRvIHNvbWUgbm9kZTpcblx0XHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNsYXNzXCJdLCBmdW5jdGlvbihkb21DbGFzcyl7XG5cdFx0XHQvL1x0fFx0XHRkb21DbGFzcy5hZGQoXCJzb21lTm9kZVwiLCBcImFuZXdDbGFzc1wiKTtcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0QWRkIHR3byBjbGFzc2VzIGF0IG9uY2U6XG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jbGFzc1wiXSwgZnVuY3Rpb24oZG9tQ2xhc3Mpe1xuXHRcdFx0Ly9cdHxcdFx0ZG9tQ2xhc3MuYWRkKFwic29tZU5vZGVcIiwgXCJmaXJzdENsYXNzIHNlY29uZENsYXNzXCIpO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRBZGQgdHdvIGNsYXNzZXMgYXQgb25jZSAodXNpbmcgYXJyYXkpOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY2xhc3NcIl0sIGZ1bmN0aW9uKGRvbUNsYXNzKXtcblx0XHRcdC8vXHR8XHRcdGRvbUNsYXNzLmFkZChcInNvbWVOb2RlXCIsIFtcImZpcnN0Q2xhc3NcIiwgXCJzZWNvbmRDbGFzc1wiXSk7XG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdEF2YWlsYWJsZSBpbiBgZG9qby9Ob2RlTGlzdGAgZm9yIG11bHRpcGxlIGFkZGl0aW9uc1xuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9xdWVyeVwiXSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdFx0Ly9cdHxcdFx0cXVlcnkoXCJ1bCA+IGxpXCIpLmFkZENsYXNzKFwiZmlyc3RMZXZlbFwiKTtcblx0XHRcdC8vXHR8XHR9KTtcblxuXHRcdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdFx0Y2xhc3NTdHIgPSBzdHIyYXJyYXkoY2xhc3NTdHIpO1xuXHRcdFx0dmFyIGNscyA9IG5vZGVbY2xhc3NOYW1lXSwgb2xkTGVuO1xuXHRcdFx0Y2xzID0gY2xzID8gXCIgXCIgKyBjbHMgKyBcIiBcIiA6IFwiIFwiO1xuXHRcdFx0b2xkTGVuID0gY2xzLmxlbmd0aDtcblx0XHRcdGZvcih2YXIgaSA9IDAsIGxlbiA9IGNsYXNzU3RyLmxlbmd0aCwgYzsgaSA8IGxlbjsgKytpKXtcblx0XHRcdFx0YyA9IGNsYXNzU3RyW2ldO1xuXHRcdFx0XHRpZihjICYmIGNscy5pbmRleE9mKFwiIFwiICsgYyArIFwiIFwiKSA8IDApe1xuXHRcdFx0XHRcdGNscyArPSBjICsgXCIgXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKG9sZExlbiA8IGNscy5sZW5ndGgpe1xuXHRcdFx0XHRub2RlW2NsYXNzTmFtZV0gPSBjbHMuc3Vic3RyKDEsIGNscy5sZW5ndGggLSAyKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmVDbGFzcygvKkRvbU5vZGV8U3RyaW5nKi8gbm9kZSwgLypTdHJpbmd8QXJyYXk/Ki8gY2xhc3NTdHIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlbW92ZXMgdGhlIHNwZWNpZmllZCBjbGFzc2VzIGZyb20gbm9kZS4gTm8gYGNvbnRhaW5zKClgXG5cdFx0XHQvL1x0XHRjaGVjayBpcyByZXF1aXJlZC5cblx0XHRcdC8vXG5cdFx0XHQvLyBub2RlOiBTdHJpbmd8RE9NTm9kZVxuXHRcdFx0Ly9cdFx0U3RyaW5nIElEIG9yIERvbU5vZGUgcmVmZXJlbmNlIHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbS5cblx0XHRcdC8vXG5cdFx0XHQvLyBjbGFzc1N0cjogU3RyaW5nfEFycmF5XG5cdFx0XHQvL1x0XHRBbiBvcHRpb25hbCBTdHJpbmcgY2xhc3MgbmFtZSB0byByZW1vdmUsIG9yIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkXG5cdFx0XHQvL1x0XHRjbGFzcyBuYW1lcywgb3IgYW4gYXJyYXkgb2YgY2xhc3MgbmFtZXMuIElmIG9taXR0ZWQsIGFsbCBjbGFzcyBuYW1lc1xuXHRcdFx0Ly9cdFx0d2lsbCBiZSBkZWxldGVkLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRSZW1vdmUgYSBjbGFzcyBmcm9tIHNvbWUgbm9kZTpcblx0XHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNsYXNzXCJdLCBmdW5jdGlvbihkb21DbGFzcyl7XG5cdFx0XHQvL1x0fFx0XHRkb21DbGFzcy5yZW1vdmUoXCJzb21lTm9kZVwiLCBcImZpcnN0Q2xhc3NcIik7XG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdFJlbW92ZSB0d28gY2xhc3NlcyBmcm9tIHNvbWUgbm9kZTpcblx0XHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNsYXNzXCJdLCBmdW5jdGlvbihkb21DbGFzcyl7XG5cdFx0XHQvL1x0fFx0XHRkb21DbGFzcy5yZW1vdmUoXCJzb21lTm9kZVwiLCBcImZpcnN0Q2xhc3Mgc2Vjb25kQ2xhc3NcIik7XG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdFJlbW92ZSB0d28gY2xhc3NlcyBmcm9tIHNvbWUgbm9kZSAodXNpbmcgYXJyYXkpOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY2xhc3NcIl0sIGZ1bmN0aW9uKGRvbUNsYXNzKXtcblx0XHRcdC8vXHR8XHRcdGRvbUNsYXNzLnJlbW92ZShcInNvbWVOb2RlXCIsIFtcImZpcnN0Q2xhc3NcIiwgXCJzZWNvbmRDbGFzc1wiXSk7XG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdFJlbW92ZSBhbGwgY2xhc3NlcyBmcm9tIHNvbWUgbm9kZTpcblx0XHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNsYXNzXCJdLCBmdW5jdGlvbihkb21DbGFzcyl7XG5cdFx0XHQvL1x0fFx0XHRkb21DbGFzcy5yZW1vdmUoXCJzb21lTm9kZVwiKTtcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0QXZhaWxhYmxlIGluIGBkb2pvL05vZGVMaXN0YCBmb3IgbXVsdGlwbGUgcmVtb3ZhbFxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9xdWVyeVwiXSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdFx0Ly9cdHxcdFx0cXVlcnkoXCJ1bCA+IGxpXCIpLnJlbW92ZUNsYXNzKFwiZm9vXCIpO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXG5cdFx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0XHR2YXIgY2xzO1xuXHRcdFx0aWYoY2xhc3NTdHIgIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdGNsYXNzU3RyID0gc3RyMmFycmF5KGNsYXNzU3RyKTtcblx0XHRcdFx0Y2xzID0gXCIgXCIgKyBub2RlW2NsYXNzTmFtZV0gKyBcIiBcIjtcblx0XHRcdFx0Zm9yKHZhciBpID0gMCwgbGVuID0gY2xhc3NTdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpe1xuXHRcdFx0XHRcdGNscyA9IGNscy5yZXBsYWNlKFwiIFwiICsgY2xhc3NTdHJbaV0gKyBcIiBcIiwgXCIgXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNscyA9IGxhbmcudHJpbShjbHMpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGNscyA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0XHRpZihub2RlW2NsYXNzTmFtZV0gIT0gY2xzKXsgbm9kZVtjbGFzc05hbWVdID0gY2xzOyB9XG5cdFx0fSxcblxuXHRcdHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2VDbGFzcygvKkRvbU5vZGV8U3RyaW5nKi8gbm9kZSwgLypTdHJpbmd8QXJyYXkqLyBhZGRDbGFzc1N0ciwgLypTdHJpbmd8QXJyYXk/Ki8gcmVtb3ZlQ2xhc3NTdHIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlcGxhY2VzIG9uZSBvciBtb3JlIGNsYXNzZXMgb24gYSBub2RlIGlmIG5vdCBwcmVzZW50LlxuXHRcdFx0Ly9cdFx0T3BlcmF0ZXMgbW9yZSBxdWlja2x5IHRoYW4gY2FsbGluZyBkb21DbGFzcy5yZW1vdmUgYW5kIGRvbUNsYXNzLmFkZFxuXHRcdFx0Ly9cblx0XHRcdC8vIG5vZGU6IFN0cmluZ3xET01Ob2RlXG5cdFx0XHQvL1x0XHRTdHJpbmcgSUQgb3IgRG9tTm9kZSByZWZlcmVuY2UgdG8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGFkZENsYXNzU3RyOiBTdHJpbmd8QXJyYXlcblx0XHRcdC8vXHRcdEEgU3RyaW5nIGNsYXNzIG5hbWUgdG8gYWRkLCBvciBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCBjbGFzcyBuYW1lcyxcblx0XHRcdC8vXHRcdG9yIGFuIGFycmF5IG9mIGNsYXNzIG5hbWVzLlxuXHRcdFx0Ly9cblx0XHRcdC8vIHJlbW92ZUNsYXNzU3RyOiBTdHJpbmd8QXJyYXk/XG5cdFx0XHQvL1x0XHRBIFN0cmluZyBjbGFzcyBuYW1lIHRvIHJlbW92ZSwgb3Igc2V2ZXJhbCBzcGFjZS1zZXBhcmF0ZWQgY2xhc3MgbmFtZXMsXG5cdFx0XHQvL1x0XHRvciBhbiBhcnJheSBvZiBjbGFzcyBuYW1lcy5cblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY2xhc3NcIl0sIGZ1bmN0aW9uKGRvbUNsYXNzKXtcblx0XHRcdC8vXHR8XHRcdGRvbUNsYXNzLnJlcGxhY2UoXCJzb21lTm9kZVwiLCBcImFkZDEgYWRkMlwiLCBcInJlbW92ZTEgcmVtb3ZlMlwiKTtcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFJlcGxhY2UgYWxsIGNsYXNzZXMgd2l0aCBhZGRNZVxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY2xhc3NcIl0sIGZ1bmN0aW9uKGRvbUNsYXNzKXtcblx0XHRcdC8vXHR8XHRcdGRvbUNsYXNzLnJlcGxhY2UoXCJzb21lTm9kZVwiLCBcImFkZE1lXCIpO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0QXZhaWxhYmxlIGluIGBkb2pvL05vZGVMaXN0YCBmb3IgbXVsdGlwbGUgdG9nZ2xlc1xuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9xdWVyeVwiXSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdFx0Ly9cdHxcdFx0cXVlcnkoXCIuZmluZE1lXCIpLnJlcGxhY2VDbGFzcyhcImFkZE1lXCIsIFwicmVtb3ZlTWVcIik7XG5cdFx0XHQvL1x0fFx0fSk7XG5cblx0XHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHRcdGZha2VOb2RlW2NsYXNzTmFtZV0gPSBub2RlW2NsYXNzTmFtZV07XG5cdFx0XHRjbHMucmVtb3ZlKGZha2VOb2RlLCByZW1vdmVDbGFzc1N0cik7XG5cdFx0XHRjbHMuYWRkKGZha2VOb2RlLCBhZGRDbGFzc1N0cik7XG5cdFx0XHRpZihub2RlW2NsYXNzTmFtZV0gIT09IGZha2VOb2RlW2NsYXNzTmFtZV0pe1xuXHRcdFx0XHRub2RlW2NsYXNzTmFtZV0gPSBmYWtlTm9kZVtjbGFzc05hbWVdO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKC8qRG9tTm9kZXxTdHJpbmcqLyBub2RlLCAvKlN0cmluZ3xBcnJheSovIGNsYXNzU3RyLCAvKkJvb2xlYW4/Ki8gY29uZGl0aW9uKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBZGRzIGEgY2xhc3MgdG8gbm9kZSBpZiBub3QgcHJlc2VudCwgb3IgcmVtb3ZlcyBpZiBwcmVzZW50LlxuXHRcdFx0Ly9cdFx0UGFzcyBhIGJvb2xlYW4gY29uZGl0aW9uIGlmIHlvdSB3YW50IHRvIGV4cGxpY2l0bHkgYWRkIG9yIHJlbW92ZS5cblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIGNvbmRpdGlvbiB0aGF0IHdhcyBzcGVjaWZpZWQgZGlyZWN0bHkgb3IgaW5kaXJlY3RseS5cblx0XHRcdC8vXG5cdFx0XHQvLyBub2RlOiBTdHJpbmd8RE9NTm9kZVxuXHRcdFx0Ly9cdFx0U3RyaW5nIElEIG9yIERvbU5vZGUgcmVmZXJlbmNlIHRvIHRvZ2dsZSBhIGNsYXNzIHN0cmluZ1xuXHRcdFx0Ly9cblx0XHRcdC8vIGNsYXNzU3RyOiBTdHJpbmd8QXJyYXlcblx0XHRcdC8vXHRcdEEgU3RyaW5nIGNsYXNzIG5hbWUgdG8gdG9nZ2xlLCBvciBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCBjbGFzcyBuYW1lcyxcblx0XHRcdC8vXHRcdG9yIGFuIGFycmF5IG9mIGNsYXNzIG5hbWVzLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGNvbmRpdGlvbjpcblx0XHRcdC8vXHRcdElmIHBhc3NlZCwgdHJ1ZSBtZWFucyB0byBhZGQgdGhlIGNsYXNzLCBmYWxzZSBtZWFucyB0byByZW1vdmUuXG5cdFx0XHQvL1x0XHRPdGhlcndpc2UgZG9tQ2xhc3MuY29udGFpbnMobm9kZSwgY2xhc3NTdHIpIGlzIHVzZWQgdG8gZGV0ZWN0IHRoZSBjbGFzcyBwcmVzZW5jZS5cblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY2xhc3NcIl0sIGZ1bmN0aW9uKGRvbUNsYXNzKXtcblx0XHRcdC8vXHR8XHRcdGRvbUNsYXNzLnRvZ2dsZShcInNvbWVOb2RlXCIsIFwiaG92ZXJlZFwiKTtcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0Rm9yY2VmdWxseSBhZGQgYSBjbGFzc1xuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY2xhc3NcIl0sIGZ1bmN0aW9uKGRvbUNsYXNzKXtcblx0XHRcdC8vXHR8XHRcdGRvbUNsYXNzLnRvZ2dsZShcInNvbWVOb2RlXCIsIFwiaG92ZXJlZFwiLCB0cnVlKTtcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0QXZhaWxhYmxlIGluIGBkb2pvL05vZGVMaXN0YCBmb3IgbXVsdGlwbGUgdG9nZ2xlc1xuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9xdWVyeVwiXSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdFx0Ly9cdHxcdFx0cXVlcnkoXCIudG9nZ2xlTWVcIikudG9nZ2xlQ2xhc3MoXCJ0b2dnbGVNZVwiKTtcblx0XHRcdC8vXHR8XHR9KTtcblxuXHRcdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdFx0aWYoY29uZGl0aW9uID09PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRjbGFzc1N0ciA9IHN0cjJhcnJheShjbGFzc1N0cik7XG5cdFx0XHRcdGZvcih2YXIgaSA9IDAsIGxlbiA9IGNsYXNzU3RyLmxlbmd0aCwgYzsgaSA8IGxlbjsgKytpKXtcblx0XHRcdFx0XHRjID0gY2xhc3NTdHJbaV07XG5cdFx0XHRcdFx0Y2xzW2Nscy5jb250YWlucyhub2RlLCBjKSA/IFwicmVtb3ZlXCIgOiBcImFkZFwiXShub2RlLCBjKTtcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGNsc1tjb25kaXRpb24gPyBcImFkZFwiIDogXCJyZW1vdmVcIl0obm9kZSwgY2xhc3NTdHIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbmRpdGlvbjsgICAvLyBCb29sZWFuXG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBjbHM7XG59KTtcbiIsImRlZmluZShbXCJleHBvcnRzXCIsIFwiLi9fYmFzZS9rZXJuZWxcIiwgXCIuL3NuaWZmXCIsIFwiLi9fYmFzZS93aW5kb3dcIiwgXCIuL2RvbVwiLCBcIi4vZG9tLWF0dHJcIl0sXG5cdFx0ZnVuY3Rpb24oZXhwb3J0cywgZG9qbywgaGFzLCB3aW4sIGRvbSwgYXR0cil7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9kb20tY29uc3RydWN0XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdFRoaXMgbW9kdWxlIGRlZmluZXMgdGhlIGNvcmUgZG9qbyBET00gY29uc3RydWN0aW9uIEFQSS5cblxuXHQvLyBUT0RPQzogc3VtbWFyeSBub3Qgc2hvd2luZyB1cCBpbiBvdXRwdXQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Nub3Zlci9qcy1kb2MtcGFyc2UvaXNzdWVzLzQyXG5cblx0Ly8gc3VwcG9ydCBzdHVmZiBmb3IgdG9Eb20oKVxuXHR2YXIgdGFnV3JhcCA9IHtcblx0XHRcdG9wdGlvbjogW1wic2VsZWN0XCJdLFxuXHRcdFx0dGJvZHk6IFtcInRhYmxlXCJdLFxuXHRcdFx0dGhlYWQ6IFtcInRhYmxlXCJdLFxuXHRcdFx0dGZvb3Q6IFtcInRhYmxlXCJdLFxuXHRcdFx0dHI6IFtcInRhYmxlXCIsIFwidGJvZHlcIl0sXG5cdFx0XHR0ZDogW1widGFibGVcIiwgXCJ0Ym9keVwiLCBcInRyXCJdLFxuXHRcdFx0dGg6IFtcInRhYmxlXCIsIFwidGhlYWRcIiwgXCJ0clwiXSxcblx0XHRcdGxlZ2VuZDogW1wiZmllbGRzZXRcIl0sXG5cdFx0XHRjYXB0aW9uOiBbXCJ0YWJsZVwiXSxcblx0XHRcdGNvbGdyb3VwOiBbXCJ0YWJsZVwiXSxcblx0XHRcdGNvbDogW1widGFibGVcIiwgXCJjb2xncm91cFwiXSxcblx0XHRcdGxpOiBbXCJ1bFwiXVxuXHRcdH0sXG5cdFx0cmVUYWcgPSAvPFxccyooW1xcd1xcOl0rKS8sXG5cdFx0bWFzdGVyTm9kZSA9IHt9LCBtYXN0ZXJOdW0gPSAwLFxuXHRcdG1hc3Rlck5hbWUgPSBcIl9fXCIgKyBkb2pvLl9zY29wZU5hbWUgKyBcIlRvRG9tSWRcIjtcblxuXHQvLyBnZW5lcmF0ZSBzdGFydC9lbmQgdGFnIHN0cmluZ3MgdG8gdXNlXG5cdC8vIGZvciB0aGUgaW5qZWN0aW9uIGZvciBlYWNoIHNwZWNpYWwgdGFnIHdyYXAgY2FzZS5cblx0Zm9yKHZhciBwYXJhbSBpbiB0YWdXcmFwKXtcblx0XHRpZih0YWdXcmFwLmhhc093blByb3BlcnR5KHBhcmFtKSl7XG5cdFx0XHR2YXIgdHcgPSB0YWdXcmFwW3BhcmFtXTtcblx0XHRcdHR3LnByZSA9IHBhcmFtID09IFwib3B0aW9uXCIgPyAnPHNlbGVjdCBtdWx0aXBsZT1cIm11bHRpcGxlXCI+JyA6IFwiPFwiICsgdHcuam9pbihcIj48XCIpICsgXCI+XCI7XG5cdFx0XHR0dy5wb3N0ID0gXCI8L1wiICsgdHcucmV2ZXJzZSgpLmpvaW4oXCI+PC9cIikgKyBcIj5cIjtcblx0XHRcdC8vIHRoZSBsYXN0IGxpbmUgaXMgZGVzdHJ1Y3RpdmU6IGl0IHJldmVyc2VzIHRoZSBhcnJheSxcblx0XHRcdC8vIGJ1dCB3ZSBkb24ndCBjYXJlIGF0IHRoaXMgcG9pbnRcblx0XHR9XG5cdH1cblxuXHR2YXIgaHRtbDVkb21maXg7XG5cdGlmKGhhcyhcImllXCIpIDw9IDgpe1xuXHRcdGh0bWw1ZG9tZml4ID0gZnVuY3Rpb24oZG9jKXtcblx0XHRcdGRvYy5fX2Rvam9faHRtbDVfdGVzdGVkID0gXCJ5ZXNcIjtcblx0XHRcdHZhciBkaXYgPSBjcmVhdGUoJ2RpdicsIHtpbm5lckhUTUw6IFwiPG5hdj5hPC9uYXY+XCIsIHN0eWxlOiB7dmlzaWJpbGl0eTogXCJoaWRkZW5cIn19LCBkb2MuYm9keSk7XG5cdFx0XHRpZihkaXYuY2hpbGROb2Rlcy5sZW5ndGggIT09IDEpe1xuXHRcdFx0XHQoJ2FiYnIgYXJ0aWNsZSBhc2lkZSBhdWRpbyBjYW52YXMgZGV0YWlscyBmaWdjYXB0aW9uIGZpZ3VyZSBmb290ZXIgaGVhZGVyICcgK1xuXHRcdFx0XHQnaGdyb3VwIG1hcmsgbWV0ZXIgbmF2IG91dHB1dCBwcm9ncmVzcyBzZWN0aW9uIHN1bW1hcnkgdGltZSB2aWRlbycpLnJlcGxhY2UoXG5cdFx0XHRcdFx0L1xcYlxcdytcXGIvZywgZnVuY3Rpb24obil7XG5cdFx0XHRcdFx0XHRkb2MuY3JlYXRlRWxlbWVudChuKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRkZXN0cm95KGRpdik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gX2luc2VydEJlZm9yZSgvKkRvbU5vZGUqLyBub2RlLCAvKkRvbU5vZGUqLyByZWYpe1xuXHRcdHZhciBwYXJlbnQgPSByZWYucGFyZW50Tm9kZTtcblx0XHRpZihwYXJlbnQpe1xuXHRcdFx0cGFyZW50Lmluc2VydEJlZm9yZShub2RlLCByZWYpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIF9pbnNlcnRBZnRlcigvKkRvbU5vZGUqLyBub2RlLCAvKkRvbU5vZGUqLyByZWYpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VHJ5IHRvIGluc2VydCBub2RlIGFmdGVyIHJlZlxuXHRcdHZhciBwYXJlbnQgPSByZWYucGFyZW50Tm9kZTtcblx0XHRpZihwYXJlbnQpe1xuXHRcdFx0aWYocGFyZW50Lmxhc3RDaGlsZCA9PSByZWYpe1xuXHRcdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0cGFyZW50Lmluc2VydEJlZm9yZShub2RlLCByZWYubmV4dFNpYmxpbmcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGV4cG9ydHMudG9Eb20gPSBmdW5jdGlvbiB0b0RvbShmcmFnLCBkb2Mpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0aW5zdGFudGlhdGVzIGFuIEhUTUwgZnJhZ21lbnQgcmV0dXJuaW5nIHRoZSBjb3JyZXNwb25kaW5nIERPTS5cblx0XHQvLyBmcmFnOiBTdHJpbmdcblx0XHQvL1x0XHR0aGUgSFRNTCBmcmFnbWVudFxuXHRcdC8vIGRvYzogRG9jdW1lbnROb2RlP1xuXHRcdC8vXHRcdG9wdGlvbmFsIGRvY3VtZW50IHRvIHVzZSB3aGVuIGNyZWF0aW5nIERPTSBub2RlcywgZGVmYXVsdHMgdG9cblx0XHQvL1x0XHRkb2pvL19iYXNlL3dpbmRvdy5kb2MgaWYgbm90IHNwZWNpZmllZC5cblx0XHQvLyByZXR1cm5zOlxuXHRcdC8vXHRcdERvY3VtZW50IGZyYWdtZW50LCB1bmxlc3MgaXQncyBhIHNpbmdsZSBub2RlIGluIHdoaWNoIGNhc2UgaXQgcmV0dXJucyB0aGUgbm9kZSBpdHNlbGZcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdENyZWF0ZSBhIHRhYmxlIHJvdzpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jb25zdHJ1Y3RcIl0sIGZ1bmN0aW9uKGRvbUNvbnN0cnVjdCl7XG5cdFx0Ly9cdHxcdFx0dmFyIHRyID0gZG9tQ29uc3RydWN0LnRvRG9tKFwiPHRyPjx0ZD5GaXJzdCE8L3RkPjwvdHI+XCIpO1xuXHRcdC8vXHR8XHR9KTtcblxuXHRcdGRvYyA9IGRvYyB8fCB3aW4uZG9jO1xuXHRcdHZhciBtYXN0ZXJJZCA9IGRvY1ttYXN0ZXJOYW1lXTtcblx0XHRpZighbWFzdGVySWQpe1xuXHRcdFx0ZG9jW21hc3Rlck5hbWVdID0gbWFzdGVySWQgPSArK21hc3Rlck51bSArIFwiXCI7XG5cdFx0XHRtYXN0ZXJOb2RlW21hc3RlcklkXSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdH1cblxuXHRcdGlmKGhhcyhcImllXCIpIDw9IDgpe1xuXHRcdFx0aWYoIWRvYy5fX2Rvam9faHRtbDVfdGVzdGVkICYmIGRvYy5ib2R5KXtcblx0XHRcdFx0aHRtbDVkb21maXgoZG9jKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBtYWtlIHN1cmUgdGhlIGZyYWcgaXMgYSBzdHJpbmcuXG5cdFx0ZnJhZyArPSBcIlwiO1xuXG5cdFx0Ly8gZmluZCB0aGUgc3RhcnRpbmcgdGFnLCBhbmQgZ2V0IG5vZGUgd3JhcHBlclxuXHRcdHZhciBtYXRjaCA9IGZyYWcubWF0Y2gocmVUYWcpLFxuXHRcdFx0dGFnID0gbWF0Y2ggPyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogXCJcIixcblx0XHRcdG1hc3RlciA9IG1hc3Rlck5vZGVbbWFzdGVySWRdLFxuXHRcdFx0d3JhcCwgaSwgZmMsIGRmO1xuXHRcdGlmKG1hdGNoICYmIHRhZ1dyYXBbdGFnXSl7XG5cdFx0XHR3cmFwID0gdGFnV3JhcFt0YWddO1xuXHRcdFx0bWFzdGVyLmlubmVySFRNTCA9IHdyYXAucHJlICsgZnJhZyArIHdyYXAucG9zdDtcblx0XHRcdGZvcihpID0gd3JhcC5sZW5ndGg7IGk7IC0taSl7XG5cdFx0XHRcdG1hc3RlciA9IG1hc3Rlci5maXJzdENoaWxkO1xuXHRcdFx0fVxuXHRcdH1lbHNle1xuXHRcdFx0bWFzdGVyLmlubmVySFRNTCA9IGZyYWc7XG5cdFx0fVxuXG5cdFx0Ly8gb25lIG5vZGUgc2hvcnRjdXQgPT4gcmV0dXJuIHRoZSBub2RlIGl0c2VsZlxuXHRcdGlmKG1hc3Rlci5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxKXtcblx0XHRcdHJldHVybiBtYXN0ZXIucmVtb3ZlQ2hpbGQobWFzdGVyLmZpcnN0Q2hpbGQpOyAvLyBET01Ob2RlXG5cdFx0fVxuXG5cdFx0Ly8gcmV0dXJuIG11bHRpcGxlIG5vZGVzIGFzIGEgZG9jdW1lbnQgZnJhZ21lbnRcblx0XHRkZiA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0d2hpbGUoKGZjID0gbWFzdGVyLmZpcnN0Q2hpbGQpKXsgLy8gaW50ZW50aW9uYWwgYXNzaWdubWVudFxuXHRcdFx0ZGYuYXBwZW5kQ2hpbGQoZmMpO1xuXHRcdH1cblx0XHRyZXR1cm4gZGY7IC8vIERvY3VtZW50RnJhZ21lbnRcblx0fTtcblxuXHRleHBvcnRzLnBsYWNlID0gZnVuY3Rpb24gcGxhY2Uobm9kZSwgcmVmTm9kZSwgcG9zaXRpb24pe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0QXR0ZW1wdCB0byBpbnNlcnQgbm9kZSBpbnRvIHRoZSBET00sIGNob29zaW5nIGZyb20gdmFyaW91cyBwb3NpdGlvbmluZyBvcHRpb25zLlxuXHRcdC8vXHRcdFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHJlc29sdmVkIHRvIGEgRE9NIG5vZGUuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxEb2N1bWVudEZyYWdtZW50fFN0cmluZ1xuXHRcdC8vXHRcdGlkIG9yIG5vZGUgcmVmZXJlbmNlLCBvciBIVE1MIGZyYWdtZW50IHN0YXJ0aW5nIHdpdGggXCI8XCIgdG8gcGxhY2UgcmVsYXRpdmUgdG8gcmVmTm9kZVxuXHRcdC8vIHJlZk5vZGU6IERPTU5vZGV8U3RyaW5nXG5cdFx0Ly9cdFx0aWQgb3Igbm9kZSByZWZlcmVuY2UgdG8gdXNlIGFzIGJhc2lzIGZvciBwbGFjZW1lbnRcblx0XHQvLyBwb3NpdGlvbjogU3RyaW5nfE51bWJlcj9cblx0XHQvL1x0XHRzdHJpbmcgbm90aW5nIHRoZSBwb3NpdGlvbiBvZiBub2RlIHJlbGF0aXZlIHRvIHJlZk5vZGUgb3IgYVxuXHRcdC8vXHRcdG51bWJlciBpbmRpY2F0aW5nIHRoZSBsb2NhdGlvbiBpbiB0aGUgY2hpbGROb2RlcyBjb2xsZWN0aW9uIG9mIHJlZk5vZGUuXG5cdFx0Ly9cdFx0QWNjZXB0ZWQgc3RyaW5nIHZhbHVlcyBhcmU6XG5cdFx0Ly9cblx0XHQvL1x0XHQtIGJlZm9yZVxuXHRcdC8vXHRcdC0gYWZ0ZXJcblx0XHQvL1x0XHQtIHJlcGxhY2Vcblx0XHQvL1x0XHQtIG9ubHlcblx0XHQvL1x0XHQtIGZpcnN0XG5cdFx0Ly9cdFx0LSBsYXN0XG5cdFx0Ly9cblx0XHQvL1x0XHRcImZpcnN0XCIgYW5kIFwibGFzdFwiIGluZGljYXRlIHBvc2l0aW9ucyBhcyBjaGlsZHJlbiBvZiByZWZOb2RlLCBcInJlcGxhY2VcIiByZXBsYWNlcyByZWZOb2RlLFxuXHRcdC8vXHRcdFwib25seVwiIHJlcGxhY2VzIGFsbCBjaGlsZHJlbi4gIHBvc2l0aW9uIGRlZmF1bHRzIHRvIFwibGFzdFwiIGlmIG5vdCBzcGVjaWZpZWRcblx0XHQvLyByZXR1cm5zOiBET01Ob2RlXG5cdFx0Ly9cdFx0UmV0dXJuZWQgdmFsdWVzIGlzIHRoZSBmaXJzdCBhcmd1bWVudCByZXNvbHZlZCB0byBhIERPTSBub2RlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0LnBsYWNlKCkgaXMgYWxzbyBhIG1ldGhvZCBvZiBgZG9qby9Ob2RlTGlzdGAsIGFsbG93aW5nIGBkb2pvL3F1ZXJ5YCBub2RlIGxvb2t1cHMuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRQbGFjZSBhIG5vZGUgYnkgc3RyaW5nIGlkIGFzIHRoZSBsYXN0IGNoaWxkIG9mIGFub3RoZXIgbm9kZSBieSBzdHJpbmcgaWQ6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY29uc3RydWN0XCJdLCBmdW5jdGlvbihkb21Db25zdHJ1Y3Qpe1xuXHRcdC8vXHR8XHRcdGRvbUNvbnN0cnVjdC5wbGFjZShcInNvbWVOb2RlXCIsIFwiYW5vdGhlck5vZGVcIik7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0UGxhY2UgYSBub2RlIGJ5IHN0cmluZyBpZCBiZWZvcmUgYW5vdGhlciBub2RlIGJ5IHN0cmluZyBpZFxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNvbnN0cnVjdFwiXSwgZnVuY3Rpb24oZG9tQ29uc3RydWN0KXtcblx0XHQvL1x0fFx0XHRkb21Db25zdHJ1Y3QucGxhY2UoXCJzb21lTm9kZVwiLCBcImFub3RoZXJOb2RlXCIsIFwiYmVmb3JlXCIpO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdENyZWF0ZSBhIE5vZGUsIGFuZCBwbGFjZSBpdCBpbiB0aGUgYm9keSBlbGVtZW50IChsYXN0IGNoaWxkKTpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jb25zdHJ1Y3RcIiwgXCJkb2pvL19iYXNlL3dpbmRvd1wiXG5cdFx0Ly9cdHxcdF0sIGZ1bmN0aW9uKGRvbUNvbnN0cnVjdCwgd2luKXtcblx0XHQvL1x0fFx0XHRkb21Db25zdHJ1Y3QucGxhY2UoXCI8ZGl2PjwvZGl2PlwiLCB3aW4uYm9keSgpKTtcblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRQdXQgYSBuZXcgTEkgYXMgdGhlIGZpcnN0IGNoaWxkIG9mIGEgbGlzdCBieSBpZDpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jb25zdHJ1Y3RcIl0sIGZ1bmN0aW9uKGRvbUNvbnN0cnVjdCl7XG5cdFx0Ly9cdHxcdFx0ZG9tQ29uc3RydWN0LnBsYWNlKFwiPGxpPjwvbGk+XCIsIFwic29tZVVsXCIsIFwiZmlyc3RcIik7XG5cdFx0Ly9cdHxcdH0pO1xuXG5cdFx0cmVmTm9kZSA9IGRvbS5ieUlkKHJlZk5vZGUpO1xuXHRcdGlmKHR5cGVvZiBub2RlID09IFwic3RyaW5nXCIpeyAvLyBpbmxpbmUnZCB0eXBlIGNoZWNrXG5cdFx0XHRub2RlID0gL15cXHMqPC8udGVzdChub2RlKSA/IGV4cG9ydHMudG9Eb20obm9kZSwgcmVmTm9kZS5vd25lckRvY3VtZW50KSA6IGRvbS5ieUlkKG5vZGUpO1xuXHRcdH1cblx0XHRpZih0eXBlb2YgcG9zaXRpb24gPT0gXCJudW1iZXJcIil7IC8vIGlubGluZSdkIHR5cGUgY2hlY2tcblx0XHRcdHZhciBjbiA9IHJlZk5vZGUuY2hpbGROb2Rlcztcblx0XHRcdGlmKCFjbi5sZW5ndGggfHwgY24ubGVuZ3RoIDw9IHBvc2l0aW9uKXtcblx0XHRcdFx0cmVmTm9kZS5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRfaW5zZXJ0QmVmb3JlKG5vZGUsIGNuW3Bvc2l0aW9uIDwgMCA/IDAgOiBwb3NpdGlvbl0pO1xuXHRcdFx0fVxuXHRcdH1lbHNle1xuXHRcdFx0c3dpdGNoKHBvc2l0aW9uKXtcblx0XHRcdFx0Y2FzZSBcImJlZm9yZVwiOlxuXHRcdFx0XHRcdF9pbnNlcnRCZWZvcmUobm9kZSwgcmVmTm9kZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJhZnRlclwiOlxuXHRcdFx0XHRcdF9pbnNlcnRBZnRlcihub2RlLCByZWZOb2RlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInJlcGxhY2VcIjpcblx0XHRcdFx0XHRyZWZOb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIHJlZk5vZGUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwib25seVwiOlxuXHRcdFx0XHRcdGV4cG9ydHMuZW1wdHkocmVmTm9kZSk7XG5cdFx0XHRcdFx0cmVmTm9kZS5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImZpcnN0XCI6XG5cdFx0XHRcdFx0aWYocmVmTm9kZS5maXJzdENoaWxkKXtcblx0XHRcdFx0XHRcdF9pbnNlcnRCZWZvcmUobm9kZSwgcmVmTm9kZS5maXJzdENoaWxkKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBlbHNlIGZhbGx0aHJvdWdoLi4uXG5cdFx0XHRcdGRlZmF1bHQ6IC8vIGFrYTogbGFzdFxuXHRcdFx0XHRcdHJlZk5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlOyAvLyBEb21Ob2RlXG5cdH07XG5cblx0dmFyIGNyZWF0ZSA9IGV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKC8qRE9NTm9kZXxTdHJpbmcqLyB0YWcsIC8qT2JqZWN0Ki8gYXR0cnMsIC8qRE9NTm9kZXxTdHJpbmc/Ki8gcmVmTm9kZSwgLypTdHJpbmc/Ki8gcG9zKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENyZWF0ZSBhbiBlbGVtZW50LCBhbGxvd2luZyBmb3Igb3B0aW9uYWwgYXR0cmlidXRlIGRlY29yYXRpb25cblx0XHQvL1x0XHRhbmQgcGxhY2VtZW50LlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEEgRE9NIEVsZW1lbnQgY3JlYXRpb24gZnVuY3Rpb24uIEEgc2hvcnRoYW5kIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBub2RlIG9yXG5cdFx0Ly9cdFx0YSBmcmFnbWVudCwgYW5kIGFsbG93aW5nIGZvciBhIGNvbnZlbmllbnQgb3B0aW9uYWwgYXR0cmlidXRlIHNldHRpbmcgc3RlcCxcblx0XHQvL1x0XHRhcyB3ZWxsIGFzIGFuIG9wdGlvbmFsIERPTSBwbGFjZW1lbnQgcmVmZXJlbmNlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0QXR0cmlidXRlcyBhcmUgc2V0IGJ5IHBhc3NpbmcgdGhlIG9wdGlvbmFsIG9iamVjdCB0aHJvdWdoIGBkb2pvL2RvbS1hdHRyLnNldGAuXG5cdFx0Ly9cdFx0U2VlIGBkb2pvL2RvbS1hdHRyLnNldGAgZm9yIG5vdGVkIGNhdmVhdHMgYW5kIG51YW5jZXMsIGFuZCBBUEkgaWYgYXBwbGljYWJsZS5cblx0XHQvL1xuXHRcdC8vXHRcdFBsYWNlbWVudCBpcyBkb25lIHZpYSBgZG9qby9kb20tY29uc3RydWN0LnBsYWNlYCwgYXNzdW1pbmcgdGhlIG5ldyBub2RlIHRvIGJlXG5cdFx0Ly9cdFx0dGhlIGFjdGlvbiBub2RlLCBwYXNzaW5nIGFsb25nIHRoZSBvcHRpb25hbCByZWZlcmVuY2Ugbm9kZSBhbmQgcG9zaXRpb24uXG5cdFx0Ly8gdGFnOiBET01Ob2RlfFN0cmluZ1xuXHRcdC8vXHRcdEEgc3RyaW5nIG9mIHRoZSBlbGVtZW50IHRvIGNyZWF0ZSAoZWc6IFwiZGl2XCIsIFwiYVwiLCBcInBcIiwgXCJsaVwiLCBcInNjcmlwdFwiLCBcImJyXCIpLFxuXHRcdC8vXHRcdG9yIGFuIGV4aXN0aW5nIERPTSBub2RlIHRvIHByb2Nlc3MuXG5cdFx0Ly8gYXR0cnM6IE9iamVjdFxuXHRcdC8vXHRcdEFuIG9iamVjdC1oYXNoIG9mIGF0dHJpYnV0ZXMgdG8gc2V0IG9uIHRoZSBuZXdseSBjcmVhdGVkIG5vZGUuXG5cdFx0Ly9cdFx0Q2FuIGJlIG51bGwsIGlmIHlvdSBkb24ndCB3YW50IHRvIHNldCBhbnkgYXR0cmlidXRlcy9zdHlsZXMuXG5cdFx0Ly9cdFx0U2VlOiBgZG9qby9kb20tYXR0ci5zZXRgIGZvciBhIGRlc2NyaXB0aW9uIG9mIGF2YWlsYWJsZSBhdHRyaWJ1dGVzLlxuXHRcdC8vIHJlZk5vZGU6IERPTU5vZGV8U3RyaW5nP1xuXHRcdC8vXHRcdE9wdGlvbmFsIHJlZmVyZW5jZSBub2RlLiBVc2VkIGJ5IGBkb2pvL2RvbS1jb25zdHJ1Y3QucGxhY2VgIHRvIHBsYWNlIHRoZSBuZXdseSBjcmVhdGVkXG5cdFx0Ly9cdFx0bm9kZSBzb21ld2hlcmUgaW4gdGhlIGRvbSByZWxhdGl2ZSB0byByZWZOb2RlLiBDYW4gYmUgYSBEb21Ob2RlIHJlZmVyZW5jZVxuXHRcdC8vXHRcdG9yIFN0cmluZyBJRCBvZiBhIG5vZGUuXG5cdFx0Ly8gcG9zOiBTdHJpbmc/XG5cdFx0Ly9cdFx0T3B0aW9uYWwgcG9zaXRpb25hbCByZWZlcmVuY2UuIERlZmF1bHRzIHRvIFwibGFzdFwiIGJ5IHdheSBvZiBgZG9qby9kb21Db25zdHJ1Y3QucGxhY2VgLFxuXHRcdC8vXHRcdHRob3VnaCBjYW4gYmUgc2V0IHRvIFwiZmlyc3RcIixcImFmdGVyXCIsXCJiZWZvcmVcIixcImxhc3RcIiwgXCJyZXBsYWNlXCIgb3IgXCJvbmx5XCJcblx0XHQvL1x0XHR0byBmdXJ0aGVyIGNvbnRyb2wgdGhlIHBsYWNlbWVudCBvZiB0aGUgbmV3IG5vZGUgcmVsYXRpdmUgdG8gdGhlIHJlZk5vZGUuXG5cdFx0Ly9cdFx0J3JlZk5vZGUnIGlzIHJlcXVpcmVkIGlmIGEgJ3BvcycgaXMgc3BlY2lmaWVkLlxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0Q3JlYXRlIGEgRElWOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNvbnN0cnVjdFwiXSwgZnVuY3Rpb24oZG9tQ29uc3RydWN0KXtcblx0XHQvL1x0fFx0XHR2YXIgbiA9IGRvbUNvbnN0cnVjdC5jcmVhdGUoXCJkaXZcIik7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRDcmVhdGUgYSBESVYgd2l0aCBjb250ZW50OlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNvbnN0cnVjdFwiXSwgZnVuY3Rpb24oZG9tQ29uc3RydWN0KXtcblx0XHQvL1x0fFx0XHR2YXIgbiA9IGRvbUNvbnN0cnVjdC5jcmVhdGUoXCJkaXZcIiwgeyBpbm5lckhUTUw6XCI8cD5oaTwvcD5cIiB9KTtcblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFBsYWNlIGEgbmV3IERJViBpbiB0aGUgQk9EWSwgd2l0aCBubyBhdHRyaWJ1dGVzIHNldFxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNvbnN0cnVjdFwiLCBcImRvam8vX2Jhc2Uvd2luZG93XCJdLCBmdW5jdGlvbihkb21Db25zdHJ1Y3QsIHdpbil7XG5cdFx0Ly9cdHxcdFx0dmFyIG4gPSBkb21Db25zdHJ1Y3QuY3JlYXRlKFwiZGl2XCIsIG51bGwsIHdpbi5ib2R5KCkpO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0Q3JlYXRlIGFuIFVMLCBhbmQgcG9wdWxhdGUgaXQgd2l0aCBMSSdzLiBQbGFjZSB0aGUgbGlzdCBhcyB0aGUgZmlyc3QtY2hpbGQgb2YgYVxuXHRcdC8vXHRcdG5vZGUgd2l0aCBpZD1cInNvbWVJZFwiOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNvbnN0cnVjdFwiLCBcImRvam8vX2Jhc2UvYXJyYXlcIl0sXG5cdFx0Ly9cdHxcdGZ1bmN0aW9uKGRvbUNvbnN0cnVjdCwgYXJyYXlVdGlsKXtcblx0XHQvL1x0fFx0XHR2YXIgdWwgPSBkb21Db25zdHJ1Y3QuY3JlYXRlKFwidWxcIiwgbnVsbCwgXCJzb21lSWRcIiwgXCJmaXJzdFwiKTtcblx0XHQvL1x0fFx0XHR2YXIgaXRlbXMgPSBbXCJvbmVcIiwgXCJ0d29cIiwgXCJ0aHJlZVwiLCBcImZvdXJcIl07XG5cdFx0Ly9cdHxcdFx0YXJyYXlVdGlsLmZvckVhY2goaXRlbXMsIGZ1bmN0aW9uKGRhdGEpe1xuXHRcdC8vXHR8XHRcdFx0ZG9tQ29uc3RydWN0LmNyZWF0ZShcImxpXCIsIHsgaW5uZXJIVE1MOiBkYXRhIH0sIHVsKTtcblx0XHQvL1x0fFx0XHR9KTtcblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdENyZWF0ZSBhbiBhbmNob3IsIHdpdGggYW4gaHJlZi4gUGxhY2UgaW4gQk9EWTpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jb25zdHJ1Y3RcIiwgXCJkb2pvL19iYXNlL3dpbmRvd1wiXSwgZnVuY3Rpb24oZG9tQ29uc3RydWN0LCB3aW4pe1xuXHRcdC8vXHR8XHRcdGRvbUNvbnN0cnVjdC5jcmVhdGUoXCJhXCIsIHsgaHJlZjpcImZvby5odG1sXCIsIHRpdGxlOlwiR290byBGT08hXCIgfSwgd2luLmJvZHkoKSk7XG5cdFx0Ly9cdHxcdH0pO1xuXG5cdFx0dmFyIGRvYyA9IHdpbi5kb2M7XG5cdFx0aWYocmVmTm9kZSl7XG5cdFx0XHRyZWZOb2RlID0gZG9tLmJ5SWQocmVmTm9kZSk7XG5cdFx0XHRkb2MgPSByZWZOb2RlLm93bmVyRG9jdW1lbnQ7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZiB0YWcgPT0gXCJzdHJpbmdcIil7IC8vIGlubGluZSdkIHR5cGUgY2hlY2tcblx0XHRcdHRhZyA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG5cdFx0fVxuXHRcdGlmKGF0dHJzKXsgYXR0ci5zZXQodGFnLCBhdHRycyk7IH1cblx0XHRpZihyZWZOb2RlKXsgZXhwb3J0cy5wbGFjZSh0YWcsIHJlZk5vZGUsIHBvcyk7IH1cblx0XHRyZXR1cm4gdGFnOyAvLyBEb21Ob2RlXG5cdH07XG5cblx0ZnVuY3Rpb24gX2VtcHR5KC8qRG9tTm9kZSovIG5vZGUpe1xuXHRcdC8vIFRPRE86IHJlbW92ZSB0aGlzIGlmKCkgYmxvY2sgaW4gMi4wIHdoZW4gd2Ugbm8gbG9uZ2VyIGhhdmUgdG8gd29ycnkgYWJvdXQgSUUgbWVtb3J5IGxlYWtzLFxuXHRcdC8vIGFuZCB0aGVuIHVuY29tbWVudCB0aGUgZW1wdHlHcmFuZGNoaWxkcmVuKCkgdGVzdCBjYXNlIGZyb20gaHRtbC5odG1sLlxuXHRcdC8vIE5vdGUgdGhhdCBiZXNpZGVzIGZpeGluZyAjMTY5NTcsIHVzaW5nIHJlbW92ZUNoaWxkKCkgaXMgYWN0dWFsbHkgZmFzdGVyIHRoYW4gc2V0dGluZyBub2RlLmlubmVySFRNTCxcblx0XHQvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2xlYXItZG9tLW5vZGUuXG5cdFx0aWYoXCJpbm5lckhUTUxcIiBpbiBub2RlKXtcblx0XHRcdHRyeXtcblx0XHRcdFx0Ly8gZmFzdCBwYXRoXG5cdFx0XHRcdG5vZGUuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHQvLyBpbm5lckhUTUwgaXMgcmVhZE9ubHkgKGUuZy4gVEFCTEUgKHN1YillbGVtZW50cyBpbiBxdWlya3MgbW9kZSlcblx0XHRcdFx0Ly8gRmFsbCB0aHJvdWdoIChzYXZlcyBieXRlcylcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTVkcvc3RyaWN0IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJIVE1MXG5cdFx0Zm9yKHZhciBjOyBjID0gbm9kZS5sYXN0Q2hpbGQ7KXsgLy8gaW50ZW50aW9uYWwgYXNzaWdubWVudFxuXHRcdFx0bm9kZS5yZW1vdmVDaGlsZChjKTtcblx0XHR9XG5cdH1cblxuXHRleHBvcnRzLmVtcHR5ID0gZnVuY3Rpb24gZW1wdHkoLypET01Ob2RlfFN0cmluZyovIG5vZGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0c2FmZWx5IHJlbW92ZXMgYWxsIGNoaWxkcmVuIG9mIHRoZSBub2RlLlxuXHRcdC8vIG5vZGU6IERPTU5vZGV8U3RyaW5nXG5cdFx0Ly9cdFx0YSByZWZlcmVuY2UgdG8gYSBET00gbm9kZSBvciBhbiBpZC5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdERlc3Ryb3kgbm9kZSdzIGNoaWxkcmVuIGJ5SWQ6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY29uc3RydWN0XCJdLCBmdW5jdGlvbihkb21Db25zdHJ1Y3Qpe1xuXHRcdC8vXHR8XHRcdGRvbUNvbnN0cnVjdC5lbXB0eShcInNvbWVJZFwiKTtcblx0XHQvL1x0fFx0fSk7XG5cblx0XHRfZW1wdHkoZG9tLmJ5SWQobm9kZSkpO1xuXHR9O1xuXG5cblx0ZnVuY3Rpb24gX2Rlc3Ryb3koLypEb21Ob2RlKi8gbm9kZSwgLypEb21Ob2RlKi8gcGFyZW50KXtcblx0XHQvLyBpbiBJRSBxdWlya3MsIG5vZGUuY2FuSGF2ZUNoaWxkcmVuIGNhbiBiZSBmYWxzZSBidXQgZmlyc3RDaGlsZCBjYW4gYmUgbm9uLW51bGwgKE9CSkVDVC9BUFBMRVQpXG5cdFx0aWYobm9kZS5maXJzdENoaWxkKXtcblx0XHRcdF9lbXB0eShub2RlKTtcblx0XHR9XG5cdFx0aWYocGFyZW50KXtcblx0XHRcdC8vIHJlbW92ZU5vZGUoZmFsc2UpIGRvZXNuJ3QgbGVhayBpbiBJRSA2KywgYnV0IHJlbW92ZUNoaWxkKCkgYW5kIHJlbW92ZU5vZGUodHJ1ZSkgYXJlIGtub3duIHRvIGxlYWsgdW5kZXIgSUUgOC0gd2hpbGUgOSsgaXMgVEJELlxuXHRcdFx0Ly8gSW4gSUUgcXVpcmtzIG1vZGUsIFBBUkFNIG5vZGVzIGFzIGNoaWxkcmVuIG9mIE9CSkVDVC9BUFBMRVQgbm9kZXMgaGF2ZSBhIHJlbW92ZU5vZGUgbWV0aG9kIHRoYXQgZG9lcyBub3RoaW5nIGFuZFxuXHRcdFx0Ly8gdGhlIHBhcmVudCBub2RlIGhhcyBjYW5IYXZlQ2hpbGRyZW49ZmFsc2UgZXZlbiB0aG91Z2ggcmVtb3ZlQ2hpbGQgY29ycmVjdGx5IHJlbW92ZXMgdGhlIFBBUkFNIGNoaWxkcmVuLlxuXHRcdFx0Ly8gSW4gSUUsIFNWRy9zdHJpY3Qgbm9kZXMgZG9uJ3QgaGF2ZSBhIHJlbW92ZU5vZGUgbWV0aG9kIG5vciBhIGNhbkhhdmVDaGlsZHJlbiBib29sZWFuLlxuXHRcdFx0aGFzKFwiaWVcIikgJiYgcGFyZW50LmNhbkhhdmVDaGlsZHJlbiAmJiBcInJlbW92ZU5vZGVcIiBpbiBub2RlID8gbm9kZS5yZW1vdmVOb2RlKGZhbHNlKSA6IHBhcmVudC5yZW1vdmVDaGlsZChub2RlKTtcblx0XHR9XG5cdH1cblx0dmFyIGRlc3Ryb3kgPSBleHBvcnRzLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KC8qRE9NTm9kZXxTdHJpbmcqLyBub2RlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJlbW92ZXMgYSBub2RlIGZyb20gaXRzIHBhcmVudCwgY2xvYmJlcmluZyBpdCBhbmQgYWxsIG9mIGl0c1xuXHRcdC8vXHRcdGNoaWxkcmVuLlxuXHRcdC8vXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0UmVtb3ZlcyBhIG5vZGUgZnJvbSBpdHMgcGFyZW50LCBjbG9iYmVyaW5nIGl0IGFuZCBhbGwgb2YgaXRzXG5cdFx0Ly9cdFx0Y2hpbGRyZW4uIEZ1bmN0aW9uIG9ubHkgd29ya3Mgd2l0aCBEb21Ob2RlcywgYW5kIHJldHVybnMgbm90aGluZy5cblx0XHQvL1xuXHRcdC8vIG5vZGU6IERPTU5vZGV8U3RyaW5nXG5cdFx0Ly9cdFx0QSBTdHJpbmcgSUQgb3IgRG9tTm9kZSByZWZlcmVuY2Ugb2YgdGhlIGVsZW1lbnQgdG8gYmUgZGVzdHJveWVkXG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdERlc3Ryb3kgYSBub2RlIGJ5SWQ6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY29uc3RydWN0XCJdLCBmdW5jdGlvbihkb21Db25zdHJ1Y3Qpe1xuXHRcdC8vXHR8XHRcdGRvbUNvbnN0cnVjdC5kZXN0cm95KFwic29tZUlkXCIpO1xuXHRcdC8vXHR8XHR9KTtcblxuXHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHRpZighbm9kZSl7IHJldHVybjsgfVxuXHRcdF9kZXN0cm95KG5vZGUsIG5vZGUucGFyZW50Tm9kZSk7XG5cdH07XG59KTtcbiIsImRlZmluZShbXCIuL19iYXNlL2xhbmdcIiwgXCIuL2RvbVwiLCBcIi4vaW8tcXVlcnlcIiwgXCIuL2pzb25cIl0sIGZ1bmN0aW9uKGxhbmcsIGRvbSwgaW9xLCBqc29uKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL2RvbS1mb3JtXG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZSgvKk9iamVjdCovIG9iaiwgLypTdHJpbmcqLyBuYW1lLCAvKlN0cmluZyovIHZhbHVlKXtcbiAgICAgICAgLy8gc3VtbWFyeTpcbiAgICAgICAgLy9cdFx0Rm9yIHRoZSBuYW1lZCBwcm9wZXJ0eSBpbiBvYmplY3QsIHNldCB0aGUgdmFsdWUuIElmIGEgdmFsdWVcbiAgICAgICAgLy9cdFx0YWxyZWFkeSBleGlzdHMgYW5kIGl0IGlzIGEgc3RyaW5nLCBjb252ZXJ0IHRoZSB2YWx1ZSB0byBiZSBhblxuICAgICAgICAvL1x0XHRhcnJheSBvZiB2YWx1ZXMuXG5cbiAgICAgICAgLy8gU2tpcCBpdCBpZiB0aGVyZSBpcyBubyB2YWx1ZVxuICAgICAgICBpZih2YWx1ZSA9PT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsID0gb2JqW25hbWVdO1xuICAgICAgICBpZih0eXBlb2YgdmFsID09IFwic3RyaW5nXCIpeyAvLyBpbmxpbmUnZCB0eXBlIGNoZWNrXG4gICAgICAgICAgICBvYmpbbmFtZV0gPSBbdmFsLCB2YWx1ZV07XG4gICAgICAgIH1lbHNlIGlmKGxhbmcuaXNBcnJheSh2YWwpKXtcbiAgICAgICAgICAgIHZhbC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuXHR2YXIgZXhjbHVkZSA9IFwiZmlsZXxzdWJtaXR8aW1hZ2V8cmVzZXR8YnV0dG9uXCI7XG5cblx0dmFyIGZvcm0gPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGlzIG1vZHVsZSBkZWZpbmVzIGZvcm0tcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG5cblx0XHRmaWVsZFRvT2JqZWN0OiBmdW5jdGlvbiBmaWVsZFRvT2JqZWN0KC8qRE9NTm9kZXxTdHJpbmcqLyBpbnB1dE5vZGUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFNlcmlhbGl6ZSBhIGZvcm0gZmllbGQgdG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0aGUgdmFsdWUgZW5jb2RlZCBpbiBhIGZvcm0gZmllbGQgYXNcblx0XHRcdC8vXHRcdGFzIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuIERpc2FibGVkIGZvcm0gZWxlbWVudHNcblx0XHRcdC8vXHRcdGFuZCB1bmNoZWNrZWQgcmFkaW8gYW5kIGNoZWNrYm94ZXMgYXJlIHNraXBwZWQuXHRNdWx0aS1zZWxlY3Rcblx0XHRcdC8vXHRcdGVsZW1lbnRzIGFyZSByZXR1cm5lZCBhcyBhbiBhcnJheSBvZiBzdHJpbmcgdmFsdWVzLlxuXHRcdFx0Ly8gaW5wdXROb2RlOiBET01Ob2RlfFN0cmluZ1xuXHRcdFx0Ly8gcmV0dXJuczogT2JqZWN0XG5cblx0XHRcdHZhciByZXQgPSBudWxsO1xuXHRcdFx0aW5wdXROb2RlID0gZG9tLmJ5SWQoaW5wdXROb2RlKTtcblx0XHRcdGlmKGlucHV0Tm9kZSl7XG5cdFx0XHRcdHZhciBfaW4gPSBpbnB1dE5vZGUubmFtZSwgdHlwZSA9IChpbnB1dE5vZGUudHlwZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRpZihfaW4gJiYgdHlwZSAmJiAhaW5wdXROb2RlLmRpc2FibGVkKXtcblx0XHRcdFx0XHRpZih0eXBlID09IFwicmFkaW9cIiB8fCB0eXBlID09IFwiY2hlY2tib3hcIil7XG5cdFx0XHRcdFx0XHRpZihpbnB1dE5vZGUuY2hlY2tlZCl7XG5cdFx0XHRcdFx0XHRcdHJldCA9IGlucHV0Tm9kZS52YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ZWxzZSBpZihpbnB1dE5vZGUubXVsdGlwbGUpe1xuXHRcdFx0XHRcdFx0cmV0ID0gW107XG5cdFx0XHRcdFx0XHR2YXIgbm9kZXMgPSBbaW5wdXROb2RlLmZpcnN0Q2hpbGRdO1xuXHRcdFx0XHRcdFx0d2hpbGUobm9kZXMubGVuZ3RoKXtcblx0XHRcdFx0XHRcdFx0Zm9yKHZhciBub2RlID0gbm9kZXMucG9wKCk7IG5vZGU7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKXtcblx0XHRcdFx0XHRcdFx0XHRpZihub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJvcHRpb25cIil7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihub2RlLnNlbGVjdGVkKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0LnB1c2gobm9kZS52YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihub2RlLm5leHRTaWJsaW5nKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZXMucHVzaChub2RlLm5leHRTaWJsaW5nKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGlmKG5vZGUuZmlyc3RDaGlsZCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGVzLnB1c2gobm9kZS5maXJzdENoaWxkKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0cmV0ID0gaW5wdXROb2RlLnZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDsgLy8gT2JqZWN0XG5cdFx0fSxcblxuXHRcdHRvT2JqZWN0OiBmdW5jdGlvbiBmb3JtVG9PYmplY3QoLypET01Ob2RlfFN0cmluZyovIGZvcm1Ob2RlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRTZXJpYWxpemUgYSBmb3JtIG5vZGUgdG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0aGUgdmFsdWVzIGVuY29kZWQgaW4gYW4gSFRNTCBmb3JtIGFzXG5cdFx0XHQvL1x0XHRzdHJpbmcgcHJvcGVydGllcyBpbiBhbiBvYmplY3Qgd2hpY2ggaXQgdGhlbiByZXR1cm5zLiBEaXNhYmxlZCBmb3JtXG5cdFx0XHQvL1x0XHRlbGVtZW50cywgYnV0dG9ucywgYW5kIG90aGVyIG5vbi12YWx1ZSBmb3JtIGVsZW1lbnRzIGFyZSBza2lwcGVkLlxuXHRcdFx0Ly9cdFx0TXVsdGktc2VsZWN0IGVsZW1lbnRzIGFyZSByZXR1cm5lZCBhcyBhbiBhcnJheSBvZiBzdHJpbmcgdmFsdWVzLlxuXHRcdFx0Ly8gZm9ybU5vZGU6IERPTU5vZGV8U3RyaW5nXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0VGhpcyBmb3JtOlxuXHRcdFx0Ly9cdFx0fFx0PGZvcm0gaWQ9XCJ0ZXN0X2Zvcm1cIj5cblx0XHRcdC8vXHRcdHxcdFx0PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImJsYWhcIiB2YWx1ZT1cImJsYWhcIj5cblx0XHRcdC8vXHRcdHxcdFx0PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cIm5vX3ZhbHVlXCIgdmFsdWU9XCJibGFoXCIgZGlzYWJsZWQ+XG5cdFx0XHQvL1x0XHR8XHRcdDxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgbmFtZT1cIm5vX3ZhbHVlMlwiIHZhbHVlPVwiYmxhaFwiPlxuXHRcdFx0Ly9cdFx0fFx0XHQ8c2VsZWN0IHR5cGU9XCJzZWxlY3RcIiBtdWx0aXBsZSBuYW1lPVwibXVsdGlcIiBzaXplPVwiNVwiPlxuXHRcdFx0Ly9cdFx0fFx0XHRcdDxvcHRpb24gdmFsdWU9XCJibGFoXCI+YmxhaDwvb3B0aW9uPlxuXHRcdFx0Ly9cdFx0fFx0XHRcdDxvcHRpb24gdmFsdWU9XCJ0aHVkXCIgc2VsZWN0ZWQ+dGh1ZDwvb3B0aW9uPlxuXHRcdFx0Ly9cdFx0fFx0XHRcdDxvcHRpb24gdmFsdWU9XCJ0aG9ua1wiIHNlbGVjdGVkPnRob25rPC9vcHRpb24+XG5cdFx0XHQvL1x0XHR8XHRcdDwvc2VsZWN0PlxuXHRcdFx0Ly9cdFx0fFx0PC9mb3JtPlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdHlpZWxkcyB0aGlzIG9iamVjdCBzdHJ1Y3R1cmUgYXMgdGhlIHJlc3VsdCBvZiBhIGNhbGwgdG9cblx0XHRcdC8vXHRcdGZvcm1Ub09iamVjdCgpOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdHxcdHtcblx0XHRcdC8vXHRcdHxcdFx0YmxhaDogXCJibGFoXCIsXG5cdFx0XHQvL1x0XHR8XHRcdG11bHRpOiBbXG5cdFx0XHQvL1x0XHR8XHRcdFx0XCJ0aHVkXCIsXG5cdFx0XHQvL1x0XHR8XHRcdFx0XCJ0aG9ua1wiXG5cdFx0XHQvL1x0XHR8XHRcdF1cblx0XHRcdC8vXHRcdHxcdH07XG5cblx0XHRcdHZhciByZXQgPSB7fSwgZWxlbXMgPSBkb20uYnlJZChmb3JtTm9kZSkuZWxlbWVudHM7XG5cdFx0XHRmb3IodmFyIGkgPSAwLCBsID0gZWxlbXMubGVuZ3RoOyBpIDwgbDsgKytpKXtcblx0XHRcdFx0dmFyIGl0ZW0gPSBlbGVtc1tpXSwgX2luID0gaXRlbS5uYW1lLCB0eXBlID0gKGl0ZW0udHlwZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRpZihfaW4gJiYgdHlwZSAmJiBleGNsdWRlLmluZGV4T2YodHlwZSkgPCAwICYmICFpdGVtLmRpc2FibGVkKXtcblx0XHRcdFx0XHRzZXRWYWx1ZShyZXQsIF9pbiwgZm9ybS5maWVsZFRvT2JqZWN0KGl0ZW0pKTtcblx0XHRcdFx0XHRpZih0eXBlID09IFwiaW1hZ2VcIil7XG5cdFx0XHRcdFx0XHRyZXRbX2luICsgXCIueFwiXSA9IHJldFtfaW4gKyBcIi55XCJdID0gcmV0W19pbl0ueCA9IHJldFtfaW5dLnkgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDsgLy8gT2JqZWN0XG5cdFx0fSxcblxuXHRcdHRvUXVlcnk6IGZ1bmN0aW9uIGZvcm1Ub1F1ZXJ5KC8qRE9NTm9kZXxTdHJpbmcqLyBmb3JtTm9kZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIFVSTC1lbmNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZvcm0gcGFzc2VkIGFzIGVpdGhlciBhXG5cdFx0XHQvL1x0XHRub2RlIG9yIHN0cmluZyBJRCBpZGVudGlmeWluZyB0aGUgZm9ybSB0byBzZXJpYWxpemVcblx0XHRcdC8vIGZvcm1Ob2RlOiBET01Ob2RlfFN0cmluZ1xuXHRcdFx0Ly8gcmV0dXJuczogU3RyaW5nXG5cblx0XHRcdHJldHVybiBpb3Eub2JqZWN0VG9RdWVyeShmb3JtLnRvT2JqZWN0KGZvcm1Ob2RlKSk7IC8vIFN0cmluZ1xuXHRcdH0sXG5cblx0XHR0b0pzb246IGZ1bmN0aW9uIGZvcm1Ub0pzb24oLypET01Ob2RlfFN0cmluZyovIGZvcm1Ob2RlLCAvKkJvb2xlYW4/Ki8gcHJldHR5UHJpbnQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENyZWF0ZSBhIHNlcmlhbGl6ZWQgSlNPTiBzdHJpbmcgZnJvbSBhIGZvcm0gbm9kZSBvciBzdHJpbmdcblx0XHRcdC8vXHRcdElEIGlkZW50aWZ5aW5nIHRoZSBmb3JtIHRvIHNlcmlhbGl6ZVxuXHRcdFx0Ly8gZm9ybU5vZGU6IERPTU5vZGV8U3RyaW5nXG5cdFx0XHQvLyBwcmV0dHlQcmludDogQm9vbGVhbj9cblx0XHRcdC8vIHJldHVybnM6IFN0cmluZ1xuXG5cdFx0XHRyZXR1cm4ganNvbi5zdHJpbmdpZnkoZm9ybS50b09iamVjdChmb3JtTm9kZSksIG51bGwsIHByZXR0eVByaW50ID8gNCA6IDApOyAvLyBTdHJpbmdcblx0XHR9XG5cdH07XG5cbiAgICByZXR1cm4gZm9ybTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vc25pZmZcIiwgXCIuL19iYXNlL3dpbmRvd1wiLFwiLi9kb21cIiwgXCIuL2RvbS1zdHlsZVwiXSxcblx0XHRmdW5jdGlvbihoYXMsIHdpbiwgZG9tLCBzdHlsZSl7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9kb20tZ2VvbWV0cnlcblxuXHQvLyB0aGUgcmVzdWx0IG9iamVjdFxuXHR2YXIgZ2VvbSA9IHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoaXMgbW9kdWxlIGRlZmluZXMgdGhlIGNvcmUgZG9qbyBET00gZ2VvbWV0cnkgQVBJLlxuXHR9O1xuXG5cdC8vIEJveCBmdW5jdGlvbnMgd2lsbCBhc3N1bWUgdGhpcyBtb2RlbC5cblx0Ly8gT24gSUUvT3BlcmEsIEJPUkRFUl9CT1ggd2lsbCBiZSBzZXQgaWYgdGhlIHByaW1hcnkgZG9jdW1lbnQgaXMgaW4gcXVpcmtzIG1vZGUuXG5cdC8vIENhbiBiZSBzZXQgdG8gY2hhbmdlIGJlaGF2aW9yIG9mIGJveCBzZXR0ZXJzLlxuXG5cdC8vIGNhbiBiZSBlaXRoZXI6XG5cdC8vXHRcImJvcmRlci1ib3hcIlxuXHQvL1x0XCJjb250ZW50LWJveFwiIChkZWZhdWx0KVxuXHRnZW9tLmJveE1vZGVsID0gXCJjb250ZW50LWJveFwiO1xuXG5cdC8vIFdlIHB1bnQgcGVyLW5vZGUgYm94IG1vZGUgdGVzdGluZyBjb21wbGV0ZWx5LlxuXHQvLyBJZiBhbnlib2R5IGNhcmVzLCB3ZSBjYW4gcHJvdmlkZSBhbiBhZGRpdGlvbmFsIChvcHRpb25hbCkgdW5pdFxuXHQvLyB0aGF0IG92ZXJyaWRlcyBleGlzdGluZyBjb2RlIHRvIGluY2x1ZGUgcGVyLW5vZGUgYm94IHNlbnNpdGl2aXR5LlxuXG5cdC8vIE9wZXJhIGRvY3VtZW50YXRpb24gY2xhaW1zIHRoYXQgT3BlcmEgOSB1c2VzIGJvcmRlci1ib3ggaW4gQmFja0NvbXBhdCBtb2RlLlxuXHQvLyBidXQgZXhwZXJpbWVudHMgKE9wZXJhIDkuMTAuODY3OSBvbiBXaW5kb3dzIFZpc3RhKSBpbmRpY2F0ZSB0aGF0IGl0IGFjdHVhbGx5IGNvbnRpbnVlcyB0byB1c2UgY29udGVudC1ib3guXG5cdC8vIElJUkMsIGVhcmxpZXIgdmVyc2lvbnMgb2YgT3BlcmEgZGlkIGluIGZhY3QgdXNlIGJvcmRlci1ib3guXG5cdC8vIE9wZXJhIGd1eXMsIHRoaXMgaXMgcmVhbGx5IGNvbmZ1c2luZy4gT3BlcmEgYmVpbmcgYnJva2VuIGluIHF1aXJrcyBtb2RlIGlzIG5vdCBvdXIgZmF1bHQuXG5cblx0aWYoaGFzKFwiaWVcIikgLyp8fCBoYXMoXCJvcGVyYVwiKSovKXtcblx0XHQvLyBjbGllbnQgY29kZSBtYXkgaGF2ZSB0byBhZGp1c3QgaWYgY29tcGF0TW9kZSB2YXJpZXMgYWNyb3NzIGlmcmFtZXNcblx0XHRnZW9tLmJveE1vZGVsID0gZG9jdW1lbnQuY29tcGF0TW9kZSA9PSBcIkJhY2tDb21wYXRcIiA/IFwiYm9yZGVyLWJveFwiIDogXCJjb250ZW50LWJveFwiO1xuXHR9XG5cblx0Z2VvbS5nZXRQYWRFeHRlbnRzID0gZnVuY3Rpb24gZ2V0UGFkRXh0ZW50cygvKkRvbU5vZGUqLyBub2RlLCAvKk9iamVjdCovIGNvbXB1dGVkU3R5bGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmV0dXJucyBvYmplY3Qgd2l0aCBzcGVjaWFsIHZhbHVlcyBzcGVjaWZpY2FsbHkgdXNlZnVsIGZvciBub2RlXG5cdFx0Ly9cdFx0Zml0dGluZy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB3YCwgYGhgLCBgbGAsIGB0YCBwcm9wZXJ0aWVzOlxuXHRcdC8vXHR8XHRcdGwvdC9yL2IgPSBsZWZ0L3RvcC9yaWdodC9ib3R0b20gcGFkZGluZyAocmVzcGVjdGl2ZWx5KVxuXHRcdC8vXHR8XHRcdHcgPSB0aGUgdG90YWwgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IHBhZGRpbmdcblx0XHQvL1x0fFx0XHRoID0gdGhlIHRvdGFsIG9mIHRoZSB0b3AgYW5kIGJvdHRvbSBwYWRkaW5nXG5cdFx0Ly9cdFx0SWYgJ25vZGUnIGhhcyBwb3NpdGlvbiwgbC90IGZvcm1zIHRoZSBvcmlnaW4gZm9yIGNoaWxkIG5vZGVzLlxuXHRcdC8vXHRcdFRoZSB3L2ggYXJlIHVzZWQgZm9yIGNhbGN1bGF0aW5nIGJveGVzLlxuXHRcdC8vXHRcdE5vcm1hbGx5IGFwcGxpY2F0aW9uIGNvZGUgd2lsbCBub3QgbmVlZCB0byBpbnZva2UgdGhpc1xuXHRcdC8vXHRcdGRpcmVjdGx5LCBhbmQgd2lsbCB1c2UgdGhlIC4uLmJveC4uLiBmdW5jdGlvbnMgaW5zdGVhZC5cblx0XHQvLyBub2RlOiBET01Ob2RlXG5cdFx0Ly8gY29tcHV0ZWRTdHlsZTogT2JqZWN0P1xuXHRcdC8vXHRcdFRoaXMgcGFyYW1ldGVyIGFjY2VwdHMgY29tcHV0ZWQgc3R5bGVzIG9iamVjdC5cblx0XHQvL1x0XHRJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLCB0aGUgZnVuY3Rpb25zIHdpbGwgY2FsbFxuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgdG8gZ2V0IG9uZS4gSXQgaXMgYSBiZXR0ZXIgd2F5LCBjYWxsaW5nXG5cdFx0Ly9cdFx0ZG9qby9kb20tc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZSBvbmNlLCBhbmQgdGhlbiBwYXNzIHRoZSByZWZlcmVuY2UgdG8gdGhpc1xuXHRcdC8vXHRcdGNvbXB1dGVkU3R5bGUgcGFyYW1ldGVyLiBXaGVyZXZlciBwb3NzaWJsZSwgcmV1c2UgdGhlIHJldHVybmVkXG5cdFx0Ly9cdFx0b2JqZWN0IG9mIGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUoKS5cblxuXHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHR2YXIgcyA9IGNvbXB1dGVkU3R5bGUgfHwgc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKSwgcHggPSBzdHlsZS50b1BpeGVsVmFsdWUsXG5cdFx0XHRsID0gcHgobm9kZSwgcy5wYWRkaW5nTGVmdCksIHQgPSBweChub2RlLCBzLnBhZGRpbmdUb3ApLCByID0gcHgobm9kZSwgcy5wYWRkaW5nUmlnaHQpLCBiID0gcHgobm9kZSwgcy5wYWRkaW5nQm90dG9tKTtcblx0XHRyZXR1cm4ge2w6IGwsIHQ6IHQsIHI6IHIsIGI6IGIsIHc6IGwgKyByLCBoOiB0ICsgYn07XG5cdH07XG5cblx0dmFyIG5vbmUgPSBcIm5vbmVcIjtcblxuXHRnZW9tLmdldEJvcmRlckV4dGVudHMgPSBmdW5jdGlvbiBnZXRCb3JkZXJFeHRlbnRzKC8qRG9tTm9kZSovIG5vZGUsIC8qT2JqZWN0Ki8gY29tcHV0ZWRTdHlsZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRyZXR1cm5zIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdXNlZnVsIGZvciBub3RpbmcgdGhlIGJvcmRlclxuXHRcdC8vXHRcdGRpbWVuc2lvbnMuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0LSBsL3Qvci9iID0gdGhlIHN1bSBvZiBsZWZ0L3RvcC9yaWdodC9ib3R0b20gYm9yZGVyIChyZXNwZWN0aXZlbHkpXG5cdFx0Ly9cdFx0LSB3ID0gdGhlIHN1bSBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgYm9yZGVyXG5cdFx0Ly9cdFx0LSBoID0gdGhlIHN1bSBvZiB0aGUgdG9wIGFuZCBib3R0b20gYm9yZGVyXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGUgdy9oIGFyZSB1c2VkIGZvciBjYWxjdWxhdGluZyBib3hlcy5cblx0XHQvL1x0XHROb3JtYWxseSBhcHBsaWNhdGlvbiBjb2RlIHdpbGwgbm90IG5lZWQgdG8gaW52b2tlIHRoaXNcblx0XHQvL1x0XHRkaXJlY3RseSwgYW5kIHdpbGwgdXNlIHRoZSAuLi5ib3guLi4gZnVuY3Rpb25zIGluc3RlYWQuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZVxuXHRcdC8vIGNvbXB1dGVkU3R5bGU6IE9iamVjdD9cblx0XHQvL1x0XHRUaGlzIHBhcmFtZXRlciBhY2NlcHRzIGNvbXB1dGVkIHN0eWxlcyBvYmplY3QuXG5cdFx0Ly9cdFx0SWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGNhbGxcblx0XHQvL1x0XHRkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlIHRvIGdldCBvbmUuIEl0IGlzIGEgYmV0dGVyIHdheSwgY2FsbGluZ1xuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgb25jZSwgYW5kIHRoZW4gcGFzcyB0aGUgcmVmZXJlbmNlIHRvIHRoaXNcblx0XHQvL1x0XHRjb21wdXRlZFN0eWxlIHBhcmFtZXRlci4gV2hlcmV2ZXIgcG9zc2libGUsIHJldXNlIHRoZSByZXR1cm5lZFxuXHRcdC8vXHRcdG9iamVjdCBvZiBkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlKCkuXG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIHB4ID0gc3R5bGUudG9QaXhlbFZhbHVlLCBzID0gY29tcHV0ZWRTdHlsZSB8fCBzdHlsZS5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLFxuXHRcdFx0bCA9IHMuYm9yZGVyTGVmdFN0eWxlICE9IG5vbmUgPyBweChub2RlLCBzLmJvcmRlckxlZnRXaWR0aCkgOiAwLFxuXHRcdFx0dCA9IHMuYm9yZGVyVG9wU3R5bGUgIT0gbm9uZSA/IHB4KG5vZGUsIHMuYm9yZGVyVG9wV2lkdGgpIDogMCxcblx0XHRcdHIgPSBzLmJvcmRlclJpZ2h0U3R5bGUgIT0gbm9uZSA/IHB4KG5vZGUsIHMuYm9yZGVyUmlnaHRXaWR0aCkgOiAwLFxuXHRcdFx0YiA9IHMuYm9yZGVyQm90dG9tU3R5bGUgIT0gbm9uZSA/IHB4KG5vZGUsIHMuYm9yZGVyQm90dG9tV2lkdGgpIDogMDtcblx0XHRyZXR1cm4ge2w6IGwsIHQ6IHQsIHI6IHIsIGI6IGIsIHc6IGwgKyByLCBoOiB0ICsgYn07XG5cdH07XG5cblx0Z2VvbS5nZXRQYWRCb3JkZXJFeHRlbnRzID0gZnVuY3Rpb24gZ2V0UGFkQm9yZGVyRXh0ZW50cygvKkRvbU5vZGUqLyBub2RlLCAvKk9iamVjdCovIGNvbXB1dGVkU3R5bGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmV0dXJucyBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHVzZWZ1bCBmb3IgYm94IGZpdHRpbmcgd2l0aFxuXHRcdC8vXHRcdHJlZ2FyZHMgdG8gcGFkZGluZy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHQtIGwvdC9yL2IgPSB0aGUgc3VtIG9mIGxlZnQvdG9wL3JpZ2h0L2JvdHRvbSBwYWRkaW5nIGFuZCBsZWZ0L3RvcC9yaWdodC9ib3R0b20gYm9yZGVyIChyZXNwZWN0aXZlbHkpXG5cdFx0Ly9cdFx0LSB3ID0gdGhlIHN1bSBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFkZGluZyBhbmQgYm9yZGVyXG5cdFx0Ly9cdFx0LSBoID0gdGhlIHN1bSBvZiB0aGUgdG9wIGFuZCBib3R0b20gcGFkZGluZyBhbmQgYm9yZGVyXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGUgdy9oIGFyZSB1c2VkIGZvciBjYWxjdWxhdGluZyBib3hlcy5cblx0XHQvL1x0XHROb3JtYWxseSBhcHBsaWNhdGlvbiBjb2RlIHdpbGwgbm90IG5lZWQgdG8gaW52b2tlIHRoaXNcblx0XHQvL1x0XHRkaXJlY3RseSwgYW5kIHdpbGwgdXNlIHRoZSAuLi5ib3guLi4gZnVuY3Rpb25zIGluc3RlYWQuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZVxuXHRcdC8vIGNvbXB1dGVkU3R5bGU6IE9iamVjdD9cblx0XHQvL1x0XHRUaGlzIHBhcmFtZXRlciBhY2NlcHRzIGNvbXB1dGVkIHN0eWxlcyBvYmplY3QuXG5cdFx0Ly9cdFx0SWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGNhbGxcblx0XHQvL1x0XHRkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlIHRvIGdldCBvbmUuIEl0IGlzIGEgYmV0dGVyIHdheSwgY2FsbGluZ1xuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgb25jZSwgYW5kIHRoZW4gcGFzcyB0aGUgcmVmZXJlbmNlIHRvIHRoaXNcblx0XHQvL1x0XHRjb21wdXRlZFN0eWxlIHBhcmFtZXRlci4gV2hlcmV2ZXIgcG9zc2libGUsIHJldXNlIHRoZSByZXR1cm5lZFxuXHRcdC8vXHRcdG9iamVjdCBvZiBkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlKCkuXG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIHMgPSBjb21wdXRlZFN0eWxlIHx8IHN0eWxlLmdldENvbXB1dGVkU3R5bGUobm9kZSksXG5cdFx0XHRwID0gZ2VvbS5nZXRQYWRFeHRlbnRzKG5vZGUsIHMpLFxuXHRcdFx0YiA9IGdlb20uZ2V0Qm9yZGVyRXh0ZW50cyhub2RlLCBzKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bDogcC5sICsgYi5sLFxuXHRcdFx0dDogcC50ICsgYi50LFxuXHRcdFx0cjogcC5yICsgYi5yLFxuXHRcdFx0YjogcC5iICsgYi5iLFxuXHRcdFx0dzogcC53ICsgYi53LFxuXHRcdFx0aDogcC5oICsgYi5oXG5cdFx0fTtcblx0fTtcblxuXHRnZW9tLmdldE1hcmdpbkV4dGVudHMgPSBmdW5jdGlvbiBnZXRNYXJnaW5FeHRlbnRzKG5vZGUsIGNvbXB1dGVkU3R5bGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0cmV0dXJucyBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHVzZWZ1bCBmb3IgYm94IGZpdHRpbmcgd2l0aFxuXHRcdC8vXHRcdHJlZ2FyZHMgdG8gYm94IG1hcmdpbnMgKGkuZS4sIHRoZSBvdXRlci1ib3gpLlxuXHRcdC8vXG5cdFx0Ly9cdFx0LSBsL3QgPSBtYXJnaW5MZWZ0LCBtYXJnaW5Ub3AsIHJlc3BlY3RpdmVseVxuXHRcdC8vXHRcdC0gdyA9IHRvdGFsIHdpZHRoLCBtYXJnaW4gaW5jbHVzaXZlXG5cdFx0Ly9cdFx0LSBoID0gdG90YWwgaGVpZ2h0LCBtYXJnaW4gaW5jbHVzaXZlXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGUgdy9oIGFyZSB1c2VkIGZvciBjYWxjdWxhdGluZyBib3hlcy5cblx0XHQvL1x0XHROb3JtYWxseSBhcHBsaWNhdGlvbiBjb2RlIHdpbGwgbm90IG5lZWQgdG8gaW52b2tlIHRoaXNcblx0XHQvL1x0XHRkaXJlY3RseSwgYW5kIHdpbGwgdXNlIHRoZSAuLi5ib3guLi4gZnVuY3Rpb25zIGluc3RlYWQuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZVxuXHRcdC8vIGNvbXB1dGVkU3R5bGU6IE9iamVjdD9cblx0XHQvL1x0XHRUaGlzIHBhcmFtZXRlciBhY2NlcHRzIGNvbXB1dGVkIHN0eWxlcyBvYmplY3QuXG5cdFx0Ly9cdFx0SWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGNhbGxcblx0XHQvL1x0XHRkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlIHRvIGdldCBvbmUuIEl0IGlzIGEgYmV0dGVyIHdheSwgY2FsbGluZ1xuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgb25jZSwgYW5kIHRoZW4gcGFzcyB0aGUgcmVmZXJlbmNlIHRvIHRoaXNcblx0XHQvL1x0XHRjb21wdXRlZFN0eWxlIHBhcmFtZXRlci4gV2hlcmV2ZXIgcG9zc2libGUsIHJldXNlIHRoZSByZXR1cm5lZFxuXHRcdC8vXHRcdG9iamVjdCBvZiBkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlKCkuXG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIHMgPSBjb21wdXRlZFN0eWxlIHx8IHN0eWxlLmdldENvbXB1dGVkU3R5bGUobm9kZSksIHB4ID0gc3R5bGUudG9QaXhlbFZhbHVlLFxuXHRcdFx0bCA9IHB4KG5vZGUsIHMubWFyZ2luTGVmdCksIHQgPSBweChub2RlLCBzLm1hcmdpblRvcCksIHIgPSBweChub2RlLCBzLm1hcmdpblJpZ2h0KSwgYiA9IHB4KG5vZGUsIHMubWFyZ2luQm90dG9tKTtcblx0XHRyZXR1cm4ge2w6IGwsIHQ6IHQsIHI6IHIsIGI6IGIsIHc6IGwgKyByLCBoOiB0ICsgYn07XG5cdH07XG5cblx0Ly8gQm94IGdldHRlcnMgd29yayBpbiBhbnkgYm94IGNvbnRleHQgYmVjYXVzZSBvZmZzZXRXaWR0aC9jbGllbnRXaWR0aFxuXHQvLyBhcmUgaW52YXJpYW50IHdydCBib3ggY29udGV4dFxuXHQvL1xuXHQvLyBUaGV5IGRvICpub3QqIHdvcmsgZm9yIGRpc3BsYXk6IGlubGluZSBvYmplY3RzIHRoYXQgaGF2ZSBwYWRkaW5nIHN0eWxlc1xuXHQvLyBiZWNhdXNlIHRoZSB1c2VyIGFnZW50IGlnbm9yZXMgcGFkZGluZyAoaXQncyBib2d1cyBzdHlsaW5nIGluIGFueSBjYXNlKVxuXHQvL1xuXHQvLyBCZSBjYXJlZnVsIHdpdGggSU1HcyBiZWNhdXNlIHRoZXkgYXJlIGlubGluZSBvciBibG9jayBkZXBlbmRpbmcgb25cblx0Ly8gYnJvd3NlciBhbmQgYnJvd3NlciBtb2RlLlxuXG5cdC8vIEFsdGhvdWdoIGl0IHdvdWxkIGJlIGVhc2llciB0byByZWFkLCB0aGVyZSBhcmUgbm90IHNlcGFyYXRlIHZlcnNpb25zIG9mXG5cdC8vIF9nZXRNYXJnaW5Cb3ggZm9yIGVhY2ggYnJvd3NlciBiZWNhdXNlOlxuXHQvLyAxLiB0aGUgYnJhbmNoaW5nIGlzIG5vdCBleHBlbnNpdmVcblx0Ly8gMi4gZmFjdG9yaW5nIHRoZSBzaGFyZWQgY29kZSB3YXN0ZXMgY3ljbGVzIChmdW5jdGlvbiBjYWxsIG92ZXJoZWFkKVxuXHQvLyAzLiBkdXBsaWNhdGluZyB0aGUgc2hhcmVkIGNvZGUgd2FzdGVzIGJ5dGVzXG5cblx0Z2VvbS5nZXRNYXJnaW5Cb3ggPSBmdW5jdGlvbiBnZXRNYXJnaW5Cb3goLypEb21Ob2RlKi8gbm9kZSwgLypPYmplY3QqLyBjb21wdXRlZFN0eWxlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdHJldHVybnMgYW4gb2JqZWN0IHRoYXQgZW5jb2RlcyB0aGUgd2lkdGgsIGhlaWdodCwgbGVmdCBhbmQgdG9wXG5cdFx0Ly9cdFx0cG9zaXRpb25zIG9mIHRoZSBub2RlJ3MgbWFyZ2luIGJveC5cblx0XHQvLyBub2RlOiBET01Ob2RlXG5cdFx0Ly8gY29tcHV0ZWRTdHlsZTogT2JqZWN0P1xuXHRcdC8vXHRcdFRoaXMgcGFyYW1ldGVyIGFjY2VwdHMgY29tcHV0ZWQgc3R5bGVzIG9iamVjdC5cblx0XHQvL1x0XHRJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLCB0aGUgZnVuY3Rpb25zIHdpbGwgY2FsbFxuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgdG8gZ2V0IG9uZS4gSXQgaXMgYSBiZXR0ZXIgd2F5LCBjYWxsaW5nXG5cdFx0Ly9cdFx0ZG9qby9kb20tc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZSBvbmNlLCBhbmQgdGhlbiBwYXNzIHRoZSByZWZlcmVuY2UgdG8gdGhpc1xuXHRcdC8vXHRcdGNvbXB1dGVkU3R5bGUgcGFyYW1ldGVyLiBXaGVyZXZlciBwb3NzaWJsZSwgcmV1c2UgdGhlIHJldHVybmVkXG5cdFx0Ly9cdFx0b2JqZWN0IG9mIGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUoKS5cblxuXHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHR2YXIgcyA9IGNvbXB1dGVkU3R5bGUgfHwgc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKSwgbWUgPSBnZW9tLmdldE1hcmdpbkV4dGVudHMobm9kZSwgcyksXG5cdFx0XHRsID0gbm9kZS5vZmZzZXRMZWZ0IC0gbWUubCwgdCA9IG5vZGUub2Zmc2V0VG9wIC0gbWUudCwgcCA9IG5vZGUucGFyZW50Tm9kZSwgcHggPSBzdHlsZS50b1BpeGVsVmFsdWUsIHBjcztcblxuXHRcdGlmKChoYXMoXCJpZVwiKSA9PSA4ICYmICFoYXMoXCJxdWlya3NcIikpKXtcblx0XHRcdC8vIElFIDggb2Zmc2V0TGVmdC9Ub3AgaW5jbHVkZXMgdGhlIHBhcmVudCdzIGJvcmRlclxuXHRcdFx0aWYocCl7XG5cdFx0XHRcdHBjcyA9IHN0eWxlLmdldENvbXB1dGVkU3R5bGUocCk7XG5cdFx0XHRcdGwgLT0gcGNzLmJvcmRlckxlZnRTdHlsZSAhPSBub25lID8gcHgobm9kZSwgcGNzLmJvcmRlckxlZnRXaWR0aCkgOiAwO1xuXHRcdFx0XHR0IC09IHBjcy5ib3JkZXJUb3BTdHlsZSAhPSBub25lID8gcHgobm9kZSwgcGNzLmJvcmRlclRvcFdpZHRoKSA6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7bDogbCwgdDogdCwgdzogbm9kZS5vZmZzZXRXaWR0aCArIG1lLncsIGg6IG5vZGUub2Zmc2V0SGVpZ2h0ICsgbWUuaH07XG5cdH07XG5cblx0Z2VvbS5nZXRDb250ZW50Qm94ID0gZnVuY3Rpb24gZ2V0Q29udGVudEJveChub2RlLCBjb21wdXRlZFN0eWxlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJldHVybnMgYW4gb2JqZWN0IHRoYXQgZW5jb2RlcyB0aGUgd2lkdGgsIGhlaWdodCwgbGVmdCBhbmQgdG9wXG5cdFx0Ly9cdFx0cG9zaXRpb25zIG9mIHRoZSBub2RlJ3MgY29udGVudCBib3gsIGlycmVzcGVjdGl2ZSBvZiB0aGVcblx0XHQvL1x0XHRjdXJyZW50IGJveCBtb2RlbC5cblx0XHQvLyBub2RlOiBET01Ob2RlXG5cdFx0Ly8gY29tcHV0ZWRTdHlsZTogT2JqZWN0P1xuXHRcdC8vXHRcdFRoaXMgcGFyYW1ldGVyIGFjY2VwdHMgY29tcHV0ZWQgc3R5bGVzIG9iamVjdC5cblx0XHQvL1x0XHRJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLCB0aGUgZnVuY3Rpb25zIHdpbGwgY2FsbFxuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgdG8gZ2V0IG9uZS4gSXQgaXMgYSBiZXR0ZXIgd2F5LCBjYWxsaW5nXG5cdFx0Ly9cdFx0ZG9qby9kb20tc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZSBvbmNlLCBhbmQgdGhlbiBwYXNzIHRoZSByZWZlcmVuY2UgdG8gdGhpc1xuXHRcdC8vXHRcdGNvbXB1dGVkU3R5bGUgcGFyYW1ldGVyLiBXaGVyZXZlciBwb3NzaWJsZSwgcmV1c2UgdGhlIHJldHVybmVkXG5cdFx0Ly9cdFx0b2JqZWN0IG9mIGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUoKS5cblxuXHRcdC8vIGNsaWVudFdpZHRoL0hlaWdodCBhcmUgaW1wb3J0YW50IHNpbmNlIHRoZSBhdXRvbWF0aWNhbGx5IGFjY291bnQgZm9yIHNjcm9sbGJhcnNcblx0XHQvLyBmYWxsYmFjayB0byBvZmZzZXRXaWR0aC9IZWlnaHQgZm9yIHNwZWNpYWwgY2FzZXMgKHNlZSAjMzM3OClcblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIHMgPSBjb21wdXRlZFN0eWxlIHx8IHN0eWxlLmdldENvbXB1dGVkU3R5bGUobm9kZSksIHcgPSBub2RlLmNsaWVudFdpZHRoLCBoLFxuXHRcdFx0cGUgPSBnZW9tLmdldFBhZEV4dGVudHMobm9kZSwgcyksIGJlID0gZ2VvbS5nZXRCb3JkZXJFeHRlbnRzKG5vZGUsIHMpLCBsID0gbm9kZS5vZmZzZXRMZWZ0ICsgcGUubCArIGJlLmwsXG5cdFx0XHR0ID0gbm9kZS5vZmZzZXRUb3AgKyBwZS50ICsgYmUudDtcblx0XHRpZighdyl7XG5cdFx0XHR3ID0gbm9kZS5vZmZzZXRXaWR0aCAtIGJlLnc7XG5cdFx0XHRoID0gbm9kZS5vZmZzZXRIZWlnaHQgLSBiZS5oO1xuXHRcdH1lbHNle1xuXHRcdFx0aCA9IG5vZGUuY2xpZW50SGVpZ2h0O1xuXHRcdH1cblxuXHRcdGlmKChoYXMoXCJpZVwiKSA9PSA4ICYmICFoYXMoXCJxdWlya3NcIikpKXtcblx0XHRcdC8vIElFIDggb2Zmc2V0TGVmdC9Ub3AgaW5jbHVkZXMgdGhlIHBhcmVudCdzIGJvcmRlclxuXHRcdFx0dmFyIHAgPSBub2RlLnBhcmVudE5vZGUsIHB4ID0gc3R5bGUudG9QaXhlbFZhbHVlLCBwY3M7XG5cdFx0XHRpZihwKXtcblx0XHRcdFx0cGNzID0gc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZShwKTtcblx0XHRcdFx0bCAtPSBwY3MuYm9yZGVyTGVmdFN0eWxlICE9IG5vbmUgPyBweChub2RlLCBwY3MuYm9yZGVyTGVmdFdpZHRoKSA6IDA7XG5cdFx0XHRcdHQgLT0gcGNzLmJvcmRlclRvcFN0eWxlICE9IG5vbmUgPyBweChub2RlLCBwY3MuYm9yZGVyVG9wV2lkdGgpIDogMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge2w6IGwsIHQ6IHQsIHc6IHcgLSBwZS53LCBoOiBoIC0gcGUuaH07XG5cdH07XG5cblx0Ly8gQm94IHNldHRlcnMgZGVwZW5kIG9uIGJveCBjb250ZXh0IGJlY2F1c2UgaW50ZXJwcmV0YXRpb24gb2Ygd2lkdGgvaGVpZ2h0IHN0eWxlc1xuXHQvLyB2YXJ5IHdydCBib3ggY29udGV4dC5cblx0Ly9cblx0Ly8gVGhlIHZhbHVlIG9mIGJveE1vZGVsIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGJveCBjb250ZXh0LlxuXHQvLyBib3hNb2RlbCBjYW4gYmUgc2V0IGRpcmVjdGx5IHRvIGNoYW5nZSBiZWhhdmlvci5cblx0Ly9cblx0Ly8gQmV3YXJlIG9mIGRpc3BsYXk6IGlubGluZSBvYmplY3RzIHRoYXQgaGF2ZSBwYWRkaW5nIHN0eWxlc1xuXHQvLyBiZWNhdXNlIHRoZSB1c2VyIGFnZW50IGlnbm9yZXMgcGFkZGluZyAoaXQncyBhIGJvZ3VzIHNldHVwIGFueXdheSlcblx0Ly9cblx0Ly8gQmUgY2FyZWZ1bCB3aXRoIElNR3MgYmVjYXVzZSB0aGV5IGFyZSBpbmxpbmUgb3IgYmxvY2sgZGVwZW5kaW5nIG9uXG5cdC8vIGJyb3dzZXIgYW5kIGJyb3dzZXIgbW9kZS5cblx0Ly9cblx0Ly8gRWxlbWVudHMgb3RoZXIgdGhhbiBESVYgbWF5IGhhdmUgc3BlY2lhbCBxdWlya3MsIGxpa2UgYnVpbHQtaW5cblx0Ly8gbWFyZ2lucyBvciBwYWRkaW5nLCBvciB2YWx1ZXMgbm90IGRldGVjdGFibGUgdmlhIGNvbXB1dGVkU3R5bGUuXG5cdC8vIEluIHBhcnRpY3VsYXIsIG1hcmdpbnMgb24gVEFCTEUgZG8gbm90IHNlZW1zIHRvIGFwcGVhclxuXHQvLyBhdCBhbGwgaW4gY29tcHV0ZWRTdHlsZSBvbiBNb3ppbGxhLlxuXG5cdGZ1bmN0aW9uIHNldEJveCgvKkRvbU5vZGUqLyBub2RlLCAvKk51bWJlcj8qLyBsLCAvKk51bWJlcj8qLyB0LCAvKk51bWJlcj8qLyB3LCAvKk51bWJlcj8qLyBoLCAvKlN0cmluZz8qLyB1KXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdHNldHMgd2lkdGgvaGVpZ2h0L2xlZnQvdG9wIGluIHRoZSBjdXJyZW50IChuYXRpdmUpIGJveC1tb2RlbFxuXHRcdC8vXHRcdGRpbWVuc2lvbnMuIFVzZXMgdGhlIHVuaXQgcGFzc2VkIGluIHUuXG5cdFx0Ly8gbm9kZTpcblx0XHQvL1x0XHRET00gTm9kZSByZWZlcmVuY2UuIElkIHN0cmluZyBub3Qgc3VwcG9ydGVkIGZvciBwZXJmb3JtYW5jZVxuXHRcdC8vXHRcdHJlYXNvbnMuXG5cdFx0Ly8gbDpcblx0XHQvL1x0XHRsZWZ0IG9mZnNldCBmcm9tIHBhcmVudC5cblx0XHQvLyB0OlxuXHRcdC8vXHRcdHRvcCBvZmZzZXQgZnJvbSBwYXJlbnQuXG5cdFx0Ly8gdzpcblx0XHQvL1x0XHR3aWR0aCBpbiBjdXJyZW50IGJveCBtb2RlbC5cblx0XHQvLyBoOlxuXHRcdC8vXHRcdHdpZHRoIGluIGN1cnJlbnQgYm94IG1vZGVsLlxuXHRcdC8vIHU6XG5cdFx0Ly9cdFx0dW5pdCBtZWFzdXJlIHRvIHVzZSBmb3Igb3RoZXIgbWVhc3VyZXMuIERlZmF1bHRzIHRvIFwicHhcIi5cblx0XHR1ID0gdSB8fCBcInB4XCI7XG5cdFx0dmFyIHMgPSBub2RlLnN0eWxlO1xuXHRcdGlmKCFpc05hTihsKSl7XG5cdFx0XHRzLmxlZnQgPSBsICsgdTtcblx0XHR9XG5cdFx0aWYoIWlzTmFOKHQpKXtcblx0XHRcdHMudG9wID0gdCArIHU7XG5cdFx0fVxuXHRcdGlmKHcgPj0gMCl7XG5cdFx0XHRzLndpZHRoID0gdyArIHU7XG5cdFx0fVxuXHRcdGlmKGggPj0gMCl7XG5cdFx0XHRzLmhlaWdodCA9IGggKyB1O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGlzQnV0dG9uVGFnKC8qRG9tTm9kZSovIG5vZGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VHJ1ZSBpZiB0aGUgbm9kZSBpcyBCVVRUT04gb3IgSU5QVVQudHlwZT1cImJ1dHRvblwiLlxuXHRcdHJldHVybiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImJ1dHRvblwiIHx8XG5cdFx0XHRub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImlucHV0XCIgJiYgKG5vZGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpID09IFwiYnV0dG9uXCI7IC8vIGJvb2xlYW5cblx0fVxuXG5cdGZ1bmN0aW9uIHVzZXNCb3JkZXJCb3goLypEb21Ob2RlKi8gbm9kZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUcnVlIGlmIHRoZSBub2RlIHVzZXMgYm9yZGVyLWJveCBsYXlvdXQuXG5cblx0XHQvLyBXZSBjb3VsZCB0ZXN0IHRoZSBjb21wdXRlZCBzdHlsZSBvZiBub2RlIHRvIHNlZSBpZiBhIHBhcnRpY3VsYXIgYm94XG5cdFx0Ly8gaGFzIGJlZW4gc3BlY2lmaWVkLCBidXQgdGhlcmUgYXJlIGRldGFpbHMgYW5kIHdlIGNob29zZSBub3QgdG8gYm90aGVyLlxuXG5cdFx0Ly8gVEFCTEUgYW5kIEJVVFRPTiAoYW5kIElOUFVUIHR5cGU9YnV0dG9uKSBhcmUgYWx3YXlzIGJvcmRlci1ib3ggYnkgZGVmYXVsdC5cblx0XHQvLyBJZiB5b3UgaGF2ZSBhc3NpZ25lZCBhIGRpZmZlcmVudCBib3ggdG8gZWl0aGVyIG9uZSB2aWEgQ1NTIHRoZW5cblx0XHQvLyBib3ggZnVuY3Rpb25zIHdpbGwgYnJlYWsuXG5cblx0XHRyZXR1cm4gZ2VvbS5ib3hNb2RlbCA9PSBcImJvcmRlci1ib3hcIiB8fCBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcInRhYmxlXCIgfHwgaXNCdXR0b25UYWcobm9kZSk7IC8vIGJvb2xlYW5cblx0fVxuXG5cdGdlb20uc2V0Q29udGVudFNpemUgPSBmdW5jdGlvbiBzZXRDb250ZW50U2l6ZSgvKkRvbU5vZGUqLyBub2RlLCAvKk9iamVjdCovIGJveCwgLypPYmplY3QqLyBjb21wdXRlZFN0eWxlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNldHMgdGhlIHNpemUgb2YgdGhlIG5vZGUncyBjb250ZW50cywgaXJyZXNwZWN0aXZlIG9mIG1hcmdpbnMsXG5cdFx0Ly9cdFx0cGFkZGluZywgb3IgYm9yZGVycy5cblx0XHQvLyBub2RlOiBET01Ob2RlXG5cdFx0Ly8gYm94OiBPYmplY3Rcblx0XHQvL1x0XHRoYXNoIHdpdGggb3B0aW9uYWwgXCJ3XCIsIGFuZCBcImhcIiBwcm9wZXJ0aWVzIGZvciBcIndpZHRoXCIsIGFuZCBcImhlaWdodFwiXG5cdFx0Ly9cdFx0cmVzcGVjdGl2ZWx5LiBBbGwgc3BlY2lmaWVkIHByb3BlcnRpZXMgc2hvdWxkIGhhdmUgbnVtZXJpYyB2YWx1ZXMgaW4gd2hvbGUgcGl4ZWxzLlxuXHRcdC8vIGNvbXB1dGVkU3R5bGU6IE9iamVjdD9cblx0XHQvL1x0XHRUaGlzIHBhcmFtZXRlciBhY2NlcHRzIGNvbXB1dGVkIHN0eWxlcyBvYmplY3QuXG5cdFx0Ly9cdFx0SWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGNhbGxcblx0XHQvL1x0XHRkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlIHRvIGdldCBvbmUuIEl0IGlzIGEgYmV0dGVyIHdheSwgY2FsbGluZ1xuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgb25jZSwgYW5kIHRoZW4gcGFzcyB0aGUgcmVmZXJlbmNlIHRvIHRoaXNcblx0XHQvL1x0XHRjb21wdXRlZFN0eWxlIHBhcmFtZXRlci4gV2hlcmV2ZXIgcG9zc2libGUsIHJldXNlIHRoZSByZXR1cm5lZFxuXHRcdC8vXHRcdG9iamVjdCBvZiBkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlKCkuXG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIHcgPSBib3gudywgaCA9IGJveC5oO1xuXHRcdGlmKHVzZXNCb3JkZXJCb3gobm9kZSkpe1xuXHRcdFx0dmFyIHBiID0gZ2VvbS5nZXRQYWRCb3JkZXJFeHRlbnRzKG5vZGUsIGNvbXB1dGVkU3R5bGUpO1xuXHRcdFx0aWYodyA+PSAwKXtcblx0XHRcdFx0dyArPSBwYi53O1xuXHRcdFx0fVxuXHRcdFx0aWYoaCA+PSAwKXtcblx0XHRcdFx0aCArPSBwYi5oO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRzZXRCb3gobm9kZSwgTmFOLCBOYU4sIHcsIGgpO1xuXHR9O1xuXG5cdHZhciBuaWxFeHRlbnRzID0ge2w6IDAsIHQ6IDAsIHc6IDAsIGg6IDB9O1xuXG5cdGdlb20uc2V0TWFyZ2luQm94ID0gZnVuY3Rpb24gc2V0TWFyZ2luQm94KC8qRG9tTm9kZSovIG5vZGUsIC8qT2JqZWN0Ki8gYm94LCAvKk9iamVjdCovIGNvbXB1dGVkU3R5bGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0c2V0cyB0aGUgc2l6ZSBvZiB0aGUgbm9kZSdzIG1hcmdpbiBib3ggYW5kIHBsYWNlbWVudFxuXHRcdC8vXHRcdChsZWZ0L3RvcCksIGlycmVzcGVjdGl2ZSBvZiBib3ggbW9kZWwuIFRoaW5rIG9mIGl0IGFzIGFcblx0XHQvL1x0XHRwYXNzdGhyb3VnaCB0byBzZXRCb3ggdGhhdCBoYW5kbGVzIGJveC1tb2RlbCB2YWdhcmllcyBmb3Jcblx0XHQvL1x0XHR5b3UuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZVxuXHRcdC8vIGJveDogT2JqZWN0XG5cdFx0Ly9cdFx0aGFzaCB3aXRoIG9wdGlvbmFsIFwibFwiLCBcInRcIiwgXCJ3XCIsIGFuZCBcImhcIiBwcm9wZXJ0aWVzIGZvciBcImxlZnRcIiwgXCJyaWdodFwiLCBcIndpZHRoXCIsIGFuZCBcImhlaWdodFwiXG5cdFx0Ly9cdFx0cmVzcGVjdGl2ZWx5LiBBbGwgc3BlY2lmaWVkIHByb3BlcnRpZXMgc2hvdWxkIGhhdmUgbnVtZXJpYyB2YWx1ZXMgaW4gd2hvbGUgcGl4ZWxzLlxuXHRcdC8vIGNvbXB1dGVkU3R5bGU6IE9iamVjdD9cblx0XHQvL1x0XHRUaGlzIHBhcmFtZXRlciBhY2NlcHRzIGNvbXB1dGVkIHN0eWxlcyBvYmplY3QuXG5cdFx0Ly9cdFx0SWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGNhbGxcblx0XHQvL1x0XHRkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlIHRvIGdldCBvbmUuIEl0IGlzIGEgYmV0dGVyIHdheSwgY2FsbGluZ1xuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgb25jZSwgYW5kIHRoZW4gcGFzcyB0aGUgcmVmZXJlbmNlIHRvIHRoaXNcblx0XHQvL1x0XHRjb21wdXRlZFN0eWxlIHBhcmFtZXRlci4gV2hlcmV2ZXIgcG9zc2libGUsIHJldXNlIHRoZSByZXR1cm5lZFxuXHRcdC8vXHRcdG9iamVjdCBvZiBkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlKCkuXG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIHMgPSBjb21wdXRlZFN0eWxlIHx8IHN0eWxlLmdldENvbXB1dGVkU3R5bGUobm9kZSksIHcgPSBib3gudywgaCA9IGJveC5oLFxuXHRcdC8vIFNvbWUgZWxlbWVudHMgaGF2ZSBzcGVjaWFsIHBhZGRpbmcsIG1hcmdpbiwgYW5kIGJveC1tb2RlbCBzZXR0aW5ncy5cblx0XHQvLyBUbyB1c2UgYm94IGZ1bmN0aW9ucyB5b3UgbWF5IG5lZWQgdG8gc2V0IHBhZGRpbmcsIG1hcmdpbiBleHBsaWNpdGx5LlxuXHRcdC8vIENvbnRyb2xsaW5nIGJveC1tb2RlbCBpcyBoYXJkZXIsIGluIGEgcGluY2ggeW91IG1pZ2h0IHNldCBkb2pvL2RvbS1nZW9tZXRyeS5ib3hNb2RlbC5cblx0XHRcdHBiID0gdXNlc0JvcmRlckJveChub2RlKSA/IG5pbEV4dGVudHMgOiBnZW9tLmdldFBhZEJvcmRlckV4dGVudHMobm9kZSwgcyksXG5cdFx0XHRtYiA9IGdlb20uZ2V0TWFyZ2luRXh0ZW50cyhub2RlLCBzKTtcblx0XHRpZihoYXMoXCJ3ZWJraXRcIikpe1xuXHRcdFx0Ly8gb24gU2FmYXJpICgzLjEuMiksIGJ1dHRvbiBub2RlcyB3aXRoIG5vIGV4cGxpY2l0IHNpemUgaGF2ZSBhIGRlZmF1bHQgbWFyZ2luXG5cdFx0XHQvLyBzZXR0aW5nIGFuIGV4cGxpY2l0IHNpemUgZWxpbWluYXRlcyB0aGUgbWFyZ2luLlxuXHRcdFx0Ly8gV2UgaGF2ZSB0byBzd2l6emxlIHRoZSB3aWR0aCB0byBnZXQgY29ycmVjdCBtYXJnaW4gcmVhZGluZy5cblx0XHRcdGlmKGlzQnV0dG9uVGFnKG5vZGUpKXtcblx0XHRcdFx0dmFyIG5zID0gbm9kZS5zdHlsZTtcblx0XHRcdFx0aWYodyA+PSAwICYmICFucy53aWR0aCl7XG5cdFx0XHRcdFx0bnMud2lkdGggPSBcIjRweFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGggPj0gMCAmJiAhbnMuaGVpZ2h0KXtcblx0XHRcdFx0XHRucy5oZWlnaHQgPSBcIjRweFwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHcgPj0gMCl7XG5cdFx0XHR3ID0gTWF0aC5tYXgodyAtIHBiLncgLSBtYi53LCAwKTtcblx0XHR9XG5cdFx0aWYoaCA+PSAwKXtcblx0XHRcdGggPSBNYXRoLm1heChoIC0gcGIuaCAtIG1iLmgsIDApO1xuXHRcdH1cblx0XHRzZXRCb3gobm9kZSwgYm94LmwsIGJveC50LCB3LCBoKTtcblx0fTtcblxuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQvLyBQb3NpdGlvbmluZ1xuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdGdlb20uaXNCb2R5THRyID0gZnVuY3Rpb24gaXNCb2R5THRyKC8qRG9jdW1lbnQ/Ki8gZG9jKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBsYW5ndWFnZSBpcyBsZWZ0LXRvLXJpZ2h0LCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuXHRcdC8vIGRvYzogRG9jdW1lbnQ/XG5cdFx0Ly9cdFx0T3B0aW9uYWwgZG9jdW1lbnQgdG8gcXVlcnkuICAgSWYgdW5zcGVjaWZpZWQsIHVzZSB3aW4uZG9jLlxuXHRcdC8vIHJldHVybnM6IEJvb2xlYW5cblxuXHRcdGRvYyA9IGRvYyB8fCB3aW4uZG9jO1xuXHRcdHJldHVybiAod2luLmJvZHkoZG9jKS5kaXIgfHwgZG9jLmRvY3VtZW50RWxlbWVudC5kaXIgfHwgXCJsdHJcIikudG9Mb3dlckNhc2UoKSA9PSBcImx0clwiOyAvLyBCb29sZWFuXG5cdH07XG5cblx0Z2VvbS5kb2NTY3JvbGwgPSBmdW5jdGlvbiBkb2NTY3JvbGwoLypEb2N1bWVudD8qLyBkb2Mpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmV0dXJucyBhbiBvYmplY3Qgd2l0aCB7bm9kZSwgeCwgeX0gd2l0aCBjb3JyZXNwb25kaW5nIG9mZnNldHMuXG5cdFx0Ly8gZG9jOiBEb2N1bWVudD9cblx0XHQvL1x0XHRPcHRpb25hbCBkb2N1bWVudCB0byBxdWVyeS4gICBJZiB1bnNwZWNpZmllZCwgdXNlIHdpbi5kb2MuXG5cdFx0Ly8gcmV0dXJuczogT2JqZWN0XG5cblx0XHRkb2MgPSBkb2MgfHwgd2luLmRvYztcblx0XHR2YXIgbm9kZSA9IHdpbi5kb2MucGFyZW50V2luZG93IHx8IHdpbi5kb2MuZGVmYXVsdFZpZXc7ICAgLy8gdXNlIFVJIHdpbmRvdywgbm90IGRvam8uZ2xvYmFsIHdpbmRvdy4gICBUT0RPOiB1c2UgZG9qby93aW5kb3c6OmdldCgpIGV4Y2VwdCBmb3IgY2lyY3VsYXIgZGVwZW5kZW5jeSBwcm9ibGVtXG5cdFx0cmV0dXJuIFwicGFnZVhPZmZzZXRcIiBpbiBub2RlID8ge3g6IG5vZGUucGFnZVhPZmZzZXQsIHk6IG5vZGUucGFnZVlPZmZzZXQgfSA6XG5cdFx0XHQobm9kZSA9IGhhcyhcInF1aXJrc1wiKSA/IHdpbi5ib2R5KGRvYykgOiBkb2MuZG9jdW1lbnRFbGVtZW50KSAmJlxuXHRcdFx0XHR7eDogZ2VvbS5maXhJZUJpRGlTY3JvbGxMZWZ0KG5vZGUuc2Nyb2xsTGVmdCB8fCAwLCBkb2MpLCB5OiBub2RlLnNjcm9sbFRvcCB8fCAwIH07XG5cdH07XG5cblx0Z2VvbS5nZXRJZURvY3VtZW50RWxlbWVudE9mZnNldCA9IGZ1bmN0aW9uKC8qRG9jdW1lbnQ/Ki8gZG9jKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdERlcHJlY2F0ZWQgbWV0aG9kIHByZXZpb3VzbHkgdXNlZCBmb3IgSUU2LUlFNy4gIE5vdywganVzdCByZXR1cm5zIGB7eDowLCB5OjB9YC5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogMCxcblx0XHRcdHk6IDBcblx0XHR9O1xuXHR9O1xuXG5cdGdlb20uZml4SWVCaURpU2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIGZpeEllQmlEaVNjcm9sbExlZnQoLypJbnRlZ2VyKi8gc2Nyb2xsTGVmdCwgLypEb2N1bWVudD8qLyBkb2Mpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0SW4gUlRMIGRpcmVjdGlvbiwgc2Nyb2xsTGVmdCBzaG91bGQgYmUgYSBuZWdhdGl2ZSB2YWx1ZSwgYnV0IElFXG5cdFx0Ly9cdFx0cmV0dXJucyBhIHBvc2l0aXZlIG9uZS4gQWxsIGNvZGVzIHVzaW5nIGRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0XG5cdFx0Ly9cdFx0bXVzdCBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gZml4IHRoaXMgZXJyb3IsIG90aGVyd2lzZSB0aGUgcG9zaXRpb25cblx0XHQvL1x0XHR3aWxsIG9mZnNldCB0byByaWdodCB3aGVuIHRoZXJlIGlzIGEgaG9yaXpvbnRhbCBzY3JvbGxiYXIuXG5cdFx0Ly8gc2Nyb2xsTGVmdDogTnVtYmVyXG5cdFx0Ly8gZG9jOiBEb2N1bWVudD9cblx0XHQvL1x0XHRPcHRpb25hbCBkb2N1bWVudCB0byBxdWVyeS4gICBJZiB1bnNwZWNpZmllZCwgdXNlIHdpbi5kb2MuXG5cdFx0Ly8gcmV0dXJuczogTnVtYmVyXG5cblx0XHQvLyBJbiBSVEwgZGlyZWN0aW9uLCBzY3JvbGxMZWZ0IHNob3VsZCBiZSBhIG5lZ2F0aXZlIHZhbHVlLCBidXQgSUVcblx0XHQvLyByZXR1cm5zIGEgcG9zaXRpdmUgb25lLiBBbGwgY29kZXMgdXNpbmcgZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRcblx0XHQvLyBtdXN0IGNhbGwgdGhpcyBmdW5jdGlvbiB0byBmaXggdGhpcyBlcnJvciwgb3RoZXJ3aXNlIHRoZSBwb3NpdGlvblxuXHRcdC8vIHdpbGwgb2Zmc2V0IHRvIHJpZ2h0IHdoZW4gdGhlcmUgaXMgYSBob3Jpem9udGFsIHNjcm9sbGJhci5cblxuXHRcdGRvYyA9IGRvYyB8fCB3aW4uZG9jO1xuXHRcdHZhciBpZSA9IGhhcyhcImllXCIpO1xuXHRcdGlmKGllICYmICFnZW9tLmlzQm9keUx0cihkb2MpKXtcblx0XHRcdHZhciBxayA9IGhhcyhcInF1aXJrc1wiKSxcblx0XHRcdFx0ZGUgPSBxayA/IHdpbi5ib2R5KGRvYykgOiBkb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0XHRwd2luID0gd2luLmdsb2JhbDtcdC8vIFRPRE86IHVzZSB3aW5VdGlscy5nZXQoZG9jKSBhZnRlciByZXNvbHZpbmcgY2lyY3VsYXIgZGVwZW5kZW5jeSBiL3cgZG9tLWdlb21ldHJ5LmpzIGFuZCBkb2pvL3dpbmRvdy5qc1xuXHRcdFx0aWYoaWUgPT0gNiAmJiAhcWsgJiYgcHdpbi5mcmFtZUVsZW1lbnQgJiYgZGUuc2Nyb2xsSGVpZ2h0ID4gZGUuY2xpZW50SGVpZ2h0KXtcblx0XHRcdFx0c2Nyb2xsTGVmdCArPSBkZS5jbGllbnRMZWZ0OyAvLyB3b3JrYXJvdW5kIGllNitzdHJpY3QrcnRsK2lmcmFtZSt2ZXJ0aWNhbC1zY3JvbGxiYXIgYnVnIHdoZXJlIGNsaWVudFdpZHRoIGlzIHRvbyBzbWFsbCBieSBjbGllbnRMZWZ0IHBpeGVsc1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIChpZSA8IDggfHwgcWspID8gKHNjcm9sbExlZnQgKyBkZS5jbGllbnRXaWR0aCAtIGRlLnNjcm9sbFdpZHRoKSA6IC1zY3JvbGxMZWZ0OyAvLyBJbnRlZ2VyXG5cdFx0fVxuXHRcdHJldHVybiBzY3JvbGxMZWZ0OyAvLyBJbnRlZ2VyXG5cdH07XG5cblx0Z2VvbS5wb3NpdGlvbiA9IGZ1bmN0aW9uKC8qRG9tTm9kZSovIG5vZGUsIC8qQm9vbGVhbj8qLyBpbmNsdWRlU2Nyb2xsKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEdldHMgdGhlIHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSBwYXNzZWQgZWxlbWVudCByZWxhdGl2ZSB0b1xuXHRcdC8vXHRcdHRoZSB2aWV3cG9ydCAoaWYgaW5jbHVkZVNjcm9sbD09ZmFsc2UpLCBvciByZWxhdGl2ZSB0byB0aGVcblx0XHQvL1x0XHRkb2N1bWVudCByb290IChpZiBpbmNsdWRlU2Nyb2xsPT10cnVlKS5cblx0XHQvL1xuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdFJldHVybnMgYW4gb2JqZWN0IG9mIHRoZSBmb3JtOlxuXHRcdC8vXHRcdGB7IHg6IDEwMCwgeTogMzAwLCB3OiAyMCwgaDogMTUgfWAuXG5cdFx0Ly9cdFx0SWYgaW5jbHVkZVNjcm9sbD09dHJ1ZSwgdGhlIHggYW5kIHkgdmFsdWVzIHdpbGwgaW5jbHVkZSBhbnlcblx0XHQvL1x0XHRkb2N1bWVudCBvZmZzZXRzIHRoYXQgbWF5IGFmZmVjdCB0aGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlXG5cdFx0Ly9cdFx0dmlld3BvcnQuXG5cdFx0Ly9cdFx0VXNlcyB0aGUgYm9yZGVyLWJveCBtb2RlbCAoaW5jbHVzaXZlIG9mIGJvcmRlciBhbmQgcGFkZGluZyBidXRcblx0XHQvL1x0XHRub3QgbWFyZ2luKS4gIERvZXMgbm90IGFjdCBhcyBhIHNldHRlci5cblx0XHQvLyBub2RlOiBET01Ob2RlfFN0cmluZ1xuXHRcdC8vIGluY2x1ZGVTY3JvbGw6IEJvb2xlYW4/XG5cdFx0Ly8gcmV0dXJuczogT2JqZWN0XG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyXHRkYiA9IHdpbi5ib2R5KG5vZGUub3duZXJEb2N1bWVudCksXG5cdFx0XHRyZXQgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHJldCA9IHt4OiByZXQubGVmdCwgeTogcmV0LnRvcCwgdzogcmV0LnJpZ2h0IC0gcmV0LmxlZnQsIGg6IHJldC5ib3R0b20gLSByZXQudG9wfTtcblxuXHRcdGlmKGhhcyhcImllXCIpIDwgOSl7XG5cdFx0XHQvLyBmaXhlcyB0aGUgcG9zaXRpb24gaW4gSUUsIHF1aXJrcyBtb2RlXG5cdFx0XHRyZXQueCAtPSAoaGFzKFwicXVpcmtzXCIpID8gZGIuY2xpZW50TGVmdCArIGRiLm9mZnNldExlZnQgOiAwKTtcblx0XHRcdHJldC55IC09IChoYXMoXCJxdWlya3NcIikgPyBkYi5jbGllbnRUb3AgKyBkYi5vZmZzZXRUb3AgOiAwKTtcblx0XHR9XG5cblx0XHQvLyBhY2NvdW50IGZvciBkb2N1bWVudCBzY3JvbGxpbmdcblx0XHQvLyBpZiBvZmZzZXRQYXJlbnQgaXMgdXNlZCwgcmV0IHZhbHVlIGFscmVhZHkgaW5jbHVkZXMgc2Nyb2xsIHBvc2l0aW9uXG5cdFx0Ly8gc28gd2UgbWF5IGhhdmUgdG8gYWN0dWFsbHkgcmVtb3ZlIHRoYXQgdmFsdWUgaWYgIWluY2x1ZGVTY3JvbGxcblx0XHRpZihpbmNsdWRlU2Nyb2xsKXtcblx0XHRcdHZhciBzY3JvbGwgPSBnZW9tLmRvY1Njcm9sbChub2RlLm93bmVyRG9jdW1lbnQpO1xuXHRcdFx0cmV0LnggKz0gc2Nyb2xsLng7XG5cdFx0XHRyZXQueSArPSBzY3JvbGwueTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0OyAvLyBPYmplY3Rcblx0fTtcblxuXHQvLyByYW5kb20gXCJwcml2YXRlXCIgZnVuY3Rpb25zIHdpbGRseSB1c2VkIHRocm91Z2hvdXQgdGhlIHRvb2xraXRcblxuXHRnZW9tLmdldE1hcmdpblNpemUgPSBmdW5jdGlvbiBnZXRNYXJnaW5TaXplKC8qRG9tTm9kZSovIG5vZGUsIC8qT2JqZWN0Ki8gY29tcHV0ZWRTdHlsZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRyZXR1cm5zIGFuIG9iamVjdCB0aGF0IGVuY29kZXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2Zcblx0XHQvL1x0XHR0aGUgbm9kZSdzIG1hcmdpbiBib3hcblx0XHQvLyBub2RlOiBET01Ob2RlfFN0cmluZ1xuXHRcdC8vIGNvbXB1dGVkU3R5bGU6IE9iamVjdD9cblx0XHQvL1x0XHRUaGlzIHBhcmFtZXRlciBhY2NlcHRzIGNvbXB1dGVkIHN0eWxlcyBvYmplY3QuXG5cdFx0Ly9cdFx0SWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGNhbGxcblx0XHQvL1x0XHRkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlIHRvIGdldCBvbmUuIEl0IGlzIGEgYmV0dGVyIHdheSwgY2FsbGluZ1xuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgb25jZSwgYW5kIHRoZW4gcGFzcyB0aGUgcmVmZXJlbmNlIHRvIHRoaXNcblx0XHQvL1x0XHRjb21wdXRlZFN0eWxlIHBhcmFtZXRlci4gV2hlcmV2ZXIgcG9zc2libGUsIHJldXNlIHRoZSByZXR1cm5lZFxuXHRcdC8vXHRcdG9iamVjdCBvZiBkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlKCkuXG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIG1lID0gZ2VvbS5nZXRNYXJnaW5FeHRlbnRzKG5vZGUsIGNvbXB1dGVkU3R5bGUgfHwgc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKSk7XG5cdFx0dmFyIHNpemUgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR3OiAoc2l6ZS5yaWdodCAtIHNpemUubGVmdCkgKyBtZS53LFxuXHRcdFx0aDogKHNpemUuYm90dG9tIC0gc2l6ZS50b3ApICsgbWUuaFxuXHRcdH07XG5cdH07XG5cblx0Z2VvbS5ub3JtYWxpemVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdE5vcm1hbGl6ZXMgdGhlIGdlb21ldHJ5IG9mIGEgRE9NIGV2ZW50LCBub3JtYWxpemluZyB0aGUgcGFnZVgsIHBhZ2VZLFxuXHRcdC8vXHRcdG9mZnNldFgsIG9mZnNldFksIGxheWVyWCwgYW5kIGxheWVyWCBwcm9wZXJ0aWVzXG5cdFx0Ly8gZXZlbnQ6IE9iamVjdFxuXHRcdGlmKCEoXCJsYXllclhcIiBpbiBldmVudCkpe1xuXHRcdFx0ZXZlbnQubGF5ZXJYID0gZXZlbnQub2Zmc2V0WDtcblx0XHRcdGV2ZW50LmxheWVyWSA9IGV2ZW50Lm9mZnNldFk7XG5cdFx0fVxuXG5cdFx0aWYoIShcInBhZ2VYXCIgaW4gZXZlbnQpKXtcblx0XHRcdC8vIEZJWE1FOiBzY3JvbGwgcG9zaXRpb24gcXVlcnkgaXMgZHVwZWQgZnJvbSBkb2pvL19iYXNlL2h0bWwgdG9cblx0XHRcdC8vIGF2b2lkIGRlcGVuZGVuY3kgb24gdGhhdCBlbnRpcmUgbW9kdWxlLiBOb3cgdGhhdCBIVE1MIGlzIGluXG5cdFx0XHQvLyBCYXNlLCB3ZSBzaG91bGQgY29udmVydCBiYWNrIHRvIHNvbWV0aGluZyBzaW1pbGFyIHRoZXJlLlxuXHRcdFx0dmFyIHNlID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0dmFyIGRvYyA9IChzZSAmJiBzZS5vd25lckRvY3VtZW50KSB8fCBkb2N1bWVudDtcblx0XHRcdC8vIERPIE5PVCByZXBsYWNlIHRoZSBmb2xsb3dpbmcgdG8gdXNlIGRvam8vX2Jhc2Uvd2luZG93LmJvZHkoKSwgaW4gSUUsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCBzaG91bGQgYmUgdXNlZFxuXHRcdFx0Ly8gaGVyZSByYXRoZXIgdGhhbiBkb2N1bWVudC5ib2R5XG5cdFx0XHR2YXIgZG9jQm9keSA9IGhhcyhcInF1aXJrc1wiKSA/IGRvYy5ib2R5IDogZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdGV2ZW50LnBhZ2VYID0gZXZlbnQuY2xpZW50WCArIGdlb20uZml4SWVCaURpU2Nyb2xsTGVmdChkb2NCb2R5LnNjcm9sbExlZnQgfHwgMCwgZG9jKTtcblx0XHRcdGV2ZW50LnBhZ2VZID0gZXZlbnQuY2xpZW50WSArIChkb2NCb2R5LnNjcm9sbFRvcCB8fCAwKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gVE9ETzogZXZhbHVhdGUgc2VwYXJhdGUgZ2V0dGVycy9zZXR0ZXJzIGZvciBwb3NpdGlvbiBhbmQgc2l6ZXM/XG5cblx0cmV0dXJuIGdlb207XG59KTtcbiIsImRlZmluZShbXCJleHBvcnRzXCIsIFwiLi9fYmFzZS9rZXJuZWxcIiwgXCIuL3NuaWZmXCIsIFwiLi9fYmFzZS9sYW5nXCIsIFwiLi9kb21cIiwgXCIuL2RvbS1zdHlsZVwiLCBcIi4vZG9tLWNvbnN0cnVjdFwiLCBcIi4vX2Jhc2UvY29ubmVjdFwiXSxcblx0XHRmdW5jdGlvbihleHBvcnRzLCBkb2pvLCBoYXMsIGxhbmcsIGRvbSwgc3R5bGUsIGN0ciwgY29ubil7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9kb20tcHJvcFxuXHQvLyBzdW1tYXJ5OlxuXHQvL1x0XHRUaGlzIG1vZHVsZSBkZWZpbmVzIHRoZSBjb3JlIGRvam8gRE9NIHByb3BlcnRpZXMgQVBJLlxuXG5cdC8vIFRPRE9DOiBzdW1tYXJ5IG5vdCBzaG93aW5nIHVwIGluIG91dHB1dCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jc25vdmVyL2pzLWRvYy1wYXJzZS9pc3N1ZXMvNDJcblxuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQvLyBFbGVtZW50IHByb3BlcnRpZXMgRnVuY3Rpb25zXG5cdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0Ly8gaGVscGVyIHRvIGNvbm5lY3QgZXZlbnRzXG5cdHZhciBfZXZ0SGRsck1hcCA9IHt9LCBfY3RyID0gMSwgX2F0dHJJZCA9IGRvam8uX3Njb3BlTmFtZSArIFwiYXR0cmlkXCI7XG5cdGhhcy5hZGQoJ2RvbS10ZXh0Q29udGVudCcsIGZ1bmN0aW9uIChnbG9iYWwsIGRvYywgZWxlbWVudCkgeyByZXR1cm4gJ3RleHRDb250ZW50JyBpbiBlbGVtZW50OyB9KTtcblxuXHRleHBvcnRzLm5hbWVzID0ge1xuXHRcdC8vIHByb3BlcnRpZXMgcmVuYW1lZCB0byBhdm9pZCBjbGFzaGVzIHdpdGggcmVzZXJ2ZWQgd29yZHNcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCIsXG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0Ly8gcHJvcGVydGllcyB3cml0dGVuIGFzIGNhbWVsQ2FzZVxuXHRcdHRhYmluZGV4OiBcInRhYkluZGV4XCIsXG5cdFx0cmVhZG9ubHk6IFwicmVhZE9ubHlcIixcblx0XHRjb2xzcGFuOiBcImNvbFNwYW5cIixcblx0XHRmcmFtZWJvcmRlcjogXCJmcmFtZUJvcmRlclwiLFxuXHRcdHJvd3NwYW46IFwicm93U3BhblwiLFxuXHRcdHRleHRjb250ZW50OiBcInRleHRDb250ZW50XCIsXG5cdFx0dmFsdWV0eXBlOiBcInZhbHVlVHlwZVwiXG5cdH07XG5cdFxuXHRmdW5jdGlvbiBnZXRUZXh0KC8qRE9NTm9kZSovbm9kZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRyZWN1cnNpb24gbWV0aG9kIGZvciBnZXQoJ3RleHRDb250ZW50JykgdG8gdXNlLiBHZXRzIHRleHQgdmFsdWUgZm9yIGEgbm9kZS5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRKdXNlIHVzZXMgbm9kZWRWYWx1ZSBzbyB0aGluZ3MgbGlrZSA8YnIvPiB0YWdzIGRvIG5vdCBlbmQgdXAgaW5cblx0XHQvL1x0XHR0aGUgdGV4dCBhcyBhbnkgc29ydCBvZiBsaW5lIHJldHVybi5cblx0XHR2YXIgdGV4dCA9IFwiXCIsIGNoID0gbm9kZS5jaGlsZE5vZGVzO1xuXHRcdGZvcih2YXIgaSA9IDAsIG47IG4gPSBjaFtpXTsgaSsrKXtcblx0XHRcdC8vU2tpcCBjb21tZW50cy5cblx0XHRcdGlmKG4ubm9kZVR5cGUgIT0gOCl7XG5cdFx0XHRcdGlmKG4ubm9kZVR5cGUgPT0gMSl7XG5cdFx0XHRcdFx0dGV4dCArPSBnZXRUZXh0KG4pO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHR0ZXh0ICs9IG4ubm9kZVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0ZXh0O1xuXHR9XG5cblx0ZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiBnZXRQcm9wKC8qRE9NTm9kZXxTdHJpbmcqLyBub2RlLCAvKlN0cmluZyovIG5hbWUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0R2V0cyBhIHByb3BlcnR5IG9uIGFuIEhUTUwgZWxlbWVudC5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRIYW5kbGVzIG5vcm1hbGl6ZWQgZ2V0dGluZyBvZiBwcm9wZXJ0aWVzIG9uIERPTSBub2Rlcy5cblx0XHQvL1xuXHRcdC8vIG5vZGU6IERPTU5vZGV8U3RyaW5nXG5cdFx0Ly9cdFx0aWQgb3IgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRvIGdldCB0aGUgcHJvcGVydHkgb25cblx0XHQvLyBuYW1lOiBTdHJpbmdcblx0XHQvL1x0XHR0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuXHRcdC8vIHJldHVybnM6XG5cdFx0Ly9cdFx0dGhlIHZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgcHJvcGVydHkgb3IgaXRzIGRlZmF1bHQgdmFsdWVcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdHxcdC8vIGdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgXCJmb29cIiBwcm9wZXJ0eSBvbiBhIG5vZGVcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1wcm9wXCIsIFwiZG9qby9kb21cIl0sIGZ1bmN0aW9uKGRvbVByb3AsIGRvbSl7XG5cdFx0Ly9cdHxcdFx0ZG9tUHJvcC5nZXQoZG9tLmJ5SWQoXCJub2RlSWRcIiksIFwiZm9vXCIpO1xuXHRcdC8vXHR8XHRcdC8vIG9yIHdlIGNhbiBqdXN0IHBhc3MgdGhlIGlkOlxuXHRcdC8vXHR8XHRcdGRvbVByb3AuZ2V0KFwibm9kZUlkXCIsIFwiZm9vXCIpO1xuXHRcdC8vXHR8XHR9KTtcblxuXHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHR2YXIgbGMgPSBuYW1lLnRvTG93ZXJDYXNlKCksIHByb3BOYW1lID0gZXhwb3J0cy5uYW1lc1tsY10gfHwgbmFtZTtcblx0XHRcblx0XHRpZihwcm9wTmFtZSA9PSBcInRleHRDb250ZW50XCIgJiYgIWhhcyhcImRvbS10ZXh0Q29udGVudFwiKSl7XG5cdFx0XHRyZXR1cm4gZ2V0VGV4dChub2RlKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG5vZGVbcHJvcE5hbWVdO1x0Ly8gQW55dGhpbmdcblx0fTtcblxuXHRleHBvcnRzLnNldCA9IGZ1bmN0aW9uIHNldFByb3AoLypET01Ob2RlfFN0cmluZyovIG5vZGUsIC8qU3RyaW5nfE9iamVjdCovIG5hbWUsIC8qU3RyaW5nPyovIHZhbHVlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNldHMgYSBwcm9wZXJ0eSBvbiBhbiBIVE1MIGVsZW1lbnQuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0SGFuZGxlcyBub3JtYWxpemVkIHNldHRpbmcgb2YgcHJvcGVydGllcyBvbiBET00gbm9kZXMuXG5cdFx0Ly9cblx0XHQvL1x0XHRXaGVuIHBhc3NpbmcgZnVuY3Rpb25zIGFzIHZhbHVlcywgbm90ZSB0aGF0IHRoZXkgd2lsbCBub3QgYmVcblx0XHQvL1x0XHRkaXJlY3RseSBhc3NpZ25lZCB0byBzbG90cyBvbiB0aGUgbm9kZSwgYnV0IHJhdGhlciB0aGUgZGVmYXVsdFxuXHRcdC8vXHRcdGJlaGF2aW9yIHdpbGwgYmUgcmVtb3ZlZCBhbmQgdGhlIG5ldyBiZWhhdmlvciB3aWxsIGJlIGFkZGVkXG5cdFx0Ly9cdFx0dXNpbmcgYGRvam8uY29ubmVjdCgpYCwgbWVhbmluZyB0aGF0IGV2ZW50IGhhbmRsZXIgcHJvcGVydGllc1xuXHRcdC8vXHRcdHdpbGwgYmUgbm9ybWFsaXplZCBhbmQgdGhhdCBzb21lIGNhdmVhdHMgd2l0aCByZWdhcmRzIHRvXG5cdFx0Ly9cdFx0bm9uLXN0YW5kYXJkIGJlaGF2aW9ycyBmb3Igb25zdWJtaXQgYXBwbHkuIE5hbWVseSB0aGF0IHlvdVxuXHRcdC8vXHRcdHNob3VsZCBjYW5jZWwgZm9ybSBzdWJtaXNzaW9uIHVzaW5nIGBkb2pvLnN0b3BFdmVudCgpYCBvbiB0aGVcblx0XHQvL1x0XHRwYXNzZWQgZXZlbnQgb2JqZWN0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGEgYm9vbGVhbiB2YWx1ZSBmcm9tXG5cdFx0Ly9cdFx0dGhlIGhhbmRsZXIgaXRzZWxmLlxuXHRcdC8vIG5vZGU6IERPTU5vZGV8U3RyaW5nXG5cdFx0Ly9cdFx0aWQgb3IgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRvIHNldCB0aGUgcHJvcGVydHkgb25cblx0XHQvLyBuYW1lOiBTdHJpbmd8T2JqZWN0XG5cdFx0Ly9cdFx0dGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHNldCwgb3IgYSBoYXNoIG9iamVjdCB0byBzZXRcblx0XHQvL1x0XHRtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2UuXG5cdFx0Ly8gdmFsdWU6IFN0cmluZz9cblx0XHQvL1x0XHRUaGUgdmFsdWUgdG8gc2V0IGZvciB0aGUgcHJvcGVydHlcblx0XHQvLyByZXR1cm5zOlxuXHRcdC8vXHRcdHRoZSBET00gbm9kZVxuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0Ly8gdXNlIHByb3AoKSB0byBzZXQgdGhlIHRhYiBpbmRleFxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLXByb3BcIl0sIGZ1bmN0aW9uKGRvbVByb3Ape1xuXHRcdC8vXHR8XHRcdGRvbVByb3Auc2V0KFwibm9kZUlkXCIsIFwidGFiSW5kZXhcIiwgMyk7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0U2V0IG11bHRpcGxlIHZhbHVlcyBhdCBvbmNlLCBpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnM6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tcHJvcFwiXSwgZnVuY3Rpb24oZG9tUHJvcCl7XG5cdFx0Ly9cdHxcdFx0ZG9tUHJvcC5zZXQoXCJmb3JtSWRcIiwge1xuXHRcdC8vXHR8XHRcdFx0XCJmb29cIjogXCJiYXJcIixcblx0XHQvL1x0fFx0XHRcdFwidGFiSW5kZXhcIjogLTEsXG5cdFx0Ly9cdHxcdFx0XHRcIm1ldGhvZFwiOiBcIlBPU1RcIixcblx0XHQvL1x0fFx0XHR9KTtcblx0XHQvL1x0fFx0fSk7XG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGlmKGwgPT0gMiAmJiB0eXBlb2YgbmFtZSAhPSBcInN0cmluZ1wiKXsgLy8gaW5saW5lJ2QgdHlwZSBjaGVja1xuXHRcdFx0Ly8gdGhlIG9iamVjdCBmb3JtIG9mIHNldHRlcjogdGhlIDJuZCBhcmd1bWVudCBpcyBhIGRpY3Rpb25hcnlcblx0XHRcdGZvcih2YXIgeCBpbiBuYW1lKXtcblx0XHRcdFx0ZXhwb3J0cy5zZXQobm9kZSwgeCwgbmFtZVt4XSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbm9kZTsgLy8gRG9tTm9kZVxuXHRcdH1cblx0XHR2YXIgbGMgPSBuYW1lLnRvTG93ZXJDYXNlKCksIHByb3BOYW1lID0gZXhwb3J0cy5uYW1lc1tsY10gfHwgbmFtZTtcblx0XHRpZihwcm9wTmFtZSA9PSBcInN0eWxlXCIgJiYgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpeyAvLyBpbmxpbmUnZCB0eXBlIGNoZWNrXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2U6IHNldHRpbmcgYSBzdHlsZVxuXHRcdFx0c3R5bGUuc2V0KG5vZGUsIHZhbHVlKTtcblx0XHRcdHJldHVybiBub2RlOyAvLyBEb21Ob2RlXG5cdFx0fVxuXHRcdGlmKHByb3BOYW1lID09IFwiaW5uZXJIVE1MXCIpe1xuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBhc3NpZ25pbmcgSFRNTFxuXHRcdFx0Ly8gdGhlIGhhc2ggbGlzdHMgZWxlbWVudHMgd2l0aCByZWFkLW9ubHkgaW5uZXJIVE1MIG9uIElFXG5cdFx0XHRpZihoYXMoXCJpZVwiKSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSBpbiB7Y29sOiAxLCBjb2xncm91cDogMSxcblx0XHRcdFx0XHRcdHRhYmxlOiAxLCB0Ym9keTogMSwgdGZvb3Q6IDEsIHRoZWFkOiAxLCB0cjogMSwgdGl0bGU6IDF9KXtcblx0XHRcdFx0Y3RyLmVtcHR5KG5vZGUpO1xuXHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKGN0ci50b0RvbSh2YWx1ZSwgbm9kZS5vd25lckRvY3VtZW50KSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0bm9kZVtwcm9wTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBub2RlOyAvLyBEb21Ob2RlXG5cdFx0fVxuXHRcdGlmKHByb3BOYW1lID09IFwidGV4dENvbnRlbnRcIiAmJiAhaGFzKFwiZG9tLXRleHRDb250ZW50XCIpKSB7XG5cdFx0XHRjdHIuZW1wdHkobm9kZSk7XG5cdFx0XHRub2RlLmFwcGVuZENoaWxkKG5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSkpO1xuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fVxuXHRcdGlmKGxhbmcuaXNGdW5jdGlvbih2YWx1ZSkpe1xuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBhc3NpZ25pbmcgYW4gZXZlbnQgaGFuZGxlclxuXHRcdFx0Ly8gY2xvYmJlciBpZiB3ZSBjYW5cblx0XHRcdHZhciBhdHRySWQgPSBub2RlW19hdHRySWRdO1xuXHRcdFx0aWYoIWF0dHJJZCl7XG5cdFx0XHRcdGF0dHJJZCA9IF9jdHIrKztcblx0XHRcdFx0bm9kZVtfYXR0cklkXSA9IGF0dHJJZDtcblx0XHRcdH1cblx0XHRcdGlmKCFfZXZ0SGRsck1hcFthdHRySWRdKXtcblx0XHRcdFx0X2V2dEhkbHJNYXBbYXR0cklkXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0dmFyIGggPSBfZXZ0SGRsck1hcFthdHRySWRdW3Byb3BOYW1lXTtcblx0XHRcdGlmKGgpe1xuXHRcdFx0XHQvL2gucmVtb3ZlKCk7XG5cdFx0XHRcdGNvbm4uZGlzY29ubmVjdChoKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0ZGVsZXRlIG5vZGVbcHJvcE5hbWVdO1xuXHRcdFx0XHR9Y2F0Y2goZSl7fVxuXHRcdFx0fVxuXHRcdFx0Ly8gZW5zdXJlIHRoYXQgZXZlbnQgb2JqZWN0cyBhcmUgbm9ybWFsaXplZCwgZXRjLlxuXHRcdFx0aWYodmFsdWUpe1xuXHRcdFx0XHQvL19ldnRIZGxyTWFwW2F0dHJJZF1bcHJvcE5hbWVdID0gb24obm9kZSwgcHJvcE5hbWUsIHZhbHVlKTtcblx0XHRcdFx0X2V2dEhkbHJNYXBbYXR0cklkXVtwcm9wTmFtZV0gPSBjb25uLmNvbm5lY3Qobm9kZSwgcHJvcE5hbWUsIHZhbHVlKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRub2RlW3Byb3BOYW1lXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbm9kZTsgLy8gRG9tTm9kZVxuXHRcdH1cblx0XHRub2RlW3Byb3BOYW1lXSA9IHZhbHVlO1xuXHRcdHJldHVybiBub2RlO1x0Ly8gRG9tTm9kZVxuXHR9O1xufSk7XG4iLCJkZWZpbmUoW1wiLi9zbmlmZlwiLCBcIi4vZG9tXCIsIFwiLi9fYmFzZS93aW5kb3dcIl0sIGZ1bmN0aW9uKGhhcywgZG9tLCB3aW4pe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vZG9tLXN0eWxlXG5cblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0Ly8gU3R5bGUgRnVuY3Rpb25zXG5cdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0Ly8gZ2V0Q29tcHV0ZWRTdHlsZSBkcml2ZXMgbW9zdCBvZiB0aGUgc3R5bGUgY29kZS5cblx0Ly8gV2hlcmV2ZXIgcG9zc2libGUsIHJldXNlIHRoZSByZXR1cm5lZCBvYmplY3QuXG5cdC8vXG5cdC8vIEFQSSBmdW5jdGlvbnMgYmVsb3cgdGhhdCBuZWVkIHRvIGFjY2VzcyBjb21wdXRlZCBzdHlsZXMgYWNjZXB0IGFuXG5cdC8vIG9wdGlvbmFsIGNvbXB1dGVkU3R5bGUgcGFyYW1ldGVyLlxuXHQvLyBJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLCB0aGUgZnVuY3Rpb25zIHdpbGwgY2FsbCBnZXRDb21wdXRlZFN0eWxlIHRoZW1zZWx2ZXMuXG5cdC8vIFRoaXMgd2F5LCBjYWxsaW5nIGNvZGUgY2FuIGFjY2VzcyBjb21wdXRlZFN0eWxlIG9uY2UsIGFuZCB0aGVuIHBhc3MgdGhlIHJlZmVyZW5jZSB0b1xuXHQvLyBtdWx0aXBsZSBBUEkgZnVuY3Rpb25zLlxuXG5cdC8vIEFsdGhvdWdoIHdlIG5vcm1hbGx5IGVzY2hldyBhcmd1bWVudCB2YWxpZGF0aW9uIGF0IHRoaXNcblx0Ly8gbGV2ZWwsIGhlcmUgd2UgdGVzdCBhcmd1bWVudCAnbm9kZScgZm9yIChkdWNrKXR5cGUsXG5cdC8vIGJ5IHRlc3Rpbmcgbm9kZVR5cGUsIGVjYXVzZSAnZG9jdW1lbnQnIGlzIHRoZSAncGFyZW50Tm9kZScgb2YgJ2JvZHknXG5cdC8vIGl0IGlzIGZyZXF1ZW50bHkgc2VudCB0byB0aGlzIGZ1bmN0aW9uIGV2ZW5cblx0Ly8gdGhvdWdoIGl0IGlzIG5vdCBFbGVtZW50LlxuXHR2YXIgZ2V0Q29tcHV0ZWRTdHlsZSwgc3R5bGUgPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGlzIG1vZHVsZSBkZWZpbmVzIHRoZSBjb3JlIGRvam8gRE9NIHN0eWxlIEFQSS5cblx0fTtcblx0aWYoaGFzKFwid2Via2l0XCIpKXtcblx0XHRnZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24oLypEb21Ob2RlKi8gbm9kZSl7XG5cdFx0XHR2YXIgcztcblx0XHRcdGlmKG5vZGUubm9kZVR5cGUgPT0gMSl7XG5cdFx0XHRcdHZhciBkdiA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRcdFx0cyA9IGR2LmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCk7XG5cdFx0XHRcdGlmKCFzICYmIG5vZGUuc3R5bGUpe1xuXHRcdFx0XHRcdG5vZGUuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdFx0cyA9IGR2LmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBzIHx8IHt9O1xuXHRcdH07XG5cdH1lbHNlIGlmKGhhcyhcImllXCIpICYmIChoYXMoXCJpZVwiKSA8IDkgfHwgaGFzKFwicXVpcmtzXCIpKSl7XG5cdFx0Z2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0Ly8gSUUgKGFzIG9mIDcpIGRvZXNuJ3QgZXhwb3NlIEVsZW1lbnQgbGlrZSBzYW5lIGJyb3dzZXJzXG5cdFx0XHQvLyBjdXJyZW50U3R5bGUgY2FuIGJlIG51bGwgb24gSUU4IVxuXHRcdFx0cmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMSAvKiBFTEVNRU5UX05PREUqLyAmJiBub2RlLmN1cnJlbnRTdHlsZSA/IG5vZGUuY3VycmVudFN0eWxlIDoge307XG5cdFx0fTtcblx0fWVsc2V7XG5cdFx0Z2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0aWYobm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBFTEVNRU5UX05PREUqLyl7XG5cdFx0XHRcdHZhciBkdiA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyxcblx0XHRcdFx0XHR3ID0gZHYub3BlbmVyID8gZHYgOiB3aW4uZ2xvYmFsLndpbmRvdztcblx0XHRcdFx0cmV0dXJuIHcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7fTtcblx0XHR9O1xuXHR9XG5cdHN0eWxlLmdldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlO1xuXHQvKj09PT09XG5cdHN0eWxlLmdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbihub2RlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJldHVybnMgYSBcImNvbXB1dGVkIHN0eWxlXCIgb2JqZWN0LlxuXHRcdC8vXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0R2V0cyBhIFwiY29tcHV0ZWQgc3R5bGVcIiBvYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZ2F0aGVyXG5cdFx0Ly9cdFx0aW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHJlbmRlcmVkIG5vZGUuXG5cdFx0Ly9cblx0XHQvL1x0XHROb3RlIHRoYXQgdGhpcyBtYXkgYmVoYXZlIGRpZmZlcmVudGx5IG9uIGRpZmZlcmVudCBicm93c2Vycy5cblx0XHQvL1x0XHRWYWx1ZXMgbWF5IGhhdmUgZGlmZmVyZW50IGZvcm1hdHMgYW5kIHZhbHVlIGVuY29kaW5ncyBhY3Jvc3Ncblx0XHQvL1x0XHRicm93c2Vycy5cblx0XHQvL1xuXHRcdC8vXHRcdE5vdGUgYWxzbyB0aGF0IHRoaXMgbWV0aG9kIGlzIGV4cGVuc2l2ZS4gIFdoZXJldmVyIHBvc3NpYmxlLFxuXHRcdC8vXHRcdHJldXNlIHRoZSByZXR1cm5lZCBvYmplY3QuXG5cdFx0Ly9cblx0XHQvL1x0XHRVc2UgdGhlIGRvam8vZG9tLXN0eWxlLmdldCgpIG1ldGhvZCBmb3IgbW9yZSBjb25zaXN0ZW50IChwaXhlbGl6ZWQpXG5cdFx0Ly9cdFx0cmV0dXJuIHZhbHVlcy5cblx0XHQvL1xuXHRcdC8vIG5vZGU6IERPTU5vZGVcblx0XHQvL1x0XHRBIHJlZmVyZW5jZSB0byBhIERPTSBub2RlLiBEb2VzIE5PVCBzdXBwb3J0IHRha2luZyBhblxuXHRcdC8vXHRcdElEIHN0cmluZyBmb3Igc3BlZWQgcmVhc29ucy5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLXN0eWxlXCIsIFwiZG9qby9kb21cIl0sIGZ1bmN0aW9uKGRvbVN0eWxlLCBkb20pe1xuXHRcdC8vXHR8XHRcdGRvbVN0eWxlLmdldENvbXB1dGVkU3R5bGUoZG9tLmJ5SWQoJ2ZvbycpKS5ib3JkZXJXaWR0aDtcblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFJldXNpbmcgdGhlIHJldHVybmVkIG9iamVjdCwgYXZvaWRpbmcgbXVsdGlwbGUgbG9va3Vwczpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1zdHlsZVwiLCBcImRvam8vZG9tXCJdLCBmdW5jdGlvbihkb21TdHlsZSwgZG9tKXtcblx0XHQvL1x0fFx0XHR2YXIgY3MgPSBkb21TdHlsZS5nZXRDb21wdXRlZFN0eWxlKGRvbS5ieUlkKFwic29tZU5vZGVcIikpO1xuXHRcdC8vXHR8XHRcdHZhciB3ID0gY3Mud2lkdGgsIGggPSBjcy5oZWlnaHQ7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdHJldHVybjsgLy8gQ1NTMlByb3BlcnRpZXNcblx0fTtcblx0PT09PT0qL1xuXG5cdHZhciB0b1BpeGVsO1xuXHRpZighaGFzKFwiaWVcIikpe1xuXHRcdHRvUGl4ZWwgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSl7XG5cdFx0XHQvLyBzdHlsZSB2YWx1ZXMgY2FuIGJlIGZsb2F0cywgY2xpZW50IGNvZGUgbWF5IHdhbnRcblx0XHRcdC8vIHRvIHJvdW5kIGZvciBpbnRlZ2VyIHBpeGVscy5cblx0XHRcdHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xuXHRcdH07XG5cdH1lbHNle1xuXHRcdHRvUGl4ZWwgPSBmdW5jdGlvbihlbGVtZW50LCBhdmFsdWUpe1xuXHRcdFx0aWYoIWF2YWx1ZSl7IHJldHVybiAwOyB9XG5cdFx0XHQvLyBvbiBJRTcsIG1lZGl1bSBpcyB1c3VhbGx5IDQgcGl4ZWxzXG5cdFx0XHRpZihhdmFsdWUgPT0gXCJtZWRpdW1cIil7IHJldHVybiA0OyB9XG5cdFx0XHQvLyBzdHlsZSB2YWx1ZXMgY2FuIGJlIGZsb2F0cywgY2xpZW50IGNvZGUgbWF5XG5cdFx0XHQvLyB3YW50IHRvIHJvdW5kIHRoaXMgdmFsdWUgZm9yIGludGVnZXIgcGl4ZWxzLlxuXHRcdFx0aWYoYXZhbHVlLnNsaWNlICYmIGF2YWx1ZS5zbGljZSgtMikgPT0gJ3B4Jyl7IHJldHVybiBwYXJzZUZsb2F0KGF2YWx1ZSk7IH1cblx0XHRcdHZhciBzID0gZWxlbWVudC5zdHlsZSwgcnMgPSBlbGVtZW50LnJ1bnRpbWVTdHlsZSwgY3MgPSBlbGVtZW50LmN1cnJlbnRTdHlsZSxcblx0XHRcdFx0c0xlZnQgPSBzLmxlZnQsIHJzTGVmdCA9IHJzLmxlZnQ7XG5cdFx0XHRycy5sZWZ0ID0gY3MubGVmdDtcblx0XHRcdHRyeXtcblx0XHRcdFx0Ly8gJ2F2YWx1ZScgbWF5IGJlIGluY29tcGF0aWJsZSB3aXRoIHN0eWxlLmxlZnQsIHdoaWNoIGNhbiBjYXVzZSBJRSB0byB0aHJvd1xuXHRcdFx0XHQvLyB0aGlzIGhhcyBiZWVuIG9ic2VydmVkIGZvciBib3JkZXIgd2lkdGhzIHVzaW5nIFwidGhpblwiLCBcIm1lZGl1bVwiLCBcInRoaWNrXCIgY29uc3RhbnRzXG5cdFx0XHRcdC8vIHRob3NlIHBhcnRpY3VsYXIgY29uc3RhbnRzIGNvdWxkIGJlIHRyYXBwZWQgYnkgYSBsb29rdXBcblx0XHRcdFx0Ly8gYnV0IHBlcmhhcHMgdGhlcmUgYXJlIG1vcmVcblx0XHRcdFx0cy5sZWZ0ID0gYXZhbHVlO1xuXHRcdFx0XHRhdmFsdWUgPSBzLnBpeGVsTGVmdDtcblx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0YXZhbHVlID0gMDtcblx0XHRcdH1cblx0XHRcdHMubGVmdCA9IHNMZWZ0O1xuXHRcdFx0cnMubGVmdCA9IHJzTGVmdDtcblx0XHRcdHJldHVybiBhdmFsdWU7XG5cdFx0fTtcblx0fVxuXHRzdHlsZS50b1BpeGVsVmFsdWUgPSB0b1BpeGVsO1xuXHQvKj09PT09XG5cdHN0eWxlLnRvUGl4ZWxWYWx1ZSA9IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdGNvbnZlcnRzIHN0eWxlIHZhbHVlIHRvIHBpeGVscyBvbiBJRSBvciByZXR1cm4gYSBudW1lcmljIHZhbHVlLlxuXHRcdC8vIG5vZGU6IERPTU5vZGVcblx0XHQvLyB2YWx1ZTogU3RyaW5nXG5cdFx0Ly8gcmV0dXJuczogTnVtYmVyXG5cdH07XG5cdD09PT09Ki9cblxuXHQvLyBGSVhNRTogdGhlcmUgb3BhY2l0eSBxdWlya3Mgb24gRkYgdGhhdCB3ZSBoYXZlbid0IHBvcnRlZCBvdmVyLiBIcm0uXG5cblx0dmFyIGFzdHIgPSBcIkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhXCI7XG5cdHZhciBhZiA9IGZ1bmN0aW9uKG4sIGYpe1xuXHRcdHRyeXtcblx0XHRcdHJldHVybiBuLmZpbHRlcnMuaXRlbShhc3RyKTtcblx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRyZXR1cm4gZiA/IHt9IDogbnVsbDtcblx0XHR9XG5cdH07XG5cblx0dmFyIF9nZXRPcGFjaXR5ID1cblx0XHRoYXMoXCJpZVwiKSA8IDkgfHwgKGhhcyhcImllXCIpIDwgMTAgJiYgaGFzKFwicXVpcmtzXCIpKSA/IGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0dHJ5e1xuXHRcdFx0XHRyZXR1cm4gYWYobm9kZSkuT3BhY2l0eSAvIDEwMDsgLy8gTnVtYmVyXG5cdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdHJldHVybiAxOyAvLyBOdW1iZXJcblx0XHRcdH1cblx0XHR9IDpcblx0XHRmdW5jdGlvbihub2RlKXtcblx0XHRcdHJldHVybiBnZXRDb21wdXRlZFN0eWxlKG5vZGUpLm9wYWNpdHk7XG5cdFx0fTtcblxuXHR2YXIgX3NldE9wYWNpdHkgPVxuXHRcdGhhcyhcImllXCIpIDwgOSB8fCAoaGFzKFwiaWVcIikgPCAxMCAmJiBoYXMoXCJxdWlya3NcIikpID8gZnVuY3Rpb24oLypEb21Ob2RlKi8gbm9kZSwgLypOdW1iZXIqLyBvcGFjaXR5KXtcblx0XHRcdGlmKG9wYWNpdHkgPT09IFwiXCIpeyBvcGFjaXR5ID0gMTsgfVxuXHRcdFx0dmFyIG92ID0gb3BhY2l0eSAqIDEwMCwgZnVsbHlPcGFxdWUgPSBvcGFjaXR5ID09PSAxO1xuXG5cdFx0XHQvLyBvbiBJRTcgQWxwaGEoRmlsdGVyIG9wYWNpdHk9MTAwKSBtYWtlcyB0ZXh0IGxvb2sgZnV6enkgc28gZGlzYWJsZSBpdCBhbHRvZ2V0aGVyIChidWcgIzI2NjEpLFxuXHRcdFx0Ly8gYnV0IHN0aWxsIHVwZGF0ZSB0aGUgb3BhY2l0eSB2YWx1ZSBzbyB3ZSBjYW4gZ2V0IGEgY29ycmVjdCByZWFkaW5nIGlmIGl0IGlzIHJlYWQgbGF0ZXI6XG5cdFx0XHQvLyBhZihub2RlLCAxKS5FbmFibGVkID0gIWZ1bGx5T3BhcXVlO1xuXG5cdFx0XHRpZihmdWxseU9wYXF1ZSl7XG5cdFx0XHRcdG5vZGUuc3R5bGUuem9vbSA9IFwiXCI7XG5cdFx0XHRcdGlmKGFmKG5vZGUpKXtcblx0XHRcdFx0XHRub2RlLnN0eWxlLmZpbHRlciA9IG5vZGUuc3R5bGUuZmlsdGVyLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRuZXcgUmVnRXhwKFwiXFxcXHMqcHJvZ2lkOlwiICsgYXN0ciArIFwiXFxcXChbXlxcXFwpXSs/XFxcXClcIiwgXCJpXCIpLCBcIlwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdG5vZGUuc3R5bGUuem9vbSA9IDE7XG5cdFx0XHRcdGlmKGFmKG5vZGUpKXtcblx0XHRcdFx0XHRhZihub2RlLCAxKS5PcGFjaXR5ID0gb3Y7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdG5vZGUuc3R5bGUuZmlsdGVyICs9IFwiIHByb2dpZDpcIiArIGFzdHIgKyBcIihPcGFjaXR5PVwiICsgb3YgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRhZihub2RlLCAxKS5FbmFibGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYobm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJ0clwiKXtcblx0XHRcdFx0Zm9yKHZhciB0ZCA9IG5vZGUuZmlyc3RDaGlsZDsgdGQ7IHRkID0gdGQubmV4dFNpYmxpbmcpe1xuXHRcdFx0XHRcdGlmKHRkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcInRkXCIpe1xuXHRcdFx0XHRcdFx0X3NldE9wYWNpdHkodGQsIG9wYWNpdHkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9wYWNpdHk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24obm9kZSwgb3BhY2l0eSl7XG5cdFx0XHRyZXR1cm4gbm9kZS5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTtcblx0XHR9O1xuXG5cdHZhciBfcGl4ZWxOYW1lc0NhY2hlID0ge1xuXHRcdGxlZnQ6IHRydWUsIHRvcDogdHJ1ZVxuXHR9O1xuXHR2YXIgX3BpeGVsUmVnRXhwID0gL21hcmdpbnxwYWRkaW5nfHdpZHRofGhlaWdodHxtYXh8bWlufG9mZnNldC87IC8vIHxib3JkZXJcblx0ZnVuY3Rpb24gX3RvU3R5bGVWYWx1ZShub2RlLCB0eXBlLCB2YWx1ZSl7XG5cdFx0Ly9UT0RPOiBzaG91bGQgd2UgcmVhbGx5IGJlIGRvaW5nIHN0cmluZyBjYXNlIGNvbnZlcnNpb24gaGVyZT8gU2hvdWxkIHdlIGNhY2hlIGl0PyBOZWVkIHRvIHByb2ZpbGUhXG5cdFx0dHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblxuXHRcdC8vIEFkanVzdG1lbnRzIGZvciBJRSBhbmQgRWRnZVxuXHRcdGlmKHZhbHVlID09IFwiYXV0b1wiKXtcblx0XHRcdGlmKHR5cGUgPT0gXCJoZWlnaHRcIil7IHJldHVybiBub2RlLm9mZnNldEhlaWdodDsgfVxuXHRcdFx0aWYodHlwZSA9PSBcIndpZHRoXCIpeyByZXR1cm4gbm9kZS5vZmZzZXRXaWR0aDsgfVxuXHRcdH1cblx0XHRpZih0eXBlID09IFwiZm9udHdlaWdodFwiKXtcblx0XHRcdHN3aXRjaCh2YWx1ZSl7XG5cdFx0XHRcdGNhc2UgNzAwOiByZXR1cm4gXCJib2xkXCI7XG5cdFx0XHRcdGNhc2UgNDAwOlxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gXCJub3JtYWxcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZighKHR5cGUgaW4gX3BpeGVsTmFtZXNDYWNoZSkpe1xuXHRcdFx0X3BpeGVsTmFtZXNDYWNoZVt0eXBlXSA9IF9waXhlbFJlZ0V4cC50ZXN0KHR5cGUpO1xuXHRcdH1cblx0XHRyZXR1cm4gX3BpeGVsTmFtZXNDYWNoZVt0eXBlXSA/IHRvUGl4ZWwobm9kZSwgdmFsdWUpIDogdmFsdWU7XG5cdH1cblxuXHR2YXIgX2Zsb2F0QWxpYXNlcyA9IHtjc3NGbG9hdDogMSwgc3R5bGVGbG9hdDogMSwgXCJmbG9hdFwiOiAxfTtcblxuXHQvLyBwdWJsaWMgQVBJXG5cblx0c3R5bGUuZ2V0ID0gZnVuY3Rpb24gZ2V0U3R5bGUoLypET01Ob2RlfFN0cmluZyovIG5vZGUsIC8qU3RyaW5nPyovIG5hbWUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0QWNjZXNzZXMgc3R5bGVzIG9uIGEgbm9kZS5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRHZXR0aW5nIHRoZSBzdHlsZSB2YWx1ZSB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBmb3IgdGhlIG5vZGUsIHNvIHRoZSB2YWx1ZVxuXHRcdC8vXHRcdHdpbGwgYmUgYSBjYWxjdWxhdGVkIHZhbHVlLCBub3QganVzdCB0aGUgaW1tZWRpYXRlIG5vZGUuc3R5bGUgdmFsdWUuXG5cdFx0Ly9cdFx0QWxzbyB3aGVuIGdldHRpbmcgdmFsdWVzLCB1c2Ugc3BlY2lmaWMgc3R5bGUgbmFtZXMsXG5cdFx0Ly9cdFx0bGlrZSBcImJvcmRlckJvdHRvbVdpZHRoXCIgaW5zdGVhZCBvZiBcImJvcmRlclwiIHNpbmNlIGNvbXBvdW5kIHZhbHVlcyBsaWtlXG5cdFx0Ly9cdFx0XCJib3JkZXJcIiBhcmUgbm90IG5lY2Vzc2FyaWx5IHJlZmxlY3RlZCBhcyBleHBlY3RlZC5cblx0XHQvL1x0XHRJZiB5b3Ugd2FudCB0byBnZXQgbm9kZSBkaW1lbnNpb25zLCB1c2UgYGRvam8vZG9tLWdlb21ldHJ5LmdldE1hcmdpbkJveCgpYCxcblx0XHQvL1x0XHRgZG9qby9kb20tZ2VvbWV0cnkuZ2V0Q29udGVudEJveCgpYCBvciBgZG9qby9kb20tZ2VvbWV0cnkuZ2V0UG9zaXRpb24oKWAuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvL1x0XHRpZCBvciByZWZlcmVuY2UgdG8gbm9kZSB0byBnZXQgc3R5bGUgZm9yXG5cdFx0Ly8gbmFtZTogU3RyaW5nP1xuXHRcdC8vXHRcdHRoZSBzdHlsZSBwcm9wZXJ0eSB0byBnZXRcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFBhc3Npbmcgb25seSBhbiBJRCBvciBub2RlIHJldHVybnMgdGhlIGNvbXB1dGVkIHN0eWxlIG9iamVjdCBvZlxuXHRcdC8vXHRcdHRoZSBub2RlOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLXN0eWxlXCIsIFwiZG9qby9kb21cIl0sIGZ1bmN0aW9uKGRvbVN0eWxlLCBkb20pe1xuXHRcdC8vXHR8XHRcdGRvbVN0eWxlLmdldChcInRoaW5nZXJcIik7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0UGFzc2luZyBhIG5vZGUgYW5kIGEgc3R5bGUgcHJvcGVydHkgcmV0dXJucyB0aGUgY3VycmVudFxuXHRcdC8vXHRcdG5vcm1hbGl6ZWQsIGNvbXB1dGVkIHZhbHVlIGZvciB0aGF0IHByb3BlcnR5OlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLXN0eWxlXCIsIFwiZG9qby9kb21cIl0sIGZ1bmN0aW9uKGRvbVN0eWxlLCBkb20pe1xuXHRcdC8vXHR8XHRcdGRvbVN0eWxlLmdldChcInRoaW5nZXJcIiwgXCJvcGFjaXR5XCIpOyAvLyAxIGJ5IGRlZmF1bHRcblx0XHQvL1x0fFx0fSk7XG5cblx0XHR2YXIgbiA9IGRvbS5ieUlkKG5vZGUpLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgb3AgPSAobmFtZSA9PSBcIm9wYWNpdHlcIik7XG5cdFx0aWYobCA9PSAyICYmIG9wKXtcblx0XHRcdHJldHVybiBfZ2V0T3BhY2l0eShuKTtcblx0XHR9XG5cdFx0bmFtZSA9IF9mbG9hdEFsaWFzZXNbbmFtZV0gPyBcImNzc0Zsb2F0XCIgaW4gbi5zdHlsZSA/IFwiY3NzRmxvYXRcIiA6IFwic3R5bGVGbG9hdFwiIDogbmFtZTtcblx0XHR2YXIgcyA9IHN0eWxlLmdldENvbXB1dGVkU3R5bGUobik7XG5cdFx0cmV0dXJuIChsID09IDEpID8gcyA6IF90b1N0eWxlVmFsdWUobiwgbmFtZSwgc1tuYW1lXSB8fCBuLnN0eWxlW25hbWVdKTsgLyogQ1NTMlByb3BlcnRpZXN8fFN0cmluZ3x8TnVtYmVyICovXG5cdH07XG5cblx0c3R5bGUuc2V0ID0gZnVuY3Rpb24gc2V0U3R5bGUoLypET01Ob2RlfFN0cmluZyovIG5vZGUsIC8qU3RyaW5nfE9iamVjdCovIG5hbWUsIC8qU3RyaW5nPyovIHZhbHVlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNldHMgc3R5bGVzIG9uIGEgbm9kZS5cblx0XHQvLyBub2RlOiBET01Ob2RlfFN0cmluZ1xuXHRcdC8vXHRcdGlkIG9yIHJlZmVyZW5jZSB0byBub2RlIHRvIHNldCBzdHlsZSBmb3Jcblx0XHQvLyBuYW1lOiBTdHJpbmd8T2JqZWN0XG5cdFx0Ly9cdFx0dGhlIHN0eWxlIHByb3BlcnR5IHRvIHNldCBpbiBET00tYWNjZXNzb3IgZm9ybWF0XG5cdFx0Ly9cdFx0KFwiYm9yZGVyV2lkdGhcIiwgbm90IFwiYm9yZGVyLXdpZHRoXCIpIG9yIGFuIG9iamVjdCB3aXRoIGtleS92YWx1ZVxuXHRcdC8vXHRcdHBhaXJzIHN1aXRhYmxlIGZvciBzZXR0aW5nIGVhY2ggcHJvcGVydHkuXG5cdFx0Ly8gdmFsdWU6IFN0cmluZz9cblx0XHQvL1x0XHRJZiBwYXNzZWQsIHNldHMgdmFsdWUgb24gdGhlIG5vZGUgZm9yIHN0eWxlLCBoYW5kbGluZ1xuXHRcdC8vXHRcdGNyb3NzLWJyb3dzZXIgY29uY2VybnMuICBXaGVuIHNldHRpbmcgYSBwaXhlbCB2YWx1ZSxcblx0XHQvL1x0XHRiZSBzdXJlIHRvIGluY2x1ZGUgXCJweFwiIGluIHRoZSB2YWx1ZS4gRm9yIGluc3RhbmNlLCB0b3A6IFwiMjAwcHhcIi5cblx0XHQvL1x0XHRPdGhlcndpc2UsIGluIHNvbWUgY2FzZXMsIHNvbWUgYnJvd3NlcnMgd2lsbCBub3QgYXBwbHkgdGhlIHN0eWxlLlxuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRQYXNzaW5nIGEgbm9kZSwgYSBzdHlsZSBwcm9wZXJ0eSwgYW5kIGEgdmFsdWUgY2hhbmdlcyB0aGVcblx0XHQvL1x0XHRjdXJyZW50IGRpc3BsYXkgb2YgdGhlIG5vZGUgYW5kIHJldHVybnMgdGhlIG5ldyBjb21wdXRlZCB2YWx1ZVxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLXN0eWxlXCJdLCBmdW5jdGlvbihkb21TdHlsZSl7XG5cdFx0Ly9cdHxcdFx0ZG9tU3R5bGUuc2V0KFwidGhpbmdlclwiLCBcIm9wYWNpdHlcIiwgMC41KTsgLy8gPT0gMC41XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRQYXNzaW5nIGEgbm9kZSwgYW4gb2JqZWN0LXN0eWxlIHN0eWxlIHByb3BlcnR5IHNldHMgZWFjaCBvZiB0aGUgdmFsdWVzIGluIHR1cm4gYW5kIHJldHVybnMgdGhlIGNvbXB1dGVkIHN0eWxlIG9iamVjdCBvZiB0aGUgbm9kZTpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1zdHlsZVwiXSwgZnVuY3Rpb24oZG9tU3R5bGUpe1xuXHRcdC8vXHR8XHRcdGRvbVN0eWxlLnNldChcInRoaW5nZXJcIiwge1xuXHRcdC8vXHR8XHRcdFx0XCJvcGFjaXR5XCI6IDAuNSxcblx0XHQvL1x0fFx0XHRcdFwiYm9yZGVyXCI6IFwiM3B4IHNvbGlkIGJsYWNrXCIsXG5cdFx0Ly9cdHxcdFx0XHRcImhlaWdodFwiOiBcIjMwMHB4XCJcblx0XHQvL1x0fFx0XHR9KTtcblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFdoZW4gdGhlIENTUyBzdHlsZSBwcm9wZXJ0eSBpcyBoeXBoZW5hdGVkLCB0aGUgSmF2YVNjcmlwdCBwcm9wZXJ0eSBpcyBjYW1lbENhc2VkLlxuXHRcdC8vXHRcdGZvbnQtc2l6ZSBiZWNvbWVzIGZvbnRTaXplLCBhbmQgc28gb24uXG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tc3R5bGVcIiwgXCJkb2pvL2RvbVwiXSwgZnVuY3Rpb24oZG9tU3R5bGUsIGRvbSl7XG5cdFx0Ly9cdHxcdFx0ZG9tU3R5bGUuc2V0KFwidGhpbmdlclwiLHtcblx0XHQvL1x0fFx0XHRcdGZvbnRTaXplOlwiMTRwdFwiLFxuXHRcdC8vXHR8XHRcdFx0bGV0dGVyU3BhY2luZzpcIjEuMmVtXCJcblx0XHQvL1x0fFx0XHR9KTtcblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdGRvam8vTm9kZUxpc3QgaW1wbGVtZW50cyAuc3R5bGUoKSB1c2luZyB0aGUgc2FtZSBzeW50YXgsIG9taXR0aW5nIHRoZSBcIm5vZGVcIiBwYXJhbWV0ZXIsIGNhbGxpbmdcblx0XHQvL1x0XHRkb2pvL2RvbS1zdHlsZS5nZXQoKSBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBsaXN0LiBTZWU6IGBkb2pvL3F1ZXJ5YCBhbmQgYGRvam8vTm9kZUxpc3RgXG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tc3R5bGVcIiwgXCJkb2pvL3F1ZXJ5XCIsIFwiZG9qby9Ob2RlTGlzdC1kb21cIl0sXG5cdFx0Ly9cdHxcdGZ1bmN0aW9uKGRvbVN0eWxlLCBxdWVyeSl7XG5cdFx0Ly9cdHxcdFx0cXVlcnkoXCIuc29tZUNsYXNzTmFtZVwiKS5zdHlsZShcInZpc2liaWxpdHlcIixcImhpZGRlblwiKTtcblx0XHQvL1x0fFx0XHQvLyBvclxuXHRcdC8vXHR8XHRcdHF1ZXJ5KFwiI2JheiA+IGRpdlwiKS5zdHlsZSh7XG5cdFx0Ly9cdHxcdFx0XHRvcGFjaXR5OjAuNzUsXG5cdFx0Ly9cdHxcdFx0XHRmb250U2l6ZTpcIjEzcHRcIlxuXHRcdC8vXHR8XHRcdH0pO1xuXHRcdC8vXHR8XHR9KTtcblxuXHRcdHZhciBuID0gZG9tLmJ5SWQobm9kZSksIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBvcCA9IChuYW1lID09IFwib3BhY2l0eVwiKTtcblx0XHRuYW1lID0gX2Zsb2F0QWxpYXNlc1tuYW1lXSA/IFwiY3NzRmxvYXRcIiBpbiBuLnN0eWxlID8gXCJjc3NGbG9hdFwiIDogXCJzdHlsZUZsb2F0XCIgOiBuYW1lO1xuXHRcdGlmKGwgPT0gMyl7XG5cdFx0XHRyZXR1cm4gb3AgPyBfc2V0T3BhY2l0eShuLCB2YWx1ZSkgOiBuLnN0eWxlW25hbWVdID0gdmFsdWU7IC8vIE51bWJlclxuXHRcdH1cblx0XHRmb3IodmFyIHggaW4gbmFtZSl7XG5cdFx0XHRzdHlsZS5zZXQobm9kZSwgeCwgbmFtZVt4XSk7XG5cdFx0fVxuXHRcdHJldHVybiBzdHlsZS5nZXRDb21wdXRlZFN0eWxlKG4pO1xuXHR9O1xuXG5cdHJldHVybiBzdHlsZTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vc25pZmZcIiwgXCIuL19iYXNlL3dpbmRvd1wiLCBcIi4vX2Jhc2Uva2VybmVsXCJdLFxuXHRcdGZ1bmN0aW9uKGhhcywgd2luLCBrZXJuZWwpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vZG9tXG5cblx0Ly8gRklYTUU6IG5lZWQgdG8gYWRkIHVuaXQgdGVzdHMgZm9yIGFsbCB0aGUgc2VtaS1wdWJsaWMgbWV0aG9kc1xuXG5cdGlmKGhhcyhcImllXCIpIDw9IDcpe1xuXHRcdHRyeXtcblx0XHRcdGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiQmFja2dyb3VuZEltYWdlQ2FjaGVcIiwgZmFsc2UsIHRydWUpO1xuXHRcdH1jYXRjaChlKXtcblx0XHRcdC8vIHNhbmUgYnJvd3NlcnMgZG9uJ3QgaGF2ZSBjYWNoZSBcImlzc3Vlc1wiXG5cdFx0fVxuXHR9XG5cblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0Ly8gRE9NIEZ1bmN0aW9uc1xuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdC8vIHRoZSByZXN1bHQgb2JqZWN0XG5cdHZhciBkb20gPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGlzIG1vZHVsZSBkZWZpbmVzIHRoZSBjb3JlIGRvam8gRE9NIEFQSS5cblx0fTtcblxuXHRpZihoYXMoXCJpZVwiKSl7XG5cdFx0ZG9tLmJ5SWQgPSBmdW5jdGlvbihpZCwgZG9jKXtcblx0XHRcdGlmKHR5cGVvZiBpZCAhPSBcInN0cmluZ1wiKXtcblx0XHRcdFx0cmV0dXJuIGlkIHx8IG51bGw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgX2QgPSBkb2MgfHwgd2luLmRvYywgdGUgPSBpZCAmJiBfZC5nZXRFbGVtZW50QnlJZChpZCk7XG5cdFx0XHQvLyBhdHRyaWJ1dGVzLmlkLnZhbHVlIGlzIGJldHRlciB0aGFuIGp1c3QgaWQgaW4gY2FzZSB0aGVcblx0XHRcdC8vIHVzZXIgaGFzIGEgbmFtZT1pZCBpbnNpZGUgYSBmb3JtXG5cdFx0XHRpZih0ZSAmJiAodGUuYXR0cmlidXRlcy5pZC52YWx1ZSA9PSBpZCB8fCB0ZS5pZCA9PSBpZCkpe1xuXHRcdFx0XHRyZXR1cm4gdGU7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0dmFyIGVsZXMgPSBfZC5hbGxbaWRdO1xuXHRcdFx0XHRpZighZWxlcyB8fCBlbGVzLm5vZGVOYW1lKXtcblx0XHRcdFx0XHRlbGVzID0gW2VsZXNdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIG1vcmUgdGhhbiAxLCBjaG9vc2UgZmlyc3Qgd2l0aCB0aGUgY29ycmVjdCBpZFxuXHRcdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRcdHdoaWxlKCh0ZSA9IGVsZXNbaSsrXSkpe1xuXHRcdFx0XHRcdGlmKCh0ZS5hdHRyaWJ1dGVzICYmIHRlLmF0dHJpYnV0ZXMuaWQgJiYgdGUuYXR0cmlidXRlcy5pZC52YWx1ZSA9PSBpZCkgfHwgdGUuaWQgPT0gaWQpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fWVsc2V7XG5cdFx0ZG9tLmJ5SWQgPSBmdW5jdGlvbihpZCwgZG9jKXtcblx0XHRcdC8vIGlubGluZSdkIHR5cGUgY2hlY2suXG5cdFx0XHQvLyBiZSBzdXJlIHRvIHJldHVybiBudWxsIHBlciBkb2N1bWVudGF0aW9uLCB0byBtYXRjaCBJRSBicmFuY2guXG5cdFx0XHRyZXR1cm4gKCh0eXBlb2YgaWQgPT0gXCJzdHJpbmdcIikgPyAoZG9jIHx8IHdpbi5kb2MpLmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkKSB8fCBudWxsOyAvLyBET01Ob2RlXG5cdFx0fTtcblx0fVxuXHQvKj09PT09XG5cdCBkb20uYnlJZCA9IGZ1bmN0aW9uKGlkLCBkb2Mpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmV0dXJucyBET00gbm9kZSB3aXRoIG1hdGNoaW5nIGBpZGAgYXR0cmlidXRlIG9yIGZhbHN5IHZhbHVlIChleDogbnVsbCBvciB1bmRlZmluZWQpXG5cdFx0Ly9cdFx0aWYgbm90IGZvdW5kLiAgSWYgYGlkYCBpcyBhIERvbU5vZGUsIHRoaXMgZnVuY3Rpb24gaXMgYSBuby1vcC5cblx0XHQvL1xuXHRcdC8vIGlkOiBTdHJpbmd8RE9NTm9kZVxuXHRcdC8vXHRcdEEgc3RyaW5nIHRvIG1hdGNoIGFuIEhUTUwgaWQgYXR0cmlidXRlIG9yIGEgcmVmZXJlbmNlIHRvIGEgRE9NIE5vZGVcblx0XHQvL1xuXHRcdC8vIGRvYzogRG9jdW1lbnQ/XG5cdFx0Ly9cdFx0RG9jdW1lbnQgdG8gd29yayBpbi4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb2Zcblx0XHQvL1x0XHRkb2pvL19iYXNlL3dpbmRvdy5kb2MuICBDYW4gYmUgdXNlZCB0byByZXRyaWV2ZVxuXHRcdC8vXHRcdG5vZGUgcmVmZXJlbmNlcyBmcm9tIG90aGVyIGRvY3VtZW50cy5cblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0TG9vayB1cCBhIG5vZGUgYnkgSUQ6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb21cIl0sIGZ1bmN0aW9uKGRvbSl7XG5cdFx0Ly9cdHxcdFx0dmFyIG4gPSBkb20uYnlJZChcImZvb1wiKTtcblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdENoZWNrIGlmIGEgbm9kZSBleGlzdHMsIGFuZCB1c2UgaXQuXG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb21cIl0sIGZ1bmN0aW9uKGRvbSl7XG5cdFx0Ly9cdHxcdFx0dmFyIG4gPSBkb20uYnlJZChcImJhclwiKTtcblx0XHQvL1x0fFx0XHRpZihuKXsgZG9TdHVmZigpIC4uLiB9XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRBbGxvdyBzdHJpbmcgb3IgRG9tTm9kZSByZWZlcmVuY2VzIHRvIGJlIHBhc3NlZCB0byBhIGN1c3RvbSBmdW5jdGlvbjpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbVwiXSwgZnVuY3Rpb24oZG9tKXtcblx0XHQvL1x0fFx0XHR2YXIgZm9vID0gZnVuY3Rpb24obm9kZU9ySWQpe1xuXHRcdC8vXHR8XHRcdFx0bm9kZU9ySWQgPSBkb20uYnlJZChub2RlT3JJZCk7XG5cdFx0Ly9cdHxcdFx0XHQvLyAuLi4gbW9yZSBzdHVmZlxuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSk7XG5cdCB9O1xuXHQgPT09PT0qL1xuXG5cdC8vIFRlc3QgZm9yIERPTU5vZGUuY29udGFpbnMoKSBtZXRob2QsIGF2YWlsYWJsZSBldmVyeXdoZXJlIGV4Y2VwdCBGRjgtXG5cdC8vIGFuZCBJRTgtLCB3aGVyZSBpdCdzIGF2YWlsYWJsZSBpbiBnZW5lcmFsLCBidXQgbm90IG9uIGRvY3VtZW50IGl0c2VsZixcblx0Ly8gYW5kIGFsc28gcHJvYmxlbXMgd2hlbiBlaXRoZXIgYW5jZXN0b3Igb3Igbm9kZSBhcmUgdGV4dCBub2Rlcy5cblxuXHR2YXIgZG9jID0ga2VybmVsLmdsb2JhbFtcImRvY3VtZW50XCJdIHx8IG51bGw7XG5cdGhhcy5hZGQoXCJkb20tY29udGFpbnNcIiwgISEoZG9jICYmIGRvYy5jb250YWlucykpO1xuXHRkb20uaXNEZXNjZW5kYW50ID0gaGFzKFwiZG9tLWNvbnRhaW5zXCIpID9cblx0XHQvLyBGRjkrLCBJRTkrLCB3ZWJraXQsIG9wZXJhLCBpT1MsIEFuZHJvaWQsIEVkZ2UsIGV0Yy5cblx0XHRmdW5jdGlvbigvKkRPTU5vZGV8U3RyaW5nKi8gbm9kZSwgLypET01Ob2RlfFN0cmluZyovIGFuY2VzdG9yKXtcblx0XHRcdHJldHVybiAhISggKGFuY2VzdG9yID0gZG9tLmJ5SWQoYW5jZXN0b3IpKSAmJiBhbmNlc3Rvci5jb250YWlucyhkb20uYnlJZChub2RlKSkgKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbigvKkRPTU5vZGV8U3RyaW5nKi8gbm9kZSwgLypET01Ob2RlfFN0cmluZyovIGFuY2VzdG9yKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRydWUgaWYgbm9kZSBpcyBhIGRlc2NlbmRhbnQgb2YgYW5jZXN0b3Jcblx0XHRcdC8vIG5vZGU6IERPTU5vZGV8U3RyaW5nXG5cdFx0XHQvL1x0XHRzdHJpbmcgaWQgb3Igbm9kZSByZWZlcmVuY2UgdG8gdGVzdFxuXHRcdFx0Ly8gYW5jZXN0b3I6IERPTU5vZGV8U3RyaW5nXG5cdFx0XHQvL1x0XHRzdHJpbmcgaWQgb3Igbm9kZSByZWZlcmVuY2Ugb2YgcG90ZW50aWFsIHBhcmVudCB0byB0ZXN0IGFnYWluc3Rcblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0VGVzdCBpcyBub2RlIGlkPVwiYmFyXCIgaXMgYSBkZXNjZW5kYW50IG9mIG5vZGUgaWQ9XCJmb29cIlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb21cIl0sIGZ1bmN0aW9uKGRvbSl7XG5cdFx0XHQvL1x0fFx0XHRpZihkb20uaXNEZXNjZW5kYW50KFwiYmFyXCIsIFwiZm9vXCIpKXsgLi4uIH1cblx0XHRcdC8vXHR8XHR9KTtcblxuXHRcdFx0dHJ5e1xuXHRcdFx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0XHRcdGFuY2VzdG9yID0gZG9tLmJ5SWQoYW5jZXN0b3IpO1xuXHRcdFx0XHR3aGlsZShub2RlKXtcblx0XHRcdFx0XHRpZihub2RlID09IGFuY2VzdG9yKXtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlOyAvLyBCb29sZWFuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1jYXRjaChlKXsgLyogc3F1ZWxjaCwgcmV0dXJuIGZhbHNlICovIH1cblx0XHRcdHJldHVybiBmYWxzZTsgLy8gQm9vbGVhblxuXHRcdH07XG5cblx0Ly8gVE9ETzogZG8gd2UgbmVlZCBzZXRTZWxlY3RhYmxlIGluIHRoZSBiYXNlP1xuXG5cdC8vIEFkZCBmZWF0dXJlIHRlc3QgZm9yIHVzZXItc2VsZWN0IENTUyBwcm9wZXJ0eVxuXHQvLyAoY3VycmVudGx5IGtub3duIHRvIHdvcmsgaW4gYWxsIGJ1dCBJRSA8IDEwIGFuZCBPcGVyYSlcblx0Ly8gVE9ETzogVGhlIHVzZXItc2VsZWN0IENTUyBwcm9wZXJ0eSBhcyBvZiBNYXkgMjAxNCBpcyBubyBsb25nZXIgcGFydCBvZlxuXHQvLyBhbnkgQ1NTIHNwZWNpZmljYXRpb24uIEluIElFLCAtbXMtdXNlci1zZWxlY3QgZG9lcyBub3QgZG8gdGhlIHNhbWUgdGhpbmdcblx0Ly8gYXMgdGhlIHVuc2VsZWN0YWJsZSBhdHRyaWJ1dGUgb24gZWxlbWVudHM7IG5hbWVseSwgZGlqaXQgRWRpdG9yIGJ1dHRvbnNcblx0Ly8gZG8gbm90IHByb3Blcmx5IHByZXZlbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGVkaXRhYmxlIGNvbnRlbnQgZnJhbWUgZnJvbVxuXHQvLyB1bmJsdXJyaW5nLiBBcyBhIHJlc3VsdCwgdGhlIC1tcy0gcHJlZml4ZWQgdmVyc2lvbiBpcyBvbWl0dGVkIGhlcmUuXG5cdGhhcy5hZGQoXCJjc3MtdXNlci1zZWxlY3RcIiwgZnVuY3Rpb24oZ2xvYmFsLCBkb2MsIGVsZW1lbnQpe1xuXHRcdC8vIEF2b2lkIGV4Y2VwdGlvbiB3aGVuIGRvbS5qcyBpcyBsb2FkZWQgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzXG5cdFx0aWYoIWVsZW1lbnQpeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG5cdFx0dmFyIHByZWZpeGVzID0gW1wiS2h0bWxcIiwgXCJPXCIsIFwiTW96XCIsIFwiV2Via2l0XCJdLFxuXHRcdFx0aSA9IHByZWZpeGVzLmxlbmd0aCxcblx0XHRcdG5hbWUgPSBcInVzZXJTZWxlY3RcIixcblx0XHRcdHByZWZpeDtcblxuXHRcdC8vIEl0ZXJhdGUgcHJlZml4ZXMgZnJvbSBtb3N0IHRvIGxlYXN0IGxpa2VseVxuXHRcdGRve1xuXHRcdFx0aWYodHlwZW9mIHN0eWxlW25hbWVdICE9PSBcInVuZGVmaW5lZFwiKXtcblx0XHRcdFx0Ly8gU3VwcG9ydGVkOyByZXR1cm4gcHJvcGVydHkgbmFtZVxuXHRcdFx0XHRyZXR1cm4gbmFtZTtcblx0XHRcdH1cblx0XHR9d2hpbGUoaS0tICYmIChuYW1lID0gcHJlZml4ZXNbaV0gKyBcIlVzZXJTZWxlY3RcIikpO1xuXG5cdFx0Ly8gTm90IHN1cHBvcnRlZCBpZiB3ZSBkaWRuJ3QgcmV0dXJuIGJlZm9yZSBub3dcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pO1xuXG5cdC8qPT09PT1cblx0ZG9tLnNldFNlbGVjdGFibGUgPSBmdW5jdGlvbihub2RlLCBzZWxlY3RhYmxlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEVuYWJsZSBvciBkaXNhYmxlIHNlbGVjdGlvbiBvbiBhIG5vZGVcblx0XHQvLyBub2RlOiBET01Ob2RlfFN0cmluZ1xuXHRcdC8vXHRcdGlkIG9yIHJlZmVyZW5jZSB0byBub2RlXG5cdFx0Ly8gc2VsZWN0YWJsZTogQm9vbGVhblxuXHRcdC8vXHRcdHN0YXRlIHRvIHB1dCB0aGUgbm9kZSBpbi4gZmFsc2UgaW5kaWNhdGVzIHVuc2VsZWN0YWJsZSwgdHJ1ZVxuXHRcdC8vXHRcdGFsbG93cyBzZWxlY3Rpb24uXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRNYWtlIHRoZSBub2RlIGlkPVwiYmFyXCIgdW5zZWxlY3RhYmxlXG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb21cIl0sIGZ1bmN0aW9uKGRvbSl7XG5cdFx0Ly9cdHxcdFx0ZG9tLnNldFNlbGVjdGFibGUoXCJiYXJcIik7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0TWFrZSB0aGUgbm9kZSBpZD1cImJhclwiIHNlbGVjdGFibGVcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbVwiXSwgZnVuY3Rpb24oZG9tKXtcblx0XHQvL1x0fFx0XHRkb20uc2V0U2VsZWN0YWJsZShcImJhclwiLCB0cnVlKTtcblx0XHQvL1x0fFx0fSk7XG5cdH07XG5cdD09PT09Ki9cblxuXHR2YXIgY3NzVXNlclNlbGVjdCA9IGhhcyhcImNzcy11c2VyLXNlbGVjdFwiKTtcblx0ZG9tLnNldFNlbGVjdGFibGUgPSBjc3NVc2VyU2VsZWN0ID8gZnVuY3Rpb24obm9kZSwgc2VsZWN0YWJsZSl7XG5cdFx0Ly8gY3NzLXVzZXItc2VsZWN0IHJldHVybnMgYSAocG9zc2libHkgdmVuZG9yLXByZWZpeGVkKSBDU1MgcHJvcGVydHkgbmFtZVxuXHRcdGRvbS5ieUlkKG5vZGUpLnN0eWxlW2Nzc1VzZXJTZWxlY3RdID0gc2VsZWN0YWJsZSA/IFwiXCIgOiBcIm5vbmVcIjtcblx0fSA6IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdGFibGUpe1xuXHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblxuXHRcdC8vIChJRSA8IDEwIC8gT3BlcmEpIEZhbGwgYmFjayB0byBzZXR0aW5nL3JlbW92aW5nIHRoZVxuXHRcdC8vIHVuc2VsZWN0YWJsZSBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQgYW5kIGFsbCBpdHMgY2hpbGRyZW5cblx0XHR2YXIgbm9kZXMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSxcblx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG5cblx0XHRpZihzZWxlY3RhYmxlKXtcblx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKFwidW5zZWxlY3RhYmxlXCIpO1xuXHRcdFx0d2hpbGUoaS0tKXtcblx0XHRcdFx0bm9kZXNbaV0ucmVtb3ZlQXR0cmlidXRlKFwidW5zZWxlY3RhYmxlXCIpO1xuXHRcdFx0fVxuXHRcdH1lbHNle1xuXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoXCJ1bnNlbGVjdGFibGVcIiwgXCJvblwiKTtcblx0XHRcdHdoaWxlKGktLSl7XG5cdFx0XHRcdG5vZGVzW2ldLnNldEF0dHJpYnV0ZShcInVuc2VsZWN0YWJsZVwiLCBcIm9uXCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gZG9tO1xufSk7XG4iLCJkZWZpbmUoWycuL2dsb2JhbCcsICcuL2hhcyddLCBmdW5jdGlvbihnbG9iYWwsIGhhcyl7XG5cdHZhciBkb2MgPSBkb2N1bWVudCxcblx0XHRyZWFkeVN0YXRlcyA9IHsgJ2xvYWRlZCc6IDEsICdjb21wbGV0ZSc6IDEgfSxcblx0XHRmaXhSZWFkeVN0YXRlID0gdHlwZW9mIGRvYy5yZWFkeVN0YXRlICE9IFwic3RyaW5nXCIsXG5cdFx0cmVhZHkgPSAhIXJlYWR5U3RhdGVzW2RvYy5yZWFkeVN0YXRlXSxcblx0XHRyZWFkeVEgPSBbXSxcblx0XHRyZWN1cnNpdmVHdWFyZDtcblxuXHRmdW5jdGlvbiBkb21SZWFkeShjYWxsYmFjayl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRQbHVnaW4gdG8gZGVsYXkgcmVxdWlyZSgpL2RlZmluZSgpIGNhbGxiYWNrIGZyb20gZmlyaW5nIHVudGlsIHRoZSBET00gaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG5cdFx0cmVhZHlRLnB1c2goY2FsbGJhY2spO1xuXHRcdGlmKHJlYWR5KXsgcHJvY2Vzc1EoKTsgfVxuXHR9XG5cdGRvbVJlYWR5LmxvYWQgPSBmdW5jdGlvbihpZCwgcmVxLCBsb2FkKXtcblx0XHRkb21SZWFkeShsb2FkKTtcblx0fTtcblxuXHQvLyBFeHBvcnQgcXVldWUgc28gdGhhdCByZWFkeSgpIGNhbiBjaGVjayBpZiBpdCdzIGVtcHR5IG9yIG5vdC5cblx0ZG9tUmVhZHkuX1EgPSByZWFkeVE7XG5cdGRvbVJlYWR5Ll9vblFFbXB0eSA9IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRQcml2YXRlIG1ldGhvZCBvdmVycmlkZGVuIGJ5IGRvam8vcmVhZHksIHRvIG5vdGlmeSB3aGVuIGV2ZXJ5dGhpbmcgaW4gdGhlXG5cdFx0Ly9cdFx0ZG9tUmVhZHkgcXVldWUgaGFzIGJlZW4gcHJvY2Vzc2VkLiAgRG8gbm90IHVzZSBkaXJlY3RseS5cblx0XHQvL1x0XHRXaWxsIGJlIHJlbW92ZWQgaW4gMi4wLCBhbG9uZyB3aXRoIGRvbVJlYWR5Ll9RLlxuXHR9O1xuXG5cdC8vIEZvciBGRiA8PSAzLjVcblx0aWYoZml4UmVhZHlTdGF0ZSl7IGRvYy5yZWFkeVN0YXRlID0gXCJsb2FkaW5nXCI7IH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzUSgpe1xuXHRcdC8vIENhbGxzIGFsbCBmdW5jdGlvbnMgaW4gdGhlIHF1ZXVlIGluIG9yZGVyLCB1bmxlc3MgcHJvY2Vzc1EoKSBpcyBhbHJlYWR5IHJ1bm5pbmcsIGluIHdoaWNoIGNhc2UganVzdCByZXR1cm5cblxuXHRcdGlmKHJlY3Vyc2l2ZUd1YXJkKXsgcmV0dXJuOyB9XG5cdFx0cmVjdXJzaXZlR3VhcmQgPSB0cnVlO1xuXG5cdFx0d2hpbGUocmVhZHlRLmxlbmd0aCl7XG5cdFx0XHR0cnl7XG5cdFx0XHRcdChyZWFkeVEuc2hpZnQoKSkoZG9jKTtcblx0XHRcdH1jYXRjaChlcnIpe1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKGVyciwgXCJpbiBkb21SZWFkeSBjYWxsYmFja1wiLCBlcnIuc3RhY2spO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJlY3Vyc2l2ZUd1YXJkID0gZmFsc2U7XG5cblx0XHQvLyBOb3RpZmljYXRpb24gZm9yIGRvam8vcmVhZHkuICBSZW1vdmUgZm9yIDIuMC5cblx0XHQvLyBOb3RlIHRoYXQgdGhpcyBjb3VsZCBhZGQgbW9yZSB0YXNrcyB0byB0aGUgcmVhZHkgcXVldWUuXG5cdFx0ZG9tUmVhZHkuX29uUUVtcHR5KCk7XG5cdH1cblxuXHRpZighcmVhZHkpe1xuXHRcdHZhciB0ZXN0cyA9IFtdLFxuXHRcdFx0ZGV0ZWN0UmVhZHkgPSBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRldnQgPSBldnQgfHwgZ2xvYmFsLmV2ZW50O1xuXHRcdFx0XHRpZihyZWFkeSB8fCAoZXZ0LnR5cGUgPT0gXCJyZWFkeXN0YXRlY2hhbmdlXCIgJiYgIXJlYWR5U3RhdGVzW2RvYy5yZWFkeVN0YXRlXSkpeyByZXR1cm47IH1cblxuXHRcdFx0XHQvLyBGb3IgRkYgPD0gMy41XG5cdFx0XHRcdGlmKGZpeFJlYWR5U3RhdGUpeyBkb2MucmVhZHlTdGF0ZSA9IFwiY29tcGxldGVcIjsgfVxuXG5cdFx0XHRcdHJlYWR5ID0gMTtcblx0XHRcdFx0cHJvY2Vzc1EoKTtcblx0XHRcdH0sXG5cdFx0XHRvbiA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50KXtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBkZXRlY3RSZWFkeSwgZmFsc2UpO1xuXHRcdFx0XHRyZWFkeVEucHVzaChmdW5jdGlvbigpeyBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGRldGVjdFJlYWR5LCBmYWxzZSk7IH0pO1xuXHRcdFx0fTtcblxuXHRcdGlmKCFoYXMoXCJkb20tYWRkZXZlbnRsaXN0ZW5lclwiKSl7XG5cdFx0XHRvbiA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50KXtcblx0XHRcdFx0ZXZlbnQgPSBcIm9uXCIgKyBldmVudDtcblx0XHRcdFx0bm9kZS5hdHRhY2hFdmVudChldmVudCwgZGV0ZWN0UmVhZHkpO1xuXHRcdFx0XHRyZWFkeVEucHVzaChmdW5jdGlvbigpeyBub2RlLmRldGFjaEV2ZW50KGV2ZW50LCBkZXRlY3RSZWFkeSk7IH0pO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0dHJ5e1xuXHRcdFx0XHRpZihkaXYuZG9TY3JvbGwgJiYgZ2xvYmFsLmZyYW1lRWxlbWVudCA9PT0gbnVsbCl7XG5cdFx0XHRcdFx0Ly8gdGhlIGRvU2Nyb2xsIHRlc3QgaXMgb25seSB1c2VmdWwgaWYgd2UncmUgaW4gdGhlIHRvcC1tb3N0IGZyYW1lXG5cdFx0XHRcdFx0dGVzdHMucHVzaChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0Ly8gRGVyaXZlZCB3aXRoIHBlcm1pc3Npb24gZnJvbSBEaWVnbyBQZXJpbmkncyBJRUNvbnRlbnRMb2FkZWRcblx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9qYXZhc2NyaXB0Lm53Ym94LmNvbS9JRUNvbnRlbnRMb2FkZWQvXG5cdFx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHRcdGRpdi5kb1Njcm9sbChcImxlZnRcIik7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHRcdFx0fWNhdGNoKGUpe31cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fWNhdGNoKGUpe31cblx0XHR9XG5cblx0XHRvbihkb2MsIFwiRE9NQ29udGVudExvYWRlZFwiKTtcblx0XHRvbihnbG9iYWwsIFwibG9hZFwiKTtcblxuXHRcdGlmKFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jKXtcblx0XHRcdG9uKGRvYywgXCJyZWFkeXN0YXRlY2hhbmdlXCIpO1xuXHRcdH1lbHNlIGlmKCFmaXhSZWFkeVN0YXRlKXtcblx0XHRcdC8vIGlmIHRoZSByZWFkeSBzdGF0ZSBwcm9wZXJ0eSBleGlzdHMgYW5kIHRoZXJlJ3Ncblx0XHRcdC8vIG5vIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQsIHBvbGwgZm9yIHRoZSBzdGF0ZVxuXHRcdFx0Ly8gdG8gY2hhbmdlXG5cdFx0XHR0ZXN0cy5wdXNoKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJldHVybiByZWFkeVN0YXRlc1tkb2MucmVhZHlTdGF0ZV07XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZih0ZXN0cy5sZW5ndGgpe1xuXHRcdFx0dmFyIHBvbGxlciA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGlmKHJlYWR5KXsgcmV0dXJuOyB9XG5cdFx0XHRcdHZhciBpID0gdGVzdHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZShpLS0pe1xuXHRcdFx0XHRcdGlmKHRlc3RzW2ldKCkpe1xuXHRcdFx0XHRcdFx0ZGV0ZWN0UmVhZHkoXCJwb2xsZXJcIik7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNldFRpbWVvdXQocG9sbGVyLCAzMCk7XG5cdFx0XHR9O1xuXHRcdFx0cG9sbGVyKCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRvbVJlYWR5O1xufSk7XG4iLCJkZWZpbmUoW1wiLi9jcmVhdGVcIl0sIGZ1bmN0aW9uKGNyZWF0ZSl7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9lcnJvcnMvQ2FuY2VsRXJyb3JcblxuXHQvKj09PT09XG5cdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0RGVmYXVsdCBlcnJvciBpZiBhIHByb21pc2UgaXMgY2FuY2VsZWQgd2l0aG91dCBhIHJlYXNvbi5cblx0fTtcblx0PT09PT0qL1xuXG5cdHJldHVybiBjcmVhdGUoXCJDYW5jZWxFcnJvclwiLCBudWxsLCBudWxsLCB7IGRvam9UeXBlOiBcImNhbmNlbFwiLCBsb2c6IGZhbHNlIH0pO1xufSk7XG4iLCJkZWZpbmUoWycuL2NyZWF0ZSddLCBmdW5jdGlvbihjcmVhdGUpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vZXJyb3JzL1JlcXVlc3RFcnJvclxuXG5cdC8qPT09PT1cblx0IHJldHVybiBmdW5jdGlvbigpe1xuXHRcdCAvLyBzdW1tYXJ5OlxuXHRcdCAvL1x0XHRUT0RPQ1xuXHQgfTtcblx0ID09PT09Ki9cblxuXHRyZXR1cm4gY3JlYXRlKFwiUmVxdWVzdEVycm9yXCIsIGZ1bmN0aW9uKG1lc3NhZ2UsIHJlc3BvbnNlKXtcblx0XHR0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG5cdH0pO1xufSk7XG4iLCJkZWZpbmUoWycuL2NyZWF0ZScsICcuL1JlcXVlc3RFcnJvciddLCBmdW5jdGlvbihjcmVhdGUsIFJlcXVlc3RFcnJvcil7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9lcnJvcnMvUmVxdWVzdFRpbWVvdXRFcnJvclxuXG5cdC8qPT09PT1cblx0IHJldHVybiBmdW5jdGlvbigpe1xuXHRcdCAvLyBzdW1tYXJ5OlxuXHRcdCAvL1x0XHRUT0RPQ1xuXHQgfTtcblx0ID09PT09Ki9cblxuXHRyZXR1cm4gY3JlYXRlKFwiUmVxdWVzdFRpbWVvdXRFcnJvclwiLCBudWxsLCBSZXF1ZXN0RXJyb3IsIHtcblx0XHRkb2pvVHlwZTogXCJ0aW1lb3V0XCJcblx0fSk7XG59KTtcbiIsImRlZmluZShbXCIuLi9fYmFzZS9sYW5nXCJdLCBmdW5jdGlvbihsYW5nKXtcblx0cmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGN0b3IsIGJhc2UsIHByb3BzKXtcblx0XHRiYXNlID0gYmFzZSB8fCBFcnJvcjtcblxuXHRcdHZhciBFcnJvckN0b3IgPSBmdW5jdGlvbihtZXNzYWdlKXtcblx0XHRcdGlmKGJhc2UgPT09IEVycm9yKXtcblx0XHRcdFx0aWYoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Upe1xuXHRcdFx0XHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEVycm9yQ3Rvcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFcnJvci5jYWxsKCkgb3BlcmF0ZXMgb24gdGhlIHJldHVybmVkIGVycm9yXG5cdFx0XHRcdC8vIG9iamVjdCByYXRoZXIgdGhhbiBvcGVyYXRpbmcgb24gfHRoaXN8XG5cdFx0XHRcdHZhciBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpLFxuXHRcdFx0XHRcdHByb3A7XG5cblx0XHRcdFx0Ly8gQ29weSBvd24gcHJvcGVydGllcyBmcm9tIGVyciB0byB8dGhpc3xcblx0XHRcdFx0Zm9yKHByb3AgaW4gZXJyKXtcblx0XHRcdFx0XHRpZihlcnIuaGFzT3duUHJvcGVydHkocHJvcCkpe1xuXHRcdFx0XHRcdFx0dGhpc1twcm9wXSA9IGVycltwcm9wXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBtZXNzc2FnZSBpcyBub24tZW51bWVyYWJsZSBpbiBFUzVcblx0XHRcdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHRcdFx0Ly8gc3RhY2sgaXMgbm9uLWVudW1lcmFibGUgaW4gYXQgbGVhc3QgRmlyZWZveFxuXHRcdFx0XHR0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGlmKGN0b3Ipe1xuXHRcdFx0XHRjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdEVycm9yQ3Rvci5wcm90b3R5cGUgPSBsYW5nLmRlbGVnYXRlKGJhc2UucHJvdG90eXBlLCBwcm9wcyk7XG5cdFx0RXJyb3JDdG9yLnByb3RvdHlwZS5uYW1lID0gbmFtZTtcblx0XHRFcnJvckN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXJyb3JDdG9yO1xuXG5cdFx0cmV0dXJuIEVycm9yQ3Rvcjtcblx0fTtcbn0pO1xuIiwiZGVmaW5lKGZ1bmN0aW9uKCl7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gZ2xvYmFsIHNwZWMgZGVmaW5lcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBjYWxsZWQgJ2dsb2JhbCdcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG4gICAgICAgIC8vIGBnbG9iYWxgIGlzIGFsc28gZGVmaW5lZCBpbiBOb2RlSlNcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gd2luZG93IGlzIGRlZmluZWQgaW4gYnJvd3NlcnNcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHNlbGYgaXMgZGVmaW5lZCBpbiBXZWJXb3JrZXJzXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn0pO1xuIiwiZGVmaW5lKFtcIi4vZ2xvYmFsXCIsIFwicmVxdWlyZVwiLCBcIm1vZHVsZVwiXSwgZnVuY3Rpb24oZ2xvYmFsLCByZXF1aXJlLCBtb2R1bGUpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vaGFzXG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdERlZmluZXMgdGhlIGhhcy5qcyBBUEkgYW5kIHNldmVyYWwgZmVhdHVyZSB0ZXN0cyB1c2VkIGJ5IGRvam8uXG5cdC8vIGRlc2NyaXB0aW9uOlxuXHQvL1x0XHRUaGlzIG1vZHVsZSBkZWZpbmVzIHRoZSBoYXMgQVBJIGFzIGRlc2NyaWJlZCBieSB0aGUgcHJvamVjdCBoYXMuanMgd2l0aCB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgZmVhdHVyZXM6XG5cdC8vXG5cdC8vXHRcdC0gdGhlIGhhcyB0ZXN0IGNhY2hlIGlzIGV4cG9zZWQgYXQgaGFzLmNhY2hlLlxuXHQvL1x0XHQtIHRoZSBtZXRob2QgaGFzLmFkZCBpbmNsdWRlcyBhIGZvcnRoIHBhcmFtZXRlciB0aGF0IGNvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGV4aXN0aW5nIHRlc3RzIGFyZSByZXBsYWNlZFxuXHQvL1x0XHQtIHRoZSBsb2FkZXIncyBoYXMgY2FjaGUgbWF5IGJlIG9wdGlvbmFsbHkgY29waWVkIGludG8gdGhpcyBtb2R1bGUncyBoYXMgY2FoY2UuXG5cdC8vXG5cdC8vXHRcdFRoaXMgbW9kdWxlIGFkb3B0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGhpZ2dpbnM0Mi9oYXMuanM7IHRoYW5rcyBoYXMuanMgdGVhbSFcblxuXHQvLyB0cnkgdG8gcHVsbCB0aGUgaGFzIGltcGxlbWVudGF0aW9uIGZyb20gdGhlIGxvYWRlcjsgYm90aCB0aGUgZG9qbyBsb2FkZXIgYW5kIGJkTG9hZCBwcm92aWRlIG9uZVxuXHQvLyBpZiB1c2luZyBhIGZvcmVpZ24gbG9hZGVyLCB0aGVuIHRoZSBoYXMgY2FjaGUgbWF5IGJlIGluaXRpYWxpemVkIHZpYSB0aGUgY29uZmlnIG9iamVjdCBmb3IgdGhpcyBtb2R1bGVcblx0Ly8gV0FSTklORzogaWYgYSBmb3JlaWduIGxvYWRlciBkZWZpbmVzIHJlcXVpcmUuaGFzIHRvIGJlIHNvbWV0aGluZyBvdGhlciB0aGFuIHRoZSBoYXMuanMgQVBJLCB0aGVuIHRoaXMgaW1wbGVtZW50YXRpb24gZmFpbFxuXHR2YXIgaGFzID0gcmVxdWlyZS5oYXMgfHwgZnVuY3Rpb24oKXt9O1xuXHRpZighaGFzKFwiZG9qby1oYXMtYXBpXCIpKXtcblx0XHR2YXJcblx0XHRcdGlzQnJvd3NlciA9XG5cdFx0XHRcdC8vIHRoZSBtb3N0IGZ1bmRhbWVudGFsIGRlY2lzaW9uOiBhcmUgd2UgaW4gdGhlIGJyb3dzZXI/XG5cdFx0XHRcdHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHR0eXBlb2YgbG9jYXRpb24gIT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHR0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHR3aW5kb3cubG9jYXRpb24gPT0gbG9jYXRpb24gJiYgd2luZG93LmRvY3VtZW50ID09IGRvY3VtZW50LFxuXG5cdFx0XHQvLyBoYXMgQVBJIHZhcmlhYmxlc1xuXHRcdFx0ZG9jID0gaXNCcm93c2VyICYmIGRvY3VtZW50LFxuXHRcdFx0ZWxlbWVudCA9IGRvYyAmJiBkb2MuY3JlYXRlRWxlbWVudChcIkRpVlwiKSxcblx0XHRcdGNhY2hlID0gKG1vZHVsZS5jb25maWcgJiYgbW9kdWxlLmNvbmZpZygpKSB8fCB7fTtcblxuXHRcdGhhcyA9IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgbmFtZWQgZmVhdHVyZS5cblx0XHRcdC8vXG5cdFx0XHQvLyBuYW1lOiBTdHJpbmd8SW50ZWdlclxuXHRcdFx0Ly9cdFx0VGhlIG5hbWUgKGlmIGEgc3RyaW5nKSBvciBpZGVudGlmaWVyIChpZiBhbiBpbnRlZ2VyKSBvZiB0aGUgZmVhdHVyZSB0byB0ZXN0LlxuXHRcdFx0Ly9cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZlYXR1cmUgbmFtZWQgYnkgbmFtZS4gVGhlIGZlYXR1cmUgbXVzdCBoYXZlIGJlZW5cblx0XHRcdC8vXHRcdHByZXZpb3VzbHkgYWRkZWQgdG8gdGhlIGNhY2hlIGJ5IGhhcy5hZGQuXG5cblx0XHRcdHJldHVybiB0eXBlb2YgY2FjaGVbbmFtZV0gPT0gXCJmdW5jdGlvblwiID8gKGNhY2hlW25hbWVdID0gY2FjaGVbbmFtZV0oZ2xvYmFsLCBkb2MsIGVsZW1lbnQpKSA6IGNhY2hlW25hbWVdOyAvLyBCb29sZWFuXG5cdFx0fTtcblxuXHRcdGhhcy5jYWNoZSA9IGNhY2hlO1xuXG5cdFx0aGFzLmFkZCA9IGZ1bmN0aW9uKG5hbWUsIHRlc3QsIG5vdywgZm9yY2Upe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHQgXHRSZWdpc3RlciBhIG5ldyBmZWF0dXJlIHRlc3QgZm9yIHNvbWUgbmFtZWQgZmVhdHVyZS5cblx0XHRcdC8vIG5hbWU6IFN0cmluZ3xJbnRlZ2VyXG5cdFx0XHQvL1x0IFx0VGhlIG5hbWUgKGlmIGEgc3RyaW5nKSBvciBpZGVudGlmaWVyIChpZiBhbiBpbnRlZ2VyKSBvZiB0aGUgZmVhdHVyZSB0byB0ZXN0LlxuXHRcdFx0Ly8gdGVzdDogRnVuY3Rpb25cblx0XHRcdC8vXHRcdCBBIHRlc3QgZnVuY3Rpb24gdG8gcmVnaXN0ZXIuIElmIGEgZnVuY3Rpb24sIHF1ZXVlZCBmb3IgdGVzdGluZyB1bnRpbCBhY3R1YWxseVxuXHRcdFx0Ly9cdFx0IG5lZWRlZC4gVGhlIHRlc3QgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGJvb2xlYW4gaW5kaWNhdGluZ1xuXHRcdFx0Ly9cdCBcdHRoZSBwcmVzZW5jZSBvZiBhIGZlYXR1cmUgb3IgYnVnLlxuXHRcdFx0Ly8gbm93OiBCb29sZWFuP1xuXHRcdFx0Ly9cdFx0IE9wdGlvbmFsLiBPbWl0IGlmIGB0ZXN0YCBpcyBub3QgYSBmdW5jdGlvbi4gUHJvdmlkZXMgYSB3YXkgdG8gaW1tZWRpYXRlbHlcblx0XHRcdC8vXHRcdCBydW4gdGhlIHRlc3QgYW5kIGNhY2hlIHRoZSByZXN1bHQuXG5cdFx0XHQvLyBmb3JjZTogQm9vbGVhbj9cblx0XHRcdC8vXHQgXHRPcHRpb25hbC4gSWYgdGhlIHRlc3QgYWxyZWFkeSBleGlzdHMgYW5kIGZvcmNlIGlzIHRydXRoeSwgdGhlbiB0aGUgZXhpc3Rpbmdcblx0XHRcdC8vXHQgXHR0ZXN0IHdpbGwgYmUgcmVwbGFjZWQ7IG90aGVyd2lzZSwgYWRkIGRvZXMgbm90IHJlcGxhY2UgYW4gZXhpc3RpbmcgdGVzdCAodGhhdFxuXHRcdFx0Ly9cdCBcdGlzLCBieSBkZWZhdWx0LCB0aGUgZmlyc3QgdGVzdCBhZHZpY2Ugd2lucykuXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0QSByZWR1bmRhbnQgdGVzdCwgdGVzdEZuIHdpdGggaW1tZWRpYXRlIGV4ZWN1dGlvbjpcblx0XHRcdC8vXHR8XHRoYXMuYWRkKFwiamF2YXNjcmlwdFwiLCBmdW5jdGlvbigpeyByZXR1cm4gdHJ1ZTsgfSwgdHJ1ZSk7XG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdEFnYWluIHdpdGggdGhlIHJlZHVuZGFudG5lc3MuIFlvdSBjYW4gZG8gdGhpcyBpbiB5b3VyIHRlc3RzLCBidXQgd2Ugc2hvdWxkXG5cdFx0XHQvL1x0XHRub3QgYmUgZG9pbmcgdGhpcyBpbiBhbnkgaW50ZXJuYWwgaGFzLmpzIHRlc3RzXG5cdFx0XHQvL1x0fFx0aGFzLmFkZChcImphdmFzY3JpcHRcIiwgdHJ1ZSk7XG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdFRocmVlIHRoaW5ncyBhcmUgcGFzc2VkIHRvIHRoZSB0ZXN0RnVuY3Rpb24uIGBnbG9iYWxgLCBgZG9jdW1lbnRgLCBhbmQgYSBnZW5lcmljIGVsZW1lbnRcblx0XHRcdC8vXHRcdGZyb20gd2hpY2ggdG8gd29yayB5b3VyIHRlc3Qgc2hvdWxkIHRoZSBuZWVkIGFyaXNlLlxuXHRcdFx0Ly9cdHxcdGhhcy5hZGQoXCJidWctYnlpZFwiLCBmdW5jdGlvbihnLCBkLCBlbCl7XG5cdFx0XHQvL1x0fFx0XHQvLyBnXHQ9PSBnbG9iYWwsIHR5cGljYWxseSB3aW5kb3csIHlhZGRhIHlhZGRhXG5cdFx0XHQvL1x0fFx0XHQvLyBkXHQ9PSBkb2N1bWVudCBvYmplY3Rcblx0XHRcdC8vXHR8XHRcdC8vIGVsID09IHRoZSBnZW5lcmljIGVsZW1lbnQuIGEgYGhhc2AgZWxlbWVudC5cblx0XHRcdC8vXHR8XHRcdHJldHVybiBmYWxzZTsgLy8gZmFrZSB0ZXN0LCBieWlkLXdoZW4tZm9ybS1oYXMtbmFtZS1tYXRjaGluZy1hbi1pZCBpcyBzbGlnaHRseSBsb25nZXJcblx0XHRcdC8vXHR8XHR9KTtcblxuXHRcdFx0KHR5cGVvZiBjYWNoZVtuYW1lXT09XCJ1bmRlZmluZWRcIiB8fCBmb3JjZSkgJiYgKGNhY2hlW25hbWVdPSB0ZXN0KTtcblx0XHRcdHJldHVybiBub3cgJiYgaGFzKG5hbWUpO1xuXHRcdH07XG5cblx0XHQvLyBzaW5jZSB3ZSdyZSBvcGVyYXRpbmcgdW5kZXIgYSBsb2FkZXIgdGhhdCBkb2Vzbid0IHByb3ZpZGUgYSBoYXMgQVBJLCB3ZSBtdXN0IGV4cGxpY2l0bHkgaW5pdGlhbGl6ZVxuXHRcdC8vIGhhcyBhcyBpdCB3b3VsZCBoYXZlIG90aGVyd2lzZSBiZWVuIGluaXRpYWxpemVkIGJ5IHRoZSBkb2pvIGxvYWRlcjsgdXNlIGhhcy5hZGQgdG8gdGhlIGJ1aWxkZXJcblx0XHQvLyBjYW4gb3B0aW1pemUgdGhlc2UgYXdheSBpZmYgZGVzaXJlZFxuXHRcdGhhcy5hZGQoXCJob3N0LWJyb3dzZXJcIiwgaXNCcm93c2VyKTtcblx0XHRoYXMuYWRkKFwiaG9zdC1ub2RlXCIsICh0eXBlb2YgcHJvY2VzcyA9PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICYmIHByb2Nlc3MudmVyc2lvbnMudjgpKTtcblx0XHRoYXMuYWRkKFwiaG9zdC1yaGlub1wiLCAodHlwZW9mIGxvYWQgPT0gXCJmdW5jdGlvblwiICYmICh0eXBlb2YgUGFja2FnZXMgPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBQYWNrYWdlcyA9PSBcIm9iamVjdFwiKSkpO1xuXHRcdGhhcy5hZGQoXCJkb21cIiwgaXNCcm93c2VyKTtcblx0XHRoYXMuYWRkKFwiZG9qby1kb20tcmVhZHktYXBpXCIsIDEpO1xuXHRcdGhhcy5hZGQoXCJkb2pvLXNuaWZmXCIsIDEpO1xuXHR9XG5cblx0aWYoaGFzKFwiaG9zdC1icm93c2VyXCIpKXtcblx0XHQvLyBDb21tb24gYXBwbGljYXRpb24gbGV2ZWwgdGVzdHNcblx0XHRoYXMuYWRkKFwiZG9tLWFkZGV2ZW50bGlzdGVuZXJcIiwgISFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKTtcblxuXHRcdC8vIERvIHRoZSBkZXZpY2UgYW5kIGJyb3dzZXIgaGF2ZSB0b3VjaCBjYXBhYmlsaXR5P1xuXHRcdGhhcy5hZGQoXCJ0b3VjaFwiLCBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50XG5cdFx0XHR8fCAoXCJvbnBvaW50ZXJkb3duXCIgaW4gZG9jdW1lbnQgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMClcblx0XHRcdHx8IHdpbmRvdy5uYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyk7XG5cblx0XHQvLyBUb3VjaCBldmVudHMgc3VwcG9ydFxuXHRcdGhhcy5hZGQoXCJ0b3VjaC1ldmVudHNcIiwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudCk7XG5cblx0XHQvLyBUZXN0IGlmIHBvaW50ZXIgZXZlbnRzIGFyZSBzdXBwb3J0ZWQgYW5kIGVuYWJsZWQsIHdpdGggZWl0aGVyIHN0YW5kYXJkIG5hbWVzIChcInBvaW50ZXJkb3duXCIgZXRjLikgb3Jcblx0XHQvLyBJRSBzcGVjaWZpYyBuYW1lcyAoXCJNU1BvaW50ZXJEb3duXCIgZXRjLikuICBUZXN0cyBhcmUgZGVzaWduZWQgdG8gd29yayBvbiBlbWJlZGRlZCBDIyBXZWJCcm93c2VyIENvbnRyb2xzXG5cdFx0Ly8gaW4gYWRkaXRpb24gdG8gSUUsIEVkZ2UsIGFuZCBmdXR1cmUgdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgQ2hyb21lLlxuXHRcdC8vIE5vdGUgdGhhdCBvbiBJRTExLCBoYXMoXCJwb2ludGVyLWV2ZW50c1wiKSBhbmQgaGFzKFwiTVNQb2ludGVyXCIpIGFyZSBib3RoIHRydWUuXG5cdFx0aGFzLmFkZChcInBvaW50ZXItZXZlbnRzXCIsIFwicG9pbnRlckVuYWJsZWRcIiBpbiB3aW5kb3cubmF2aWdhdG9yID9cblx0XHRcdFx0d2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCA6IFwiUG9pbnRlckV2ZW50XCIgaW4gd2luZG93KTtcblx0XHRoYXMuYWRkKFwiTVNQb2ludGVyXCIsIHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCk7XG5cdFx0Ly8gVGhlIFwicG9pbnRlcm1vdmVcIlwiIGV2ZW50IGlzIG9ubHkgY29udGludW91c2x5IGVtaXR0ZWQgaW4gYSB0b3VjaCBlbnZpcm9ubWVudCBpZlxuXHRcdC8vIHRoZSB0YXJnZXQgbm9kZSdzIFwidG91Y2gtYWN0aW9uXCJcIiBDU1MgcHJvcGVydHkgaXMgc2V0IHRvIFwibm9uZVwiXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvI3RoZS10b3VjaC1hY3Rpb24tY3NzLXByb3BlcnR5XG5cdFx0aGFzLmFkZChcInRvdWNoLWFjdGlvblwiLCBoYXMoXCJ0b3VjaFwiKSAmJiBoYXMoXCJwb2ludGVyLWV2ZW50c1wiKSk7XG5cblx0XHQvLyBJIGRvbid0IGtub3cgaWYgYW55IG9mIHRoZXNlIHRlc3RzIGFyZSByZWFsbHkgY29ycmVjdCwganVzdCBhIHJvdWdoIGd1ZXNzXG5cdFx0aGFzLmFkZChcImRldmljZS13aWR0aFwiLCBzY3JlZW4uYXZhaWxXaWR0aCB8fCBpbm5lcldpZHRoKTtcblxuXHRcdC8vIFRlc3RzIGZvciBET01Ob2RlLmF0dHJpYnV0ZXNbXSBiZWhhdmlvcjpcblx0XHQvL1x0IC0gZG9tLWF0dHJpYnV0ZXMtZXhwbGljaXQgLSBhdHRyaWJ1dGVzW10gb25seSBsaXN0cyBleHBsaWNpdGx5IHVzZXIgc3BlY2lmaWVkIGF0dHJpYnV0ZXNcblx0XHQvL1x0IC0gZG9tLWF0dHJpYnV0ZXMtc3BlY2lmaWVkLWZsYWcgKElFOCkgLSBuZWVkIHRvIGNoZWNrIGF0dHIuc3BlY2lmaWVkIGZsYWcgdG8gc2tpcCBhdHRyaWJ1dGVzIHVzZXIgZGlkbid0IHNwZWNpZnlcblx0XHQvL1x0IC0gT3RoZXJ3aXNlLCBpbiBJRTYtNy4gYXR0cmlidXRlc1tdIHdpbGwgbGlzdCBodW5kcmVkcyBvZiB2YWx1ZXMsIHNvIG5lZWQgdG8gZG8gb3V0ZXJIVE1MIHRvIGdldCBhdHRycyBpbnN0ZWFkLlxuXHRcdHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIik7XG5cdFx0aGFzLmFkZChcImRvbS1hdHRyaWJ1dGVzLWV4cGxpY2l0XCIsIGZvcm0uYXR0cmlidXRlcy5sZW5ndGggPT0gMCk7IC8vIFczQ1xuXHRcdGhhcy5hZGQoXCJkb20tYXR0cmlidXRlcy1zcGVjaWZpZWQtZmxhZ1wiLCBmb3JtLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCAmJiBmb3JtLmF0dHJpYnV0ZXMubGVuZ3RoIDwgNDApO1x0Ly8gSUU4XG5cdH1cblxuXHRoYXMuY2xlYXJFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0IERlbGV0ZXMgdGhlIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50IHBhc3NlZCB0byB0ZXN0IGZ1bmN0aW9ucy5cblx0XHRlbGVtZW50LmlubmVySFRNTD0gXCJcIjtcblx0XHRyZXR1cm4gZWxlbWVudDtcblx0fTtcblxuXHRoYXMubm9ybWFsaXplID0gZnVuY3Rpb24oaWQsIHRvQWJzTWlkKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHQgUmVzb2x2ZXMgaWQgaW50byBhIG1vZHVsZSBpZCBiYXNlZCBvbiBwb3NzaWJseS1uZXN0ZWQgdGVuYXJ5IGV4cHJlc3Npb24gdGhhdCBicmFuY2hlcyBvbiBoYXMgZmVhdHVyZSB0ZXN0IHZhbHVlKHMpLlxuXHRcdC8vXG5cdFx0Ly8gdG9BYnNNaWQ6IEZ1bmN0aW9uXG5cdFx0Ly9cdCBSZXNvbHZlcyBhIHJlbGF0aXZlIG1vZHVsZSBpZCBpbnRvIGFuIGFic29sdXRlIG1vZHVsZSBpZFxuXHRcdHZhclxuXHRcdFx0dG9rZW5zID0gaWQubWF0Y2goL1tcXD86XXxbXjpcXD9dKi9nKSwgaSA9IDAsXG5cdFx0XHRnZXQgPSBmdW5jdGlvbihza2lwKXtcblx0XHRcdFx0dmFyIHRlcm0gPSB0b2tlbnNbaSsrXTtcblx0XHRcdFx0aWYodGVybSA9PSBcIjpcIil7XG5cdFx0XHRcdFx0Ly8gZW1wdHkgc3RyaW5nIG1vZHVsZSBuYW1lLCByZXNvbHZlcyB0byAwXG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdC8vIHBvc3RmaXhlZCB3aXRoIGEgPyBtZWFucyBpdCBpcyBhIGZlYXR1cmUgdG8gYnJhbmNoIG9uLCB0aGUgdGVybSBpcyB0aGUgbmFtZSBvZiB0aGUgZmVhdHVyZVxuXHRcdFx0XHRcdGlmKHRva2Vuc1tpKytdID09IFwiP1wiKXtcblx0XHRcdFx0XHRcdGlmKCFza2lwICYmIGhhcyh0ZXJtKSl7XG5cdFx0XHRcdFx0XHRcdC8vIG1hdGNoZWQgdGhlIGZlYXR1cmUsIGdldCB0aGUgZmlyc3QgdmFsdWUgZnJvbSB0aGUgb3B0aW9uc1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0KCk7XG5cdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0Ly8gZGlkIG5vdCBtYXRjaCwgZ2V0IHRoZSBzZWNvbmQgdmFsdWUsIHBhc3Npbmcgb3ZlciB0aGUgZmlyc3Rcblx0XHRcdFx0XHRcdFx0Z2V0KHRydWUpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0KHNraXApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBhIG1vZHVsZVxuXHRcdFx0XHRcdHJldHVybiB0ZXJtIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0aWQgPSBnZXQoKTtcblx0XHRyZXR1cm4gaWQgJiYgdG9BYnNNaWQoaWQpO1xuXHR9O1xuXG5cdGhhcy5sb2FkID0gZnVuY3Rpb24oaWQsIHBhcmVudFJlcXVpcmUsIGxvYWRlZCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRDb25kaXRpb25hbCBsb2FkaW5nIG9mIEFNRCBtb2R1bGVzIGJhc2VkIG9uIGEgaGFzIGZlYXR1cmUgdGVzdCB2YWx1ZS5cblx0XHQvLyBpZDogU3RyaW5nXG5cdFx0Ly9cdFx0R2l2ZXMgdGhlIHJlc29sdmVkIG1vZHVsZSBpZCB0byBsb2FkLlxuXHRcdC8vIHBhcmVudFJlcXVpcmU6IEZ1bmN0aW9uXG5cdFx0Ly9cdFx0VGhlIGxvYWRlciByZXF1aXJlIGZ1bmN0aW9uIHdpdGggcmVzcGVjdCB0byB0aGUgbW9kdWxlIHRoYXQgY29udGFpbmVkIHRoZSBwbHVnaW4gcmVzb3VyY2UgaW4gaXQnc1xuXHRcdC8vXHRcdGRlcGVuZGVuY3kgbGlzdC5cblx0XHQvLyBsb2FkZWQ6IEZ1bmN0aW9uXG5cdFx0Ly9cdCBDYWxsYmFjayB0byBsb2FkZXIgdGhhdCBjb25zdW1lcyByZXN1bHQgb2YgcGx1Z2luIGRlbWFuZC5cblxuXHRcdGlmKGlkKXtcblx0XHRcdHBhcmVudFJlcXVpcmUoW2lkXSwgbG9hZGVkKTtcblx0XHR9ZWxzZXtcblx0XHRcdGxvYWRlZCgpO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gaGFzO1xufSk7XG4iLCJkZWZpbmUoW1xuXHRcInJlcXVpcmVcIixcdFx0XHQvLyByZXF1aXJlLCByZXF1aXJlLnRvVXJsXG5cdFwiLi9fYmFzZS9jb25maWdcIiwgLy8gY29uZmlnLmJsYW5rR2lmXG5cdFwiLi9kb20tY2xhc3NcIiwgLy8gZG9tQ2xhc3MuYWRkXG5cdFwiLi9kb20tc3R5bGVcIiwgLy8gZG9tU3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZVxuXHRcIi4vaGFzXCIsXG5cdFwiLi9kb21SZWFkeVwiLFxuXHRcIi4vX2Jhc2Uvd2luZG93XCIgLy8gd2luLmJvZHlcbl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGNvbmZpZywgZG9tQ2xhc3MsIGRvbVN0eWxlLCBoYXMsIGRvbVJlYWR5LCB3aW4pe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9oY2Nzc1xuXG5cdC8qPT09PT1cblx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUZXN0IGlmIGNvbXB1dGVyIGlzIGluIGhpZ2ggY29udHJhc3QgbW9kZSAoaS5lLiBpZiBicm93c2VyIGlzIG5vdCBkaXNwbGF5aW5nIGJhY2tncm91bmQgaW1hZ2VzKS5cblx0XHQvL1x0XHREZWZpbmVzIGBoYXMoXCJoaWdoY29udHJhc3RcIilgIGFuZCBzZXRzIGBkal9hMTF5YCBDU1MgY2xhc3Mgb24gYDxib2R5PmAgaWYgbWFjaGluZSBpcyBpbiBoaWdoIGNvbnRyYXN0IG1vZGUuXG5cdFx0Ly9cdFx0UmV0dXJucyBgaGFzKClgIG1ldGhvZDtcblx0fTtcblx0PT09PT0qL1xuXG5cdC8vIEhhcygpIHRlc3QgZm9yIHdoZW4gYmFja2dyb3VuZCBpbWFnZXMgYXJlbid0IGRpc3BsYXllZC4gIERvbid0IGNhbGwgaGFzKFwiaGlnaGNvbnRyYXN0XCIpIGJlZm9yZSBkb2pvL2RvbVJlYWR5IS5cblx0aGFzLmFkZChcImhpZ2hjb250cmFzdFwiLCBmdW5jdGlvbigpe1xuXHRcdC8vIG5vdGU6IGlmIG11bHRpcGxlIGRvY3VtZW50cywgZG9lc24ndCBtYXR0ZXIgd2hpY2ggb25lIHdlIHVzZVxuXHRcdHZhciBkaXYgPSB3aW4uZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0dHJ5e1xuXHRcdFx0ZGl2LnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjogMXB4IHNvbGlkOyBib3JkZXItY29sb3I6cmVkIGdyZWVuOyBwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogNXB4OyB0b3A6IC05OTlweDtcIiArXG5cdFx0XHRcdFwiYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJcIiArIChjb25maWcuYmxhbmtHaWYgfHwgcmVxdWlyZS50b1VybChcIi4vcmVzb3VyY2VzL2JsYW5rLmdpZlwiKSkgKyBcIlxcXCIpO1wiO1xuXHRcdFx0d2luLmJvZHkoKS5hcHBlbmRDaGlsZChkaXYpO1xuXG5cdFx0XHR2YXIgY3MgPSBkb21TdHlsZS5nZXRDb21wdXRlZFN0eWxlKGRpdiksXG5cdFx0XHRcdGJrSW1nID0gY3MuYmFja2dyb3VuZEltYWdlO1xuXHRcdFx0cmV0dXJuIGNzLmJvcmRlclRvcENvbG9yID09IGNzLmJvcmRlclJpZ2h0Q29sb3IgfHxcblx0XHRcdFx0KGJrSW1nICYmIChia0ltZyA9PSBcIm5vbmVcIiB8fCBia0ltZyA9PSBcInVybChpbnZhbGlkLXVybDopXCIgKSk7XG5cdFx0fWNhdGNoKGUpe1xuXHRcdFx0Y29uc29sZS53YXJuKFwiaGNjc3M6IGV4Y2VwdGlvbiBkZXRlY3RpbmcgaGlnaC1jb250cmFzdCBtb2RlLCBkb2N1bWVudCBpcyBsaWtlbHkgaGlkZGVuOiBcIiArIGUudG9TdHJpbmcoKSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fWZpbmFsbHl7XG5cdFx0XHRpZihoYXMoXCJpZVwiKSA8PSA4KXtcblx0XHRcdFx0ZGl2Lm91dGVySFRNTCA9IFwiXCI7XHRcdC8vIHByZXZlbnQgbWl4ZWQtY29udGVudCB3YXJuaW5nLCBzZWUgaHR0cDovL3N1cHBvcnQubWljcm9zb2Z0LmNvbS9rYi85MjUwMTRcblx0XHRcdH1lbHNle1xuXHRcdFx0XHR3aW4uYm9keSgpLnJlbW92ZUNoaWxkKGRpdik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRkb21SZWFkeShmdW5jdGlvbigpe1xuXHRcdGlmKGhhcyhcImhpZ2hjb250cmFzdFwiKSl7XG5cdFx0XHRkb21DbGFzcy5hZGQod2luLmJvZHkoKSwgXCJkal9hMTF5XCIpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGhhcztcbn0pO1xuIiwiZGVmaW5lKFtcIi4vX2Jhc2Uva2VybmVsXCIsIFwicmVxdWlyZVwiLCBcIi4vaGFzXCIsIFwiLi9fYmFzZS9hcnJheVwiLCBcIi4vX2Jhc2UvY29uZmlnXCIsIFwiLi9fYmFzZS9sYW5nXCIsIFwiLi9oYXMhaG9zdC1icm93c2VyPy4vX2Jhc2UveGhyXCIsIFwiLi9qc29uXCIsIFwibW9kdWxlXCJdLFxuXHRmdW5jdGlvbihkb2pvLCByZXF1aXJlLCBoYXMsIGFycmF5LCBjb25maWcsIGxhbmcsIHhociwganNvbiwgbW9kdWxlKXtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vaTE4blxuXG5cdGhhcy5hZGQoXCJkb2pvLXByZWxvYWQtaTE4bi1BcGlcIixcblx0XHQvLyBpZiB0cnVlLCBkZWZpbmUgdGhlIHByZWxvYWQgbG9jYWxpemF0aW9ucyBtYWNoaW5lcnlcblx0XHQxXG5cdCk7XG5cblx0aGFzLmFkZChcImRvam8tdjF4LWkxOG4tQXBpXCIsXG5cdFx0Ly8gaWYgdHJ1ZSwgZGVmaW5lIHRoZSB2MS54IGkxOG4gZnVuY3Rpb25zXG5cdFx0MVxuXHQpO1xuXG5cdHZhclxuXHRcdHRoaXNNb2R1bGUgPSBkb2pvLmkxOG4gPVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0XHQvL1x0XHRUaGlzIG1vZHVsZSBpbXBsZW1lbnRzIHRoZSBkb2pvL2kxOG4hIHBsdWdpbiBhbmQgdGhlIHYxLjYtIGkxOG4gQVBJXG5cdFx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0XHQvL1x0XHRXZSBjaG9vc2UgdG8gaW5jbHVkZSBvdXIgb3duIHBsdWdpbiB0byBsZXZlcmFnZSBmdW5jdGlvbmFsaXR5IGFscmVhZHkgY29udGFpbmVkIGluIGRvam9cblx0XHRcdFx0Ly9cdFx0YW5kIHRoZXJlYnkgcmVkdWNlIHRoZSBzaXplIG9mIHRoZSBwbHVnaW4gY29tcGFyZWQgdG8gdmFyaW91cyBsb2FkZXIgaW1wbGVtZW50YXRpb25zLiBBbHNvLCB0aGlzXG5cdFx0XHRcdC8vXHRcdGFsbG93cyBmb3JlaWduIEFNRCBsb2FkZXJzIHRvIGJlIHVzZWQgd2l0aG91dCB0aGVpciBwbHVnaW5zLlxuXHRcdFx0fSxcblxuXHRcdG5sc1JlID1cblx0XHRcdC8vIHJlZ2V4cCBmb3IgcmVjb25zdHJ1Y3RpbmcgdGhlIG1hc3RlciBidW5kbGUgbmFtZSBmcm9tIHBhcnRzIG9mIHRoZSByZWdleHAgbWF0Y2hcblx0XHRcdC8vIG5sc1JlLmV4ZWMoXCJmb28vYmFyL2Jhei9ubHMvZW4tY2EvZm9vXCIpIGdpdmVzOlxuXHRcdFx0Ly8gW1wiZm9vL2Jhci9iYXovbmxzL2VuLWNhL2Zvb1wiLCBcImZvby9iYXIvYmF6L25scy9cIiwgXCIvXCIsIFwiL1wiLCBcImVuLWNhXCIsIFwiZm9vXCJdXG5cdFx0XHQvLyBubHNSZS5leGVjKFwiZm9vL2Jhci9iYXovbmxzL2Zvb1wiKSBnaXZlczpcblx0XHRcdC8vIFtcImZvby9iYXIvYmF6L25scy9mb29cIiwgXCJmb28vYmFyL2Jhei9ubHMvXCIsIFwiL1wiLCBcIi9cIiwgXCJmb29cIiwgXCJcIl1cblx0XHRcdC8vIHNvLCBpZiBtYXRjaFs1XSBpcyBibGFuaywgaXQgbWVhbnMgdGhpcyBpcyB0aGUgdG9wIGJ1bmRsZSBkZWZpbml0aW9uLlxuXHRcdFx0Ly8gY291cnRlc3kgb2YgaHR0cDovL3JlcXVpcmVqcy5vcmdcblx0XHRcdC8oXi4qKF58XFwvKW5scykoXFwvfCQpKFteXFwvXSopXFwvPyhbXlxcL10qKS8sXG5cblx0XHRnZXRBdmFpbGFibGVMb2NhbGVzID0gZnVuY3Rpb24oXG5cdFx0XHRyb290LFxuXHRcdFx0bG9jYWxlLFxuXHRcdFx0YnVuZGxlUGF0aCxcblx0XHRcdGJ1bmRsZU5hbWVcblx0XHQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdHJldHVybiBhIHZlY3RvciBvZiBtb2R1bGUgaWRzIGNvbnRhaW5pbmcgYWxsIGF2YWlsYWJsZSBsb2NhbGVzIHdpdGggcmVzcGVjdCB0byB0aGUgdGFyZ2V0IGxvY2FsZVxuXHRcdFx0Ly9cdFx0Rm9yIGV4YW1wbGUsIGFzc3VtaW5nOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdC0gdGhlIHJvb3QgYnVuZGxlIGluZGljYXRlcyBzcGVjaWZpYyBidW5kbGVzIGZvciBcImZyXCIgYW5kIFwiZnItY2FcIixcblx0XHRcdC8vXHRcdC0gIGJ1bmRsZVBhdGggaXMgXCJteVBhY2thZ2UvbmxzXCJcblx0XHRcdC8vXHRcdC0gYnVuZGxlTmFtZSBpcyBcIm15QnVuZGxlXCJcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRUaGVuIGEgbG9jYWxlIGFyZ3VtZW50IG9mIFwiZnItY2FcIiB3b3VsZCByZXR1cm5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRcdFtcIm15UGFja2FnZS9ubHMvbXlCdW5kbGVcIiwgXCJteVBhY2thZ2UvbmxzL2ZyL215QnVuZGxlXCIsIFwibXlQYWNrYWdlL25scy9mci1jYS9teUJ1bmRsZVwiXVxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdE5vdGljZSB0aGF0IGJ1bmRsZXMgYXJlIHJldHVybmVkIGxlYXN0LXNwZWNpZmljIHRvIG1vc3Qtc3BlY2lmaWMsIHN0YXJ0aW5nIHdpdGggdGhlIHJvb3QuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0SWYgcm9vdD09PWZhbHNlIGluZGljYXRlcyB3ZSdyZSB3b3JraW5nIHdpdGggYSBwcmUtQU1EIGkxOG4gYnVuZGxlIHRoYXQgZG9lc24ndCB0ZWxsIGFib3V0IHRoZSBhdmFpbGFibGUgbG9jYWxlcztcblx0XHRcdC8vXHRcdHRoZXJlZm9yZSwgYXNzdW1lIGV2ZXJ5dGhpbmcgaXMgYXZhaWxhYmxlIGFuZCBnZXQgNDA0IGVycm9ycyB0aGF0IGluZGljYXRlIGEgcGFydGljdWxhciBsb2NhbGl6YXRpb24gaXMgbm90IGF2YWlsYWJsZVxuXG5cdFx0XHRmb3IodmFyIHJlc3VsdCA9IFtidW5kbGVQYXRoICsgYnVuZGxlTmFtZV0sIGxvY2FsZVBhcnRzID0gbG9jYWxlLnNwbGl0KFwiLVwiKSwgY3VycmVudCA9IFwiXCIsIGkgPSAwOyBpPGxvY2FsZVBhcnRzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0Y3VycmVudCArPSAoY3VycmVudCA/IFwiLVwiIDogXCJcIikgKyBsb2NhbGVQYXJ0c1tpXTtcblx0XHRcdFx0aWYoIXJvb3QgfHwgcm9vdFtjdXJyZW50XSl7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goYnVuZGxlUGF0aCArIGN1cnJlbnQgKyBcIi9cIiArIGJ1bmRsZU5hbWUpO1xuXHRcdFx0XHRcdHJlc3VsdC5zcGVjaWZpY2l0eSA9IGN1cnJlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdGNhY2hlID0ge30sXG5cblx0XHRnZXRCdW5kbGVOYW1lID0gZnVuY3Rpb24obW9kdWxlTmFtZSwgYnVuZGxlTmFtZSwgbG9jYWxlKXtcblx0XHRcdGxvY2FsZSA9IGxvY2FsZSA/IGxvY2FsZS50b0xvd2VyQ2FzZSgpIDogZG9qby5sb2NhbGU7XG5cdFx0XHRtb2R1bGVOYW1lID0gbW9kdWxlTmFtZS5yZXBsYWNlKC9cXC4vZywgXCIvXCIpO1xuXHRcdFx0YnVuZGxlTmFtZSA9IGJ1bmRsZU5hbWUucmVwbGFjZSgvXFwuL2csIFwiL1wiKTtcblx0XHRcdHJldHVybiAoL3Jvb3QvaS50ZXN0KGxvY2FsZSkpID9cblx0XHRcdFx0KG1vZHVsZU5hbWUgKyBcIi9ubHMvXCIgKyBidW5kbGVOYW1lKSA6XG5cdFx0XHRcdChtb2R1bGVOYW1lICsgXCIvbmxzL1wiICsgbG9jYWxlICsgXCIvXCIgKyBidW5kbGVOYW1lKTtcblx0XHR9LFxuXG5cdFx0Z2V0TDEwbk5hbWUgPSBkb2pvLmdldEwxMG5OYW1lID0gZnVuY3Rpb24obW9kdWxlTmFtZSwgYnVuZGxlTmFtZSwgbG9jYWxlKXtcblx0XHRcdHJldHVybiBtb2R1bGVOYW1lID0gbW9kdWxlLmlkICsgXCIhXCIgKyBnZXRCdW5kbGVOYW1lKG1vZHVsZU5hbWUsIGJ1bmRsZU5hbWUsIGxvY2FsZSk7XG5cdFx0fSxcblxuXHRcdGRvTG9hZCA9IGZ1bmN0aW9uKHJlcXVpcmUsIGJ1bmRsZVBhdGhBbmROYW1lLCBidW5kbGVQYXRoLCBidW5kbGVOYW1lLCBsb2NhbGUsIGxvYWQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdGdldCB0aGUgcm9vdCBidW5kbGUgd2hpY2ggaW5zdHJ1Y3RzIHdoaWNoIG90aGVyIGJ1bmRsZXMgYXJlIHJlcXVpcmVkIHRvIGNvbnN0cnVjdCB0aGUgbG9jYWxpemVkIGJ1bmRsZVxuXHRcdFx0cmVxdWlyZShbYnVuZGxlUGF0aEFuZE5hbWVdLCBmdW5jdGlvbihyb290KXtcblx0XHRcdFx0dmFyIGN1cnJlbnQgPSBsYW5nLmNsb25lKHJvb3Qucm9vdCB8fCByb290LlJPT1QpLC8vIDEuNiBidWlsdCBidW5kbGUgZGVmaW5lZCBST09UXG5cdFx0XHRcdFx0YXZhaWxhYmxlTG9jYWxlcyA9IGdldEF2YWlsYWJsZUxvY2FsZXMoIXJvb3QuX3YxeCAmJiByb290LCBsb2NhbGUsIGJ1bmRsZVBhdGgsIGJ1bmRsZU5hbWUpO1xuXHRcdFx0XHRyZXF1aXJlKGF2YWlsYWJsZUxvY2FsZXMsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDE7IGk8YXZhaWxhYmxlTG9jYWxlcy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0XHRjdXJyZW50ID0gbGFuZy5taXhpbihsYW5nLmNsb25lKGN1cnJlbnQpLCBhcmd1bWVudHNbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyB0YXJnZXQgbWF5IG5vdCBoYXZlIGJlZW4gcmVzb2x2ZSAoZS5nLiwgbWF5YmUgb25seSBcImZyXCIgZXhpc3RzIHdoZW4gXCJmci1jYVwiIHdhcyByZXF1ZXN0ZWQpXG5cdFx0XHRcdFx0dmFyIHRhcmdldCA9IGJ1bmRsZVBhdGhBbmROYW1lICsgXCIvXCIgKyBsb2NhbGU7XG5cdFx0XHRcdFx0Y2FjaGVbdGFyZ2V0XSA9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0Y3VycmVudC4kbG9jYWxlID0gYXZhaWxhYmxlTG9jYWxlcy5zcGVjaWZpY2l0eTtcblx0XHRcdFx0XHRsb2FkKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdG5vcm1hbGl6ZSA9IGZ1bmN0aW9uKGlkLCB0b0Fic01pZCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0aWQgbWF5IGJlIHJlbGF0aXZlLlxuXHRcdFx0Ly9cdFx0cHJlbG9hZCBoYXMgZm9ybSBgKnByZWxvYWQqPHBhdGg+L25scy88bW9kdWxlPio8ZmxhdHRlbmVkIGxvY2FsZXM+YCBhbmRcblx0XHRcdC8vXHRcdHRoZXJlZm9yZSBuZXZlciBsb29rcyBsaWtlIGEgcmVsYXRpdmVcblx0XHRcdHJldHVybiAvXlxcLi8udGVzdChpZCkgPyB0b0Fic01pZChpZCkgOiBpZDtcblx0XHR9LFxuXG5cdFx0Z2V0TG9jYWxlc1RvTG9hZCA9IGZ1bmN0aW9uKHRhcmdldExvY2FsZSl7XG5cdFx0XHR2YXIgbGlzdCA9IGNvbmZpZy5leHRyYUxvY2FsZSB8fCBbXTtcblx0XHRcdGxpc3QgPSBsYW5nLmlzQXJyYXkobGlzdCkgPyBsaXN0IDogW2xpc3RdO1xuXHRcdFx0bGlzdC5wdXNoKHRhcmdldExvY2FsZSk7XG5cdFx0XHRyZXR1cm4gbGlzdDtcblx0XHR9LFxuXG5cdFx0bG9hZCA9IGZ1bmN0aW9uKGlkLCByZXF1aXJlLCBsb2FkKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRpZCBpcyBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0MS4gPHBhdGg+L25scy88YnVuZGxlPlxuXHRcdFx0Ly9cdFx0XHQ9PiBsb2FkIHRoZSBidW5kbGUsIGxvY2FsaXplZCB0byBjb25maWcubG9jYWxlOyBsb2FkIGFsbCBidW5kbGVzIGxvY2FsaXplZCB0b1xuXHRcdFx0Ly9cdFx0XHRjb25maWcuZXh0cmFMb2NhbGUgKGlmIGFueSk7IHJldHVybiB0aGUgbG9hZGVkIGJ1bmRsZSBsb2NhbGl6ZWQgdG8gY29uZmlnLmxvY2FsZS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHQyLiA8cGF0aD4vbmxzLzxsb2NhbGU+LzxidW5kbGU+XG5cdFx0XHQvL1x0XHRcdD0+IGxvYWQgdGhlbiByZXR1cm4gdGhlIGJ1bmRsZSBsb2NhbGl6ZWQgdG8gPGxvY2FsZT5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHQzLiAqcHJlbG9hZCo8cGF0aD4vbmxzLzxtb2R1bGU+KjxKU09OIGFycmF5IG9mIGF2YWlsYWJsZSBsb2NhbGVzPlxuXHRcdFx0Ly9cdFx0XHQ9PiBmb3IgY29uZmlnLmxvY2FsZSBhbmQgYWxsIGNvbmZpZy5leHRyYUxvY2FsZSwgbG9hZCBhbGwgYnVuZGxlcyBmb3VuZFxuXHRcdFx0Ly9cdFx0XHRpbiB0aGUgYmVzdC1tYXRjaGluZyBidW5kbGUgcm9sbHVwLiBBIHZhbHVlIG9mIDEgaXMgcmV0dXJuZWQsIHdoaWNoXG5cdFx0XHQvL1x0XHRcdGlzIG1lYW5pbmdsZXNzIG90aGVyIHRoYW4gdG8gc2F5IHRoZSBwbHVnaW4gaXMgZXhlY3V0aW5nIHRoZSByZXF1ZXN0ZWRcblx0XHRcdC8vXHRcdFx0cHJlbG9hZHNcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRJbiBjYXNlcyAxIGFuZCAyLCA8cGF0aD4gaXMgYWx3YXlzIG5vcm1hbGl6ZWQgdG8gYW4gYWJzb2x1dGUgbW9kdWxlIGlkIHVwb24gZW50cnk7IHNlZVxuXHRcdFx0Ly9cdFx0bm9ybWFsaXplLiBJbiBjYXNlIDMsIGl0IDxwYXRoPiBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlOyB0aGlzIGlzIGFycmFuZ2VkIGJ5IHRoZSBidWlsZGVyLlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdFRvIGxvYWQgYSBidW5kbGUgbWVhbnMgdG8gaW5zZXJ0IHRoZSBidW5kbGUgaW50byB0aGUgcGx1Z2luJ3MgY2FjaGUgYW5kIHB1Ymxpc2ggdGhlIGJ1bmRsZVxuXHRcdFx0Ly9cdFx0dmFsdWUgdG8gdGhlIGxvYWRlci4gR2l2ZW4gPHBhdGg+LCA8YnVuZGxlPiwgYW5kIGEgcGFydGljdWxhciA8bG9jYWxlPiwgdGhlIGNhY2hlIGtleVxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdFx0PHBhdGg+L25scy88YnVuZGxlPi88bG9jYWxlPlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdHdpbGwgaG9sZCB0aGUgdmFsdWUuIFNpbWlsYXJseSwgdGhlbiBwbHVnaW4gd2lsbCBwdWJsaXNoIHRoaXMgdmFsdWUgdG8gdGhlIGxvYWRlciBieVxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdFx0ZGVmaW5lKFwiPHBhdGg+L25scy88YnVuZGxlPi88bG9jYWxlPlwiLCA8YnVuZGxlLXZhbHVlPik7XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0R2l2ZW4gdGhpcyBhbGdvcml0aG0sIG90aGVyIG1hY2hpbmVyeSBjYW4gcHJvdmlkZSBmYXN0IGxvYWQgcGF0aHMgYmUgcHJlcGxhY2luZ1xuXHRcdFx0Ly9cdFx0dmFsdWVzIGluIHRoZSBwbHVnaW4ncyBjYWNoZSwgd2hpY2ggaXMgcHVibGljLiBXaGVuIGEgbG9hZCBpcyBkZW1hbmRlZCB0aGVcblx0XHRcdC8vXHRcdGNhY2hlIGlzIGluc3BlY3RlZCBiZWZvcmUgc3RhcnRpbmcgYW55IGxvYWRpbmcuIEV4cGxpY2l0bHkgcGxhY2luZyB2YWx1ZXMgaW4gdGhlIHBsdWdpblxuXHRcdFx0Ly9cdFx0Y2FjaGUgaXMgYW4gYWR2YW5jZWQvZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBzaG91bGQgbm90IGJlIG5lZWRlZDsgdXNlIGF0IHlvdXIgb3duIHJpc2suXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Rm9yIHRoZSBub3JtYWwgQU1EIGFsZ29yaXRobSwgdGhlIHJvb3QgYnVuZGxlIGlzIGxvYWRlZCBmaXJzdCwgd2hpY2ggaW5zdHJ1Y3RzIHRoZVxuXHRcdFx0Ly9cdFx0cGx1Z2luIHdoYXQgYWRkaXRpb25hbCBsb2NhbGl6ZWQgYnVuZGxlcyBhcmUgcmVxdWlyZWQgZm9yIGEgcGFydGljdWxhciBsb2NhbGUuIFRoZXNlXG5cdFx0XHQvL1x0XHRhZGRpdGlvbmFsIGxvY2FsZXMgYXJlIGxvYWRlZCBhbmQgYSBtaXggb2YgdGhlIHJvb3QgYW5kIGVhY2ggcHJvZ3Jlc3NpdmVseS1zcGVjaWZpY1xuXHRcdFx0Ly9cdFx0bG9jYWxlIGlzIHJldHVybmVkLiBGb3IgZXhhbXBsZTpcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHQxLiBUaGUgY2xpZW50IGRlbWFuZHMgXCJkb2pvL2kxOG4hc29tZS9wYXRoL25scy9zb21lQnVuZGxlXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Mi4gVGhlIGxvYWRlciBkZW1hbmRzIGxvYWQoc29tZS9wYXRoL25scy9zb21lQnVuZGxlKVxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdDMuIFRoaXMgcGx1Z2luIHJlcXVpcmUncyBcInNvbWUvcGF0aC9ubHMvc29tZUJ1bmRsZVwiLCB3aGljaCBpcyB0aGUgcm9vdCBidW5kbGUuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0NC4gQXNzdW1pbmcgY29uZmlnLmxvY2FsZSBpcyBcImFiLWNkLWVmXCIgYW5kIHRoZSByb290IGJ1bmRsZSBpbmRpY2F0ZXMgdGhhdCBsb2NhbGl6YXRpb25zXG5cdFx0XHQvL1x0XHRhcmUgYXZhaWxhYmxlIGZvciBcImFiXCIgYW5kIFwiYWItY2QtZWZcIiAobm90ZSB0aGUgbWlzc2luZyBcImFiLWNkXCIsIHRoZW4gdGhlIHBsdWdpblxuXHRcdFx0Ly9cdFx0cmVxdWlyZXMgXCJzb21lL3BhdGgvbmxzL2FiL3NvbWVCdW5kbGVcIiBhbmQgXCJzb21lL3BhdGgvbmxzL2FiLWNkLWVmL3NvbWVCdW5kbGVcIlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdDUuIFVwb24gcmVjZWl2aW5nIGFsbCByZXF1aXJlZCBidW5kbGVzLCB0aGUgcGx1Z2luIGNvbnN0cnVjdHMgdGhlIHZhbHVlIG9mIHRoZSBidW5kbGVcblx0XHRcdC8vXHRcdGFiLWNkLWVmIGFzLi4uXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0XHRcdG1peGluKG1peGluKG1peGluKHt9LCByZXF1aXJlKFwic29tZS9wYXRoL25scy9zb21lQnVuZGxlXCIpLFxuXHRcdFx0Ly9cdFx0ICBcdFx0XHRyZXF1aXJlKFwic29tZS9wYXRoL25scy9hYi9zb21lQnVuZGxlXCIpKSxcblx0XHRcdC8vXHRcdFx0XHRcdHJlcXVpcmUoXCJzb21lL3BhdGgvbmxzL2FiLWNkLWVmL3NvbWVCdW5kbGVcIikpO1xuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdFRoaXMgdmFsdWUgaXMgaW5zZXJ0ZWQgaW50byB0aGUgY2FjaGUgYW5kIHB1Ymxpc2hlZCB0byB0aGUgbG9hZGVyIGF0IHRoZVxuXHRcdFx0Ly9cdFx0a2V5L21vZHVsZS1pZCBzb21lL3BhdGgvbmxzL3NvbWVCdW5kbGUvYWItY2QtZWYuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VGhlIHNwZWNpYWwgcHJlbG9hZCBzaWduYXR1cmUgKGNhc2UgMykgaW5zdHJ1Y3RzIHRoZSBwbHVnaW4gdG8gc3RvcCBzZXJ2aWNpbmcgYWxsIG5vcm1hbCByZXF1ZXN0c1xuXHRcdFx0Ly9cdFx0KGZ1cnRoZXIgcHJlbG9hZCByZXF1ZXN0cyB3aWxsIGJlIHNlcnZpY2VkKSB1bnRpbCBhbGwgb25nb2luZyBwcmVsb2FkaW5nIGhhcyBjb21wbGV0ZWQuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VGhlIHByZWxvYWQgc2lnbmF0dXJlIGluc3RydWN0cyB0aGUgcGx1Z2luIHRoYXQgYSBzcGVjaWFsIHJvbGx1cCBtb2R1bGUgaXMgYXZhaWxhYmxlIHRoYXQgY29udGFpbnNcblx0XHRcdC8vXHRcdG9uZSBvciBtb3JlIGZsYXR0ZW5lZCwgbG9jYWxpemVkIGJ1bmRsZXMuIFRoZSBKU09OIGFycmF5IG9mIGF2YWlsYWJsZSBsb2NhbGVzIGluZGljYXRlcyB3aGljaCBsb2NhbGVzXG5cdFx0XHQvL1x0XHRhcmUgYXZhaWxhYmxlLiBIZXJlIGlzIGFuIGV4YW1wbGU6XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0XHQqcHJlbG9hZCpzb21lL3BhdGgvbmxzL3NvbWVNb2R1bGUqW1wicm9vdFwiLCBcImFiXCIsIFwiYWItY2QtZWZcIl1cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRUaGlzIGluZGljYXRlcyB0aGUgZm9sbG93aW5nIHJvbGx1cCBtb2R1bGVzIGFyZSBhdmFpbGFibGU6XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0XHRzb21lL3BhdGgvbmxzL3NvbWVNb2R1bGVfUk9PVFxuXHRcdFx0Ly9cdFx0XHRzb21lL3BhdGgvbmxzL3NvbWVNb2R1bGVfYWJcblx0XHRcdC8vXHRcdFx0c29tZS9wYXRoL25scy9zb21lTW9kdWxlX2FiLWNkLWVmXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0RWFjaCBvZiB0aGVzZSBtb2R1bGVzIGlzIGEgbm9ybWFsIEFNRCBtb2R1bGUgdGhhdCBjb250YWlucyBvbmUgb3IgbW9yZSBmbGF0dGVuZWQgYnVuZGxlcyBpbiBhIGhhc2guXG5cdFx0XHQvL1x0XHRGb3IgZXhhbXBsZSwgYXNzdW1lIHNvbWVNb2R1bGUgY29udGFpbmVkIHRoZSBidW5kbGVzIHNvbWUvYnVuZGxlL3BhdGgvc29tZUJ1bmRsZSBhbmRcblx0XHRcdC8vXHRcdHNvbWUvYnVuZGxlL3BhdGgvc29tZU90aGVyQnVuZGxlLCB0aGVuIHNvbWUvcGF0aC9ubHMvc29tZU1vZHVsZV9hYiB3b3VsZCBiZSBleHByZXNzZWQgYXMgZm9sbG93czpcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRcdGRlZmluZSh7XG5cdFx0XHQvL1x0XHRcdFx0c29tZS9idW5kbGUvcGF0aC9zb21lQnVuZGxlOjx2YWx1ZSBvZiBzb21lQnVuZGxlLCBmbGF0dGVuZWQgd2l0aCByZXNwZWN0IHRvIGxvY2FsZSBhYj4sXG5cdFx0XHQvL1x0XHRcdFx0c29tZS9idW5kbGUvcGF0aC9zb21lT3RoZXJCdW5kbGU6PHZhbHVlIG9mIHNvbWVPdGhlckJ1bmRsZSwgZmxhdHRlbmVkIHdpdGggcmVzcGVjdCB0byBsb2NhbGUgYWI+LFxuXHRcdFx0Ly9cdFx0XHR9KTtcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRFLmcuLCBnaXZlbiB0aGlzIGRlc2lnbiwgcHJlbG9hZGluZyBmb3IgbG9jYWxlPT1cImFiXCIgY2FuIGV4ZWN1dGUgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0XHRyZXF1aXJlKFtcInNvbWUvcGF0aC9ubHMvc29tZU1vZHVsZV9hYlwiXSwgZnVuY3Rpb24ocm9sbHVwKXtcblx0XHRcdC8vXHRcdFx0XHRmb3IodmFyIHAgaW4gcm9sbHVwKXtcblx0XHRcdC8vXHRcdFx0XHRcdHZhciBpZCA9IHAgKyBcIi9hYlwiLFxuXHRcdFx0Ly9cdFx0XHRcdFx0Y2FjaGVbaWRdID0gcm9sbHVwW3BdO1xuXHRcdFx0Ly9cdFx0XHRcdFx0ZGVmaW5lKGlkLCByb2xsdXBbcF0pO1xuXHRcdFx0Ly9cdFx0XHRcdH1cblx0XHRcdC8vXHRcdFx0fSk7XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0U2ltaWxhcmx5LCBpZiBcImFiLWNkXCIgaXMgcmVxdWVzdGVkLCB0aGUgYWxnb3JpdGhtIGNhbiBkZXRlcm1pbmUgdGhhdCBcImFiXCIgaXMgdGhlIGJlc3QgYXZhaWxhYmxlIGFuZFxuXHRcdFx0Ly9cdFx0bG9hZCBhY2NvcmRpbmdseS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRUaGUgYnVpbGRlciB3aWxsIHdyaXRlIHN1Y2ggcm9sbHVwcyBmb3IgZXZlcnkgbGF5ZXIgaWYgYSBub24tZW1wdHkgbG9jYWxlTGlzdCAgcHJvZmlsZSBwcm9wZXJ0eSBpc1xuXHRcdFx0Ly9cdFx0cHJvdmlkZWQuIEZ1cnRoZXIsIHRoZSBidWlsZGVyIHdpbGwgaW5jbHVkZSB0aGUgZm9sbG93aW5nIGNhY2hlIGVudHJ5IGluIHRoZSBjYWNoZSBhc3NvY2lhdGVkIHdpdGhcblx0XHRcdC8vXHRcdGFueSBsYXllci5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRcdFwiKm5vd1wiOmZ1bmN0aW9uKHIpe3IoWydkb2pvL2kxOG4hKnByZWxvYWQqPHBhdGg+L25scy88bW9kdWxlPio8SlNPTiBhcnJheSBvZiBhdmFpbGFibGUgbG9jYWxlcz4nXSk7fVxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdFRoZSAqbm93IHNwZWNpYWwgY2FjaGUgbW9kdWxlIGluc3RydWN0cyB0aGUgbG9hZGVyIHRvIGFwcGx5IHRoZSBwcm92aWRlZCBmdW5jdGlvbiB0byBjb250ZXh0LXJlcXVpcmVcblx0XHRcdC8vXHRcdHdpdGggcmVzcGVjdCB0byB0aGUgcGFydGljdWxhciBsYXllciBiZWluZyBkZWZpbmVkLiBUaGlzIGNhdXNlcyB0aGUgcGx1Z2luIHRvIGhvbGQgYWxsIG5vcm1hbCBzZXJ2aWNlXG5cdFx0XHQvL1x0XHRyZXF1ZXN0cyB1bnRpbCBhbGwgcHJlbG9hZGluZyBpcyBjb21wbGV0ZS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHROb3RpY2UgdGhhdCB0aGlzIGFsZ29yaXRobSBpcyByYXJlbHkgYmV0dGVyIHRoYW4gdGhlIHN0YW5kYXJkIEFNRCBsb2FkIGFsZ29yaXRobS4gQ29uc2lkZXIgdGhlIG5vcm1hbCBjYXNlXG5cdFx0XHQvL1x0XHR3aGVyZSB0aGUgdGFyZ2V0IGxvY2FsZSBoYXMgYSBzaW5nbGUgc2VnbWVudCBhbmQgYSBsYXllciBkZXBlbmRzIG9uIGEgc2luZ2xlIGJ1bmRsZTpcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRXaXRob3V0IFByZWxvYWRzOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdDEuIExheWVyIGxvYWRzIHJvb3QgYnVuZGxlLlxuXHRcdFx0Ly9cdFx0Mi4gYnVuZGxlIGlzIGRlbWFuZGVkOyBwbHVnaW4gbG9hZHMgc2luZ2xlIGxvY2FsaXplZCBidW5kbGUuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0V2l0aCBQcmVsb2Fkczpcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHQxLiBMYXllciBjYXVzZXMgcHJlbG9hZGluZyBvZiB0YXJnZXQgYnVuZGxlLlxuXHRcdFx0Ly9cdFx0Mi4gYnVuZGxlIGlzIGRlbWFuZGVkOyBzZXJ2aWNlIGlzIGRlbGF5ZWQgdW50aWwgcHJlbG9hZGluZyBjb21wbGV0ZTsgYnVuZGxlIGlzIHJldHVybmVkLlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdEluIGVhY2ggY2FzZSBhIHNpbmdsZSB0cmFuc2FjdGlvbiBpcyByZXF1aXJlZCB0byBsb2FkIHRoZSB0YXJnZXQgYnVuZGxlLiBJbiBjYXNlcyB3aGVyZSBtdWx0aXBsZSBidW5kbGVzXG5cdFx0XHQvL1x0XHRhcmUgcmVxdWlyZWQgYW5kL29yIHRoZSBsb2NhbGUgaGFzIG11bHRpcGxlIHNlZ21lbnRzLCBwcmVsb2FkcyBzdGlsbCByZXF1aXJlcyBhIHNpbmdsZSB0cmFuc2FjdGlvbiB3aGVyZWFzXG5cdFx0XHQvL1x0XHR0aGUgbm9ybWFsIHBhdGggcmVxdWlyZXMgYW4gYWRkaXRpb25hbCB0cmFuc2FjdGlvbiBmb3IgZWFjaCBhZGRpdGlvbmFsIGJ1bmRsZS9sb2NhbGUtc2VnbWVudC4gSG93ZXZlciBhbGxcblx0XHRcdC8vXHRcdG9mIHRoZXNlIGFkZGl0aW9uYWwgdHJhbnNhY3Rpb25zIGNhbiBiZSBkb25lIGNvbmN1cnJlbnRseS4gT3dpbmcgdG8gdGhpcyBhbmFseXNpcywgdGhlIGVudGlyZSBwcmVsb2FkaW5nXG5cdFx0XHQvL1x0XHRhbGdvcml0aG0gY2FuIGJlIGRpc2NhcmQgZHVyaW5nIGEgYnVpbGQgYnkgc2V0dGluZyB0aGUgaGFzIGZlYXR1cmUgZG9qby1wcmVsb2FkLWkxOG4tQXBpIHRvIGZhbHNlLlxuXG5cdFx0XHR2YXIgbWF0Y2ggPSBubHNSZS5leGVjKGlkKSxcblx0XHRcdFx0YnVuZGxlUGF0aCA9IG1hdGNoWzFdICsgXCIvXCIsXG5cdFx0XHRcdGJ1bmRsZU5hbWUgPSBtYXRjaFs1XSB8fCBtYXRjaFs0XSxcblx0XHRcdFx0YnVuZGxlUGF0aEFuZE5hbWUgPSBidW5kbGVQYXRoICsgYnVuZGxlTmFtZSxcblx0XHRcdFx0bG9jYWxlU3BlY2lmaWVkID0gKG1hdGNoWzVdICYmIG1hdGNoWzRdKSxcblx0XHRcdFx0dGFyZ2V0TG9jYWxlID1cdGxvY2FsZVNwZWNpZmllZCB8fCBkb2pvLmxvY2FsZSB8fCBcIlwiLFxuXHRcdFx0XHRsb2FkVGFyZ2V0ID0gYnVuZGxlUGF0aEFuZE5hbWUgKyBcIi9cIiArIHRhcmdldExvY2FsZSxcblx0XHRcdFx0bG9hZExpc3QgPSBsb2NhbGVTcGVjaWZpZWQgPyBbdGFyZ2V0TG9jYWxlXSA6IGdldExvY2FsZXNUb0xvYWQodGFyZ2V0TG9jYWxlKSxcblx0XHRcdFx0cmVtYWluaW5nID0gbG9hZExpc3QubGVuZ3RoLFxuXHRcdFx0XHRmaW5pc2ggPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmKCEtLXJlbWFpbmluZyl7XG5cdFx0XHRcdFx0XHRsb2FkKGxhbmcuZGVsZWdhdGUoY2FjaGVbbG9hZFRhcmdldF0pKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNwbGl0ID0gaWQuc3BsaXQoXCIqXCIpLFxuXHRcdFx0XHRwcmVsb2FkRGVtYW5kID0gc3BsaXRbMV0gPT0gXCJwcmVsb2FkXCI7XG5cblx0XHRcdGlmKGhhcyhcImRvam8tcHJlbG9hZC1pMThuLUFwaVwiKSl7XG5cdFx0XHRcdGlmKHByZWxvYWREZW1hbmQpe1xuXHRcdFx0XHRcdGlmKCFjYWNoZVtpZF0pe1xuXHRcdFx0XHRcdFx0Ly8gdXNlIGNhY2hlW2lkXSB0byBwcmV2ZW50IG11bHRpcGxlIHByZWxvYWRzIG9mIHRoZSBzYW1lIHByZWxvYWQ7IHRoaXMgc2hvdWxkbid0IGhhcHBlbiwgYnV0XG5cdFx0XHRcdFx0XHQvLyB3aG8ga25vd3Mgd2hhdCBvdmVyLWFnZ3Jlc3NpdmUgaHVtYW4gb3B0aW1pemVycyBtYXkgYXR0ZW1wdFxuXHRcdFx0XHRcdFx0Y2FjaGVbaWRdID0gMTtcblx0XHRcdFx0XHRcdHByZWxvYWRMMTBuKHNwbGl0WzJdLCBqc29uLnBhcnNlKHNwbGl0WzNdKSwgMSwgcmVxdWlyZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGRvbid0IHN0YWxsIHRoZSBsb2FkZXIhXG5cdFx0XHRcdFx0bG9hZCgxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihwcmVsb2FkRGVtYW5kIHx8ICh3YWl0Rm9yUHJlbG9hZHMoaWQsIHJlcXVpcmUsIGxvYWQpICYmICFjYWNoZVtsb2FkVGFyZ2V0XSkpe1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAocHJlbG9hZERlbWFuZCkge1xuXHRcdFx0XHQvLyBJZiBhIGJ1aWxkIGlzIGNyZWF0ZWQgd2l0aCBubHMgcmVzb3VyY2VzIGFuZCAnZG9qby1wcmVsb2FkLWkxOG4tQXBpJyBoYXMgbm90IGJlZW4gc2V0IHRvIGZhbHNlLFxuXHRcdFx0XHQvLyB0aGUgYnVpbHQgZmlsZSB3aWxsIGluY2x1ZGUgYSBwcmVsb2FkIGluIHRoZSBjYWNoZSAod2hpY2ggbG9va3MgYWJvdXQgbGlrZSBzbzopXG5cdFx0XHRcdC8vICcqbm93JzpmdW5jdGlvbihyKXtyKFsnZG9qby9pMThuISpwcmVsb2FkKmRvam8vbmxzL2Rvam8qW1wiYXJcIixcImNhXCIsXCJjc1wiLFwiZGFcIixcImRlXCIsXCJlbFwiLFwiZW4tZ2JcIixcImVuLXVzXCIsXCJlcy1lc1wiLFwiZmktZmlcIixcImZyLWZyXCIsXCJoZS1pbFwiLFwiaHVcIixcIml0LWl0XCIsXCJqYS1qcFwiLFwia28ta3JcIixcIm5sLW5sXCIsXCJuYlwiLFwicGxcIixcInB0LWJyXCIsXCJwdC1wdFwiLFwicnVcIixcInNrXCIsXCJzbFwiLFwic3ZcIixcInRoXCIsXCJ0clwiLFwiemgtdHdcIixcInpoLWNuXCIsXCJST09UXCJdJ10pO31cblx0XHRcdFx0Ly8gSWYgdGhlIGNvbnN1bWVyIG9mIHRoZSBidWlsZCBzZXRzICdkb2pvLXByZWxvYWQtaTE4bi1BcGknIHRvIGZhbHNlIGluIHRoZSBEb2pvIGNvbmZpZywgdGhlIGNhY2hlZFxuXHRcdFx0XHQvLyBwcmVsb2FkIHdpbGwgbm90IGJlIHBhcnNlZCBhbmQgd2lsbCByZXN1bHQgaW4gYW4gYXR0ZW1wdCB0byBjYWxsICdyZXF1aXJlJyBwYXNzaW5nIGl0IHRoZSB1bnBhcnNlZFxuXHRcdFx0XHQvLyBwcmVsb2FkLCB3aGljaCBpcyBub3QgYSB2YWxpZCBtb2R1bGUgaWQuXG5cdFx0XHRcdC8vIEluIHRoaXMgY2FzZSB3ZSBzaG91bGQgc2tpcCB0aGlzIHJlcXVlc3QuXG5cdFx0XHRcdGxvYWQoMSk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRhcnJheS5mb3JFYWNoKGxvYWRMaXN0LCBmdW5jdGlvbihsb2NhbGUpe1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gYnVuZGxlUGF0aEFuZE5hbWUgKyBcIi9cIiArIGxvY2FsZTtcblx0XHRcdFx0aWYoaGFzKFwiZG9qby1wcmVsb2FkLWkxOG4tQXBpXCIpKXtcblx0XHRcdFx0XHRjaGVja0ZvckxlZ2FjeU1vZHVsZXModGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighY2FjaGVbdGFyZ2V0XSl7XG5cdFx0XHRcdFx0ZG9Mb2FkKHJlcXVpcmUsIGJ1bmRsZVBhdGhBbmROYW1lLCBidW5kbGVQYXRoLCBidW5kbGVOYW1lLCBsb2NhbGUsIGZpbmlzaCk7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGZpbmlzaCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdGlmKGhhcyhcImRvam8tcHJlbG9hZC1pMThuLUFwaVwiKSB8fCBoYXMoXCJkb2pvLXYxeC1pMThuLUFwaVwiKSl7XG5cdFx0dmFyIG5vcm1hbGl6ZUxvY2FsZSA9IHRoaXNNb2R1bGUubm9ybWFsaXplTG9jYWxlID0gZnVuY3Rpb24obG9jYWxlKXtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IGxvY2FsZSA/IGxvY2FsZS50b0xvd2VyQ2FzZSgpIDogZG9qby5sb2NhbGU7XG5cdFx0XHRcdHJldHVybiByZXN1bHQgPT0gXCJyb290XCIgPyBcIlJPT1RcIiA6IHJlc3VsdDtcblx0XHRcdH0sXG5cblx0XHRcdGlzWGQgPSBmdW5jdGlvbihtaWQsIGNvbnRleHRSZXF1aXJlKXtcblx0XHRcdFx0cmV0dXJuIChoYXMoXCJkb2pvLXN5bmMtbG9hZGVyXCIpICYmIGhhcyhcImRvam8tdjF4LWkxOG4tQXBpXCIpKSA/XG5cdFx0XHRcdFx0Y29udGV4dFJlcXVpcmUuaXNYZFVybChyZXF1aXJlLnRvVXJsKG1pZCArIFwiLmpzXCIpKSA6XG5cdFx0XHRcdFx0dHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdHByZWxvYWRpbmcgPSAwLFxuXG5cdFx0XHRwcmVsb2FkV2FpdFF1ZXVlID0gW10sXG5cblx0XHRcdHByZWxvYWRMMTBuID0gdGhpc01vZHVsZS5fcHJlbG9hZExvY2FsaXphdGlvbnMgPSBmdW5jdGlvbigvKlN0cmluZyovYnVuZGxlUHJlZml4LCAvKkFycmF5Ki9sb2NhbGVzR2VuZXJhdGVkLCAvKmJvb2xlYW4/Ki8gZ3VhcmFudGVlZEFtZEZvcm1hdCwgLypmdW5jdGlvbj8qLyBjb250ZXh0UmVxdWlyZSl7XG5cdFx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHRcdC8vXHRcdExvYWQgYXZhaWxhYmxlIGZsYXR0ZW5lZCByZXNvdXJjZSBidW5kbGVzIGFzc29jaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgbW9kdWxlIGZvciBkb2pvL2xvY2FsZSBhbmQgYWxsIGRvam8vY29uZmlnLmV4dHJhTG9jYWxlIChpZiBhbnkpXG5cdFx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0XHQvL1x0XHRPbmx5IGNhbGxlZCBieSBidWlsdCBsYXllciBmaWxlcy4gVGhlIGVudGlyZSBsb2NhbGUgaGllcmFyY2h5IGlzIGxvYWRlZC4gRm9yIGV4YW1wbGUsXG5cdFx0XHRcdC8vXHRcdGlmIGxvY2FsZT09XCJhYi1jZFwiLCB0aGVuIFJPT1QsIFwiYWJcIiwgYW5kIFwiYWItY2RcIiBhcmUgbG9hZGVkLiBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIHYxLjYtXG5cdFx0XHRcdC8vXHRcdGluIHRoYXQgdGhlIHYxLjYtIHdvdWxkIG9ubHkgbG9hZCBhYi1jZC4uLndoaWNoIHdhcyAqYWx3YXlzKiBmbGF0dGVuZWQuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vXHRcdElmIGd1YXJhbnRlZWRBbWRGb3JtYXQgaXMgdHJ1ZSwgdGhlbiB0aGUgbW9kdWxlIGNhbiBiZSBsb2FkZWQgd2l0aCByZXF1aXJlIHRoZXJlYnkgY2lyY3VtdmVudGluZyB0aGUgZGV0ZWN0aW9uIGFsZ29yaXRobVxuXHRcdFx0XHQvL1x0XHRhbmQgdGhlIGV4dHJhIHBvc3NpYmxlIGV4dHJhIHRyYW5zYWN0aW9uLlxuXG5cdFx0XHRcdC8vIElmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGZyb20gbGVnYWN5IGNvZGUsIHRoZW4gZ3VhcmFudGVlZEFtZEZvcm1hdCBhbmQgY29udGV4dFJlcXVpcmUgd2lsbCBiZSB1bmRlZmluZWQuIFNpbmNlIHRoZSBmdW5jdGlvblxuXHRcdFx0XHQvLyBuZWVkcyBhIHJlcXVpcmUgaW4gb3JkZXIgdG8gcmVzb2x2ZSBtb2R1bGUgaWRzLCBmYWxsIGJhY2sgdG8gdGhlIGNvbnRleHQtcmVxdWlyZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBkb2pvL2kxOG4gbW9kdWxlLCB3aGljaFxuXHRcdFx0XHQvLyBpdHNlbGYgbWF5IGhhdmUgYmVlbiBtYXBwZWQuXG5cdFx0XHRcdGNvbnRleHRSZXF1aXJlID0gY29udGV4dFJlcXVpcmUgfHwgcmVxdWlyZTtcblxuXHRcdFx0XHRmdW5jdGlvbiBkb1JlcXVpcmUobWlkLCBjYWxsYmFjayl7XG5cdFx0XHRcdFx0aWYoaXNYZChtaWQsIGNvbnRleHRSZXF1aXJlKSB8fCBndWFyYW50ZWVkQW1kRm9ybWF0KXtcblx0XHRcdFx0XHRcdGNvbnRleHRSZXF1aXJlKFttaWRdLCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRzeW5jUmVxdWlyZShbbWlkXSwgY2FsbGJhY2ssIGNvbnRleHRSZXF1aXJlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiBmb3JFYWNoTG9jYWxlKGxvY2FsZSwgZnVuYyl7XG5cdFx0XHRcdFx0Ly8gZ2l2ZW4gbG9jYWxlPSBcImFiLWNkLWVmXCIsIGNhbGxzIGZ1bmMgb24gXCJhYi1jZC1lZlwiLCBcImFiLWNkXCIsIFwiYWJcIiwgXCJST09UXCI7IHN0b3BzIGNhbGxpbmcgdGhlIGZpcnN0IHRpbWUgZnVuYyByZXR1cm5zIHRydXRoeVxuXHRcdFx0XHRcdHZhciBwYXJ0cyA9IGxvY2FsZS5zcGxpdChcIi1cIik7XG5cdFx0XHRcdFx0d2hpbGUocGFydHMubGVuZ3RoKXtcblx0XHRcdFx0XHRcdGlmKGZ1bmMocGFydHMuam9pbihcIi1cIikpKXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFydHMucG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZ1bmMoXCJST09UXCIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmdW5jdGlvbiBwcmVsb2FkaW5nQWRkTG9jaygpe1xuXHRcdFx0XHRcdFx0cHJlbG9hZGluZysrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZ1bmN0aW9uIHByZWxvYWRpbmdSZWxMb2NrKCl7XG5cdFx0XHRcdFx0XHQtLXByZWxvYWRpbmc7XG5cdFx0XHRcdFx0XHR3aGlsZSghcHJlbG9hZGluZyAmJiBwcmVsb2FkV2FpdFF1ZXVlLmxlbmd0aCl7XG5cdFx0XHRcdFx0XHRcdGxvYWQuYXBwbHkobnVsbCwgcHJlbG9hZFdhaXRRdWV1ZS5zaGlmdCgpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmdW5jdGlvbiBjYWNoZUlkKHBhdGgsIG5hbWUsIGxvYywgcmVxdWlyZSl7XG5cdFx0XHRcdFx0XHQvLyBwYXRoIGlzIGFzc3VtZWQgdG8gaGF2ZSBhIHRyYWlsaW5nIFwiL1wiXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVxdWlyZS50b0Fic01pZChwYXRoICsgbmFtZSArIFwiL1wiICsgbG9jKVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZ1bmN0aW9uIHByZWxvYWQobG9jYWxlKXtcblx0XHRcdFx0XHRcdGxvY2FsZSA9IG5vcm1hbGl6ZUxvY2FsZShsb2NhbGUpO1xuXHRcdFx0XHRcdFx0Zm9yRWFjaExvY2FsZShsb2NhbGUsIGZ1bmN0aW9uKGxvYyl7XG5cdFx0XHRcdFx0XHRcdGlmKGFycmF5LmluZGV4T2YobG9jYWxlc0dlbmVyYXRlZCwgbG9jKSA+PSAwKXtcblx0XHRcdFx0XHRcdFx0XHR2YXIgbWlkID0gYnVuZGxlUHJlZml4LnJlcGxhY2UoL1xcLi9nLCBcIi9cIikgKyBcIl9cIiArIGxvYztcblx0XHRcdFx0XHRcdFx0XHRwcmVsb2FkaW5nQWRkTG9jaygpO1xuXHRcdFx0XHRcdFx0XHRcdGRvUmVxdWlyZShtaWQsIGZ1bmN0aW9uKHJvbGx1cCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IodmFyIHAgaW4gcm9sbHVwKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGJ1bmRsZSA9IHJvbGx1cFtwXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXRjaCA9IHAubWF0Y2goLyguKylcXC8oW15cXC9dKykkLyksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnVuZGxlTmFtZSwgYnVuZGxlUGF0aDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBubyBtYXRjaCwgdGhlIGJ1bmRsZSBpcyBub3QgYSByZWd1bGFyIGJ1bmRsZSBmcm9tIGFuIEFNRCBsYXllci5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIW1hdGNoKXtjb250aW51ZTt9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRidW5kbGVOYW1lID0gbWF0Y2hbMl07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnVuZGxlUGF0aCA9IG1hdGNoWzFdICsgXCIvXCI7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYmFja2NvbXBhdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZighYnVuZGxlLl9sb2NhbGl6ZWQpe2NvbnRpbnVlO31cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgbG9jYWxpemVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihsb2MgPT09IFwiUk9PVFwiKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgcm9vdCA9IGxvY2FsaXplZCA9IGJ1bmRsZS5fbG9jYWxpemVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSBidW5kbGUuX2xvY2FsaXplZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyb290LnJvb3QgPSBidW5kbGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FjaGVbcmVxdWlyZS50b0Fic01pZChwKV0gPSByb290O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsb2NhbGl6ZWQgPSBidW5kbGUuX2xvY2FsaXplZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYWNoZVtjYWNoZUlkKGJ1bmRsZVBhdGgsIGJ1bmRsZU5hbWUsIGxvYywgcmVxdWlyZSldID0gYnVuZGxlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYobG9jICE9PSBsb2NhbGUpe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGNhcHR1cmUgc29tZSBsb2NhbGUgdmFyaWFibGVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24gaW1wcm92ZUJ1bmRsZShidW5kbGVQYXRoLCBidW5kbGVOYW1lLCBidW5kbGUsIGxvY2FsaXplZCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBsb2NhbGUgd2FzIG5vdCBmbGF0dGVuZWQgYW5kIHdlJ3ZlIGZhbGxlbiBiYWNrIHRvIGEgbGVzcy1zcGVjaWZpYyBsb2NhbGUgdGhhdCB3YXMgZmxhdHRlbmVkXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBmb3IgZXhhbXBsZSwgd2UgaGFkIGEgZmxhdHRlbmVkICdmcicsIGEgJ2ZyLWNhJyBpcyBhdmFpbGFibGUgZm9yIGF0IGxlYXN0IHRoaXMgYnVuZGxlLCBhbmRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGxvY2FsZT09PSdmci1jYSc7IHRoZXJlZm9yZSwgd2UgbXVzdCBpbXByb3ZlIHRoZSBidW5kbGUgYXMgcmV0cmlldmVkIGZyb20gdGhlIHJvbGx1cCBieVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gbWFudWFsbHkgbG9hZGluZyB0aGUgZnItY2EgdmVyc2lvbiBvZiB0aGUgYnVuZGxlIGFuZCBtaXhpbmcgdGhpcyBpbnRvIHRoZSBhbHJlYWR5LXJldHJpZXZlZCAnZnInXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyB2ZXJzaW9uIG9mIHRoZSBidW5kbGUuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmVtZW1iZXIsIGRpZmZlcmVudCBidW5kbGVzIG1heSBoYXZlIGRpZmZlcmVudCBzZXRzIG9mIGxvY2FsZXMgYXZhaWxhYmxlLlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHdlIGFyZSByZWFsbHkgZmFsbGluZyBiYWNrIG9uIHRoZSByZWd1bGFyIGFsZ29yaXRobSBoZXJlLCBidXQtLWhvcGVmdWxseS0tc3RhcnRpbmcgd2l0aCBtb3N0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBvZiB0aGUgcmVxdWlyZWQgYnVuZGxlcyBhbHJlYWR5IG9uIGJvYXJkIGFzIGdpdmVuIGJ5IHRoZSByb2xsdXAgYW5kIHdlIG5lZWQgdG8gXCJtYW51YWxseVwiIGxvYWRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIG9ubHkgb25lIGxvY2FsZSBmcm9tIGEgZmV3IGJ1bmRsZXMuLi5vciBldmVuIGJldHRlci4uLndlIHdvbid0IGZpbmQgYW55dGhpbmcgYmV0dGVyIHRvIGxvYWQuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGlzIGFsZ29yaXRobSBlbnN1cmVzIHRoZXJlIGlzIG5vdGhpbmcgYmV0dGVyIHRvIGxvYWQgZXZlbiB3aGVuIHdlIGNhbiBvbmx5IGxvYWQgYSBsZXNzLXNwZWNpZmljIHJvbGx1cC5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBub3RlOiB0aGlzIGZlYXR1cmUgaXMgb25seSBhdmFpbGFibGUgaW4gYXN5bmMgbW9kZVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBpbnNwZWN0IHRoZSBsb2FkZWQgYnVuZGxlIHRoYXQgY2FtZSBmcm9tIHRoZSByb2xsdXAgdG8gc2VlIGlmIHNvbWV0aGluZyBiZXR0ZXIgaXMgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBmb3IgYW55IGJ1bmRsZSBpbiBhIHJvbGx1cCwgbW9yZS1zcGVjaWZpYyBhdmFpbGFibGUgbG9jYWxlcyBhcmUgZ2l2ZW4gYXQgbG9jYWxpemVkLlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJlcXVpcmVkQnVuZGxlcyA9IFtdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYWNoZUlkcyA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yRWFjaExvY2FsZShsb2NhbGUsIGZ1bmN0aW9uKGxvYyl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmKGxvY2FsaXplZFtsb2NdKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1aXJlZEJ1bmRsZXMucHVzaChyZXF1aXJlLnRvQWJzTWlkKGJ1bmRsZVBhdGggKyBsb2MgKyBcIi9cIiArIGJ1bmRsZU5hbWUpKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYWNoZUlkcy5wdXNoKGNhY2hlSWQoYnVuZGxlUGF0aCwgYnVuZGxlTmFtZSwgbG9jLCByZXF1aXJlKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZihyZXF1aXJlZEJ1bmRsZXMubGVuZ3RoKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJlbG9hZGluZ0FkZExvY2soKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udGV4dFJlcXVpcmUocmVxdWlyZWRCdW5kbGVzLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHJlcXVpcmVkQnVuZGxlcyB3YXMgY29uc3RydWN0ZWQgYnkgZm9yRWFjaExvY2FsZSBzbyBpdCBjb250YWlucyBsb2NhbGVzIGZyb20gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gbGVzcyBzcGVjaWZpYyB0byBtb3N0IHNwZWNpZmljLiBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyB0aGUgbG9vcCBzdGFydHMgd2l0aCB0aGUgbW9zdCBzcGVjaWZpYyBsb2NhbGUsIHRoZSBsYXN0IG9uZS5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IodmFyIGkgPSByZXF1aXJlZEJ1bmRsZXMubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJ1bmRsZSA9IGxhbmcubWl4aW4obGFuZy5jbG9uZShidW5kbGUpLCBhcmd1bWVudHNbaV0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FjaGVbY2FjaGVJZHNbaV1dID0gYnVuZGxlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzIGlzIHRoZSBiZXN0IHBvc3NpYmxlIChtYXliZSBhIHBlcmZlY3QgbWF0Y2gsIG1heWJlIG5vdCksIGFjY2VwdCBpdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhY2hlW2NhY2hlSWQoYnVuZGxlUGF0aCwgYnVuZGxlTmFtZSwgbG9jYWxlLCByZXF1aXJlKV0gPSBsYW5nLmNsb25lKGJ1bmRsZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJlbG9hZGluZ1JlbExvY2soKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBpcyB0aGUgYmVzdCBwb3NzaWJsZSAoZGVmaW5pdGVseSBub3QgYSBwZXJmZWN0IG1hdGNoKSwgYWNjZXB0IGl0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhY2hlW2NhY2hlSWQoYnVuZGxlUGF0aCwgYnVuZGxlTmFtZSwgbG9jYWxlLCByZXF1aXJlKV0gPSBidW5kbGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGltcHJvdmVCdW5kbGUoYnVuZGxlUGF0aCwgYnVuZGxlTmFtZSwgYnVuZGxlLCBsb2NhbGl6ZWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRwcmVsb2FkaW5nUmVsTG9jaygpO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRwcmVsb2FkKCk7XG5cdFx0XHRcdGFycmF5LmZvckVhY2goZG9qby5jb25maWcuZXh0cmFMb2NhbGUsIHByZWxvYWQpO1xuXHRcdFx0fSxcblxuXHRcdFx0d2FpdEZvclByZWxvYWRzID0gZnVuY3Rpb24oaWQsIHJlcXVpcmUsIGxvYWQpe1xuXHRcdFx0XHRpZihwcmVsb2FkaW5nKXtcblx0XHRcdFx0XHRwcmVsb2FkV2FpdFF1ZXVlLnB1c2goW2lkLCByZXF1aXJlLCBsb2FkXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHByZWxvYWRpbmc7XG5cdFx0XHR9LFxuXG5cdFx0XHRjaGVja0ZvckxlZ2FjeU1vZHVsZXMgPSBmdW5jdGlvbigpXG5cdFx0XHRcdHt9O1xuXHR9XG5cblx0aWYoaGFzKFwiZG9qby12MXgtaTE4bi1BcGlcIikpe1xuXHRcdC8vIHRoaXMgY29kZSBwYXRoIGFzc3VtZXMgdGhlIGRvam8gbG9hZGVyIGFuZCB3b24ndCB3b3JrIHdpdGggYSBzdGFuZGFyZCBBTUQgbG9hZGVyXG5cdFx0dmFyIGFtZFZhbHVlID0ge30sXG5cdFx0XHRsMTBuQ2FjaGUgPSB7fSxcblx0XHRcdGV2YWxCdW5kbGUsXG5cblx0XHRcdHN5bmNSZXF1aXJlID0gZnVuY3Rpb24oZGVwcywgY2FsbGJhY2ssIHJlcXVpcmUpe1xuXHRcdFx0XHR2YXIgcmVzdWx0cyA9IFtdO1xuXHRcdFx0XHRhcnJheS5mb3JFYWNoKGRlcHMsIGZ1bmN0aW9uKG1pZCl7XG5cdFx0XHRcdFx0dmFyIHVybCA9IHJlcXVpcmUudG9VcmwobWlkICsgXCIuanNcIik7XG5cblx0XHRcdFx0XHRmdW5jdGlvbiBsb2FkKHRleHQpe1xuXHRcdFx0XHRcdFx0aWYgKCFldmFsQnVuZGxlKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVzZSB0aGUgZnVuY3Rpb24gY3RvciB0byBrZWVwIHRoZSBtaW5pZmllcnMgYXdheSAoYWxzbyBjb21lIGNsb3NlIHRvIGdsb2JhbCBzY29wZSwgYnV0IHRoaXMgaXMgc2Vjb25kYXJ5KVxuXHRcdFx0XHRcdFx0XHRldmFsQnVuZGxlID0gbmV3IEZ1bmN0aW9uKFxuXHRcdFx0XHRcdFx0XHRcdFwiX19idW5kbGVcIixcdFx0XHRcdCAgIC8vIHRoZSBidW5kbGUgdG8gZXZhbHV0YXRlXG5cdFx0XHRcdFx0XHRcdFx0XCJfX2NoZWNrRm9yTGVnYWN5TW9kdWxlc1wiLCAvLyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIF9fYnVuZGxlIGRlZmluZWQgX19taWQgaW4gdGhlIGdsb2JhbCBzcGFjZVxuXHRcdFx0XHRcdFx0XHRcdFwiX19taWRcIixcdFx0XHRcdCAgIC8vIHRoZSBtaWQgdGhhdCBfX2J1bmRsZSBpcyBpbnRlbmRlZCB0byBkZWZpbmVcblx0XHRcdFx0XHRcdFx0XHRcIl9fYW1kVmFsdWVcIixcblxuXHRcdFx0XHRcdFx0XHRcdC8vIHJldHVybnMgb25lIG9mOlxuXHRcdFx0XHRcdFx0XHRcdC8vXHRcdDEgPT4gdGhlIGJ1bmRsZSB3YXMgYW4gQU1EIGJ1bmRsZVxuXHRcdFx0XHRcdFx0XHRcdC8vXHRcdGEgbGVnYWN5IGJ1bmRsZSBvYmplY3QgdGhhdCBpcyB0aGUgdmFsdWUgb2YgX19taWRcblx0XHRcdFx0XHRcdFx0XHQvL1x0XHRpbnN0YW5jZSBvZiBFcnJvciA9PiBjb3VsZCBub3QgZmlndXJlIG91dCBob3cgdG8gZXZhbHVhdGUgYnVuZGxlXG5cblx0XHRcdFx0XHRcdFx0XHQvLyB1c2VkIHRvIGRldGVjdCB3aGVuIF9fYnVuZGxlIGNhbGxzIGRlZmluZVxuXHRcdFx0XHRcdFx0XHRcdFwidmFyIGRlZmluZSA9IGZ1bmN0aW9uKG1pZCwgZmFjdG9yeSl7ZGVmaW5lLmNhbGxlZCA9IDE7IF9fYW1kVmFsdWUucmVzdWx0ID0gZmFjdG9yeSB8fCBtaWQ7fSxcIlxuXHRcdFx0XHRcdFx0XHRcdCsgXCJcdCAgIHJlcXVpcmUgPSBmdW5jdGlvbigpe2RlZmluZS5jYWxsZWQgPSAxO307XCJcblxuXHRcdFx0XHRcdFx0XHRcdCsgXCJ0cnl7XCJcblx0XHRcdFx0XHRcdFx0XHQrXHRcdFwiZGVmaW5lLmNhbGxlZCA9IDA7XCJcblx0XHRcdFx0XHRcdFx0XHQrXHRcdFwiZXZhbChfX2J1bmRsZSk7XCJcblx0XHRcdFx0XHRcdFx0XHQrXHRcdFwiaWYoZGVmaW5lLmNhbGxlZD09MSlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGJ1bmRsZSBjYWxsZWQgZGVmaW5lOyB0aGVyZWZvcmUgc2lnbmFsIGl0J3MgYW4gQU1EIGJ1bmRsZVxuXHRcdFx0XHRcdFx0XHRcdCtcdFx0XHRcInJldHVybiBfX2FtZFZhbHVlO1wiXG5cblx0XHRcdFx0XHRcdFx0XHQrXHRcdFwiaWYoKF9fY2hlY2tGb3JMZWdhY3lNb2R1bGVzID0gX19jaGVja0ZvckxlZ2FjeU1vZHVsZXMoX19taWQpKSlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGJ1bmRsZSB3YXMgcHJvYmFibHkgYSB2MS42LSBidWlsdCBOTFMgZmxhdHRlbmVkIE5MUyBidW5kbGUgdGhhdCBkZWZpbmVkIF9fbWlkIGluIHRoZSBnbG9iYWwgc3BhY2Vcblx0XHRcdFx0XHRcdFx0XHQrXHRcdFx0XCJyZXR1cm4gX19jaGVja0ZvckxlZ2FjeU1vZHVsZXM7XCJcblxuXHRcdFx0XHRcdFx0XHRcdCsgXCJ9Y2F0Y2goZSl7fVwiXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXZhdWxhdGluZyB0aGUgYnVuZGxlIHdhcyAqbmVpdGhlciogYW4gQU1EICpub3IqIGEgbGVnYWN5IGZsYXR0ZW5lZCBidW5kbGVcblx0XHRcdFx0XHRcdFx0XHQvLyBlaXRoZXIgd2F5LCByZS1ldmFsICphZnRlciogc3Vycm91bmRpbmcgd2l0aCBwYXJlbnRoZXNlc1xuXG5cdFx0XHRcdFx0XHRcdFx0KyBcInRyeXtcIlxuXHRcdFx0XHRcdFx0XHRcdCtcdFx0XCJyZXR1cm4gZXZhbCgnKCcrX19idW5kbGUrJyknKTtcIlxuXHRcdFx0XHRcdFx0XHRcdCsgXCJ9Y2F0Y2goZSl7XCJcblx0XHRcdFx0XHRcdFx0XHQrXHRcdFwicmV0dXJuIGU7XCJcblx0XHRcdFx0XHRcdFx0XHQrIFwifVwiXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gZXZhbEJ1bmRsZSh0ZXh0LCBjaGVja0ZvckxlZ2FjeU1vZHVsZXMsIG1pZCwgYW1kVmFsdWUpO1xuXHRcdFx0XHRcdFx0aWYocmVzdWx0PT09YW1kVmFsdWUpe1xuXHRcdFx0XHRcdFx0XHQvLyB0aGUgYnVuZGxlIHdhcyBhbiBBTUQgbW9kdWxlOyByZS1pbmplY3QgaXQgdGhyb3VnaCB0aGUgbm9ybWFsIEFNRCBwYXRoXG5cdFx0XHRcdFx0XHRcdC8vIHdlIGdvdHRhIGRvIHRoaXMgc2luY2UgaXQgY291bGQgYmUgYW4gYW5vbnltb3VzIG1vZHVsZSBhbmQgc2ltcGx5IGV2YWx1YXRpbmdcblx0XHRcdFx0XHRcdFx0Ly8gdGhlIHRleHQgaGVyZSB3b24ndCBwcm92aWRlIHRoZSBsb2FkZXIgd2l0aCB0aGUgY29udGV4dCB0byBrbm93IHdoYXRcblx0XHRcdFx0XHRcdFx0Ly8gbW9kdWxlIGlzIGJlaW5nIGRlZmluZWQoKSdkLiBXaXRoIGJyb3dzZXIgY2FjaGluZywgdGhpcyBzaG91bGQgYmUgZnJlZTsgZnVydGhlclxuXHRcdFx0XHRcdFx0XHQvLyB0aGlzIGVudGlyZSBjb2RlIHBhdGggY2FuIGJlIGNpcmN1bXZlbnRlZCBieSB1c2luZyB0aGUgQU1EIGZvcm1hdCB0byBiZWdpbiB3aXRoXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaChjYWNoZVt1cmxdID0gYW1kVmFsdWUucmVzdWx0KTtcblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRpZihyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcil7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcImZhaWxlZCB0byBldmFsdWF0ZSBpMThuIGJ1bmRsZTsgdXJsPVwiICsgdXJsLCByZXN1bHQpO1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIG5scy88bG9jYWxlPi88YnVuZGxlLW5hbWU+IGluZGljYXRlcyBub3QgdGhlIHJvb3QuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaChjYWNoZVt1cmxdID0gKC9ubHNcXC9bXlxcL10rXFwvW15cXC9dKyQvLnRlc3QodXJsKSA/IHJlc3VsdCA6IHtyb290OnJlc3VsdCwgX3YxeDoxfSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmKGNhY2hlW3VybF0pe1xuXHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKGNhY2hlW3VybF0pO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0dmFyIGJ1bmRsZSA9IHJlcXVpcmUuc3luY0xvYWRObHMobWlkKTtcblx0XHRcdFx0XHRcdC8vIG5lZWQgdG8gY2hlY2sgZm9yIGxlZ2FjeSBtb2R1bGUgaGVyZSBiZWNhdXNlIHRoZXJlIG1pZ2h0IGJlIGEgbGVnYWN5IG1vZHVsZSBmb3IgYVxuXHRcdFx0XHRcdFx0Ly8gbGVzcyBzcGVjaWZpYyBsb2NhbGUgKHdoaWNoIHdhcyBub3QgbG9va2VkIHVwIGR1cmluZyB0aGUgZmlyc3QgY2hlY2tGb3JMZWdhY3lNb2R1bGVzXG5cdFx0XHRcdFx0XHQvLyBjYWxsIGluIGxvYWQoKSkuXG5cdFx0XHRcdFx0XHQvLyBBbHNvIG5lZWQgdG8gcmV2ZXJzZSB0aGUgbG9jYWxlIGFuZCB0aGUgbW9kdWxlIG5hbWUgaW4gdGhlIG1pZCBiZWNhdXNlIHN5bmNSZXF1aXJlXG5cdFx0XHRcdFx0XHQvLyBkZXBzIHBhcmFtZXRlcnMgdXNlcyB0aGUgQU1EIHN0eWxlIHBhY2thZ2UvbmxzL2xvY2FsZS9tb2R1bGUgd2hpbGUgbGVnYWN5IGNvZGUgdXNlc1xuXHRcdFx0XHRcdFx0Ly8gcGFja2FnZS9ubHMvbW9kdWxlL2xvY2FsZS5cblx0XHRcdFx0XHRcdGlmKCFidW5kbGUpe1xuXHRcdFx0XHRcdFx0XHRidW5kbGUgPSBjaGVja0ZvckxlZ2FjeU1vZHVsZXMobWlkLnJlcGxhY2UoL25sc1xcLyhbXlxcL10qKVxcLyhbXlxcL10qKSQvLCBcIm5scy8kMi8kMVwiKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihidW5kbGUpe1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goYnVuZGxlKTtcblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRpZigheGhyKXtcblx0XHRcdFx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXF1aXJlLmdldFRleHQodXJsLCB0cnVlLCBsb2FkKTtcblx0XHRcdFx0XHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goY2FjaGVbdXJsXSA9IHt9KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRcdHhoci5nZXQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0dXJsOnVybCxcblx0XHRcdFx0XHRcdFx0XHRcdHN5bmM6dHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdGxvYWQ6bG9hZCxcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOmZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaChjYWNoZVt1cmxdID0ge30pO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y2FsbGJhY2sgJiYgY2FsbGJhY2suYXBwbHkobnVsbCwgcmVzdWx0cyk7XG5cdFx0XHR9O1xuXG5cdFx0Y2hlY2tGb3JMZWdhY3lNb2R1bGVzID0gZnVuY3Rpb24odGFyZ2V0KXtcblx0XHRcdC8vIGxlZ2FjeSBjb2RlIG1heSBoYXZlIGFscmVhZHkgbG9hZGVkIFtlLmddIHRoZSByYXcgYnVuZGxlIHgveS96IGF0IHgueS56OyB3aGVuIHRydWUsIHB1c2ggaW50byB0aGUgY2FjaGVcblx0XHRcdGZvcih2YXIgcmVzdWx0LCBuYW1lcyA9IHRhcmdldC5zcGxpdChcIi9cIiksIG9iamVjdCA9IGRvam8uZ2xvYmFsW25hbWVzWzBdXSwgaSA9IDE7IG9iamVjdCAmJiBpPG5hbWVzLmxlbmd0aC0xOyBvYmplY3QgPSBvYmplY3RbbmFtZXNbaSsrXV0pe31cblx0XHRcdGlmKG9iamVjdCl7XG5cdFx0XHRcdHJlc3VsdCA9IG9iamVjdFtuYW1lc1tpXV07XG5cdFx0XHRcdGlmKCFyZXN1bHQpe1xuXHRcdFx0XHRcdC8vIGZhbGxiYWNrIGZvciBpbmNvcnJlY3QgYnVuZGxlIGJ1aWxkIG9mIDEuNlxuXHRcdFx0XHRcdHJlc3VsdCA9IG9iamVjdFtuYW1lc1tpXS5yZXBsYWNlKC8tL2csXCJfXCIpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihyZXN1bHQpe1xuXHRcdFx0XHRcdGNhY2hlW3RhcmdldF0gPSByZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblxuXHRcdHRoaXNNb2R1bGUuZ2V0TG9jYWxpemF0aW9uID0gZnVuY3Rpb24obW9kdWxlTmFtZSwgYnVuZGxlTmFtZSwgbG9jYWxlKXtcblx0XHRcdHZhciByZXN1bHQsXG5cdFx0XHRcdGwxMG5OYW1lID0gZ2V0QnVuZGxlTmFtZShtb2R1bGVOYW1lLCBidW5kbGVOYW1lLCBsb2NhbGUpO1xuXG5cdFx0XHRpZiAobDEwbkNhY2hlW2wxMG5OYW1lXSkge1xuXHRcdFx0XHRyZXR1cm4gbDEwbkNhY2hlW2wxMG5OYW1lXTtcblx0XHRcdH1cblxuXHRcdFx0bG9hZChcblx0XHRcdFx0bDEwbk5hbWUsXG5cblx0XHRcdFx0Ly8gaXNYZCgpIGFuZCBzeW5jUmVxdWlyZSgpIG5lZWQgYSBjb250ZXh0LXJlcXVpcmUgaW4gb3JkZXIgdG8gcmVzb2x2ZSB0aGUgbWlkIHdpdGggcmVzcGVjdCB0byBhIHJlZmVyZW5jZSBtb2R1bGUuXG5cdFx0XHRcdC8vIFNpbmNlIHRoaXMgbGVnYWN5IGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgdGhlIGNvbmNlcHQgb2YgYSByZWZlcmVuY2UgbW9kdWxlLCByZXNvbHZlIHdpdGggcmVzcGVjdCB0byB0aGlzXG5cdFx0XHRcdC8vIGRvam8vaTE4biBtb2R1bGUsIHdoaWNoLCBpdHNlbGYgbWF5IGhhdmUgYmVlbiBtYXBwZWQuXG5cdFx0XHRcdCghaXNYZChsMTBuTmFtZSwgcmVxdWlyZSkgPyBmdW5jdGlvbihkZXBzLCBjYWxsYmFjayl7IHN5bmNSZXF1aXJlKGRlcHMsIGNhbGxiYWNrLCByZXF1aXJlKTsgfSA6IHJlcXVpcmUpLFxuXG5cdFx0XHRcdGZ1bmN0aW9uKHJlc3VsdF8pe1xuXHRcdFx0XHRcdGwxMG5DYWNoZVtsMTBuTmFtZV0gPSByZXN1bHRfO1xuXHRcdFx0XHRcdHJlc3VsdCA9IHJlc3VsdF87XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gbGFuZy5taXhpbih0aGlzTW9kdWxlLCB7XG5cdFx0ZHluYW1pYzp0cnVlLFxuXHRcdG5vcm1hbGl6ZTpub3JtYWxpemUsXG5cdFx0bG9hZDpsb2FkLFxuXHRcdGNhY2hlOmNhY2hlLFxuXHRcdGdldEwxMG5OYW1lOiBnZXRMMTBuTmFtZVxuXHR9KTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vX2Jhc2UvbGFuZ1wiXSwgZnVuY3Rpb24obGFuZyl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL2lvLXF1ZXJ5XG5cblx0dmFyIGJhY2tzdG9wID0ge307XG5cblx0cmV0dXJuIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoaXMgbW9kdWxlIGRlZmluZXMgcXVlcnkgc3RyaW5nIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuXG5cdFx0b2JqZWN0VG9RdWVyeTogZnVuY3Rpb24gb2JqZWN0VG9RdWVyeSgvKk9iamVjdCovIG1hcCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0dGFrZXMgYSBuYW1lL3ZhbHVlIG1hcHBpbmcgb2JqZWN0IGFuZCByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZ1xuXHRcdFx0Ly9cdFx0YSBVUkwtZW5jb2RlZCB2ZXJzaW9uIG9mIHRoYXQgb2JqZWN0LlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdHRoaXMgb2JqZWN0OlxuXHRcdFx0Ly9cblx0XHRcdC8vXHR8XHR7XG5cdFx0XHQvL1x0fFx0XHRibGFoOiBcImJsYWhcIixcblx0XHRcdC8vXHR8XHRcdG11bHRpOiBbXG5cdFx0XHQvL1x0fFx0XHRcdFwidGh1ZFwiLFxuXHRcdFx0Ly9cdHxcdFx0XHRcInRob25rXCJcblx0XHRcdC8vXHR8XHRcdF1cblx0XHRcdC8vXHR8XHR9O1xuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdHlpZWxkcyB0aGUgZm9sbG93aW5nIHF1ZXJ5IHN0cmluZzpcblx0XHRcdC8vXG5cdFx0XHQvL1x0fFx0XCJibGFoPWJsYWgmbXVsdGk9dGh1ZCZtdWx0aT10aG9ua1wiXG5cblx0XHRcdC8vIEZJWE1FOiBuZWVkIHRvIGltcGxlbWVudCBlbmNvZGVBc2NpaSEhXG5cdFx0XHR2YXIgZW5jID0gZW5jb2RlVVJJQ29tcG9uZW50LCBwYWlycyA9IFtdO1xuXHRcdFx0Zm9yKHZhciBuYW1lIGluIG1hcCl7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IG1hcFtuYW1lXTtcblx0XHRcdFx0aWYodmFsdWUgIT0gYmFja3N0b3BbbmFtZV0pe1xuXHRcdFx0XHRcdHZhciBhc3NpZ24gPSBlbmMobmFtZSkgKyBcIj1cIjtcblx0XHRcdFx0XHRpZihsYW5nLmlzQXJyYXkodmFsdWUpKXtcblx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpe1xuXHRcdFx0XHRcdFx0XHRwYWlycy5wdXNoKGFzc2lnbiArIGVuYyh2YWx1ZVtpXSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0cGFpcnMucHVzaChhc3NpZ24gKyBlbmModmFsdWUpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBwYWlycy5qb2luKFwiJlwiKTsgLy8gU3RyaW5nXG5cdFx0fSxcblxuXHRcdHF1ZXJ5VG9PYmplY3Q6IGZ1bmN0aW9uIHF1ZXJ5VG9PYmplY3QoLypTdHJpbmcqLyBzdHIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENyZWF0ZSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZGUtc2VyaWFsaXplZCBxdWVyeSBzZWN0aW9uIG9mIGFcblx0XHRcdC8vXHRcdFVSTC4gUXVlcnkga2V5cyB3aXRoIG11bHRpcGxlIHZhbHVlcyBhcmUgcmV0dXJuZWQgaW4gYW4gYXJyYXkuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdFRoaXMgc3RyaW5nOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHR8XHRcdFwiZm9vPWJhciZmb289YmF6JnRoaW5nZXI9JTIwc3BhY2VzJTIwPWJsYWgmem9uaz1ibGFyZyZcIlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdHJlc3VsdHMgaW4gdGhpcyBvYmplY3Qgc3RydWN0dXJlOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHR8XHRcdHtcblx0XHRcdC8vXHR8XHRcdFx0Zm9vOiBbIFwiYmFyXCIsIFwiYmF6XCIgXSxcblx0XHRcdC8vXHR8XHRcdFx0dGhpbmdlcjogXCIgc3BhY2VzID1ibGFoXCIsXG5cdFx0XHQvL1x0fFx0XHRcdHpvbms6IFwiYmxhcmdcIlxuXHRcdFx0Ly9cdHxcdFx0fVxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdE5vdGUgdGhhdCBzcGFjZXMgYW5kIG90aGVyIHVybGVuY29kZWQgZW50aXRpZXMgYXJlIGNvcnJlY3RseVxuXHRcdFx0Ly9cdFx0aGFuZGxlZC5cblxuICAgICAgICBcdHZhciBkZWMgPSBkZWNvZGVVUklDb21wb25lbnQsIHFwID0gc3RyLnNwbGl0KFwiJlwiKSwgcmV0ID0ge30sIG5hbWUsIHZhbDtcblx0XHRcdGZvcih2YXIgaSA9IDAsIGwgPSBxcC5sZW5ndGgsIGl0ZW07IGkgPCBsOyArK2kpe1xuXHRcdFx0XHRpdGVtID0gcXBbaV07XG5cdFx0XHRcdGlmKGl0ZW0ubGVuZ3RoKXtcblx0XHRcdFx0XHR2YXIgcyA9IGl0ZW0uaW5kZXhPZihcIj1cIik7XG5cdFx0XHRcdFx0aWYocyA8IDApe1xuXHRcdFx0XHRcdFx0bmFtZSA9IGRlYyhpdGVtKTtcblx0XHRcdFx0XHRcdHZhbCA9IFwiXCI7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRuYW1lID0gZGVjKGl0ZW0uc2xpY2UoMCwgcykpO1xuXHRcdFx0XHRcdFx0dmFsID0gZGVjKGl0ZW0uc2xpY2UocyArIDEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYodHlwZW9mIHJldFtuYW1lXSA9PSBcInN0cmluZ1wiKXsgLy8gaW5saW5lJ2QgdHlwZSBjaGVja1xuXHRcdFx0XHRcdFx0cmV0W25hbWVdID0gW3JldFtuYW1lXV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYobGFuZy5pc0FycmF5KHJldFtuYW1lXSkpe1xuXHRcdFx0XHRcdFx0cmV0W25hbWVdLnB1c2godmFsKTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdHJldFtuYW1lXSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7IC8vIE9iamVjdFxuXHRcdH1cblx0fTtcbn0pOyIsImRlZmluZShbXCIuL2hhc1wiXSwgZnVuY3Rpb24oaGFzKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBoYXNKU09OID0gdHlwZW9mIEpTT04gIT0gXCJ1bmRlZmluZWRcIjtcblx0aGFzLmFkZChcImpzb24tcGFyc2VcIiwgaGFzSlNPTik7IC8vIGFsbCB0aGUgcGFyc2VycyB3b3JrIGZpbmVcblx0XHQvLyBGaXJlZm94IDMuNS9HZWNrbyAxLjkgZmFpbHMgdG8gdXNlIHJlcGxhY2VyIGluIHN0cmluZ2lmeSBwcm9wZXJseSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01MDkxODRcblx0aGFzLmFkZChcImpzb24tc3RyaW5naWZ5XCIsIGhhc0pTT04gJiYgSlNPTi5zdHJpbmdpZnkoe2E6MH0sIGZ1bmN0aW9uKGssdil7cmV0dXJuIHZ8fDE7fSkgPT0gJ3tcImFcIjoxfScpO1xuXG5cdC8qPT09PT1cblx0cmV0dXJuIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEZ1bmN0aW9ucyB0byBwYXJzZSBhbmQgc2VyaWFsaXplIEpTT05cblxuXHRcdHBhcnNlOiBmdW5jdGlvbihzdHIsIHN0cmljdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UGFyc2VzIGEgW0pTT05dKGh0dHA6Ly9qc29uLm9yZykgc3RyaW5nIHRvIHJldHVybiBhIEphdmFTY3JpcHQgb2JqZWN0LlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRUaGlzIGZ1bmN0aW9uIGZvbGxvd3MgW25hdGl2ZSBKU09OIEFQSV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSlNPTilcblx0XHRcdC8vXHRcdFRocm93cyBmb3IgaW52YWxpZCBKU09OIHN0cmluZ3MuIFRoaXMgZGVsZWdhdGVzIHRvIGV2YWwoKSBpZiBuYXRpdmUgSlNPTlxuXHRcdFx0Ly9cdFx0c3VwcG9ydCBpcyBub3QgYXZhaWxhYmxlLiBCeSBkZWZhdWx0IHRoaXMgd2lsbCBldmFsdWF0ZSBhbnkgdmFsaWQgSlMgZXhwcmVzc2lvbi5cblx0XHRcdC8vXHRcdFdpdGggdGhlIHN0cmljdCBwYXJhbWV0ZXIgc2V0IHRvIHRydWUsIHRoZSBwYXJzZXIgd2lsbCBlbnN1cmUgdGhhdCBvbmx5XG5cdFx0XHQvL1x0XHR2YWxpZCBKU09OIHN0cmluZ3MgYXJlIHBhcnNlZCAob3RoZXJ3aXNlIHRocm93aW5nIGFuIGVycm9yKS4gV2l0aG91dCB0aGUgc3RyaWN0XG5cdFx0XHQvL1x0XHRwYXJhbWV0ZXIsIHRoZSBjb250ZW50IHBhc3NlZCB0byB0aGlzIG1ldGhvZCBtdXN0IGNvbWVcblx0XHRcdC8vXHRcdGZyb20gYSB0cnVzdGVkIHNvdXJjZS5cblx0XHRcdC8vIHN0cjpcblx0XHRcdC8vXHRcdGEgc3RyaW5nIGxpdGVyYWwgb2YgYSBKU09OIGl0ZW0sIGZvciBpbnN0YW5jZTpcblx0XHRcdC8vXHRcdGAneyBcImZvb1wiOiBbIFwiYmFyXCIsIDEsIHsgXCJiYXpcIjogXCJ0aHVkXCIgfSBdIH0nYFxuXHRcdFx0Ly8gc3RyaWN0OlxuXHRcdFx0Ly9cdFx0V2hlbiBzZXQgdG8gdHJ1ZSwgdGhpcyB3aWxsIGVuc3VyZSB0aGF0IG9ubHkgdmFsaWQsIHNlY3VyZSBKU09OIGlzIGV2ZXIgcGFyc2VkLlxuXHRcdFx0Ly9cdFx0TWFrZSBzdXJlIHRoaXMgaXMgc2V0IHRvIHRydWUgZm9yIHVudHJ1c3RlZCBjb250ZW50LiBOb3RlIHRoYXQgb24gYnJvd3NlcnMvZW5naW5lc1xuXHRcdFx0Ly9cdFx0d2l0aG91dCBuYXRpdmUgSlNPTiBzdXBwb3J0LCBzZXR0aW5nIHRoaXMgdG8gdHJ1ZSB3aWxsIHJ1biBzbG93ZXIuXG5cdFx0fSxcblx0XHRzdHJpbmdpZnk6IGZ1bmN0aW9uKHZhbHVlLCByZXBsYWNlciwgc3BhY2VyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgW0pTT05dKGh0dHA6Ly9qc29uLm9yZykgc2VyaWFsaXphdGlvbiBvZiBhbiBvYmplY3QuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFJldHVybnMgYSBbSlNPTl0oaHR0cDovL2pzb24ub3JnKSBzZXJpYWxpemF0aW9uIG9mIGFuIG9iamVjdC5cblx0XHRcdC8vXHRcdFRoaXMgZnVuY3Rpb24gZm9sbG93cyBbbmF0aXZlIEpTT04gQVBJXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KU09OKVxuXHRcdFx0Ly9cdFx0Tm90ZSB0aGF0IHRoaXMgZG9lc24ndCBjaGVjayBmb3IgaW5maW5pdGUgcmVjdXJzaW9uLCBzbyBkb24ndCBkbyB0aGF0IVxuXHRcdFx0Ly8gdmFsdWU6XG5cdFx0XHQvL1x0XHRBIHZhbHVlIHRvIGJlIHNlcmlhbGl6ZWQuXG5cdFx0XHQvLyByZXBsYWNlcjpcblx0XHRcdC8vXHRcdEEgcmVwbGFjZXIgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZm9yIGVhY2ggdmFsdWUgYW5kIGNhbiByZXR1cm4gYSByZXBsYWNlbWVudFxuXHRcdFx0Ly8gc3BhY2VyOlxuXHRcdFx0Ly9cdFx0QSBzcGFjZXIgc3RyaW5nIHRvIGJlIHVzZWQgZm9yIHByZXR0eSBwcmludGluZyBvZiBKU09OXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0c2ltcGxlIHNlcmlhbGl6YXRpb24gb2YgYSB0cml2aWFsIG9iamVjdFxuXHRcdFx0Ly9cdHxcdGRlZmluZShbXCJkb2pvL2pzb25cIl0sIGZ1bmN0aW9uKEpTT04pe1xuXHRcdFx0Ly8gXHR8XHRcdHZhciBqc29uU3RyID0gSlNPTi5zdHJpbmdpZnkoeyBob3dkeTogXCJzdHJhbmdlciFcIiwgaXNTdHJhbmdlOiB0cnVlIH0pO1xuXHRcdFx0Ly9cdHxcdFx0ZG9oLmlzKCd7XCJob3dkeVwiOlwic3RyYW5nZXIhXCIsXCJpc1N0cmFuZ2VcIjp0cnVlfScsIGpzb25TdHIpO1xuXHRcdH1cblx0fTtcblx0PT09PT0qL1xuXG5cdGlmKGhhcyhcImpzb24tc3RyaW5naWZ5XCIpKXtcblx0XHRyZXR1cm4gSlNPTjtcblx0fWVsc2V7XG5cdFx0dmFyIGVzY2FwZVN0cmluZyA9IGZ1bmN0aW9uKC8qU3RyaW5nKi9zdHIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEFkZHMgZXNjYXBlIHNlcXVlbmNlcyBmb3Igbm9uLXZpc3VhbCBjaGFyYWN0ZXJzLCBkb3VibGUgcXVvdGUgYW5kXG5cdFx0XHQvL1x0XHRiYWNrc2xhc2ggYW5kIHN1cnJvdW5kcyB3aXRoIGRvdWJsZSBxdW90ZXMgdG8gZm9ybSBhIHZhbGlkIHN0cmluZ1xuXHRcdFx0Ly9cdFx0bGl0ZXJhbC5cblx0XHRcdHJldHVybiAoJ1wiJyArIHN0ci5yZXBsYWNlKC8oW1wiXFxcXF0pL2csICdcXFxcJDEnKSArICdcIicpLlxuXHRcdFx0XHRyZXBsYWNlKC9bXFxmXS9nLCBcIlxcXFxmXCIpLnJlcGxhY2UoL1tcXGJdL2csIFwiXFxcXGJcIikucmVwbGFjZSgvW1xcbl0vZywgXCJcXFxcblwiKS5cblx0XHRcdFx0cmVwbGFjZSgvW1xcdF0vZywgXCJcXFxcdFwiKS5yZXBsYWNlKC9bXFxyXS9nLCBcIlxcXFxyXCIpOyAvLyBzdHJpbmdcblx0XHR9O1xuXHRcdHJldHVybiB7XG5cdFx0XHRwYXJzZTogaGFzKFwianNvbi1wYXJzZVwiKSA/IEpTT04ucGFyc2UgOiBmdW5jdGlvbihzdHIsIHN0cmljdCl7XG5cdFx0XHRcdGlmKHN0cmljdCAmJiAhL14oW1xcc1xcW1xce10qKD86XCIoPzpcXFxcLnxbXlwiXSkqXCJ8LT9cXGRbXFxkXFwuXSooPzpbRWVdWystXT9cXGQrKT98bnVsbHx0cnVlfGZhbHNlfClbXFxzXFxdXFx9XSooPzosfDp8JCkpKyQvLnRlc3Qoc3RyKSl7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXJzIGluIEpTT05cIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGV2YWwoJygnICsgc3RyICsgJyknKTtcblx0XHRcdH0sXG5cdFx0XHRzdHJpbmdpZnk6IGZ1bmN0aW9uKHZhbHVlLCByZXBsYWNlciwgc3BhY2VyKXtcblx0XHRcdFx0dmFyIHVuZGVmO1xuXHRcdFx0XHRpZih0eXBlb2YgcmVwbGFjZXIgPT0gXCJzdHJpbmdcIil7XG5cdFx0XHRcdFx0c3BhY2VyID0gcmVwbGFjZXI7XG5cdFx0XHRcdFx0cmVwbGFjZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgaW5kZW50LCBrZXkpe1xuXHRcdFx0XHRcdGlmKHJlcGxhY2VyKXtcblx0XHRcdFx0XHRcdGl0ID0gcmVwbGFjZXIoa2V5LCBpdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB2YWwsIG9ianR5cGUgPSB0eXBlb2YgaXQ7XG5cdFx0XHRcdFx0aWYob2JqdHlwZSA9PSBcIm51bWJlclwiKXtcblx0XHRcdFx0XHRcdHJldHVybiBpc0Zpbml0ZShpdCkgPyBpdCArIFwiXCIgOiBcIm51bGxcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYob2JqdHlwZSA9PSBcImJvb2xlYW5cIil7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaXQgKyBcIlwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihpdCA9PT0gbnVsbCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJudWxsXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHR5cGVvZiBpdCA9PSBcInN0cmluZ1wiKXtcblx0XHRcdFx0XHRcdHJldHVybiBlc2NhcGVTdHJpbmcoaXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihvYmp0eXBlID09IFwiZnVuY3Rpb25cIiB8fCBvYmp0eXBlID09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmOyAvLyB1bmRlZmluZWRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc2hvcnQtY2lyY3VpdCBmb3Igb2JqZWN0cyB0aGF0IHN1cHBvcnQgXCJqc29uXCIgc2VyaWFsaXphdGlvblxuXHRcdFx0XHRcdC8vIGlmIHRoZXkgcmV0dXJuIFwic2VsZlwiIHRoZW4ganVzdCBwYXNzLXRocm91Z2guLi5cblx0XHRcdFx0XHRpZih0eXBlb2YgaXQudG9KU09OID09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KGl0LnRvSlNPTihrZXkpLCBpbmRlbnQsIGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGl0IGluc3RhbmNlb2YgRGF0ZSl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ1wie0Z1bGxZZWFyfS17TW9udGgrfS17RGF0ZX1Ue0hvdXJzfTp7TWludXRlc306e1NlY29uZHN9WlwiJy5yZXBsYWNlKC9cXHsoXFx3KykoXFwrKT9cXH0vZywgZnVuY3Rpb24odCwgcHJvcCwgcGx1cyl7XG5cdFx0XHRcdFx0XHRcdHZhciBudW0gPSBpdFtcImdldFVUQ1wiICsgcHJvcF0oKSArIChwbHVzID8gMSA6IDApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVtIDwgMTAgPyBcIjBcIiArIG51bSA6IG51bTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihpdC52YWx1ZU9mKCkgIT09IGl0KXtcblx0XHRcdFx0XHRcdC8vIHByaW1pdGl2ZSB3cmFwcGVyLCB0cnkgYWdhaW4gdW53cmFwcGVkOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeShpdC52YWx1ZU9mKCksIGluZGVudCwga2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIG5leHRJbmRlbnQ9IHNwYWNlciA/IChpbmRlbnQgKyBzcGFjZXIpIDogXCJcIjtcblx0XHRcdFx0XHQvKiB3ZSB1c2VkIHRvIHRlc3QgZm9yIERPTSBub2RlcyBhbmQgdGhyb3csIGJ1dCBGRiBzZXJpYWxpemVzIHRoZW0gYXMge30sIHNvIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3kgaXMgcHJvYmFibHkgbm90IGVmZmljaWVudGx5IGF0dGFpbmFibGUgKi8gXG5cdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBzZXAgPSBzcGFjZXIgPyBcIiBcIiA6IFwiXCI7XG5cdFx0XHRcdFx0dmFyIG5ld0xpbmUgPSBzcGFjZXIgPyBcIlxcblwiIDogXCJcIjtcblx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gYXJyYXlcblx0XHRcdFx0XHRpZihpdCBpbnN0YW5jZW9mIEFycmF5KXtcblx0XHRcdFx0XHRcdHZhciBpdGwgPSBpdC5sZW5ndGgsIHJlcyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yKGtleSA9IDA7IGtleSA8IGl0bDsga2V5Kyspe1xuXHRcdFx0XHRcdFx0XHR2YXIgb2JqID0gaXRba2V5XTtcblx0XHRcdFx0XHRcdFx0dmFsID0gc3RyaW5naWZ5KG9iaiwgbmV4dEluZGVudCwga2V5KTtcblx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIHZhbCAhPSBcInN0cmluZ1wiKXtcblx0XHRcdFx0XHRcdFx0XHR2YWwgPSBcIm51bGxcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXMucHVzaChuZXdMaW5lICsgbmV4dEluZGVudCArIHZhbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJbXCIgKyByZXMuam9pbihcIixcIikgKyBuZXdMaW5lICsgaW5kZW50ICsgXCJdXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGdlbmVyaWMgb2JqZWN0IGNvZGUgcGF0aFxuXHRcdFx0XHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHRcdFx0XHRmb3Ioa2V5IGluIGl0KXtcblx0XHRcdFx0XHRcdHZhciBrZXlTdHI7XG5cdFx0XHRcdFx0XHRpZihpdC5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcblx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIGtleSA9PSBcIm51bWJlclwiKXtcblx0XHRcdFx0XHRcdFx0XHRrZXlTdHIgPSAnXCInICsga2V5ICsgJ1wiJztcblx0XHRcdFx0XHRcdFx0fWVsc2UgaWYodHlwZW9mIGtleSA9PSBcInN0cmluZ1wiKXtcblx0XHRcdFx0XHRcdFx0XHRrZXlTdHIgPSBlc2NhcGVTdHJpbmcoa2V5KTtcblx0XHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2tpcCBub24tc3RyaW5nIG9yIG51bWJlciBrZXlzXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dmFsID0gc3RyaW5naWZ5KGl0W2tleV0sIG5leHRJbmRlbnQsIGtleSk7XG5cdFx0XHRcdFx0XHRcdGlmKHR5cGVvZiB2YWwgIT0gXCJzdHJpbmdcIil7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2tpcCBub24tc2VyaWFsaXphYmxlIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBtb3N0IG5vbi1JRSBicm93c2VycyBkb24ndCBnZXQgaW4gdGhpcyBicmFuY2ggXG5cdFx0XHRcdFx0XHRcdC8vICh0aGV5IGhhdmUgbmF0aXZlIEpTT04pLCBzbyBwdXNoIGlzIGRlZmluaXRlbHkgdGhlIHdheSB0b1xuXHRcdFx0XHRcdFx0XHRvdXRwdXQucHVzaChuZXdMaW5lICsgbmV4dEluZGVudCArIGtleVN0ciArIFwiOlwiICsgc2VwICsgdmFsKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIFwie1wiICsgb3V0cHV0LmpvaW4oXCIsXCIpICsgbmV3TGluZSArIGluZGVudCArIFwifVwiOyAvLyBTdHJpbmdcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KHZhbHVlLCBcIlwiLCBcIlwiKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcbiIsImRlZmluZShbXCIuL19iYXNlL2tlcm5lbFwiLCBcIi4vc25pZmZcIl0sIGZ1bmN0aW9uKGRvam8sIGhhcyl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL2tleXNcblxuXHRyZXR1cm4gZG9qby5rZXlzID0ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0RGVmaW5pdGlvbnMgZm9yIGNvbW1vbiBrZXkgdmFsdWVzLiAgQ2xpZW50IGNvZGUgc2hvdWxkIHRlc3Qga2V5Q29kZSBhZ2FpbnN0IHRoZXNlIG5hbWVkIGNvbnN0YW50cyxcblx0XHQvL1x0XHRhcyB0aGUgYWN0dWFsIGNvZGVzIGNhbiB2YXJ5IGJ5IGJyb3dzZXIuXG5cblx0XHRCQUNLU1BBQ0U6IDgsXG5cdFx0VEFCOiA5LFxuXHRcdENMRUFSOiAxMixcblx0XHRFTlRFUjogMTMsXG5cdFx0U0hJRlQ6IDE2LFxuXHRcdENUUkw6IDE3LFxuXHRcdEFMVDogMTgsXG5cdFx0TUVUQTogaGFzKFwid2Via2l0XCIpID8gOTEgOiAyMjQsXHRcdC8vIHRoZSBhcHBsZSBrZXkgb24gbWFjc1xuXHRcdFBBVVNFOiAxOSxcblx0XHRDQVBTX0xPQ0s6IDIwLFxuXHRcdEVTQ0FQRTogMjcsXG5cdFx0U1BBQ0U6IDMyLFxuXHRcdFBBR0VfVVA6IDMzLFxuXHRcdFBBR0VfRE9XTjogMzQsXG5cdFx0RU5EOiAzNSxcblx0XHRIT01FOiAzNixcblx0XHRMRUZUX0FSUk9XOiAzNyxcblx0XHRVUF9BUlJPVzogMzgsXG5cdFx0UklHSFRfQVJST1c6IDM5LFxuXHRcdERPV05fQVJST1c6IDQwLFxuXHRcdElOU0VSVDogNDUsXG5cdFx0REVMRVRFOiA0Nixcblx0XHRIRUxQOiA0Nyxcblx0XHRMRUZUX1dJTkRPVzogOTEsXG5cdFx0UklHSFRfV0lORE9XOiA5Mixcblx0XHRTRUxFQ1Q6IDkzLFxuXHRcdE5VTVBBRF8wOiA5Nixcblx0XHROVU1QQURfMTogOTcsXG5cdFx0TlVNUEFEXzI6IDk4LFxuXHRcdE5VTVBBRF8zOiA5OSxcblx0XHROVU1QQURfNDogMTAwLFxuXHRcdE5VTVBBRF81OiAxMDEsXG5cdFx0TlVNUEFEXzY6IDEwMixcblx0XHROVU1QQURfNzogMTAzLFxuXHRcdE5VTVBBRF84OiAxMDQsXG5cdFx0TlVNUEFEXzk6IDEwNSxcblx0XHROVU1QQURfTVVMVElQTFk6IDEwNixcblx0XHROVU1QQURfUExVUzogMTA3LFxuXHRcdE5VTVBBRF9FTlRFUjogMTA4LFxuXHRcdE5VTVBBRF9NSU5VUzogMTA5LFxuXHRcdE5VTVBBRF9QRVJJT0Q6IDExMCxcblx0XHROVU1QQURfRElWSURFOiAxMTEsXG5cdFx0RjE6IDExMixcblx0XHRGMjogMTEzLFxuXHRcdEYzOiAxMTQsXG5cdFx0RjQ6IDExNSxcblx0XHRGNTogMTE2LFxuXHRcdEY2OiAxMTcsXG5cdFx0Rjc6IDExOCxcblx0XHRGODogMTE5LFxuXHRcdEY5OiAxMjAsXG5cdFx0RjEwOiAxMjEsXG5cdFx0RjExOiAxMjIsXG5cdFx0RjEyOiAxMjMsXG5cdFx0RjEzOiAxMjQsXG5cdFx0RjE0OiAxMjUsXG5cdFx0RjE1OiAxMjYsXG5cdFx0TlVNX0xPQ0s6IDE0NCxcblx0XHRTQ1JPTExfTE9DSzogMTQ1LFxuXHRcdFVQX0RQQUQ6IDE3NSxcblx0XHRET1dOX0RQQUQ6IDE3Nixcblx0XHRMRUZUX0RQQUQ6IDE3Nyxcblx0XHRSSUdIVF9EUEFEOiAxNzgsXG5cdFx0Ly8gdmlydHVhbCBrZXkgbWFwcGluZ1xuXHRcdGNvcHlLZXk6IGhhcyhcIm1hY1wiKSAmJiAhaGFzKFwiYWlyXCIpID8gKGhhcyhcInNhZmFyaVwiKSA/IDkxIDogMjI0ICkgOiAxN1xuXHR9O1xufSk7XG4iLCJkZWZpbmUoW1wiLi9fYmFzZS9rZXJuZWxcIiwgXCIuL29uXCIsIFwiLi9oYXNcIiwgXCIuL2RvbVwiLCBcIi4vX2Jhc2Uvd2luZG93XCJdLCBmdW5jdGlvbihkb2pvLCBvbiwgaGFzLCBkb20sIHdpbil7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL21vdXNlXG5cbiAgICBoYXMuYWRkKFwiZG9tLXF1aXJrc1wiLCB3aW4uZG9jICYmIHdpbi5kb2MuY29tcGF0TW9kZSA9PSBcIkJhY2tDb21wYXRcIik7XG5cdGhhcy5hZGQoXCJldmVudHMtbW91c2VlbnRlclwiLCB3aW4uZG9jICYmIFwib25tb3VzZWVudGVyXCIgaW4gd2luLmRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcblx0aGFzLmFkZChcImV2ZW50cy1tb3VzZXdoZWVsXCIsIHdpbi5kb2MgJiYgJ29ubW91c2V3aGVlbCcgaW4gd2luLmRvYyk7XG5cblx0dmFyIG1vdXNlQnV0dG9ucztcblx0aWYoKGhhcyhcImRvbS1xdWlya3NcIikgJiYgaGFzKFwiaWVcIikpIHx8ICFoYXMoXCJkb20tYWRkZXZlbnRsaXN0ZW5lclwiKSl7XG5cdFx0bW91c2VCdXR0b25zID0ge1xuXHRcdFx0TEVGVDogICAxLFxuXHRcdFx0TUlERExFOiA0LFxuXHRcdFx0UklHSFQ6ICAyLFxuXHRcdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXHRcdFx0aXNCdXR0b246IGZ1bmN0aW9uKGUsIGJ1dHRvbil7IHJldHVybiBlLmJ1dHRvbiAmIGJ1dHRvbjsgfSxcblx0XHRcdGlzTGVmdDogICBmdW5jdGlvbihlKXsgcmV0dXJuIGUuYnV0dG9uICYgMTsgfSxcblx0XHRcdGlzTWlkZGxlOiBmdW5jdGlvbihlKXsgcmV0dXJuIGUuYnV0dG9uICYgNDsgfSxcblx0XHRcdGlzUmlnaHQ6ICBmdW5jdGlvbihlKXsgcmV0dXJuIGUuYnV0dG9uICYgMjsgfVxuXHRcdH07XG5cdH1lbHNle1xuXHRcdG1vdXNlQnV0dG9ucyA9IHtcblx0XHRcdExFRlQ6ICAgMCxcblx0XHRcdE1JRERMRTogMSxcblx0XHRcdFJJR0hUOiAgMixcblx0XHRcdC8vIGhlbHBlciBmdW5jdGlvbnNcblx0XHRcdGlzQnV0dG9uOiBmdW5jdGlvbihlLCBidXR0b24peyByZXR1cm4gZS5idXR0b24gPT0gYnV0dG9uOyB9LFxuXHRcdFx0aXNMZWZ0OiAgIGZ1bmN0aW9uKGUpeyByZXR1cm4gZS5idXR0b24gPT0gMDsgfSxcblx0XHRcdGlzTWlkZGxlOiBmdW5jdGlvbihlKXsgcmV0dXJuIGUuYnV0dG9uID09IDE7IH0sXG5cdFx0XHRpc1JpZ2h0OiAgZnVuY3Rpb24oZSl7IHJldHVybiBlLmJ1dHRvbiA9PSAyOyB9XG5cdFx0fTtcblx0fVxuXHRkb2pvLm1vdXNlQnV0dG9ucyA9IG1vdXNlQnV0dG9ucztcblxuLyo9PT09PVxuXHRkb2pvLm1vdXNlQnV0dG9ucyA9IHtcblx0XHQvLyBMRUZUOiBOdW1iZXJcblx0XHQvL1x0XHROdW1lcmljIHZhbHVlIG9mIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBmb3IgdGhlIHBsYXRmb3JtLlxuXHRcdExFRlQ6ICAgMCxcblx0XHQvLyBNSURETEU6IE51bWJlclxuXHRcdC8vXHRcdE51bWVyaWMgdmFsdWUgb2YgdGhlIG1pZGRsZSBtb3VzZSBidXR0b24gZm9yIHRoZSBwbGF0Zm9ybS5cblx0XHRNSURETEU6IDEsXG5cdFx0Ly8gUklHSFQ6IE51bWJlclxuXHRcdC8vXHRcdE51bWVyaWMgdmFsdWUgb2YgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBmb3IgdGhlIHBsYXRmb3JtLlxuXHRcdFJJR0hUOiAgMixcblxuXHRcdGlzQnV0dG9uOiBmdW5jdGlvbihlLCBidXR0b24pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENoZWNrcyBhbiBldmVudCBvYmplY3QgZm9yIGEgcHJlc3NlZCBidXR0b25cblx0XHRcdC8vIGU6IEV2ZW50XG5cdFx0XHQvL1x0XHRFdmVudCBvYmplY3QgdG8gZXhhbWluZVxuXHRcdFx0Ly8gYnV0dG9uOiBOdW1iZXJcblx0XHRcdC8vXHRcdFRoZSBidXR0b24gdmFsdWUgKGV4YW1wbGU6IGRvam8ubW91c2VCdXR0b24uTEVGVClcblx0XHRcdHJldHVybiBlLmJ1dHRvbiA9PSBidXR0b247IC8vIEJvb2xlYW5cblx0XHR9LFxuXHRcdGlzTGVmdDogZnVuY3Rpb24oZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIGFuIGV2ZW50IG9iamVjdCBmb3IgdGhlIHByZXNzZWQgbGVmdCBidXR0b25cblx0XHRcdC8vIGU6IEV2ZW50XG5cdFx0XHQvL1x0XHRFdmVudCBvYmplY3QgdG8gZXhhbWluZVxuXHRcdFx0cmV0dXJuIGUuYnV0dG9uID09IDA7IC8vIEJvb2xlYW5cblx0XHR9LFxuXHRcdGlzTWlkZGxlOiBmdW5jdGlvbihlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDaGVja3MgYW4gZXZlbnQgb2JqZWN0IGZvciB0aGUgcHJlc3NlZCBtaWRkbGUgYnV0dG9uXG5cdFx0XHQvLyBlOiBFdmVudFxuXHRcdFx0Ly9cdFx0RXZlbnQgb2JqZWN0IHRvIGV4YW1pbmVcblx0XHRcdHJldHVybiBlLmJ1dHRvbiA9PSAxOyAvLyBCb29sZWFuXG5cdFx0fSxcblx0XHRpc1JpZ2h0OiBmdW5jdGlvbihlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDaGVja3MgYW4gZXZlbnQgb2JqZWN0IGZvciB0aGUgcHJlc3NlZCByaWdodCBidXR0b25cblx0XHRcdC8vIGU6IEV2ZW50XG5cdFx0XHQvL1x0XHRFdmVudCBvYmplY3QgdG8gZXhhbWluZVxuXHRcdFx0cmV0dXJuIGUuYnV0dG9uID09IDI7IC8vIEJvb2xlYW5cblx0XHR9XG5cdH07XG49PT09PSovXG5cblx0ZnVuY3Rpb24gZXZlbnRIYW5kbGVyKHR5cGUsIHNlbGVjdEhhbmRsZXIpe1xuXHRcdC8vIGVtdWxhdGlvbiBvZiBtb3VzZWVudGVyL2xlYXZlIHdpdGggbW91c2VvdmVyL291dCB1c2luZyBkZXNjZW5kYW50IGNoZWNraW5nXG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHRyZXR1cm4gb24obm9kZSwgdHlwZSwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0aWYoc2VsZWN0SGFuZGxlcil7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGVjdEhhbmRsZXIoZXZ0LCBsaXN0ZW5lcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWRvbS5pc0Rlc2NlbmRhbnQoZXZ0LnJlbGF0ZWRUYXJnZXQsIG5vZGUpKXtcblx0XHRcdFx0XHRyZXR1cm4gbGlzdGVuZXIuY2FsbCh0aGlzLCBldnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdGhhbmRsZXIuYnViYmxlID0gZnVuY3Rpb24oc2VsZWN0KXtcblx0XHRcdHJldHVybiBldmVudEhhbmRsZXIodHlwZSwgZnVuY3Rpb24oZXZ0LCBsaXN0ZW5lcil7XG5cdFx0XHRcdC8vIHVzaW5nIGEgc2VsZWN0b3IsIHVzZSB0aGUgc2VsZWN0IGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiB0aGUgbW91c2UgbW92ZWQgaW5zaWRlIHRoZSBzZWxlY3RvciBhbmQgd2FzIHByZXZpb3VzbHkgb3V0c2lkZSB0aGUgc2VsZWN0b3Jcblx0XHRcdFx0dmFyIHRhcmdldCA9IHNlbGVjdChldnQudGFyZ2V0KTtcblx0XHRcdFx0dmFyIHJlbGF0ZWRUYXJnZXQgPSBldnQucmVsYXRlZFRhcmdldDtcblx0XHRcdFx0aWYodGFyZ2V0ICYmICh0YXJnZXQgIT0gKHJlbGF0ZWRUYXJnZXQgJiYgcmVsYXRlZFRhcmdldC5ub2RlVHlwZSA9PSAxICYmIHNlbGVjdChyZWxhdGVkVGFyZ2V0KSkpKXtcblx0XHRcdFx0XHRyZXR1cm4gbGlzdGVuZXIuY2FsbCh0YXJnZXQsIGV2dCk7XG5cdFx0XHRcdH0gXG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdHJldHVybiBoYW5kbGVyO1xuXHR9XG5cdHZhciB3aGVlbDtcblx0aWYoaGFzKFwiZXZlbnRzLW1vdXNld2hlZWxcIikpe1xuXHRcdHdoZWVsID0gJ21vdXNld2hlZWwnO1xuXHR9ZWxzZXsgLy9maXJlZm94XG5cdFx0d2hlZWwgPSBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHRyZXR1cm4gb24obm9kZSwgJ0RPTU1vdXNlU2Nyb2xsJywgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0ZXZ0LndoZWVsRGVsdGEgPSAtZXZ0LmRldGFpbDtcblx0XHRcdFx0bGlzdGVuZXIuY2FsbCh0aGlzLCBldnQpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhpcyBtb2R1bGUgcHJvdmlkZSBtb3VzZSBldmVudCBoYW5kbGluZyB1dGlsaXR5IGZ1bmN0aW9ucyBhbmQgZXhwb3J0c1xuXHRcdC8vXHRcdG1vdXNlZW50ZXIgYW5kIG1vdXNlbGVhdmUgZXZlbnQgZW11bGF0aW9uLlxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0VG8gdXNlIHRoZXNlIGV2ZW50cywgeW91IHJlZ2lzdGVyIGEgbW91c2VlbnRlciBsaWtlIHRoaXM6XG5cdFx0Ly9cdFx0fFx0ZGVmaW5lKFtcImRvam8vb25cIiwgXCJkb2pvL21vdXNlXCJdLCBmdW5jdGlvbihvbiwgbW91c2Upe1xuXHRcdC8vXHRcdHxcdFx0b24odGFyZ2V0Tm9kZSwgbW91c2UuZW50ZXIsIGZ1bmN0aW9uKGV2ZW50KXtcblx0XHQvL1x0XHR8XHRcdFx0ZG9qby5hZGRDbGFzcyh0YXJnZXROb2RlLCBcImhpZ2hsaWdodGVkXCIpO1xuXHRcdC8vXHRcdHxcdFx0fSk7XG5cdFx0Ly9cdFx0fFx0XHRvbih0YXJnZXROb2RlLCBtb3VzZS5sZWF2ZSwgZnVuY3Rpb24oZXZlbnQpe1xuXHRcdC8vXHRcdHxcdFx0XHRkb2pvLnJlbW92ZUNsYXNzKHRhcmdldE5vZGUsIFwiaGlnaGxpZ2h0ZWRcIik7XG5cdFx0Ly9cdFx0fFx0XHR9KTtcblxuXHRcdF9ldmVudEhhbmRsZXI6IGV2ZW50SGFuZGxlcixcdFx0Ly8gZm9yIGRvam8vdG91Y2hcblxuXHRcdC8vIGVudGVyOiBTeW50aGV0aWMgRXZlbnRcblx0XHQvL1x0XHRUaGlzIGlzIGFuIGV4dGVuc2lvbiBldmVudCBmb3IgdGhlIG1vdXNlZW50ZXIgdGhhdCBJRSBwcm92aWRlcywgZW11bGF0aW5nIHRoZVxuXHRcdC8vXHRcdGJlaGF2aW9yIG9uIG90aGVyIGJyb3dzZXJzLlxuXHRcdGVudGVyOiBldmVudEhhbmRsZXIoXCJtb3VzZW92ZXJcIiksXG5cblx0XHQvLyBsZWF2ZTogU3ludGhldGljIEV2ZW50XG5cdFx0Ly9cdFx0VGhpcyBpcyBhbiBleHRlbnNpb24gZXZlbnQgZm9yIHRoZSBtb3VzZWxlYXZlIHRoYXQgSUUgcHJvdmlkZXMsIGVtdWxhdGluZyB0aGVcblx0XHQvL1x0XHRiZWhhdmlvciBvbiBvdGhlciBicm93c2Vycy5cblx0XHRsZWF2ZTogZXZlbnRIYW5kbGVyKFwibW91c2VvdXRcIiksXG5cblx0XHQvLyB3aGVlbDogTm9ybWFsaXplZCBNb3VzZSBXaGVlbCBFdmVudFxuXHRcdC8vXHRcdFRoaXMgaXMgYW4gZXh0ZW5zaW9uIGV2ZW50IGZvciB0aGUgbW91c2V3aGVlbCB0aGF0IG5vbi1Nb3ppbGxhIGJyb3dzZXJzIHByb3ZpZGUsXG5cdFx0Ly9cdFx0ZW11bGF0aW5nIHRoZSBiZWhhdmlvciBvbiBNb3ppbGxhIGJhc2VkIGJyb3dzZXJzLlxuXHRcdHdoZWVsOiB3aGVlbCxcblxuXHRcdGlzTGVmdDogbW91c2VCdXR0b25zLmlzTGVmdCxcblx0XHQvKj09PT09XG5cdFx0aXNMZWZ0OiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRlc3QgYW4gZXZlbnQgb2JqZWN0IChmcm9tIGEgbW91c2Vkb3duIGV2ZW50KSB0byBzZWUgaWYgdGhlIGxlZnQgYnV0dG9uIHdhcyBwcmVzc2VkLlxuXHRcdH0sXG5cdFx0PT09PT0qL1xuXG5cdFx0aXNNaWRkbGU6IG1vdXNlQnV0dG9ucy5pc01pZGRsZSxcblx0XHQvKj09PT09XG5cdFx0IGlzTWlkZGxlOiBmdW5jdGlvbigpe1xuXHRcdFx0IC8vIHN1bW1hcnk6XG5cdFx0XHQgLy9cdFx0VGVzdCBhbiBldmVudCBvYmplY3QgKGZyb20gYSBtb3VzZWRvd24gZXZlbnQpIHRvIHNlZSBpZiB0aGUgbWlkZGxlIGJ1dHRvbiB3YXMgcHJlc3NlZC5cblx0XHQgfSxcblx0XHQgPT09PT0qL1xuXG5cdFx0aXNSaWdodDogbW91c2VCdXR0b25zLmlzUmlnaHRcblx0XHQvKj09PT09XG5cdFx0ICwgaXNSaWdodDogZnVuY3Rpb24oKXtcblx0XHRcdCAvLyBzdW1tYXJ5OlxuXHRcdFx0IC8vXHRcdFRlc3QgYW4gZXZlbnQgb2JqZWN0IChmcm9tIGEgbW91c2Vkb3duIGV2ZW50KSB0byBzZWUgaWYgdGhlIHJpZ2h0IGJ1dHRvbiB3YXMgcHJlc3NlZC5cblx0XHQgfVxuXHRcdCA9PT09PSovXG5cdH07XG59KTtcbiIsImRlZmluZShbXCIuL2hhcyFkb20tYWRkZXZlbnRsaXN0ZW5lcj86Li9hc3BlY3RcIiwgXCIuL19iYXNlL2tlcm5lbFwiLCBcIi4vc25pZmZcIl0sIGZ1bmN0aW9uKGFzcGVjdCwgZG9qbywgaGFzKXtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0aWYoaGFzKFwiZG9tXCIpKXsgLy8gY2hlY2sgdG8gbWFrZSBzdXJlIHdlIGFyZSBpbiBhIGJyb3dzZXIsIHRoaXMgbW9kdWxlIHNob3VsZCB3b3JrIGFueXdoZXJlXG5cdFx0dmFyIG1ham9yID0gd2luZG93LlNjcmlwdEVuZ2luZU1ham9yVmVyc2lvbjtcblx0XHRoYXMuYWRkKFwianNjcmlwdFwiLCBtYWpvciAmJiAobWFqb3IoKSArIFNjcmlwdEVuZ2luZU1pbm9yVmVyc2lvbigpIC8gMTApKTtcblx0XHRoYXMuYWRkKFwiZXZlbnQtb3JpZW50YXRpb25jaGFuZ2VcIiwgaGFzKFwidG91Y2hcIikgJiYgIWhhcyhcImFuZHJvaWRcIikpOyAvLyBUT0RPOiBob3cgZG8gd2UgZGV0ZWN0IHRoaXM/XG5cdFx0aGFzLmFkZChcImV2ZW50LXN0b3BpbW1lZGlhdGVwcm9wYWdhdGlvblwiLCB3aW5kb3cuRXZlbnQgJiYgISF3aW5kb3cuRXZlbnQucHJvdG90eXBlICYmICEhd2luZG93LkV2ZW50LnByb3RvdHlwZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pO1xuXHRcdGhhcy5hZGQoXCJldmVudC1mb2N1c2luXCIsIGZ1bmN0aW9uKGdsb2JhbCwgZG9jLCBlbGVtZW50KXtcblx0XHRcdHJldHVybiAnb25mb2N1c2luJyBpbiBlbGVtZW50O1xuXHRcdH0pO1xuXG5cdFx0aWYoaGFzKFwidG91Y2hcIikpe1xuXHRcdFx0aGFzLmFkZChcInRvdWNoLWNhbi1tb2RpZnktZXZlbnQtZGVsZWdhdGVcIiwgZnVuY3Rpb24oKXtcblx0XHRcdFx0Ly8gVGhpcyBmZWF0dXJlIHRlc3QgY2hlY2tzIHdoZXRoZXIgZGVsZXRpbmcgYSBwcm9wZXJ0eSBvZiBhbiBldmVudCBkZWxlZ2F0ZSB3b3Jrc1xuXHRcdFx0XHQvLyBmb3IgYSB0b3VjaC1lbmFibGVkIGRldmljZS4gSWYgaXQgd29ya3MsIGV2ZW50IGRlbGVnYXRpb24gY2FuIGJlIHVzZWQgYXMgZmFsbGJhY2tcblx0XHRcdFx0Ly8gZm9yIGJyb3dzZXJzIHN1Y2ggYXMgU2FmYXJpIGluIG9sZGVyIGlPUyB3aGVyZSBkZWxldGluZyBwcm9wZXJ0aWVzIG9mIHRoZSBvcmlnaW5hbFxuXHRcdFx0XHQvLyBldmVudCBkb2VzIG5vdCB3b3JrLlxuXHRcdFx0XHR2YXIgRXZlbnREZWxlZ2F0ZSA9IGZ1bmN0aW9uKCl7fTtcblx0XHRcdFx0RXZlbnREZWxlZ2F0ZS5wcm90b3R5cGUgPVxuXHRcdFx0XHRcdGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7IC8vIG9yaWdpbmFsIGV2ZW50XG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gbW9kaWZ5IGEgcHJvcGVydHkgb2YgYW4gZXZlbnQgZGVsZWdhdGUgYW5kIGNoZWNrIGlmXG5cdFx0XHRcdC8vIGl0IHN1Y2NlZWRzLiBEZXBlbmRpbmcgb24gYnJvd3NlcnMgYW5kIG9uIHdoZXRoZXIgZG9qby9vbidzXG5cdFx0XHRcdC8vIHN0cmljdCBtb2RlIGlzIHN0cmlwcGVkIGluIGEgRG9qbyBidWlsZCwgdGhlcmUgYXJlIDMga25vd24gYmVoYXZpb3JzOlxuXHRcdFx0XHQvLyBpdCBtYXkgZWl0aGVyIHN1Y2NlZWQsIG9yIHJhaXNlIGFuIGVycm9yLCBvciBmYWlsIHRvIHNldCB0aGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gd2l0aG91dCByYWlzaW5nIGFuIGVycm9yLlxuXHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0dmFyIGV2ZW50RGVsZWdhdGUgPSBuZXcgRXZlbnREZWxlZ2F0ZTtcblx0XHRcdFx0XHRldmVudERlbGVnYXRlLnRhcmdldCA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuIGV2ZW50RGVsZWdhdGUudGFyZ2V0ID09PSBudWxsO1xuXHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBjYW5ub3QgdXNlIGV2ZW50IGRlbGVnYXRpb25cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdHZhciBvbiA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGRvbnRGaXgpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0QSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGNvcmUgZXZlbnQgbGlzdGVuaW5nIGZ1bmN0aW9uYWxpdHkuIFdpdGggdGhpcyBmdW5jdGlvblxuXHRcdC8vXHRcdHlvdSBjYW4gcHJvdmlkZSBhIHRhcmdldCwgZXZlbnQgdHlwZSwgYW5kIGxpc3RlbmVyIHRvIGJlIG5vdGlmaWVkIG9mXG5cdFx0Ly9cdFx0ZnV0dXJlIG1hdGNoaW5nIGV2ZW50cyB0aGF0IGFyZSBmaXJlZC5cblx0XHQvLyB0YXJnZXQ6IEVsZW1lbnR8T2JqZWN0XG5cdFx0Ly9cdFx0VGhpcyBpcyB0aGUgdGFyZ2V0IG9iamVjdCBvciBET00gZWxlbWVudCB0aGF0IHRvIHJlY2VpdmUgZXZlbnRzIGZyb21cblx0XHQvLyB0eXBlOiBTdHJpbmd8RnVuY3Rpb25cblx0XHQvL1x0XHRUaGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yIG9yIGFuIGV4dGVuc2lvbiBldmVudCB0eXBlLlxuXHRcdC8vIGxpc3RlbmVyOiBGdW5jdGlvblxuXHRcdC8vXHRcdFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBmaXJlcy5cblx0XHQvLyByZXR1cm5zOiBPYmplY3Rcblx0XHQvL1x0XHRBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSgpIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0b3AgbGlzdGVuaW5nIGZvciB0aGlzXG5cdFx0Ly9cdFx0ZXZlbnQuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0VG8gbGlzdGVuIGZvciBcImNsaWNrXCIgZXZlbnRzIG9uIGEgYnV0dG9uIG5vZGUsIHdlIGNhbiBkbzpcblx0XHQvL1x0XHR8XHRkZWZpbmUoW1wiZG9qby9vblwiXSwgZnVuY3Rpb24ob24pe1xuXHRcdC8vXHRcdHxcdFx0b24oYnV0dG9uLCBcImNsaWNrXCIsIGNsaWNrSGFuZGxlcik7XG5cdFx0Ly9cdFx0fFx0XHQuLi5cblx0XHQvL1x0XHRFdmVudGVkIEphdmFTY3JpcHQgb2JqZWN0cyBjYW4gYWxzbyBoYXZlIHRoZWlyIG93biBldmVudHMuXG5cdFx0Ly9cdFx0fFx0dmFyIG9iaiA9IG5ldyBFdmVudGVkO1xuXHRcdC8vXHRcdHxcdG9uKG9iaiwgXCJmb29cIiwgZm9vSGFuZGxlcik7XG5cdFx0Ly9cdFx0QW5kIHRoZW4gd2UgY291bGQgcHVibGlzaCBhIFwiZm9vXCIgZXZlbnQ6XG5cdFx0Ly9cdFx0fFx0b24uZW1pdChvYmosIFwiZm9vXCIsIHtrZXk6IFwidmFsdWVcIn0pO1xuXHRcdC8vXHRcdFdlIGNhbiB1c2UgZXh0ZW5zaW9uIGV2ZW50cyBhcyB3ZWxsLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGxpc3RlbiBmb3IgYSB0YXAgZ2VzdHVyZTpcblx0XHQvL1x0XHR8XHRkZWZpbmUoW1wiZG9qby9vblwiLCBcImRvam8vZ2VzdHVyZS90YXBcIiwgZnVuY3Rpb24ob24sIHRhcCl7XG5cdFx0Ly9cdFx0fFx0XHRvbihidXR0b24sIHRhcCwgdGFwSGFuZGxlcik7XG5cdFx0Ly9cdFx0fFx0XHQuLi5cblx0XHQvL1x0XHR3aGljaCB3b3VsZCB0cmlnZ2VyIGZvb0hhbmRsZXIuIE5vdGUgdGhhdCBmb3IgYSBzaW1wbGUgb2JqZWN0IHRoaXMgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nOlxuXHRcdC8vXHRcdHxcdG9iai5vbmZvbyh7a2V5OlwidmFsdWVcIn0pO1xuXHRcdC8vXHRcdElmIHlvdSB1c2Ugb24uZW1pdCBvbiBhIERPTSBub2RlLCBpdCB3aWxsIHVzZSBuYXRpdmUgZXZlbnQgZGlzcGF0Y2hpbmcgd2hlbiBwb3NzaWJsZS5cblxuXHRcdGlmKHR5cGVvZiB0YXJnZXQub24gPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB0eXBlICE9IFwiZnVuY3Rpb25cIiAmJiAhdGFyZ2V0Lm5vZGVUeXBlKXtcblx0XHRcdC8vIGRlbGVnYXRlIHRvIHRoZSB0YXJnZXQncyBvbigpIG1ldGhvZCwgc28gaXQgY2FuIGhhbmRsZSBpdCdzIG93biBsaXN0ZW5pbmcgaWYgaXQgd2FudHMgKHVubGVzcyBpdFxuXHRcdFx0Ly8gaXMgRE9NIG5vZGUgYW5kIHdlIG1heSBiZSBkZWFsaW5nIHdpdGggalF1ZXJ5IG9yIFByb3RvdHlwZSdzIGluY29tcGF0aWJsZSBhZGRpdGlvbiB0byB0aGVcblx0XHRcdC8vIEVsZW1lbnQgcHJvdG90eXBlXG5cdFx0XHRyZXR1cm4gdGFyZ2V0Lm9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHR9XG5cdFx0Ly8gZGVsZWdhdGUgdG8gbWFpbiBsaXN0ZW5lciBjb2RlXG5cdFx0cmV0dXJuIG9uLnBhcnNlKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGFkZExpc3RlbmVyLCBkb250Rml4LCB0aGlzKTtcblx0fTtcblx0b24ucGF1c2FibGUgPSAgZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgZG9udEZpeCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGlzIGZ1bmN0aW9uIGFjdHMgdGhlIHNhbWUgYXMgb24oKSwgYnV0IHdpdGggcGF1c2FibGUgZnVuY3Rpb25hbGl0eS4gVGhlXG5cdFx0Ly9cdFx0cmV0dXJuZWQgc2lnbmFsIG9iamVjdCBoYXMgcGF1c2UoKSBhbmQgcmVzdW1lKCkgZnVuY3Rpb25zLiBDYWxsaW5nIHRoZVxuXHRcdC8vXHRcdHBhdXNlKCkgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGxpc3RlbmVyIHRvIG5vdCBiZSBjYWxsZWQgZm9yIGZ1dHVyZSBldmVudHMuIENhbGxpbmcgdGhlXG5cdFx0Ly9cdFx0cmVzdW1lKCkgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGxpc3RlbmVyIHRvIGFnYWluIGJlIGNhbGxlZCBmb3IgZnV0dXJlIGV2ZW50cy5cblx0XHR2YXIgcGF1c2VkO1xuXHRcdHZhciBzaWduYWwgPSBvbih0YXJnZXQsIHR5cGUsIGZ1bmN0aW9uKCl7XG5cdFx0XHRpZighcGF1c2VkKXtcblx0XHRcdFx0cmV0dXJuIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fSwgZG9udEZpeCk7XG5cdFx0c2lnbmFsLnBhdXNlID0gZnVuY3Rpb24oKXtcblx0XHRcdHBhdXNlZCA9IHRydWU7XG5cdFx0fTtcblx0XHRzaWduYWwucmVzdW1lID0gZnVuY3Rpb24oKXtcblx0XHRcdHBhdXNlZCA9IGZhbHNlO1xuXHRcdH07XG5cdFx0cmV0dXJuIHNpZ25hbDtcblx0fTtcblx0b24ub25jZSA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGRvbnRGaXgpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhpcyBmdW5jdGlvbiBhY3RzIHRoZSBzYW1lIGFzIG9uKCksIGJ1dCB3aWxsIG9ubHkgY2FsbCB0aGUgbGlzdGVuZXIgb25jZS4gVGhlXG5cdFx0Ly9cdFx0bGlzdGVuZXIgd2lsbCBiZSBjYWxsZWQgZm9yIHRoZSBmaXJzdFxuXHRcdC8vXHRcdGV2ZW50IHRoYXQgdGFrZXMgcGxhY2UgYW5kIHRoZW4gbGlzdGVuZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHJlbW92ZWQuXG5cdFx0dmFyIHNpZ25hbCA9IG9uKHRhcmdldCwgdHlwZSwgZnVuY3Rpb24oKXtcblx0XHRcdC8vIHJlbW92ZSB0aGlzIGxpc3RlbmVyXG5cdFx0XHRzaWduYWwucmVtb3ZlKCk7XG5cdFx0XHQvLyBwcm9jZWVkIHRvIGNhbGwgdGhlIGxpc3RlbmVyXG5cdFx0XHRyZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gc2lnbmFsO1xuXHR9O1xuXHRvbi5wYXJzZSA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGFkZExpc3RlbmVyLCBkb250Rml4LCBtYXRjaGVzVGFyZ2V0KXtcblx0XHR2YXIgZXZlbnRzO1xuXHRcdGlmKHR5cGUuY2FsbCl7XG5cdFx0XHQvLyBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBvbihub2RlLCB0b3VjaC5wcmVzcywgdG91Y2hMaXN0ZW5lcik7XG5cdFx0XHRyZXR1cm4gdHlwZS5jYWxsKG1hdGNoZXNUYXJnZXQsIHRhcmdldCwgbGlzdGVuZXIpO1xuXHRcdH1cblxuXHRcdGlmKHR5cGUgaW5zdGFuY2VvZiBBcnJheSl7XG5cdFx0XHQvLyBhbGxvdyBhbiBhcnJheSBvZiBldmVudCBuYW1lcyAob3IgZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMpXG5cdFx0XHRldmVudHMgPSB0eXBlO1xuXHRcdH1lbHNlIGlmKHR5cGUuaW5kZXhPZihcIixcIikgPiAtMSl7XG5cdFx0XHQvLyB3ZSBhbGxvdyBjb21tYSBkZWxpbWl0ZWQgZXZlbnQgbmFtZXMsIHNvIHlvdSBjYW4gcmVnaXN0ZXIgZm9yIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG5cdFx0XHRldmVudHMgPSB0eXBlLnNwbGl0KC9cXHMqLFxccyovKTtcblx0XHR9XG5cdFx0aWYoZXZlbnRzKXtcblx0XHRcdHZhciBoYW5kbGVzID0gW107XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHR2YXIgZXZlbnROYW1lO1xuXHRcdFx0d2hpbGUoZXZlbnROYW1lID0gZXZlbnRzW2krK10peyAvLyBpbnRlbnRpb25hbCBhc3NpZ25tZW50XG5cdFx0XHRcdGhhbmRsZXMucHVzaChvbi5wYXJzZSh0YXJnZXQsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIGFkZExpc3RlbmVyLCBkb250Rml4LCBtYXRjaGVzVGFyZ2V0KSk7XG5cdFx0XHR9XG5cdFx0XHRoYW5kbGVzLnJlbW92ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBoYW5kbGVzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRoYW5kbGVzW2ldLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGhhbmRsZXM7XG5cdFx0fVxuXHRcdHJldHVybiBhZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBkb250Rml4LCBtYXRjaGVzVGFyZ2V0KTtcblx0fTtcblx0dmFyIHRvdWNoRXZlbnRzID0gL150b3VjaC87XG5cdGZ1bmN0aW9uIGFkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGRvbnRGaXgsIG1hdGNoZXNUYXJnZXQpe1xuXHRcdC8vIGV2ZW50IGRlbGVnYXRpb246XG5cdFx0dmFyIHNlbGVjdG9yID0gdHlwZS5tYXRjaCgvKC4qKTooLiopLyk7XG5cdFx0Ly8gaWYgd2UgaGF2ZSBhIHNlbGVjdG9yOmV2ZW50LCB0aGUgbGFzdCBvbmUgaXMgaW50ZXJwcmV0ZWQgYXMgYW4gZXZlbnQsIGFuZCB3ZSB1c2UgZXZlbnQgZGVsZWdhdGlvblxuXHRcdGlmKHNlbGVjdG9yKXtcblx0XHRcdHR5cGUgPSBzZWxlY3RvclsyXTtcblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3JbMV07XG5cdFx0XHQvLyBjcmVhdGUgdGhlIGV4dGVuc2lvbiBldmVudCBmb3Igc2VsZWN0b3JzIGFuZCBkaXJlY3RseSBjYWxsIGl0XG5cdFx0XHRyZXR1cm4gb24uc2VsZWN0b3Ioc2VsZWN0b3IsIHR5cGUpLmNhbGwobWF0Y2hlc1RhcmdldCwgdGFyZ2V0LCBsaXN0ZW5lcik7XG5cdFx0fVxuXHRcdC8vIHRlc3QgdG8gc2VlIGlmIGl0IGEgdG91Y2ggZXZlbnQgcmlnaHQgbm93LCBzbyB3ZSBkb24ndCBoYXZlIHRvIGRvIGl0IGV2ZXJ5IHRpbWUgaXQgZmlyZXNcblx0XHRpZihoYXMoXCJ0b3VjaFwiKSl7XG5cdFx0XHRpZih0b3VjaEV2ZW50cy50ZXN0KHR5cGUpKXtcblx0XHRcdFx0Ly8gdG91Y2ggZXZlbnQsIGZpeCBpdFxuXHRcdFx0XHRsaXN0ZW5lciA9IGZpeFRvdWNoTGlzdGVuZXIobGlzdGVuZXIpO1xuXHRcdFx0fVxuXHRcdFx0aWYoIWhhcyhcImV2ZW50LW9yaWVudGF0aW9uY2hhbmdlXCIpICYmICh0eXBlID09IFwib3JpZW50YXRpb25jaGFuZ2VcIikpe1xuXHRcdFx0XHQvL1wib3JpZW50YXRpb25jaGFuZ2VcIiBub3Qgc3VwcG9ydGVkIDw9IEFuZHJvaWQgMi4xLFxuXHRcdFx0XHQvL2J1dCB3b3JrcyB0aHJvdWdoIFwicmVzaXplXCIgb24gd2luZG93XG5cdFx0XHRcdHR5cGUgPSBcInJlc2l6ZVwiO1xuXHRcdFx0XHR0YXJnZXQgPSB3aW5kb3c7XG5cdFx0XHRcdGxpc3RlbmVyID0gZml4VG91Y2hMaXN0ZW5lcihsaXN0ZW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKGFkZFN0b3BJbW1lZGlhdGUpe1xuXHRcdFx0Ly8gYWRkIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiBpZiBpdCBkb2Vzbid0IGV4aXN0XG5cdFx0XHRsaXN0ZW5lciA9IGFkZFN0b3BJbW1lZGlhdGUobGlzdGVuZXIpO1xuXHRcdH1cblx0XHQvLyBub3JtYWwgcGF0aCwgdGhlIHRhcmdldCBpcyB8dGhpc3xcblx0XHRpZih0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcil7XG5cdFx0XHQvLyB0aGUgdGFyZ2V0IGhhcyBhZGRFdmVudExpc3RlbmVyLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpZiBhdmFpbGFibGUgKG1pZ2h0IG9yIG1pZ2h0IG5vdCBiZSBhIG5vZGUsIG5vbi1ub2RlcyBjYW4gaW1wbGVtZW50IHRoaXMgbWV0aG9kIGFzIHdlbGwpXG5cdFx0XHQvLyBjaGVjayBmb3IgY2FwdHVyZSBjb252ZXJzaW9uc1xuXHRcdFx0dmFyIGNhcHR1cmUgPSB0eXBlIGluIGNhcHR1cmVzLFxuXHRcdFx0XHRhZGp1c3RlZFR5cGUgPSBjYXB0dXJlID8gY2FwdHVyZXNbdHlwZV0gOiB0eXBlO1xuXHRcdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoYWRqdXN0ZWRUeXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG5cdFx0XHQvLyBjcmVhdGUgYW5kIHJldHVybiB0aGUgc2lnbmFsXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoYWRqdXN0ZWRUeXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHR5cGUgPSBcIm9uXCIgKyB0eXBlO1xuXHRcdGlmKGZpeEF0dGFjaCAmJiB0YXJnZXQuYXR0YWNoRXZlbnQpe1xuXHRcdFx0cmV0dXJuIGZpeEF0dGFjaCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKTtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IG11c3QgYmUgYW4gZXZlbnQgZW1pdHRlclwiKTtcblx0fVxuXHRvbi5tYXRjaGVzID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IsIGNvbnRleHQsIGNoaWxkcmVuLCBtYXRjaGVzVGFyZ2V0KSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRDaGVjayBpZiBhIG5vZGUgbWF0Y2ggdGhlIGN1cnJlbnQgc2VsZWN0b3Igd2l0aGluIHRoZSBjb25zdHJhaW50IG9mIGEgY29udGV4dFxuXHRcdC8vIG5vZGU6IERPTU5vZGVcblx0XHQvL1x0XHRUaGUgbm9kZSB0aGF0IG9yaWdpbmF0ZSB0aGUgZXZlbnRcblx0XHQvLyBzZWxlY3RvcjogU3RyaW5nXG5cdFx0Ly9cdFx0VGhlIHNlbGVjdG9yIHRvIGNoZWNrIGFnYWluc3Rcblx0XHQvLyBjb250ZXh0OiBET01Ob2RlXG5cdFx0Ly9cdFx0VGhlIGNvbnRleHQgdG8gc2VhcmNoIGluLlxuXHRcdC8vIGNoaWxkcmVuOiBCb29sZWFuXG5cdFx0Ly9cdFx0SW5kaWNhdGVzIGlmIGNoaWxkcmVuIGVsZW1lbnRzIG9mIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgYWxsb3dlZC4gVGhpcyBkZWZhdWx0cyB0b1xuXHRcdC8vXHRcdHRydWVcblx0XHQvLyBtYXRjaGVzVGFyZ2V0OiBPYmplY3R8ZG9qby9xdWVyeT9cblx0XHQvL1x0XHRBbiBvYmplY3Qgd2l0aCBhIHByb3BlcnR5IFwibWF0Y2hlc1wiIGFzIGEgZnVuY3Rpb24uIERlZmF1bHQgaXMgZG9qby9xdWVyeS5cblx0XHQvL1x0XHRNYXRjaGluZyBET01Ob2RlcyB3aWxsIGJlIGRvbmUgYWdhaW5zdCB0aGlzIGZ1bmN0aW9uXG5cdFx0Ly9cdFx0VGhlIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgQm9vbGVhbi5cblx0XHQvL1x0XHRJdCB3aWxsIGhhdmUgMyBhcmd1bWVudHM6IFwibm9kZVwiLCBcInNlbGVjdG9yXCIgYW5kIFwiY29udGV4dFwiXG5cdFx0Ly9cdFx0VHJ1ZSBpcyBleHBlY3RlZCBpZiBcIm5vZGVcIiBpcyBtYXRjaGluZyB0aGUgY3VycmVudCBcInNlbGVjdG9yXCIgaW4gdGhlIHBhc3NlZCBcImNvbnRleHRcIlxuXHRcdC8vIHJldHVybnM6IERPTU5vZGU/XG5cdFx0Ly9cdFx0VGhlIG1hdGNoaW5nIG5vZGUsIGlmIGFueS4gRWxzZSB5b3UgZ2V0IGZhbHNlXG5cblx0XHQvLyBzZWUgaWYgd2UgaGF2ZSBhIHZhbGlkIG1hdGNoZXNUYXJnZXQgb3IgZGVmYXVsdCB0byBkb2pvL3F1ZXJ5XG5cdFx0bWF0Y2hlc1RhcmdldCA9IG1hdGNoZXNUYXJnZXQgJiYgKHR5cGVvZiBtYXRjaGVzVGFyZ2V0Lm1hdGNoZXMgPT0gXCJmdW5jdGlvblwiKSA/IG1hdGNoZXNUYXJnZXQgOiBkb2pvLnF1ZXJ5O1xuXHRcdGNoaWxkcmVuID0gY2hpbGRyZW4gIT09IGZhbHNlO1xuXHRcdC8vIHRoZXJlIGlzIGEgc2VsZWN0b3IsIHNvIG1ha2Ugc3VyZSBpdCBtYXRjaGVzXG5cdFx0aWYobm9kZS5ub2RlVHlwZSAhPSAxKXtcblx0XHRcdC8vIHRleHQgbm9kZSB3aWxsIGZhaWwgaW4gbmF0aXZlIG1hdGNoIHNlbGVjdG9yXG5cdFx0XHRub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRcdH1cblx0XHR3aGlsZSghbWF0Y2hlc1RhcmdldC5tYXRjaGVzKG5vZGUsIHNlbGVjdG9yLCBjb250ZXh0KSl7XG5cdFx0XHRpZihub2RlID09IGNvbnRleHQgfHwgY2hpbGRyZW4gPT09IGZhbHNlIHx8ICEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkgfHwgbm9kZS5ub2RlVHlwZSAhPSAxKXsgLy8gaW50ZW50aW9uYWwgYXNzaWdubWVudFxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRvbi5zZWxlY3RvciA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBldmVudFR5cGUsIGNoaWxkcmVuKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENyZWF0ZXMgYSBuZXcgZXh0ZW5zaW9uIGV2ZW50IHdpdGggZXZlbnQgZGVsZWdhdGlvbi4gVGhpcyBpcyBiYXNlZCBvblxuXHRcdC8vXHRcdHRoZSBwcm92aWRlZCBldmVudCB0eXBlIChjYW4gYmUgZXh0ZW5zaW9uIGV2ZW50KSB0aGF0XG5cdFx0Ly9cdFx0b25seSBjYWxscyB0aGUgbGlzdGVuZXIgd2hlbiB0aGUgQ1NTIHNlbGVjdG9yIG1hdGNoZXMgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnQuXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGUgYXBwbGljYXRpb24gbXVzdCByZXF1aXJlKCkgYW4gYXBwcm9wcmlhdGUgbGV2ZWwgb2YgZG9qby9xdWVyeSB0byBoYW5kbGUgdGhlIHNlbGVjdG9yLlxuXHRcdC8vIHNlbGVjdG9yOlxuXHRcdC8vXHRcdFRoZSBDU1Mgc2VsZWN0b3IgdG8gdXNlIGZvciBmaWx0ZXIgZXZlbnRzIGFuZCBkZXRlcm1pbmUgdGhlIHx0aGlzfCBvZiB0aGUgZXZlbnQgbGlzdGVuZXIuXG5cdFx0Ly8gZXZlbnRUeXBlOlxuXHRcdC8vXHRcdFRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG5cdFx0Ly8gY2hpbGRyZW46XG5cdFx0Ly9cdFx0SW5kaWNhdGVzIGlmIGNoaWxkcmVuIGVsZW1lbnRzIG9mIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgYWxsb3dlZC4gVGhpcyBkZWZhdWx0cyB0b1xuXHRcdC8vXHRcdHRydWVcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vIHxcdHJlcXVpcmUoW1wiZG9qby9vblwiLCBcImRvam8vbW91c2VcIiwgXCJkb2pvL3F1ZXJ5IWNzczJcIl0sIGZ1bmN0aW9uKG9uLCBtb3VzZSl7XG5cdFx0Ly8gfFx0XHRvbihub2RlLCBvbi5zZWxlY3RvcihcIi5teS1jbGFzc1wiLCBtb3VzZS5lbnRlciksIGhhbmRsZXJGb3JNeUhvdmVyKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBsaXN0ZW5lcil7XG5cdFx0XHQvLyBpZiB0aGUgc2VsZWN0b3IgaXMgZnVuY3Rpb24sIHVzZSBpdCB0byBzZWxlY3QgdGhlIG5vZGUsIG90aGVyd2lzZSB1c2UgdGhlIG1hdGNoZXMgbWV0aG9kXG5cdFx0XHR2YXIgbWF0Y2hlc1RhcmdldCA9IHR5cGVvZiBzZWxlY3RvciA9PSBcImZ1bmN0aW9uXCIgPyB7bWF0Y2hlczogc2VsZWN0b3J9IDogdGhpcyxcblx0XHRcdFx0YnViYmxlID0gZXZlbnRUeXBlLmJ1YmJsZTtcblx0XHRcdGZ1bmN0aW9uIHNlbGVjdChldmVudFRhcmdldCl7XG5cdFx0XHRcdHJldHVybiBvbi5tYXRjaGVzKGV2ZW50VGFyZ2V0LCBzZWxlY3RvciwgdGFyZ2V0LCBjaGlsZHJlbiwgbWF0Y2hlc1RhcmdldCk7XG5cdFx0XHR9XG5cdFx0XHRpZihidWJibGUpe1xuXHRcdFx0XHQvLyB0aGUgZXZlbnQgdHlwZSBkb2Vzbid0IG5hdHVyYWxseSBidWJibGUsIGJ1dCBoYXMgYSBidWJibGluZyBmb3JtLCB1c2UgdGhhdCwgYW5kIGdpdmUgaXQgdGhlIHNlbGVjdG9yIHNvIGl0IGNhbiBwZXJmb3JtIHRoZSBzZWxlY3QgaXRzZWxmXG5cdFx0XHRcdHJldHVybiBvbih0YXJnZXQsIGJ1YmJsZShzZWxlY3QpLCBsaXN0ZW5lcik7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdGFuZGFyZCBldmVudCBkZWxlZ2F0aW9uXG5cdFx0XHRyZXR1cm4gb24odGFyZ2V0LCBldmVudFR5cGUsIGZ1bmN0aW9uKGV2ZW50KXtcblx0XHRcdFx0Ly8gY2FsbCBzZWxlY3QgdG8gc2VlIGlmIHdlIG1hdGNoXG5cdFx0XHRcdHZhciBldmVudFRhcmdldCA9IHNlbGVjdChldmVudC50YXJnZXQpO1xuXHRcdFx0XHQvLyBpZiBpdCBtYXRjaGVzIHdlIGNhbGwgdGhlIGxpc3RlbmVyXG5cdFx0XHRcdGlmIChldmVudFRhcmdldCkge1xuXHRcdFx0XHRcdC8vIFdlIHNhdmUgdGhlIG1hdGNoaW5nIHRhcmdldCBpbnRvIHRoZSBldmVudCwgc28gaXQgY2FuIGJlIGFjY2Vzc2VkIGV2ZW4gd2hlbiBoaXRjaGluZyAoc2VlICMxODM1NSlcblx0XHRcdFx0XHRldmVudC5zZWxlY3RvclRhcmdldCA9IGV2ZW50VGFyZ2V0O1xuXHRcdFx0XHRcdHJldHVybiBsaXN0ZW5lci5jYWxsKGV2ZW50VGFyZ2V0LCBldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cdH07XG5cblx0ZnVuY3Rpb24gc3ludGhldGljUHJldmVudERlZmF1bHQoKXtcblx0XHR0aGlzLmNhbmNlbGFibGUgPSBmYWxzZTtcblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuXHR9XG5cdGZ1bmN0aW9uIHN5bnRoZXRpY1N0b3BQcm9wYWdhdGlvbigpe1xuXHRcdHRoaXMuYnViYmxlcyA9IGZhbHNlO1xuXHR9XG5cdHZhciBzbGljZSA9IFtdLnNsaWNlLFxuXHRcdHN5bnRoZXRpY0Rpc3BhdGNoID0gb24uZW1pdCA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgZXZlbnQpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0RmlyZXMgYW4gZXZlbnQgb24gdGhlIHRhcmdldCBvYmplY3QuXG5cdFx0Ly8gdGFyZ2V0OlxuXHRcdC8vXHRcdFRoZSB0YXJnZXQgb2JqZWN0IHRvIGZpcmUgdGhlIGV2ZW50IG9uLiBUaGlzIGNhbiBiZSBhIERPTSBlbGVtZW50IG9yIGEgcGxhaW5cblx0XHQvL1x0XHRKUyBvYmplY3QuIElmIHRoZSB0YXJnZXQgaXMgYSBET00gZWxlbWVudCwgbmF0aXZlIGV2ZW50IGVtaXR0aW5nIG1lY2hhbmlzbXNcblx0XHQvL1x0XHRhcmUgdXNlZCB3aGVuIHBvc3NpYmxlLlxuXHRcdC8vIHR5cGU6XG5cdFx0Ly9cdFx0VGhlIGV2ZW50IHR5cGUgbmFtZS4gWW91IGNhbiBlbXVsYXRlIHN0YW5kYXJkIG5hdGl2ZSBldmVudHMgbGlrZSBcImNsaWNrXCIgYW5kXG5cdFx0Ly9cdFx0XCJtb3VzZW92ZXJcIiBvciBjcmVhdGUgY3VzdG9tIGV2ZW50cyBsaWtlIFwib3BlblwiIG9yIFwiZmluaXNoXCIuXG5cdFx0Ly8gZXZlbnQ6XG5cdFx0Ly9cdFx0QW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgdGhlIHByb3BlcnRpZXMgZm9yIHRoZSBldmVudC4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9ldmVudC5pbml0RXZlbnRcblx0XHQvL1x0XHRmb3Igc29tZSBvZiB0aGUgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgY29waWVkIHRvIHRoZSBldmVudCBvYmplY3QuXG5cdFx0Ly9cdFx0T2YgcGFydGljdWxhciBpbXBvcnRhbmNlIGFyZSB0aGUgY2FuY2VsYWJsZSBhbmQgYnViYmxlcyBwcm9wZXJ0aWVzLiBUaGVcblx0XHQvL1x0XHRjYW5jZWxhYmxlIHByb3BlcnR5IGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgZXZlbnQgaGFzIGEgZGVmYXVsdCBhY3Rpb25cblx0XHQvL1x0XHR0aGF0IGNhbiBiZSBjYW5jZWxsZWQuIFRoZSBldmVudCBpcyBjYW5jZWxsZWQgYnkgY2FsbGluZyBwcmV2ZW50RGVmYXVsdCgpIG9uXG5cdFx0Ly9cdFx0dGhlIGV2ZW50IG9iamVjdC4gVGhlIGJ1YmJsZXMgcHJvcGVydHkgaW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZVxuXHRcdC8vXHRcdGV2ZW50IHdpbGwgYnViYmxlIHVwIHRoZSBET00gdHJlZS4gSWYgYnViYmxlcyBpcyB0cnVlLCB0aGUgZXZlbnQgd2lsbCBiZSBjYWxsZWRcblx0XHQvL1x0XHRvbiB0aGUgdGFyZ2V0IGFuZCB0aGVuIGVhY2ggcGFyZW50IHN1Y2Nlc3NpdmVseSB1bnRpbCB0aGUgdG9wIG9mIHRoZSB0cmVlXG5cdFx0Ly9cdFx0aXMgcmVhY2hlZCBvciBzdG9wUHJvcGFnYXRpb24oKSBpcyBjYWxsZWQuIEJvdGggYnViYmxlcyBhbmQgY2FuY2VsYWJsZVxuXHRcdC8vXHRcdGRlZmF1bHQgdG8gZmFsc2UuXG5cdFx0Ly8gcmV0dXJuczpcblx0XHQvL1x0XHRJZiB0aGUgZXZlbnQgaXMgY2FuY2VsYWJsZSBhbmQgdGhlIGV2ZW50IGlzIG5vdCBjYW5jZWxsZWQsXG5cdFx0Ly9cdFx0ZW1pdCB3aWxsIHJldHVybiB0cnVlLiBJZiB0aGUgZXZlbnQgaXMgY2FuY2VsYWJsZSBhbmQgdGhlIGV2ZW50IGlzIGNhbmNlbGxlZCxcblx0XHQvL1x0XHRlbWl0IHdpbGwgcmV0dXJuIGZhbHNlLlxuXHRcdC8vIGRldGFpbHM6XG5cdFx0Ly9cdFx0Tm90ZSB0aGF0IHRoaXMgaXMgZGVzaWduZWQgdG8gZW1pdCBldmVudHMgZm9yIGxpc3RlbmVycyByZWdpc3RlcmVkIHRocm91Z2hcblx0XHQvL1x0XHRkb2pvL29uLiBJdCBzaG91bGQgYWN0dWFsbHkgd29yayB3aXRoIGFueSBldmVudCBsaXN0ZW5lciBleGNlcHQgdGhvc2Vcblx0XHQvL1x0XHRhZGRlZCB0aHJvdWdoIElFJ3MgYXR0YWNoRXZlbnQgKElFOCBhbmQgYmVsb3cncyBub24tVzNDIGV2ZW50IGVtaXR0aW5nXG5cdFx0Ly9cdFx0ZG9lc24ndCBzdXBwb3J0IGN1c3RvbSBldmVudCB0eXBlcykuIEl0IHNob3VsZCB3b3JrIHdpdGggYWxsIGV2ZW50cyByZWdpc3RlcmVkXG5cdFx0Ly9cdFx0dGhyb3VnaCBkb2pvL29uLiBBbHNvIG5vdGUgdGhhdCB0aGUgZW1pdCBtZXRob2QgZG9lcyBkbyBhbnkgZGVmYXVsdFxuXHRcdC8vXHRcdGFjdGlvbiwgaXQgb25seSByZXR1cm5zIGEgdmFsdWUgdG8gaW5kaWNhdGUgaWYgdGhlIGRlZmF1bHQgYWN0aW9uIHNob3VsZCB0YWtlXG5cdFx0Ly9cdFx0cGxhY2UuIEZvciBleGFtcGxlLCBlbWl0dGluZyBhIGtleXByZXNzIGV2ZW50IHdvdWxkIG5vdCBjYXVzZSBhIGNoYXJhY3RlclxuXHRcdC8vXHRcdHRvIGFwcGVhciBpbiBhIHRleHRib3guXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRUbyBmaXJlIG91ciBvd24gY2xpY2sgZXZlbnRcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL29uXCIsIFwiZG9qby9kb21cIlxuXHRcdC8vXHR8XHRdLCBmdW5jdGlvbihvbiwgZG9tKXtcblx0XHQvL1x0fFx0XHRvbi5lbWl0KGRvbS5ieUlkKFwiYnV0dG9uXCIpLCBcImNsaWNrXCIsIHtcblx0XHQvL1x0fFx0XHRcdGNhbmNlbGFibGU6IHRydWUsXG5cdFx0Ly9cdHxcdFx0XHRidWJibGVzOiB0cnVlLFxuXHRcdC8vXHR8XHRcdFx0c2NyZWVuWDogMzMsXG5cdFx0Ly9cdHxcdFx0XHRzY3JlZW5ZOiA0NFxuXHRcdC8vXHR8XHRcdH0pO1xuXHRcdC8vXHRcdFdlIGNhbiBhbHNvIGZpcmUgb3VyIG93biBjdXN0b20gZXZlbnRzOlxuXHRcdC8vXHR8XHRcdG9uLmVtaXQoZG9tLmJ5SWQoXCJzbGlkZXJcIiksIFwic2xpZGVcIiwge1xuXHRcdC8vXHR8XHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0XHQvL1x0fFx0XHRcdGJ1YmJsZXM6IHRydWUsXG5cdFx0Ly9cdHxcdFx0XHRkaXJlY3Rpb246IFwibGVmdC10by1yaWdodFwiXG5cdFx0Ly9cdHxcdFx0fSk7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHRcdHZhciBtZXRob2QgPSBcIm9uXCIgKyB0eXBlO1xuXHRcdGlmKFwicGFyZW50Tm9kZVwiIGluIHRhcmdldCl7XG5cdFx0XHQvLyBub2RlIChvciBub2RlLWxpa2UpLCBjcmVhdGUgZXZlbnQgY29udHJvbGxlciBtZXRob2RzXG5cdFx0XHR2YXIgbmV3RXZlbnQgPSBhcmdzWzBdID0ge307XG5cdFx0XHRmb3IodmFyIGkgaW4gZXZlbnQpe1xuXHRcdFx0XHRuZXdFdmVudFtpXSA9IGV2ZW50W2ldO1xuXHRcdFx0fVxuXHRcdFx0bmV3RXZlbnQucHJldmVudERlZmF1bHQgPSBzeW50aGV0aWNQcmV2ZW50RGVmYXVsdDtcblx0XHRcdG5ld0V2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IHN5bnRoZXRpY1N0b3BQcm9wYWdhdGlvbjtcblx0XHRcdG5ld0V2ZW50LnRhcmdldCA9IHRhcmdldDtcblx0XHRcdG5ld0V2ZW50LnR5cGUgPSB0eXBlO1xuXHRcdFx0ZXZlbnQgPSBuZXdFdmVudDtcblx0XHR9XG5cdFx0ZG97XG5cdFx0XHQvLyBjYWxsIGFueSBub2RlIHdoaWNoIGhhcyBhIGhhbmRsZXIgKG5vdGUgdGhhdCBpZGVhbGx5IHdlIHdvdWxkIHRyeS9jYXRjaCB0byBzaW11bGF0ZSBub3JtYWwgZXZlbnQgcHJvcGFnYXRpb24gYnV0IHRoYXQgY2F1c2VzIHRvbyBtdWNoIHBhaW4gZm9yIGRlYnVnZ2luZylcblx0XHRcdHRhcmdldFttZXRob2RdICYmIHRhcmdldFttZXRob2RdLmFwcGx5KHRhcmdldCwgYXJncyk7XG5cdFx0XHQvLyBhbmQgdGhlbiBjb250aW51ZSB1cCB0aGUgcGFyZW50IG5vZGUgY2hhaW4gaWYgaXQgaXMgc3RpbGwgYnViYmxpbmcgKGlmIHN0YXJ0ZWQgYXMgYnViYmxlcyBhbmQgc3RvcFByb3BhZ2F0aW9uIGhhc24ndCBiZWVuIGNhbGxlZClcblx0XHR9d2hpbGUoZXZlbnQgJiYgZXZlbnQuYnViYmxlcyAmJiAodGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpKTtcblx0XHRyZXR1cm4gZXZlbnQgJiYgZXZlbnQuY2FuY2VsYWJsZSAmJiBldmVudDsgLy8gaWYgaXQgaXMgc3RpbGwgdHJ1ZSAod2FzIGNhbmNlbGFibGUgYW5kIHdhcyBjYW5jZWxsZWQpLCByZXR1cm4gdGhlIGV2ZW50IHRvIGluZGljYXRlIGRlZmF1bHQgYWN0aW9uIHNob3VsZCBoYXBwZW5cblx0fTtcblx0dmFyIGNhcHR1cmVzID0gaGFzKFwiZXZlbnQtZm9jdXNpblwiKSA/IHt9IDoge2ZvY3VzaW46IFwiZm9jdXNcIiwgZm9jdXNvdXQ6IFwiYmx1clwifTtcblx0aWYoIWhhcyhcImV2ZW50LXN0b3BpbW1lZGlhdGVwcm9wYWdhdGlvblwiKSl7XG5cdFx0dmFyIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuaW1tZWRpYXRlbHlTdG9wcGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMubW9kaWZpZWQgPSB0cnVlOyAvLyBtYXJrIGl0IGFzIG1vZGlmaWVkIHNvIHRoZSBldmVudCB3aWxsIGJlIGNhY2hlZCBpbiBJRVxuXHRcdH07XG5cdFx0dmFyIGFkZFN0b3BJbW1lZGlhdGUgPSBmdW5jdGlvbihsaXN0ZW5lcil7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZXZlbnQpe1xuXHRcdFx0XHRpZighZXZlbnQuaW1tZWRpYXRlbHlTdG9wcGVkKXsvLyBjaGVjayB0byBtYWtlIHN1cmUgaXQgaGFzbid0IGJlZW4gc3RvcHBlZCBpbW1lZGlhdGVseVxuXHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcblx0XHRcdFx0XHRyZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cdGlmKGhhcyhcImRvbS1hZGRldmVudGxpc3RlbmVyXCIpKXtcblx0XHQvLyBlbWl0dGVyIHRoYXQgd29ya3Mgd2l0aCBuYXRpdmUgZXZlbnQgaGFuZGxpbmdcblx0XHRvbi5lbWl0ID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBldmVudCl7XG5cdFx0XHRpZih0YXJnZXQuZGlzcGF0Y2hFdmVudCAmJiBkb2N1bWVudC5jcmVhdGVFdmVudCl7XG5cdFx0XHRcdC8vIHVzZSB0aGUgbmF0aXZlIGV2ZW50IGVtaXR0aW5nIG1lY2hhbmlzbSBpZiBpdCBpcyBhdmFpbGFibGUgb24gdGhlIHRhcmdldCBvYmplY3Rcblx0XHRcdFx0Ly8gY3JlYXRlIGEgZ2VuZXJpYyBldmVudFxuXHRcdFx0XHQvLyB3ZSBjb3VsZCBjcmVhdGUgYnJhbmNoIGludG8gdGhlIGRpZmZlcmVudCB0eXBlcyBvZiBldmVudCBjb25zdHJ1Y3RvcnMsIGJ1dFxuXHRcdFx0XHQvLyB0aGF0IHdvdWxkIGJlIGEgbG90IG9mIGV4dHJhIGNvZGUsIHdpdGggbGl0dGxlIGJlbmVmaXQgdGhhdCBJIGNhbiBzZWUsIHNlZW1zXG5cdFx0XHRcdC8vIGJlc3QgdG8gdXNlIHRoZSBnZW5lcmljIGNvbnN0cnVjdG9yIGFuZCBjb3B5IHByb3BlcnRpZXMgb3ZlciwgbWFraW5nIGl0XG5cdFx0XHRcdC8vIGVhc3kgdG8gaGF2ZSBldmVudHMgbG9vayBsaWtlIHRoZSBvbmVzIGNyZWF0ZWQgd2l0aCBzcGVjaWZpYyBpbml0aWFsaXplcnNcblx0XHRcdFx0dmFyIG93bmVyRG9jdW1lbnQgPSB0YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0dmFyIG5hdGl2ZUV2ZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFdmVudChcIkhUTUxFdmVudHNcIik7XG5cdFx0XHRcdG5hdGl2ZUV2ZW50LmluaXRFdmVudCh0eXBlLCAhIWV2ZW50LmJ1YmJsZXMsICEhZXZlbnQuY2FuY2VsYWJsZSk7XG5cdFx0XHRcdC8vIGFuZCBjb3B5IGFsbCBvdXIgcHJvcGVydGllcyBvdmVyXG5cdFx0XHRcdGZvcih2YXIgaSBpbiBldmVudCl7XG5cdFx0XHRcdFx0aWYoIShpIGluIG5hdGl2ZUV2ZW50KSl7XG5cdFx0XHRcdFx0XHRuYXRpdmVFdmVudFtpXSA9IGV2ZW50W2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmF0aXZlRXZlbnQpICYmIG5hdGl2ZUV2ZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN5bnRoZXRpY0Rpc3BhdGNoLmFwcGx5KG9uLCBhcmd1bWVudHMpOyAvLyBlbWl0IGZvciBhIG5vbi1ub2RlXG5cdFx0fTtcblx0fWVsc2V7XG5cdFx0Ly8gbm8gYWRkRXZlbnRMaXN0ZW5lciwgYmFzaWNhbGx5IG9sZCBJRSBldmVudCBub3JtYWxpemF0aW9uXG5cdFx0b24uX2ZpeEV2ZW50ID0gZnVuY3Rpb24oZXZ0LCBzZW5kZXIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdG5vcm1hbGl6ZXMgcHJvcGVydGllcyBvbiB0aGUgZXZlbnQgb2JqZWN0IGluY2x1ZGluZyBldmVudFxuXHRcdFx0Ly9cdFx0YnViYmxpbmcgbWV0aG9kcywga2V5c3Ryb2tlIG5vcm1hbGl6YXRpb24sIGFuZCB4L3kgcG9zaXRpb25zXG5cdFx0XHQvLyBldnQ6XG5cdFx0XHQvL1x0XHRuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0XHQvLyBzZW5kZXI6XG5cdFx0XHQvL1x0XHRub2RlIHRvIHRyZWF0IGFzIFwiY3VycmVudFRhcmdldFwiXG5cdFx0XHRpZighZXZ0KXtcblx0XHRcdFx0dmFyIHcgPSBzZW5kZXIgJiYgKHNlbmRlci5vd25lckRvY3VtZW50IHx8IHNlbmRlci5kb2N1bWVudCB8fCBzZW5kZXIpLnBhcmVudFdpbmRvdyB8fCB3aW5kb3c7XG5cdFx0XHRcdGV2dCA9IHcuZXZlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZighZXZ0KXtyZXR1cm4gZXZ0O31cblx0XHRcdHRyeXtcblx0XHRcdFx0aWYobGFzdEV2ZW50ICYmIGV2dC50eXBlID09IGxhc3RFdmVudC50eXBlICAmJiBldnQuc3JjRWxlbWVudCA9PSBsYXN0RXZlbnQudGFyZ2V0KXtcblx0XHRcdFx0XHQvLyBzaG91bGQgYmUgc2FtZSBldmVudCwgcmV1c2UgZXZlbnQgb2JqZWN0IChzbyBpdCBjYW4gYmUgYXVnbWVudGVkKTtcblx0XHRcdFx0XHQvLyBhY2Nlc3NpbmcgZXZ0LnNyY0VsZW1lbnQgcmF0aGVyIHRoYW4gZXZ0LnRhcmdldCBzaW5jZSBldnQudGFyZ2V0IG5vdCBzZXQgb24gSUUgdW50aWwgZml4dXAgYmVsb3dcblx0XHRcdFx0XHRldnQgPSBsYXN0RXZlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0Ly8gd2lsbCBvY2N1ciBvbiBJRSBvbiBsYXN0RXZlbnQudHlwZSByZWZlcmVuY2UgaWYgbGFzdEV2ZW50IHBvaW50cyB0byBhIHByZXZpb3VzIGV2ZW50IHRoYXQgYWxyZWFkeVxuXHRcdFx0XHQvLyBmaW5pc2hlZCBidWJibGluZywgYnV0IHRoZSBzZXRUaW1lb3V0KCkgdG8gY2xlYXIgbGFzdEV2ZW50IGhhc24ndCBmaXJlZCB5ZXRcblx0XHRcdH1cblx0XHRcdGlmKCFldnQudGFyZ2V0KXsgLy8gY2hlY2sgdG8gc2VlIGlmIGl0IGhhcyBiZWVuIGZpeGVkIHlldFxuXHRcdFx0XHRldnQudGFyZ2V0ID0gZXZ0LnNyY0VsZW1lbnQ7XG5cdFx0XHRcdGV2dC5jdXJyZW50VGFyZ2V0ID0gKHNlbmRlciB8fCBldnQuc3JjRWxlbWVudCk7XG5cdFx0XHRcdGlmKGV2dC50eXBlID09IFwibW91c2VvdmVyXCIpe1xuXHRcdFx0XHRcdGV2dC5yZWxhdGVkVGFyZ2V0ID0gZXZ0LmZyb21FbGVtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGV2dC50eXBlID09IFwibW91c2VvdXRcIil7XG5cdFx0XHRcdFx0ZXZ0LnJlbGF0ZWRUYXJnZXQgPSBldnQudG9FbGVtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFldnQuc3RvcFByb3BhZ2F0aW9uKXtcblx0XHRcdFx0XHRldnQuc3RvcFByb3BhZ2F0aW9uID0gc3RvcFByb3BhZ2F0aW9uO1xuXHRcdFx0XHRcdGV2dC5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaChldnQudHlwZSl7XG5cdFx0XHRcdFx0Y2FzZSBcImtleXByZXNzXCI6XG5cdFx0XHRcdFx0XHR2YXIgYyA9IChcImNoYXJDb2RlXCIgaW4gZXZ0ID8gZXZ0LmNoYXJDb2RlIDogZXZ0LmtleUNvZGUpO1xuXHRcdFx0XHRcdFx0aWYgKGM9PTEwKXtcblx0XHRcdFx0XHRcdFx0Ly8gQ1RSTC1FTlRFUiBpcyBDVFJMLUFTQ0lJKDEwKSBvbiBJRSwgYnV0IENUUkwtRU5URVIgb24gTW96aWxsYVxuXHRcdFx0XHRcdFx0XHRjPTA7XG5cdFx0XHRcdFx0XHRcdGV2dC5rZXlDb2RlID0gMTM7XG5cdFx0XHRcdFx0XHR9ZWxzZSBpZihjPT0xM3x8Yz09Mjcpe1xuXHRcdFx0XHRcdFx0XHRjPTA7IC8vIE1vemlsbGEgY29uc2lkZXJzIEVOVEVSIGFuZCBFU0Mgbm9uLXByaW50YWJsZVxuXHRcdFx0XHRcdFx0fWVsc2UgaWYoYz09Myl7XG5cdFx0XHRcdFx0XHRcdGM9OTk7IC8vIE1vemlsbGEgbWFwcyBDVFJMLUJSRUFLIHRvIENUUkwtY1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gTW96aWxsYSBzZXRzIGtleUNvZGUgdG8gMCB3aGVuIHRoZXJlIGlzIGEgY2hhckNvZGVcblx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHN0b3BzIHRoZSBldmVudCBvbiBJRS5cblx0XHRcdFx0XHRcdGV2dC5jaGFyQ29kZSA9IGM7XG5cdFx0XHRcdFx0XHRfc2V0S2V5Q2hhcihldnQpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBldnQ7XG5cdFx0fTtcblx0XHR2YXIgbGFzdEV2ZW50LCBJRVNpZ25hbCA9IGZ1bmN0aW9uKGhhbmRsZSl7XG5cdFx0XHR0aGlzLmhhbmRsZSA9IGhhbmRsZTtcblx0XHR9O1xuXHRcdElFU2lnbmFsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpe1xuXHRcdFx0ZGVsZXRlIF9kb2pvSUVMaXN0ZW5lcnNfW3RoaXMuaGFuZGxlXTtcblx0XHR9O1xuXHRcdHZhciBmaXhMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKXtcblx0XHRcdC8vIHRoaXMgaXMgYSBtaW5pbWFsIGZ1bmN0aW9uIGZvciBjbG9zaW5nIG9uIHRoZSBwcmV2aW91cyBsaXN0ZW5lciB3aXRoIGFzIGZldyBhcyB2YXJpYWJsZXMgYXMgcG9zc2libGVcblx0XHRcdHJldHVybiBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRldnQgPSBvbi5fZml4RXZlbnQoZXZ0LCB0aGlzKTtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IGxpc3RlbmVyLmNhbGwodGhpcywgZXZ0KTtcblx0XHRcdFx0aWYoZXZ0Lm1vZGlmaWVkKXtcblx0XHRcdFx0XHQvLyBjYWNoZSB0aGUgbGFzdCBldmVudCBhbmQgcmV1c2UgaXQgaWYgd2UgY2FuXG5cdFx0XHRcdFx0aWYoIWxhc3RFdmVudCl7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdGxhc3RFdmVudCA9IG51bGw7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFzdEV2ZW50ID0gZXZ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0dmFyIGZpeEF0dGFjaCA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpe1xuXHRcdFx0bGlzdGVuZXIgPSBmaXhMaXN0ZW5lcihsaXN0ZW5lcik7XG5cdFx0XHRpZigoKHRhcmdldC5vd25lckRvY3VtZW50ID8gdGFyZ2V0Lm93bmVyRG9jdW1lbnQucGFyZW50V2luZG93IDogdGFyZ2V0LnBhcmVudFdpbmRvdyB8fCB0YXJnZXQud2luZG93IHx8IHdpbmRvdykgIT0gdG9wIHx8XG5cdFx0XHRcdFx0XHRoYXMoXCJqc2NyaXB0XCIpIDwgNS44KSAmJlxuXHRcdFx0XHRcdCFoYXMoXCJjb25maWctX2FsbG93X2xlYWtzXCIpKXtcblx0XHRcdFx0Ly8gSUUgd2lsbCBsZWFrIG1lbW9yeSBvbiBjZXJ0YWluIGhhbmRsZXJzIGluIGZyYW1lcyAoSUU4IGFuZCBlYXJsaWVyKSBhbmQgaW4gdW5hdHRhY2hlZCBET00gbm9kZXMgZm9yIEpTY3JpcHQgNS43IGFuZCBiZWxvdy5cblx0XHRcdFx0Ly8gSGVyZSB3ZSB1c2UgZ2xvYmFsIHJlZGlyZWN0aW9uIHRvIHNvbHZlIHRoZSBtZW1vcnkgbGVha3Ncblx0XHRcdFx0aWYodHlwZW9mIF9kb2pvSUVMaXN0ZW5lcnNfID09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdF9kb2pvSUVMaXN0ZW5lcnNfID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGVtaXR0ZXIgPSB0YXJnZXRbdHlwZV07XG5cdFx0XHRcdGlmKCFlbWl0dGVyIHx8ICFlbWl0dGVyLmxpc3RlbmVycyl7XG5cdFx0XHRcdFx0dmFyIG9sZExpc3RlbmVyID0gZW1pdHRlcjtcblx0XHRcdFx0XHRlbWl0dGVyID0gRnVuY3Rpb24oJ2V2ZW50JywgJ3ZhciBjYWxsZWUgPSBhcmd1bWVudHMuY2FsbGVlOyBmb3IodmFyIGkgPSAwOyBpPGNhbGxlZS5saXN0ZW5lcnMubGVuZ3RoOyBpKyspe3ZhciBsaXN0ZW5lciA9IF9kb2pvSUVMaXN0ZW5lcnNfW2NhbGxlZS5saXN0ZW5lcnNbaV1dOyBpZihsaXN0ZW5lcil7bGlzdGVuZXIuY2FsbCh0aGlzLGV2ZW50KTt9fScpO1xuXHRcdFx0XHRcdGVtaXR0ZXIubGlzdGVuZXJzID0gW107XG5cdFx0XHRcdFx0dGFyZ2V0W3R5cGVdID0gZW1pdHRlcjtcblx0XHRcdFx0XHRlbWl0dGVyLmdsb2JhbCA9IHRoaXM7XG5cdFx0XHRcdFx0aWYob2xkTGlzdGVuZXIpe1xuXHRcdFx0XHRcdFx0ZW1pdHRlci5saXN0ZW5lcnMucHVzaChfZG9qb0lFTGlzdGVuZXJzXy5wdXNoKG9sZExpc3RlbmVyKSAtIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgaGFuZGxlO1xuXHRcdFx0XHRlbWl0dGVyLmxpc3RlbmVycy5wdXNoKGhhbmRsZSA9IChlbWl0dGVyLmdsb2JhbC5fZG9qb0lFTGlzdGVuZXJzXy5wdXNoKGxpc3RlbmVyKSAtIDEpKTtcblx0XHRcdFx0cmV0dXJuIG5ldyBJRVNpZ25hbChoYW5kbGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFzcGVjdC5hZnRlcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcblx0XHR9O1xuXG5cdFx0dmFyIF9zZXRLZXlDaGFyID0gZnVuY3Rpb24oZXZ0KXtcblx0XHRcdGV2dC5rZXlDaGFyID0gZXZ0LmNoYXJDb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShldnQuY2hhckNvZGUpIDogJyc7XG5cdFx0XHRldnQuY2hhck9yQ29kZSA9IGV2dC5rZXlDaGFyIHx8IGV2dC5rZXlDb2RlO1x0Ly8gVE9ETzogcmVtb3ZlIGZvciAyLjBcblx0XHR9O1xuXHRcdC8vIENhbGxlZCBpbiBFdmVudCBzY29wZVxuXHRcdHZhciBzdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuXHRcdH07XG5cdFx0dmFyIHByZXZlbnREZWZhdWx0ID0gb24uX3ByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIFNldHRpbmcga2V5Q29kZSB0byAwIGlzIHRoZSBvbmx5IHdheSB0byBwcmV2ZW50IGNlcnRhaW4ga2V5cHJlc3NlcyAobmFtZWx5XG5cdFx0XHQvLyBjdHJsLWNvbWJpbmF0aW9ucyB0aGF0IGNvcnJlc3BvbmQgdG8gbWVudSBhY2NlbGVyYXRvciBrZXlzKS5cblx0XHRcdC8vIE90b2gsIGl0IHByZXZlbnRzIHVwc3RyZWFtIGxpc3RlbmVycyBmcm9tIGdldHRpbmcgdGhpcyBpbmZvcm1hdGlvblxuXHRcdFx0Ly8gVHJ5IHRvIHNwbGl0IHRoZSBkaWZmZXJlbmNlIGhlcmUgYnkgY2xvYmJlcmluZyBrZXlDb2RlIG9ubHkgZm9yIGN0cmxcblx0XHRcdC8vIGNvbWJpbmF0aW9ucy4gSWYgeW91IHN0aWxsIG5lZWQgdG8gYWNjZXNzIHRoZSBrZXkgdXBzdHJlYW0sIGJ1YmJsZWRLZXlDb2RlIGlzXG5cdFx0XHQvLyBwcm92aWRlZCBhcyBhIHdvcmthcm91bmQuXG5cdFx0XHR0aGlzLmJ1YmJsZWRLZXlDb2RlID0gdGhpcy5rZXlDb2RlO1xuXHRcdFx0aWYodGhpcy5jdHJsS2V5KXtcblx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdC8vIHNxdWVsY2ggZXJyb3JzIHdoZW4ga2V5Q29kZSBpcyByZWFkLW9ubHlcblx0XHRcdFx0XHQvLyAoZS5nLiBpZiBrZXlDb2RlIGlzIGN0cmwgb3Igc2hpZnQpXG5cdFx0XHRcdFx0dGhpcy5rZXlDb2RlID0gMDtcblx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5tb2RpZmllZCA9IHRydWU7IC8vIG1hcmsgaXQgYXMgbW9kaWZpZWQgIChmb3IgZGVmYXVsdFByZXZlbnRlZCBmbGFnKSBzbyB0aGUgZXZlbnQgd2lsbCBiZSBjYWNoZWQgaW4gSUVcblx0XHR9O1xuXHR9XG5cdGlmKGhhcyhcInRvdWNoXCIpKXtcblx0XHR2YXIgRXZlbnREZWxlZ2F0ZSA9IGZ1bmN0aW9uKCl7fTtcblx0XHR2YXIgd2luZG93T3JpZW50YXRpb24gPSB3aW5kb3cub3JpZW50YXRpb247XG5cdFx0dmFyIGZpeFRvdWNoTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcil7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24ob3JpZ2luYWxFdmVudCl7XG5cdFx0XHRcdC8vRXZlbnQgbm9ybWFsaXphdGlvbihmb3Igb250b3VjaHh4eCBhbmQgcmVzaXplKTpcblx0XHRcdFx0Ly8xLmluY29ycmVjdCBlLnBhZ2VYfHBhZ2VZIGluIGlPU1xuXHRcdFx0XHQvLzIudGhlcmUgYXJlIG5vIFwiZS5yb3RhdGlvblwiLCBcImUuc2NhbGVcIiBhbmQgXCJvbm9yaWVudGF0aW9uY2hhbmdlXCIgaW4gQW5kcm9pZFxuXHRcdFx0XHQvLzMuTW9yZSBUQkQgZS5nLiBmb3JjZSB8IHNjcmVlblggfCBzY3JlZW5YIHwgY2xpZW50WCB8IGNsaWVudFkgfCByYWRpdXNYIHwgcmFkaXVzWVxuXG5cdFx0XHRcdC8vIHNlZSBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNvcnJlY3RlZFxuXHRcdFx0XHR2YXIgZXZlbnQgPSBvcmlnaW5hbEV2ZW50LmNvcnJlY3RlZDtcblx0XHRcdFx0aWYoIWV2ZW50KXtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IG9yaWdpbmFsRXZlbnQudHlwZTtcblx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHRkZWxldGUgb3JpZ2luYWxFdmVudC50eXBlOyAvLyBvbiBzb21lIEpTIGVuZ2luZXMgKGFuZHJvaWQpLCBkZWxldGluZyBwcm9wZXJ0aWVzIG1ha2VzIHRoZW0gbXV0YWJsZVxuXHRcdFx0XHRcdH1jYXRjaChlKXt9XG5cdFx0XHRcdFx0aWYob3JpZ2luYWxFdmVudC50eXBlKXtcblx0XHRcdFx0XHRcdC8vIERlbGV0aW5nIHRoZSBwcm9wZXJ0eSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgZGlkIG5vdCB3b3JrICh0aGlzIGlzIHRoZSBjYXNlIG9mXG5cdFx0XHRcdFx0XHQvLyBicm93c2VycyBzdWNoIGFzIG9sZGVyIFNhZmFyaSBpT1MpLCBoZW5jZSBmYWxsYmFjazpcblx0XHRcdFx0XHRcdGlmKGhhcyhcInRvdWNoLWNhbi1tb2RpZnktZXZlbnQtZGVsZWdhdGVcIikpe1xuXHRcdFx0XHRcdFx0XHQvLyBJZiBkZWxldGluZyBwcm9wZXJ0aWVzIG9mIGRlbGVnYXRlZCBldmVudCB3b3JrcywgdXNlIGV2ZW50IGRlbGVnYXRpb246XG5cdFx0XHRcdFx0XHRcdEV2ZW50RGVsZWdhdGUucHJvdG90eXBlID0gb3JpZ2luYWxFdmVudDtcblx0XHRcdFx0XHRcdFx0ZXZlbnQgPSBuZXcgRXZlbnREZWxlZ2F0ZTtcblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UgbGFzdCBmYWxsYmFjazogb3RoZXIgYnJvd3NlcnMsIHN1Y2ggYXMgbW9iaWxlIEZpcmVmb3gsIGRvIG5vdCBsaWtlXG5cdFx0XHRcdFx0XHRcdC8vIGRlbGVnYXRlZCBwcm9wZXJ0aWVzLCBzbyB3ZSBoYXZlIHRvIGNvcHlcblx0XHRcdFx0XHRcdFx0ZXZlbnQgPSB7fTtcblx0XHRcdFx0XHRcdFx0Zm9yKHZhciBuYW1lIGluIG9yaWdpbmFsRXZlbnQpe1xuXHRcdFx0XHRcdFx0XHRcdGV2ZW50W25hbWVdID0gb3JpZ2luYWxFdmVudFtuYW1lXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gaGF2ZSB0byBkZWxlZ2F0ZSBtZXRob2RzIHRvIG1ha2UgdGhlbSB3b3JrXG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdC8vIGRlbGV0aW9uIHdvcmtlZCwgdXNlIHByb3BlcnR5IGFzIGlzXG5cdFx0XHRcdFx0XHRldmVudCA9IG9yaWdpbmFsRXZlbnQ7XG5cdFx0XHRcdFx0XHRldmVudC50eXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b3JpZ2luYWxFdmVudC5jb3JyZWN0ZWQgPSBldmVudDtcblx0XHRcdFx0XHRpZih0eXBlID09ICdyZXNpemUnKXtcblx0XHRcdFx0XHRcdGlmKHdpbmRvd09yaWVudGF0aW9uID09IHdpbmRvdy5vcmllbnRhdGlvbil7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsOy8vZG91YmxlIHRhcCBjYXVzZXMgYW4gdW5leHBlY3RlZCAncmVzaXplJyBpbiBBbmRyb2lkXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR3aW5kb3dPcmllbnRhdGlvbiA9IHdpbmRvdy5vcmllbnRhdGlvbjtcblx0XHRcdFx0XHRcdGV2ZW50LnR5cGUgPSBcIm9yaWVudGF0aW9uY2hhbmdlXCI7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFdlIHVzZSB0aGUgb3JpZ2luYWwgZXZlbnQgYW5kIGF1Z21lbnQsIHJhdGhlciB0aGFuIGRvaW5nIGFuIGV4cGVuc2l2ZSBtaXhpbiBvcGVyYXRpb25cblx0XHRcdFx0XHRpZighKFwicm90YXRpb25cIiBpbiBldmVudCkpeyAvLyB0ZXN0IHRvIHNlZSBpZiBpdCBoYXMgcm90YXRpb25cblx0XHRcdFx0XHRcdGV2ZW50LnJvdGF0aW9uID0gMDtcblx0XHRcdFx0XHRcdGV2ZW50LnNjYWxlID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHdpbmRvdy5Ub3VjaEV2ZW50ICYmIG9yaWdpbmFsRXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XG5cdFx0XHRcdFx0XHQvLyB1c2UgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVh8cGFnZVl8c2NyZWVuWHxzY3JlZW5ZfGNsaWVudFh8Y2xpZW50WXx0YXJnZXRcblx0XHRcdFx0XHRcdHZhciBmaXJzdENoYW5nZVRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cdFx0XHRcdFx0XHRmb3IodmFyIGkgaW4gZmlyc3RDaGFuZ2VUb3VjaCl7IC8vIHVzZSBmb3ItaW4sIHdlIGRvbid0IG5lZWQgdG8gaGF2ZSBkZXBlbmRlbmN5IG9uIGRvam8vX2Jhc2UvbGFuZyBoZXJlXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBldmVudFtpXTsgLy8gZGVsZXRlIGl0IGZpcnN0IHRvIG1ha2UgaXQgbXV0YWJsZVxuXHRcdFx0XHRcdFx0XHRldmVudFtpXSA9IGZpcnN0Q2hhbmdlVG91Y2hbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gb247XG59KTtcbiIsImRlZmluZShbXG5cdFwiLi4vX2Jhc2UvbGFuZ1wiXG5dLCBmdW5jdGlvbihsYW5nKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL3Byb21pc2UvUHJvbWlzZVxuXG5cdGZ1bmN0aW9uIHRocm93QWJzdHJhY3QoKXtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiYWJzdHJhY3RcIik7XG5cdH1cblxuXHRyZXR1cm4gbGFuZy5leHRlbmQoZnVuY3Rpb24gUHJvbWlzZSgpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhlIHB1YmxpYyBpbnRlcmZhY2UgdG8gYSBkZWZlcnJlZC5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRUaGUgcHVibGljIGludGVyZmFjZSB0byBhIGRlZmVycmVkLiBBbGwgcHJvbWlzZXMgaW4gRG9qbyBhcmVcblx0XHQvL1x0XHRpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy5cblx0fSwge1xuXHRcdHRoZW46IGZ1bmN0aW9uKGNhbGxiYWNrLCBlcnJiYWNrLCBwcm9nYmFjayl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0QWRkIG5ldyBjYWxsYmFja3MgdG8gdGhlIHByb21pc2UuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEFkZCBuZXcgY2FsbGJhY2tzIHRvIHRoZSBkZWZlcnJlZC4gQ2FsbGJhY2tzIGNhbiBiZSBhZGRlZFxuXHRcdFx0Ly9cdFx0YmVmb3JlIG9yIGFmdGVyIHRoZSBkZWZlcnJlZCBpcyBmdWxmaWxsZWQuXG5cdFx0XHQvLyBjYWxsYmFjazogRnVuY3Rpb24/XG5cdFx0XHQvL1x0XHRDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQuXG5cdFx0XHQvL1x0XHRSZWNlaXZlcyB0aGUgcmVzb2x1dGlvbiB2YWx1ZS5cblx0XHRcdC8vIGVycmJhY2s6IEZ1bmN0aW9uP1xuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuXHRcdFx0Ly9cdFx0UmVjZWl2ZXMgdGhlIHJlamVjdGlvbiBlcnJvci5cblx0XHRcdC8vIHByb2diYWNrOiBGdW5jdGlvbj9cblx0XHRcdC8vXHRcdENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgcHJvbWlzZSBlbWl0cyBhIHByb2dyZXNzXG5cdFx0XHQvL1x0XHR1cGRhdGUuIFJlY2VpdmVzIHRoZSBwcm9ncmVzcyB1cGRhdGUuXG5cdFx0XHQvLyByZXR1cm5zOiBkb2pvL3Byb21pc2UvUHJvbWlzZVxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIG5ldyBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjayhzKS5cblx0XHRcdC8vXHRcdFRoaXMgY2FuIGJlIHVzZWQgZm9yIGNoYWluaW5nIG1hbnkgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuXG5cblx0XHRcdHRocm93QWJzdHJhY3QoKTtcblx0XHR9LFxuXG5cdFx0Y2FuY2VsOiBmdW5jdGlvbihyZWFzb24sIHN0cmljdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0SW5mb3JtIHRoZSBkZWZlcnJlZCBpdCBtYXkgY2FuY2VsIGl0cyBhc3luY2hyb25vdXMgb3BlcmF0aW9uLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRJbmZvcm0gdGhlIGRlZmVycmVkIGl0IG1heSBjYW5jZWwgaXRzIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uXG5cdFx0XHQvL1x0XHRUaGUgZGVmZXJyZWQncyAob3B0aW9uYWwpIGNhbmNlbGVyIGlzIGludm9rZWQgYW5kIHRoZVxuXHRcdFx0Ly9cdFx0ZGVmZXJyZWQgd2lsbCBiZSBsZWZ0IGluIGEgcmVqZWN0ZWQgc3RhdGUuIENhbiBhZmZlY3Qgb3RoZXJcblx0XHRcdC8vXHRcdHByb21pc2VzIHRoYXQgb3JpZ2luYXRlIHdpdGggdGhlIHNhbWUgZGVmZXJyZWQuXG5cdFx0XHQvLyByZWFzb246IGFueVxuXHRcdFx0Ly9cdFx0QSBtZXNzYWdlIHRoYXQgbWF5IGJlIHNlbnQgdG8gdGhlIGRlZmVycmVkJ3MgY2FuY2VsZXIsXG5cdFx0XHQvL1x0XHRleHBsYWluaW5nIHdoeSBpdCdzIGJlaW5nIGNhbmNlbGVkLlxuXHRcdFx0Ly8gc3RyaWN0OiBCb29sZWFuP1xuXHRcdFx0Ly9cdFx0SWYgc3RyaWN0LCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBkZWZlcnJlZCBoYXMgYWxyZWFkeVxuXHRcdFx0Ly9cdFx0YmVlbiBmdWxmaWxsZWQgYW5kIGNvbnNlcXVlbnRseSBjYW5ub3QgYmUgY2FuY2VsZWQuXG5cdFx0XHQvLyByZXR1cm5zOiBhbnlcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIHJlamVjdGlvbiByZWFzb24gaWYgdGhlIGRlZmVycmVkIHdhcyBjYW5jZWxlZFxuXHRcdFx0Ly9cdFx0bm9ybWFsbHkuXG5cblx0XHRcdHRocm93QWJzdHJhY3QoKTtcblx0XHR9LFxuXG5cdFx0aXNSZXNvbHZlZDogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDaGVja3Mgd2hldGhlciB0aGUgcHJvbWlzZSBoYXMgYmVlbiByZXNvbHZlZC5cblx0XHRcdC8vIHJldHVybnM6IEJvb2xlYW5cblxuXHRcdFx0dGhyb3dBYnN0cmFjdCgpO1xuXHRcdH0sXG5cblx0XHRpc1JlamVjdGVkOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENoZWNrcyB3aGV0aGVyIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkLlxuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXG5cdFx0XHR0aHJvd0Fic3RyYWN0KCk7XG5cdFx0fSxcblxuXHRcdGlzRnVsZmlsbGVkOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENoZWNrcyB3aGV0aGVyIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlxuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXG5cdFx0XHR0aHJvd0Fic3RyYWN0KCk7XG5cdFx0fSxcblxuXHRcdGlzQ2FuY2VsZWQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIHdoZXRoZXIgdGhlIHByb21pc2UgaGFzIGJlZW4gY2FuY2VsZWQuXG5cdFx0XHQvLyByZXR1cm5zOiBCb29sZWFuXG5cblx0XHRcdHRocm93QWJzdHJhY3QoKTtcblx0XHR9LFxuXG5cdFx0YWx3YXlzOiBmdW5jdGlvbihjYWxsYmFja09yRXJyYmFjayl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0QWRkIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkXG5cdFx0XHQvL1x0XHRvciByZWplY3RlZC5cblx0XHRcdC8vIGNhbGxiYWNrT3JFcnJiYWNrOiBGdW5jdGlvbj9cblx0XHRcdC8vXHRcdEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIGJvdGggYXMgYSBjYWxsYmFjayBhbmQgZXJyYmFjay5cblx0XHRcdC8vIHJldHVybnM6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgbmV3IHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrL2VycmJhY2suXG5cblx0XHRcdHJldHVybiB0aGlzLnRoZW4oY2FsbGJhY2tPckVycmJhY2ssIGNhbGxiYWNrT3JFcnJiYWNrKTtcblx0XHR9LFxuXG5cdFx0XCJjYXRjaFwiOiBmdW5jdGlvbihlcnJiYWNrKXtcblx0XHQgICAgLy8gc3VtbWFyeTpcblx0XHQgICAgLy9cdFx0QWRkIG5ldyBlcnJiYWNrcyB0byB0aGUgcHJvbWlzZS4gRm9sbG93cyBFQ01BIHNwZWNpZmljYXRpb24gbmFtaW5nLlxuXHRcdCAgICAvLyBlcnJiYWNrOiBGdW5jdGlvbj9cblx0XHQgICAgLy9cdFx0Q2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuXHRcdCAgICAvLyByZXR1cm5zOiBkb2pvL3Byb21pc2UvUHJvbWlzZVxuXHRcdCAgICAvL1x0XHRSZXR1cm5zIGEgbmV3IHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgdGhlIGVycmJhY2suXG5cblx0XHQgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBlcnJiYWNrKTtcblx0XHR9LFxuXG5cdFx0b3RoZXJ3aXNlOiBmdW5jdGlvbihlcnJiYWNrKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBZGQgbmV3IGVycmJhY2tzIHRvIHRoZSBwcm9taXNlLlxuXHRcdFx0Ly8gZXJyYmFjazogRnVuY3Rpb24/XG5cdFx0XHQvL1x0XHRDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG5cdFx0XHQvLyByZXR1cm5zOiBkb2pvL3Byb21pc2UvUHJvbWlzZVxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIG5ldyBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBlcnJiYWNrLlxuXG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKG51bGwsIGVycmJhY2spO1xuXHRcdH0sXG5cblx0XHR0cmFjZTogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHR0cmFjZVJlamVjdGVkOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gcmV0dXJuczogc3RyaW5nXG5cdFx0XHQvL1x0XHRSZXR1cm5zIGBbb2JqZWN0IFByb21pc2VdYC5cblxuXHRcdFx0cmV0dXJuIFwiW29iamVjdCBQcm9taXNlXVwiO1xuXHRcdH1cblx0fSk7XG59KTtcbiIsImRlZmluZShbXG5cdFwiLi90cmFjZXJcIixcblx0XCIuLi9oYXNcIixcblx0XCIuLi9fYmFzZS9sYW5nXCIsXG5cdFwiLi4vX2Jhc2UvYXJyYXlcIlxuXSwgZnVuY3Rpb24odHJhY2VyLCBoYXMsIGxhbmcsIGFycmF5VXRpbCl7XG5cdGhhcy5hZGQoXCJjb25maWctdXNlRGVmZXJyZWRJbnN0cnVtZW50YXRpb25cIiwgXCJyZXBvcnQtdW5oYW5kbGVkLXJlamVjdGlvbnNcIik7XG5cblx0ZnVuY3Rpb24gbG9nRXJyb3IoZXJyb3IsIHJlamVjdGlvbiwgZGVmZXJyZWQpe1xuXHRcdGlmKGVycm9yICYmIGVycm9yLmxvZyA9PT0gZmFsc2Upe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgc3RhY2sgPSBcIlwiO1xuXHRcdGlmKGVycm9yICYmIGVycm9yLnN0YWNrKXtcblx0XHRcdHN0YWNrICs9IGVycm9yLnN0YWNrO1xuXHRcdH1cblx0XHRpZihyZWplY3Rpb24gJiYgcmVqZWN0aW9uLnN0YWNrKXtcblx0XHRcdHN0YWNrICs9IFwiXFxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgcmVqZWN0ZWRcIiArIHJlamVjdGlvbi5zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgxKS5qb2luKFwiXFxuXCIpLnJlcGxhY2UoL15cXHMrLywgXCIgXCIpO1xuXHRcdH1cblx0XHRpZihkZWZlcnJlZCAmJiBkZWZlcnJlZC5zdGFjayl7XG5cdFx0XHRzdGFjayArPSBcIlxcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgKyBkZWZlcnJlZC5zdGFjaztcblx0XHR9XG5cdFx0Y29uc29sZS5lcnJvcihlcnJvciwgc3RhY2spO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVwb3J0UmVqZWN0aW9ucyhlcnJvciwgaGFuZGxlZCwgcmVqZWN0aW9uLCBkZWZlcnJlZCl7XG5cdFx0aWYoIWhhbmRsZWQpe1xuXHRcdFx0bG9nRXJyb3IoZXJyb3IsIHJlamVjdGlvbiwgZGVmZXJyZWQpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBlcnJvcnMgPSBbXTtcblx0dmFyIGFjdGl2ZVRpbWVvdXQgPSBmYWxzZTtcblx0dmFyIHVuaGFuZGxlZFdhaXQgPSAxMDAwO1xuXHRmdW5jdGlvbiB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMoZXJyb3IsIGhhbmRsZWQsIHJlamVjdGlvbiwgZGVmZXJyZWQpe1xuXHRcdC8vIHRyeSB0byBmaW5kIHRoZSBleGlzdGluZyB0cmFja2luZyBvYmplY3Rcblx0XHRpZighYXJyYXlVdGlsLnNvbWUoZXJyb3JzLCBmdW5jdGlvbihvYmope1xuXHRcdFx0aWYob2JqLmVycm9yID09PSBlcnJvcil7XG5cdFx0XHRcdC8vIGZvdW5kIHRoZSB0cmFja2luZyBvYmplY3QgZm9yIHRoaXMgZXJyb3Jcblx0XHRcdFx0aWYoaGFuZGxlZCl7XG5cdFx0XHRcdFx0Ly8gaWYgaGFuZGxlZCwgdXBkYXRlIHRoZSBzdGF0ZVxuXHRcdFx0XHRcdG9iai5oYW5kbGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KSl7XG5cdFx0XHQvLyBubyB0cmFja2luZyBvYmplY3QgaGFzIGJlZW4gc2V0dXAsIGNyZWF0ZSBvbmVcblx0XHRcdGVycm9ycy5wdXNoKHtcblx0XHRcdFx0ZXJyb3I6IGVycm9yLFxuXHRcdFx0XHRyZWplY3Rpb246IHJlamVjdGlvbixcblx0XHRcdFx0aGFuZGxlZDogaGFuZGxlZCxcblx0XHRcdFx0ZGVmZXJyZWQ6IGRlZmVycmVkLFxuXHRcdFx0XHR0aW1lc3RhbXA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZighYWN0aXZlVGltZW91dCl7XG5cdFx0XHRhY3RpdmVUaW1lb3V0ID0gc2V0VGltZW91dChsb2dSZWplY3RlZCwgdW5oYW5kbGVkV2FpdCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbG9nUmVqZWN0ZWQoKXtcblx0XHR2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0dmFyIHJlcG9ydEJlZm9yZSA9IG5vdyAtIHVuaGFuZGxlZFdhaXQ7XG5cdFx0ZXJyb3JzID0gYXJyYXlVdGlsLmZpbHRlcihlcnJvcnMsIGZ1bmN0aW9uKG9iail7XG5cdFx0XHQvLyBvbmx5IHJlcG9ydCB0aGUgZXJyb3IgaWYgd2UgaGF2ZSB3YWl0ZWQgbG9uZyBlbm91Z2ggYW5kXG5cdFx0XHQvLyBpdCBoYXNuJ3QgYmVlbiBoYW5kbGVkXG5cdFx0XHRpZihvYmoudGltZXN0YW1wIDwgcmVwb3J0QmVmb3JlKXtcblx0XHRcdFx0aWYoIW9iai5oYW5kbGVkKXtcblx0XHRcdFx0XHRsb2dFcnJvcihvYmouZXJyb3IsIG9iai5yZWplY3Rpb24sIG9iai5kZWZlcnJlZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cblx0XHRpZihlcnJvcnMubGVuZ3RoKXtcblx0XHRcdGFjdGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGxvZ1JlamVjdGVkLCBlcnJvcnNbMF0udGltZXN0YW1wICsgdW5oYW5kbGVkV2FpdCAtIG5vdyk7XG5cdFx0fWVsc2V7XG5cdFx0XHRhY3RpdmVUaW1lb3V0ID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKERlZmVycmVkKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEluaXRpYWxpemUgaW5zdHJ1bWVudGF0aW9uIGZvciB0aGUgRGVmZXJyZWQgY2xhc3MuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0SW5pdGlhbGl6ZSBpbnN0cnVtZW50YXRpb24gZm9yIHRoZSBEZWZlcnJlZCBjbGFzcy5cblx0XHQvL1x0XHREb25lIGF1dG9tYXRpY2FsbHkgYnkgYGRvam8vRGVmZXJyZWRgIGlmIHRoZVxuXHRcdC8vXHRcdGBkZWZlcnJlZEluc3RydW1lbnRhdGlvbmAgYW5kIGB1c2VEZWZlcnJlZEluc3RydW1lbnRhdGlvbmBcblx0XHQvL1x0XHRjb25maWcgb3B0aW9ucyBhcmUgc2V0LlxuXHRcdC8vXG5cdFx0Ly9cdFx0U2V0cyB1cCBgZG9qby9wcm9taXNlL3RyYWNlcmAgdG8gbG9nIHRvIHRoZSBjb25zb2xlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0U2V0cyB1cCBpbnN0cnVtZW50YXRpb24gb2YgcmVqZWN0ZWQgZGVmZXJyZWRzIHNvIHVuaGFuZGxlZFxuXHRcdC8vXHRcdGVycm9ycyBhcmUgbG9nZ2VkIHRvIHRoZSBjb25zb2xlLlxuXG5cdFx0dmFyIHVzYWdlID0gaGFzKFwiY29uZmlnLXVzZURlZmVycmVkSW5zdHJ1bWVudGF0aW9uXCIpO1xuXHRcdGlmKHVzYWdlKXtcblx0XHRcdHRyYWNlci5vbihcInJlc29sdmVkXCIsIGxhbmcuaGl0Y2goY29uc29sZSwgXCJsb2dcIiwgXCJyZXNvbHZlZFwiKSk7XG5cdFx0XHR0cmFjZXIub24oXCJyZWplY3RlZFwiLCBsYW5nLmhpdGNoKGNvbnNvbGUsIFwibG9nXCIsIFwicmVqZWN0ZWRcIikpO1xuXHRcdFx0dHJhY2VyLm9uKFwicHJvZ3Jlc3NcIiwgbGFuZy5oaXRjaChjb25zb2xlLCBcImxvZ1wiLCBcInByb2dyZXNzXCIpKTtcblxuXHRcdFx0dmFyIGFyZ3MgPSBbXTtcblx0XHRcdGlmKHR5cGVvZiB1c2FnZSA9PT0gXCJzdHJpbmdcIil7XG5cdFx0XHRcdGFyZ3MgPSB1c2FnZS5zcGxpdChcIixcIik7XG5cdFx0XHRcdHVzYWdlID0gYXJncy5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYodXNhZ2UgPT09IFwicmVwb3J0LXJlamVjdGlvbnNcIil7XG5cdFx0XHRcdERlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZCA9IHJlcG9ydFJlamVjdGlvbnM7XG5cdFx0XHR9ZWxzZSBpZih1c2FnZSA9PT0gXCJyZXBvcnQtdW5oYW5kbGVkLXJlamVjdGlvbnNcIiB8fCB1c2FnZSA9PT0gdHJ1ZSB8fCB1c2FnZSA9PT0gMSl7XG5cdFx0XHRcdERlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZCA9IHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucztcblx0XHRcdFx0dW5oYW5kbGVkV2FpdCA9IHBhcnNlSW50KGFyZ3NbMF0sIDEwKSB8fCB1bmhhbmRsZWRXYWl0O1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGluc3RydW1lbnRhdGlvbiB1c2FnZSA8XCIgKyB1c2FnZSArIFwiPlwiKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59KTtcbiIsImRlZmluZShbXG5cdFwiLi4vX2Jhc2UvbGFuZ1wiLFxuXHRcIi4vUHJvbWlzZVwiLFxuXHRcIi4uL0V2ZW50ZWRcIlxuXSwgZnVuY3Rpb24obGFuZywgUHJvbWlzZSwgRXZlbnRlZCl7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9wcm9taXNlL3RyYWNlclxuXG5cdC8qPT09PT1cblx0cmV0dXJuIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRyYWNlIHByb21pc2UgZnVsZmlsbG1lbnQuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0VHJhY2UgcHJvbWlzZSBmdWxmaWxsbWVudC4gQ2FsbGluZyBgLnRyYWNlKClgIG9yIGAudHJhY2VFcnJvcigpYCBvbiBhXG5cdFx0Ly9cdFx0cHJvbWlzZSBlbmFibGVzIHRyYWNpbmcuIFdpbGwgZW1pdCBgcmVzb2x2ZWRgLCBgcmVqZWN0ZWRgIG9yIGBwcm9ncmVzc2Bcblx0XHQvL1x0XHRldmVudHMuXG5cblx0XHRvbjogZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFN1YnNjcmliZSB0byB0cmFjZXMuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFNlZSBgZG9qby9FdmVudGVkI29uKClgLlxuXHRcdFx0Ly8gdHlwZTogU3RyaW5nXG5cdFx0XHQvL1x0XHRgcmVzb2x2ZWRgLCBgcmVqZWN0ZWRgLCBvciBgcHJvZ3Jlc3NgXG5cdFx0XHQvLyBsaXN0ZW5lcjogRnVuY3Rpb25cblx0XHRcdC8vXHRcdFRoZSBsaXN0ZW5lciBpcyBwYXNzZWQgdGhlIHRyYWNlZCB2YWx1ZSBhbmQgYW55IGFyZ3VtZW50c1xuXHRcdFx0Ly9cdFx0dGhhdCB3ZXJlIHVzZWQgd2l0aCB0aGUgYC50cmFjZSgpYCBjYWxsLlxuXHRcdH1cblx0fTtcblx0PT09PT0qL1xuXG5cdHZhciBldmVudGVkID0gbmV3IEV2ZW50ZWQ7XG5cdHZhciBlbWl0ID0gZXZlbnRlZC5lbWl0O1xuXHRldmVudGVkLmVtaXQgPSBudWxsO1xuXHQvLyBFbWl0IGV2ZW50cyBhc3luY2hyb25vdXNseSBzaW5jZSB0aGV5IHNob3VsZCBub3QgY2hhbmdlIHRoZSBwcm9taXNlIHN0YXRlLlxuXHRmdW5jdGlvbiBlbWl0QXN5bmMoYXJncyl7XG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0ZW1pdC5hcHBseShldmVudGVkLCBhcmdzKTtcblx0XHR9LCAwKTtcblx0fVxuXG5cdFByb21pc2UucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24oKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRyYWNlIHRoZSBwcm9taXNlLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdFRyYWNpbmcgYWxsb3dzIHlvdSB0byB0cmFuc3BhcmVudGx5IGxvZyBwcm9ncmVzcyxcblx0XHQvL1x0XHRyZXNvbHV0aW9uIGFuZCByZWplY3Rpb24gb2YgcHJvbWlzZXMsIHdpdGhvdXQgYWZmZWN0aW5nIHRoZVxuXHRcdC8vXHRcdHByb21pc2UgaXRzZWxmLiBBbnkgYXJndW1lbnRzIHBhc3NlZCB0byBgdHJhY2UoKWAgYXJlXG5cdFx0Ly9cdFx0ZW1pdHRlZCBpbiB0cmFjZSBldmVudHMuIFNlZSBgZG9qby9wcm9taXNlL3RyYWNlcmAgb24gaG93XG5cdFx0Ly9cdFx0dG8gaGFuZGxlIHRyYWNlcy5cblx0XHQvLyByZXR1cm5zOiBkb2pvL3Byb21pc2UvUHJvbWlzZVxuXHRcdC8vXHRcdFRoZSBwcm9taXNlIGluc3RhbmNlIGB0cmFjZSgpYCBpcyBjYWxsZWQgb24uXG5cblx0XHR2YXIgYXJncyA9IGxhbmcuX3RvQXJyYXkoYXJndW1lbnRzKTtcblx0XHR0aGlzLnRoZW4oXG5cdFx0XHRmdW5jdGlvbih2YWx1ZSl7IGVtaXRBc3luYyhbXCJyZXNvbHZlZFwiLCB2YWx1ZV0uY29uY2F0KGFyZ3MpKTsgfSxcblx0XHRcdGZ1bmN0aW9uKGVycm9yKXsgZW1pdEFzeW5jKFtcInJlamVjdGVkXCIsIGVycm9yXS5jb25jYXQoYXJncykpOyB9LFxuXHRcdFx0ZnVuY3Rpb24odXBkYXRlKXsgZW1pdEFzeW5jKFtcInByb2dyZXNzXCIsIHVwZGF0ZV0uY29uY2F0KGFyZ3MpKTsgfVxuXHRcdCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0UHJvbWlzZS5wcm90b3R5cGUudHJhY2VSZWplY3RlZCA9IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUcmFjZSByZWplY3Rpb24gb2YgdGhlIHByb21pc2UuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0VHJhY2luZyBhbGxvd3MgeW91IHRvIHRyYW5zcGFyZW50bHkgbG9nIHByb2dyZXNzLFxuXHRcdC8vXHRcdHJlc29sdXRpb24gYW5kIHJlamVjdGlvbiBvZiBwcm9taXNlcywgd2l0aG91dCBhZmZlY3RpbmcgdGhlXG5cdFx0Ly9cdFx0cHJvbWlzZSBpdHNlbGYuIEFueSBhcmd1bWVudHMgcGFzc2VkIHRvIGB0cmFjZSgpYCBhcmVcblx0XHQvL1x0XHRlbWl0dGVkIGluIHRyYWNlIGV2ZW50cy4gU2VlIGBkb2pvL3Byb21pc2UvdHJhY2VyYCBvbiBob3dcblx0XHQvL1x0XHR0byBoYW5kbGUgdHJhY2VzLlxuXHRcdC8vIHJldHVybnM6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdFx0Ly9cdFx0VGhlIHByb21pc2UgaW5zdGFuY2UgYHRyYWNlUmVqZWN0ZWQoKWAgaXMgY2FsbGVkIG9uLlxuXG5cdFx0dmFyIGFyZ3MgPSBsYW5nLl90b0FycmF5KGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5vdGhlcndpc2UoZnVuY3Rpb24oZXJyb3Ipe1xuXHRcdFx0ZW1pdEFzeW5jKFtcInJlamVjdGVkXCIsIGVycm9yXS5jb25jYXQoYXJncykpO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdHJldHVybiBldmVudGVkO1xufSk7XG4iLCJkZWZpbmUoW1wiLi9fYmFzZS9rZXJuZWxcIiwgXCIuL2hhc1wiLCBcIi4vZG9tXCIsIFwiLi9vblwiLCBcIi4vX2Jhc2UvYXJyYXlcIiwgXCIuL19iYXNlL2xhbmdcIiwgXCIuL3NlbGVjdG9yL19sb2FkZXJcIiwgXCIuL3NlbGVjdG9yL19sb2FkZXIhZGVmYXVsdFwiXSxcblx0ZnVuY3Rpb24oZG9qbywgaGFzLCBkb20sIG9uLCBhcnJheSwgbGFuZywgbG9hZGVyLCBkZWZhdWx0RW5naW5lKXtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRoYXMuYWRkKFwiYXJyYXktZXh0ZW5zaWJsZVwiLCBmdW5jdGlvbigpe1xuXHRcdC8vIHRlc3QgdG8gc2VlIGlmIHdlIGNhbiBleHRlbmQgYW4gYXJyYXkgKG5vdCBzdXBwb3J0ZWQgaW4gb2xkIElFKVxuXHRcdHJldHVybiBsYW5nLmRlbGVnYXRlKFtdLCB7bGVuZ3RoOiAxfSkubGVuZ3RoID09IDEgJiYgIWhhcyhcImJ1Zy1mb3ItaW4tc2tpcHMtc2hhZG93ZWRcIik7XG5cdH0pO1xuXHRcblx0dmFyIGFwID0gQXJyYXkucHJvdG90eXBlLCBhcHMgPSBhcC5zbGljZSwgYXBjID0gYXAuY29uY2F0LCBmb3JFYWNoID0gYXJyYXkuZm9yRWFjaDtcblxuXHR2YXIgdG5sID0gZnVuY3Rpb24oLypBcnJheSovIGEsIC8qZG9qby9Ob2RlTGlzdD8qLyBwYXJlbnQsIC8qRnVuY3Rpb24/Ki8gTm9kZUxpc3RDdG9yKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdGRlY29yYXRlIGFuIGFycmF5IHRvIG1ha2UgaXQgbG9vayBsaWtlIGEgYGRvam8vTm9kZUxpc3RgLlxuXHRcdC8vIGE6XG5cdFx0Ly9cdFx0QXJyYXkgb2Ygbm9kZXMgdG8gZGVjb3JhdGUuXG5cdFx0Ly8gcGFyZW50OlxuXHRcdC8vXHRcdEFuIG9wdGlvbmFsIHBhcmVudCBOb2RlTGlzdCB0aGF0IGdlbmVyYXRlZCB0aGUgY3VycmVudFxuXHRcdC8vXHRcdGxpc3Qgb2Ygbm9kZXMuIFVzZWQgdG8gY2FsbCBfc3Rhc2goKSBzbyB0aGUgcGFyZW50IE5vZGVMaXN0XG5cdFx0Ly9cdFx0Y2FuIGJlIGFjY2Vzc2VkIHZpYSBlbmQoKSBsYXRlci5cblx0XHQvLyBOb2RlTGlzdEN0b3I6XG5cdFx0Ly9cdFx0QW4gb3B0aW9uYWwgY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gdXNlIGZvciBhbnlcblx0XHQvL1x0XHRuZXcgTm9kZUxpc3QgY2FsbHMuIFRoaXMgYWxsb3dzIGEgY2VydGFpbiBjaGFpbiBvZlxuXHRcdC8vXHRcdE5vZGVMaXN0IGNhbGxzIHRvIHVzZSBhIGRpZmZlcmVudCBvYmplY3QgdGhhbiBkb2pvL05vZGVMaXN0LlxuXHRcdHZhciBub2RlTGlzdCA9IG5ldyAoTm9kZUxpc3RDdG9yIHx8IHRoaXMuX05vZGVMaXN0Q3RvciB8fCBubCkoYSk7XG5cdFx0cmV0dXJuIHBhcmVudCA/IG5vZGVMaXN0Ll9zdGFzaChwYXJlbnQpIDogbm9kZUxpc3Q7XG5cdH07XG5cblx0dmFyIGxvb3BCb2R5ID0gZnVuY3Rpb24oZiwgYSwgbyl7XG5cdFx0YSA9IFswXS5jb25jYXQoYXBzLmNhbGwoYSwgMCkpO1xuXHRcdG8gPSBvIHx8IGRvam8uZ2xvYmFsO1xuXHRcdHJldHVybiBmdW5jdGlvbihub2RlKXtcblx0XHRcdGFbMF0gPSBub2RlO1xuXHRcdFx0cmV0dXJuIGYuYXBwbHkobywgYSk7XG5cdFx0fTtcblx0fTtcblxuXHQvLyBhZGFwdGVyc1xuXG5cdHZhciBhZGFwdEFzRm9yRWFjaCA9IGZ1bmN0aW9uKGYsIG8pe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0YWRhcHRzIGEgc2luZ2xlIG5vZGUgZnVuY3Rpb24gdG8gYmUgdXNlZCBpbiB0aGUgZm9yRWFjaC10eXBlXG5cdFx0Ly9cdFx0YWN0aW9ucy4gVGhlIGluaXRpYWwgb2JqZWN0IGlzIHJldHVybmVkIGZyb20gdGhlIHNwZWNpYWxpemVkXG5cdFx0Ly9cdFx0ZnVuY3Rpb24uXG5cdFx0Ly8gZjogRnVuY3Rpb25cblx0XHQvL1x0XHRhIGZ1bmN0aW9uIHRvIGFkYXB0XG5cdFx0Ly8gbzogT2JqZWN0P1xuXHRcdC8vXHRcdGFuIG9wdGlvbmFsIGNvbnRleHQgZm9yIGZcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuZm9yRWFjaChsb29wQm9keShmLCBhcmd1bWVudHMsIG8pKTtcblx0XHRcdHJldHVybiB0aGlzO1x0Ly8gT2JqZWN0XG5cdFx0fTtcblx0fTtcblxuXHR2YXIgYWRhcHRBc01hcCA9IGZ1bmN0aW9uKGYsIG8pe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0YWRhcHRzIGEgc2luZ2xlIG5vZGUgZnVuY3Rpb24gdG8gYmUgdXNlZCBpbiB0aGUgbWFwLXR5cGVcblx0XHQvL1x0XHRhY3Rpb25zLiBUaGUgcmV0dXJuIGlzIGEgbmV3IGFycmF5IG9mIHZhbHVlcywgYXMgdmlhIGBkb2pvL19iYXNlL2FycmF5Lm1hcGBcblx0XHQvLyBmOiBGdW5jdGlvblxuXHRcdC8vXHRcdGEgZnVuY3Rpb24gdG8gYWRhcHRcblx0XHQvLyBvOiBPYmplY3Q/XG5cdFx0Ly9cdFx0YW4gb3B0aW9uYWwgY29udGV4dCBmb3IgZlxuXHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMubWFwKGxvb3BCb2R5KGYsIGFyZ3VtZW50cywgbykpO1xuXHRcdH07XG5cdH07XG5cblx0dmFyIGFkYXB0QXNGaWx0ZXIgPSBmdW5jdGlvbihmLCBvKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdGFkYXB0cyBhIHNpbmdsZSBub2RlIGZ1bmN0aW9uIHRvIGJlIHVzZWQgaW4gdGhlIGZpbHRlci10eXBlIGFjdGlvbnNcblx0XHQvLyBmOiBGdW5jdGlvblxuXHRcdC8vXHRcdGEgZnVuY3Rpb24gdG8gYWRhcHRcblx0XHQvLyBvOiBPYmplY3Q/XG5cdFx0Ly9cdFx0YW4gb3B0aW9uYWwgY29udGV4dCBmb3IgZlxuXHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZmlsdGVyKGxvb3BCb2R5KGYsIGFyZ3VtZW50cywgbykpO1xuXHRcdH07XG5cdH07XG5cblx0dmFyIGFkYXB0V2l0aENvbmRpdGlvbiA9IGZ1bmN0aW9uKGYsIGcsIG8pe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0YWRhcHRzIGEgc2luZ2xlIG5vZGUgZnVuY3Rpb24gdG8gYmUgdXNlZCBpbiB0aGUgbWFwLXR5cGVcblx0XHQvL1x0XHRhY3Rpb25zLCBiZWhhdmVzIGxpa2UgZm9yRWFjaCgpIG9yIG1hcCgpIGRlcGVuZGluZyBvbiBhcmd1bWVudHNcblx0XHQvLyBmOiBGdW5jdGlvblxuXHRcdC8vXHRcdGEgZnVuY3Rpb24gdG8gYWRhcHRcblx0XHQvLyBnOiBGdW5jdGlvblxuXHRcdC8vXHRcdGEgY29uZGl0aW9uIGZ1bmN0aW9uLCBpZiB0cnVlIHJ1bnMgYXMgbWFwKCksIG90aGVyd2lzZSBydW5zIGFzIGZvckVhY2goKVxuXHRcdC8vIG86IE9iamVjdD9cblx0XHQvL1x0XHRhbiBvcHRpb25hbCBjb250ZXh0IGZvciBmIGFuZCBnXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgYSA9IGFyZ3VtZW50cywgYm9keSA9IGxvb3BCb2R5KGYsIGEsIG8pO1xuXHRcdFx0aWYoZy5jYWxsKG8gfHwgZG9qby5nbG9iYWwsIGEpKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGJvZHkpO1x0Ly8gc2VsZlxuXHRcdFx0fVxuXHRcdFx0dGhpcy5mb3JFYWNoKGJvZHkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XHQvLyBzZWxmXG5cdFx0fTtcblx0fTtcblxuXHR2YXIgTm9kZUxpc3QgPSBmdW5jdGlvbihhcnJheSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRBcnJheS1saWtlIG9iamVjdCB3aGljaCBhZGRzIHN5bnRhY3RpY1xuXHRcdC8vXHRcdHN1Z2FyIGZvciBjaGFpbmluZywgY29tbW9uIGl0ZXJhdGlvbiBvcGVyYXRpb25zLCBhbmltYXRpb24sIGFuZFxuXHRcdC8vXHRcdG5vZGUgbWFuaXB1bGF0aW9uLiBOb2RlTGlzdHMgYXJlIG1vc3Qgb2Z0ZW4gcmV0dXJuZWQgYXMgdGhlXG5cdFx0Ly9cdFx0cmVzdWx0IG9mIGRvam8vcXVlcnkoKSBjYWxscy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHROb2RlTGlzdCBpbnN0YW5jZXMgcHJvdmlkZSBtYW55IHV0aWxpdGllcyB0aGF0IHJlZmxlY3Rcblx0XHQvL1x0XHRjb3JlIERvam8gQVBJcyBmb3IgQXJyYXkgaXRlcmF0aW9uIGFuZCBtYW5pcHVsYXRpb24sIERPTVxuXHRcdC8vXHRcdG1hbmlwdWxhdGlvbiwgYW5kIGV2ZW50IGhhbmRsaW5nLiBJbnN0ZWFkIG9mIG5lZWRpbmcgdG8gZGlnIHVwXG5cdFx0Ly9cdFx0ZnVuY3Rpb25zIGluIHRoZSBkb2pvIHBhY2thZ2UsIE5vZGVMaXN0cyBnZW5lcmFsbHkgbWFrZSB0aGVcblx0XHQvL1x0XHRmdWxsIHBvd2VyIG9mIERvam8gYXZhaWxhYmxlIGZvciBET00gbWFuaXB1bGF0aW9uIHRhc2tzIGluIGFcblx0XHQvL1x0XHRzaW1wbGUsIGNoYWluYWJsZSB3YXkuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRjcmVhdGUgYSBub2RlIGxpc3QgZnJvbSBhIG5vZGVcblx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnlcIiwgXCJkb2pvL2RvbVwiXG5cdFx0Ly9cdFx0fFx0XSwgZnVuY3Rpb24ocXVlcnksIGRvbSl7XG5cdFx0Ly9cdFx0fFx0XHRxdWVyeS5Ob2RlTGlzdChkb20uYnlJZChcImZvb1wiKSk7XG5cdFx0Ly9cdFx0fFx0fSk7XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRnZXQgYSBOb2RlTGlzdCBmcm9tIGEgQ1NTIHF1ZXJ5IGFuZCBpdGVyYXRlIG9uIGl0XG5cdFx0Ly9cdFx0fFx0cmVxdWlyZShbXCJkb2pvL29uXCIsIFwiZG9qby9kb21cIlxuXHRcdC8vXHRcdHxcdF0sIGZ1bmN0aW9uKG9uLCBkb20pe1xuXHRcdC8vXHRcdHxcdFx0dmFyIGwgPSBxdWVyeShcIi50aGluZ2VyXCIpO1xuXHRcdC8vXHRcdHxcdFx0bC5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUsIGluZGV4LCBub2RlTGlzdCl7XG5cdFx0Ly9cdFx0fFx0XHRcdGNvbnNvbGUubG9nKGluZGV4LCBub2RlLmlubmVySFRNTCk7XG5cdFx0Ly9cdFx0fFx0XHR9KTtcblx0XHQvL1x0XHR8XHR9KTtcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdHVzZSBuYXRpdmUgYW5kIERvam8tcHJvdmlkZWQgYXJyYXkgbWV0aG9kcyB0byBtYW5pcHVsYXRlIGFcblx0XHQvL1x0XHROb2RlTGlzdCB3aXRob3V0IG5lZWRpbmcgdG8gdXNlIGRvam8uKiBmdW5jdGlvbnMgZXhwbGljaXRseTpcblx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnlcIiwgXCJkb2pvL2RvbS1jb25zdHJ1Y3RcIiwgXCJkb2pvL2RvbVwiXG5cdFx0Ly9cdFx0fFx0XSwgZnVuY3Rpb24ocXVlcnksIGRvbUNvbnN0cnVjdCwgZG9tKXtcblx0XHQvL1x0XHR8XHRcdHZhciBsID0gcXVlcnkoXCIudGhpbmdlclwiKTtcblx0XHQvL1x0XHR8XHRcdC8vIHNpbmNlIE5vZGVMaXN0cyBhcmUgcmVhbCBhcnJheXMsIHRoZXkgaGF2ZSBhIGxlbmd0aFxuXHRcdC8vXHRcdHxcdFx0Ly8gcHJvcGVydHkgdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSBhbmRcblx0XHQvL1x0XHR8XHRcdC8vIHB1c2gvcG9wL3NoaWZ0L3Vuc2hpZnQgbWV0aG9kc1xuXHRcdC8vXHRcdHxcdFx0Y29uc29sZS5sb2cobC5sZW5ndGgpO1xuXHRcdC8vXHRcdHxcdFx0bC5wdXNoKGRvbUNvbnN0cnVjdC5jcmVhdGUoXCJzcGFuXCIpKTtcblx0XHQvL1x0XHR8XG5cdFx0Ly9cdFx0fFx0XHQvLyBkb2pvJ3Mgbm9ybWFsaXplZCBhcnJheSBtZXRob2RzIHdvcmsgdG9vOlxuXHRcdC8vXHRcdHxcdFx0Y29uc29sZS5sb2coIGwuaW5kZXhPZihkb20uYnlJZChcImZvb1wiKSkgKTtcblx0XHQvL1x0XHR8XHRcdC8vIC4uLmluY2x1ZGluZyB0aGUgc3BlY2lhbCBcImZ1bmN0aW9uIGFzIHN0cmluZ1wiIHNob3J0aGFuZFxuXHRcdC8vXHRcdHxcdFx0Y29uc29sZS5sb2coIGwuZXZlcnkoXCJpdGVtLm5vZGVUeXBlID09IDFcIikgKTtcblx0XHQvL1x0XHR8XG5cdFx0Ly9cdFx0fFx0XHQvLyBOb2RlTGlzdHMgY2FuIGJlIFsuLl0gaW5kZXhlZCwgb3IgeW91IGNhbiB1c2UgdGhlIGF0KClcblx0XHQvL1x0XHR8XHRcdC8vIGZ1bmN0aW9uIHRvIGdldCBzcGVjaWZpYyBpdGVtcyB3cmFwcGVkIGluIGEgbmV3IE5vZGVMaXN0OlxuXHRcdC8vXHRcdHxcdFx0dmFyIG5vZGUgPSBsWzNdOyAvLyB0aGUgNHRoIGVsZW1lbnRcblx0XHQvL1x0XHR8XHRcdHZhciBuZXdMaXN0ID0gbC5hdCgxLCAzKTsgLy8gdGhlIDJuZCBhbmQgNHRoIGVsZW1lbnRzXG5cdFx0Ly9cdFx0fFx0fSk7XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRjaGFpbmFiaWxpdHkgaXMgYSBrZXkgYWR2YW50YWdlIG9mIE5vZGVMaXN0czpcblx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnlcIiwgXCJkb2pvL05vZGVMaXN0LWRvbVwiXG5cdFx0Ly9cdFx0fFx0XSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdC8vXHRcdHxcdFx0cXVlcnkoXCIudGhpbmdlclwiKVxuXHRcdC8vXHRcdHxcdFx0XHQub25jbGljayhmdW5jdGlvbihlKXsgLyogLi4uICovIH0pXG5cdFx0Ly9cdFx0fFx0XHRcdC5hdCgxLCAzLCA4KSAvLyBnZXQgYSBzdWJzZXRcblx0XHQvL1x0XHR8XHRcdFx0XHQuc3R5bGUoXCJwYWRkaW5nXCIsIFwiNXB4XCIpXG5cdFx0Ly9cdFx0fFx0XHRcdFx0LmZvckVhY2goY29uc29sZS5sb2cpO1xuXHRcdC8vXHRcdHxcdH0pO1xuXG5cdFx0dmFyIGlzTmV3ID0gdGhpcyBpbnN0YW5jZW9mIG5sICYmIGhhcyhcImFycmF5LWV4dGVuc2libGVcIik7XG5cdFx0aWYodHlwZW9mIGFycmF5ID09IFwibnVtYmVyXCIpe1xuXHRcdFx0YXJyYXkgPSBBcnJheShhcnJheSk7XG5cdFx0fVxuXHRcdHZhciBub2RlQXJyYXkgPSAoYXJyYXkgJiYgXCJsZW5ndGhcIiBpbiBhcnJheSkgPyBhcnJheSA6IGFyZ3VtZW50cztcblx0XHRpZihpc05ldyB8fCAhbm9kZUFycmF5LnNvcnQpe1xuXHRcdFx0Ly8gbWFrZSBzdXJlIGl0J3MgYSByZWFsIGFycmF5IGJlZm9yZSB3ZSBwYXNzIGl0IG9uIHRvIGJlIHdyYXBwZWQgXG5cdFx0XHR2YXIgdGFyZ2V0ID0gaXNOZXcgPyB0aGlzIDogW10sXG5cdFx0XHRcdGwgPSB0YXJnZXQubGVuZ3RoID0gbm9kZUFycmF5Lmxlbmd0aDtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspe1xuXHRcdFx0XHR0YXJnZXRbaV0gPSBub2RlQXJyYXlbaV07XG5cdFx0XHR9XG5cdFx0XHRpZihpc05ldyl7XG5cdFx0XHRcdC8vIGNhbGxlZCB3aXRoIG5ldyBvcGVyYXRvciwgdGhpcyBtZWFucyB3ZSBhcmUgZ29pbmcgdG8gdXNlIHRoaXMgaW5zdGFuY2UgYW5kIHB1c2hcblx0XHRcdFx0Ly8gdGhlIG5vZGVzIG9uIHRvIGl0LiBUaGlzIGlzIHVzdWFsbHkgbXVjaCBmYXN0ZXIgc2luY2UgdGhlIE5vZGVMaXN0IHByb3BlcnRpZXNcblx0XHRcdFx0Ly9cdGRvbid0IG5lZWQgdG8gYmUgY29waWVkICh1bmxlc3MgdGhlIGxpc3Qgb2Ygbm9kZXMgaXMgZXh0cmVtZWx5IGxhcmdlKS5cblx0XHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHRcdH1cblx0XHRcdG5vZGVBcnJheSA9IHRhcmdldDtcblx0XHR9XG5cdFx0Ly8gY2FsbGVkIHdpdGhvdXQgbmV3IG9wZXJhdG9yLCB1c2UgYSByZWFsIGFycmF5IGFuZCBjb3B5IHByb3RvdHlwZSBwcm9wZXJ0aWVzLFxuXHRcdC8vIHRoaXMgaXMgc2xvd2VyIGFuZCBleGlzdHMgZm9yIGJhY2stY29tcGF0LiBTaG91bGQgYmUgcmVtb3ZlZCBpbiAyLjAuXG5cdFx0bGFuZy5fbWl4aW4obm9kZUFycmF5LCBubHApO1xuXHRcdG5vZGVBcnJheS5fTm9kZUxpc3RDdG9yID0gZnVuY3Rpb24oYXJyYXkpe1xuXHRcdFx0Ly8gY2FsbCB3aXRob3V0IG5ldyBvcGVyYXRvciB0byBwcmVzZXJ2ZSBiYWNrLWNvbXBhdCBiZWhhdmlvclxuXHRcdFx0cmV0dXJuIG5sKGFycmF5KTtcblx0XHR9O1xuXHRcdHJldHVybiBub2RlQXJyYXk7XG5cdH07XG5cdFxuXHR2YXIgbmwgPSBOb2RlTGlzdCwgbmxwID0gbmwucHJvdG90eXBlID0gXG5cdFx0aGFzKFwiYXJyYXktZXh0ZW5zaWJsZVwiKSA/IFtdIDoge307Ly8gZXh0ZW5kIGFuIGFycmF5IGlmIGl0IGlzIGV4dGVuc2libGVcblxuXHQvLyBleHBvc2UgYWRhcHRlcnMgYW5kIHRoZSB3cmFwcGVyIGFzIHByaXZhdGUgZnVuY3Rpb25zXG5cblx0bmwuX3dyYXAgPSBubHAuX3dyYXAgPSB0bmw7XG5cdG5sLl9hZGFwdEFzTWFwID0gYWRhcHRBc01hcDtcblx0bmwuX2FkYXB0QXNGb3JFYWNoID0gYWRhcHRBc0ZvckVhY2g7XG5cdG5sLl9hZGFwdEFzRmlsdGVyICA9IGFkYXB0QXNGaWx0ZXI7XG5cdG5sLl9hZGFwdFdpdGhDb25kaXRpb24gPSBhZGFwdFdpdGhDb25kaXRpb247XG5cblx0Ly8gbWFzcyBhc3NpZ25tZW50XG5cblx0Ly8gYWRkIGFycmF5IHJlZGlyZWN0b3JzXG5cdGZvckVhY2goW1wic2xpY2VcIiwgXCJzcGxpY2VcIl0sIGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHZhciBmID0gYXBbbmFtZV07XG5cdFx0Ly9Vc2UgYSBjb3B5IG9mIHRoZSB0aGlzIGFycmF5IHZpYSB0aGlzLnNsaWNlKCkgdG8gYWxsb3cgLmVuZCgpIHRvIHdvcmsgcmlnaHQgaW4gdGhlIHNwbGljZSBjYXNlLlxuXHRcdC8vIENBTk5PVCBhcHBseSAuX3N0YXNoKCkvZW5kKCkgdG8gc3BsaWNlIHNpbmNlIGl0IGN1cnJlbnRseSBtb2RpZmllc1xuXHRcdC8vIHRoZSBleGlzdGluZyB0aGlzIGFycmF5IC0tIGl0IHdvdWxkIGJyZWFrIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgaWYgd2UgY29weSB0aGUgYXJyYXkgYmVmb3JlXG5cdFx0Ly8gdGhlIHNwbGljZSBzbyB0aGF0IHdlIGNhbiB1c2UgLmVuZCgpLiBTbyBvbmx5IGRvaW5nIHRoZSBzdGFzaCBvcHRpb24gdG8gdGhpcy5fd3JhcCBmb3Igc2xpY2UuXG5cdFx0bmxwW25hbWVdID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX3dyYXAoZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBuYW1lID09IFwic2xpY2VcIiA/IHRoaXMgOiBudWxsKTsgfTtcblx0fSk7XG5cdC8vIGNvbmNhdCBzaG91bGQgYmUgaGVyZSBidXQgc29tZSBicm93c2VycyB3aXRoIG5hdGl2ZSBOb2RlTGlzdCBoYXZlIHByb2JsZW1zIHdpdGggaXRcblxuXHQvLyBhZGQgYXJyYXkuanMgcmVkaXJlY3RvcnNcblx0Zm9yRWFjaChbXCJpbmRleE9mXCIsIFwibGFzdEluZGV4T2ZcIiwgXCJldmVyeVwiLCBcInNvbWVcIl0sIGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHZhciBmID0gYXJyYXlbbmFtZV07XG5cdFx0bmxwW25hbWVdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGYuYXBwbHkoZG9qbywgW3RoaXNdLmNvbmNhdChhcHMuY2FsbChhcmd1bWVudHMsIDApKSk7IH07XG5cdH0pO1xuXG5cdGxhbmcuZXh0ZW5kKE5vZGVMaXN0LCB7XG5cdFx0Ly8gY29weSB0aGUgY29uc3RydWN0b3JzXG5cdFx0Y29uc3RydWN0b3I6IG5sLFxuXHRcdF9Ob2RlTGlzdEN0b3I6IG5sLFxuXHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQXJyYXkucHJvdG90eXBlLnRvU3RyaW5nIGNhbid0IGJlIGFwcGxpZWQgdG8gb2JqZWN0cywgc28gd2UgdXNlIGpvaW5cblx0XHRcdHJldHVybiB0aGlzLmpvaW4oXCIsXCIpO1xuXHRcdH0sXG5cdFx0X3N0YXNoOiBmdW5jdGlvbihwYXJlbnQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdHByaXZhdGUgZnVuY3Rpb24gdG8gaG9sZCB0byBhIHBhcmVudCBOb2RlTGlzdC4gZW5kKCkgdG8gcmV0dXJuIHRoZSBwYXJlbnQgTm9kZUxpc3QuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdEhvdyB0byBtYWtlIGEgYGRvam8vTm9kZUxpc3RgIG1ldGhvZCB0aGF0IG9ubHkgcmV0dXJucyB0aGUgdGhpcmQgbm9kZSBpblxuXHRcdFx0Ly9cdFx0dGhlIGRvam8vTm9kZUxpc3QgYnV0IGFsbG93cyBhY2Nlc3MgdG8gdGhlIG9yaWdpbmFsIE5vZGVMaXN0IGJ5IHVzaW5nIHRoaXMuX3N0YXNoOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9xdWVyeVwiLCBcImRvam8vX2Jhc2UvbGFuZ1wiLCBcImRvam8vTm9kZUxpc3RcIiwgXCJkb2pvL05vZGVMaXN0LWRvbVwiXG5cdFx0XHQvL1x0fFx0XSwgZnVuY3Rpb24ocXVlcnksIGxhbmcpe1xuXHRcdFx0Ly9cdHxcdFx0bGFuZy5leHRlbmQoTm9kZUxpc3QsIHtcblx0XHRcdC8vXHR8XHRcdFx0dGhpcmQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvL1x0fFx0XHRcdFx0dmFyIG5ld05vZGVMaXN0ID0gTm9kZUxpc3QodGhpc1syXSk7XG5cdFx0XHQvL1x0fFx0XHRcdFx0cmV0dXJuIG5ld05vZGVMaXN0Ll9zdGFzaCh0aGlzKTtcblx0XHRcdC8vXHR8XHRcdFx0fVxuXHRcdFx0Ly9cdHxcdFx0fSk7XG5cdFx0XHQvL1x0fFx0XHQvLyB0aGVuIHNlZSBob3cgX3N0YXNoIGFwcGxpZXMgYSBzdWItbGlzdCwgdG8gYmUgLmVuZCgpJ2VkIG91dCBvZlxuXHRcdFx0Ly9cdHxcdFx0cXVlcnkoXCIuZm9vXCIpXG5cdFx0XHQvL1x0fFx0XHRcdC50aGlyZCgpXG5cdFx0XHQvL1x0fFx0XHRcdFx0LmFkZENsYXNzKFwidGhpcmRGb29cIilcblx0XHRcdC8vXHR8XHRcdFx0LmVuZCgpXG5cdFx0XHQvL1x0fFx0XHRcdC8vIGFjY2VzcyB0byB0aGUgb3JpZyAuZm9vIGxpc3Rcblx0XHRcdC8vXHR8XHRcdFx0LnJlbW92ZUNsYXNzKFwiZm9vXCIpXG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1xuXHRcdFx0dGhpcy5fcGFyZW50ID0gcGFyZW50O1xuXHRcdFx0cmV0dXJuIHRoaXM7IC8vIGRvam8vTm9kZUxpc3Rcblx0XHR9LFxuXG5cdFx0b246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdExpc3RlbiBmb3IgZXZlbnRzIG9uIHRoZSBub2RlcyBpbiB0aGUgTm9kZUxpc3QuIEJhc2ljIHVzYWdlIGlzOlxuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnlcIlxuXHRcdFx0Ly9cdFx0fFx0XSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdFx0Ly9cdFx0fFx0XHRxdWVyeShcIi5teS1jbGFzc1wiKS5vbihcImNsaWNrXCIsIGxpc3RlbmVyKTtcblx0XHRcdC8vXHRcdFx0VGhpcyBzdXBwb3J0cyBldmVudCBkZWxlZ2F0aW9uIGJ5IHVzaW5nIHNlbGVjdG9ycyBhcyB0aGUgZmlyc3QgYXJndW1lbnQgd2l0aCB0aGUgZXZlbnQgbmFtZXMgYXNcblx0XHRcdC8vXHRcdFx0cHNldWRvIHNlbGVjdG9ycy4gRm9yIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHR8IFx0XHRxdWVyeShcIiNteS1saXN0XCIpLm9uKFwibGk6Y2xpY2tcIiwgbGlzdGVuZXIpO1xuXHRcdFx0Ly9cdFx0XHRUaGlzIHdpbGwgbGlzdGVuIGZvciBjbGljayBldmVudHMgd2l0aGluIGA8bGk+YCBlbGVtZW50cyB0aGF0IGFyZSBpbnNpZGUgdGhlIGAjbXktbGlzdGAgZWxlbWVudC5cblx0XHRcdC8vXHRcdFx0QmVjYXVzZSBvbiBzdXBwb3J0cyBDU1Mgc2VsZWN0b3Igc3ludGF4LCB3ZSBjYW4gdXNlIGNvbW1hLWRlbGltaXRlZCBldmVudHMgYXMgd2VsbDpcblx0XHRcdC8vXHRcdHwgXHRcdHF1ZXJ5KFwiI215LWxpc3RcIikub24oXCJsaSBidXR0b246bW91c2VvdmVyLCBsaTpjbGlja1wiLCBsaXN0ZW5lcik7XG5cdFx0XHQvL1x0XHR8XHR9KTtcblx0XHRcdHZhciBoYW5kbGVzID0gdGhpcy5tYXAoZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdHJldHVybiBvbihub2RlLCBldmVudE5hbWUsIGxpc3RlbmVyKTsgLy8gVE9ETzogYXBwbHkgdG8gdGhlIE5vZGVMaXN0IHNvIHRoZSBzYW1lIHNlbGVjdG9yIGVuZ2luZSBpcyB1c2VkIGZvciBtYXRjaGVzXG5cdFx0XHR9KTtcblx0XHRcdGhhbmRsZXMucmVtb3ZlID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGhhbmRsZXMubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdGhhbmRsZXNbaV0ucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gaGFuZGxlcztcblx0XHR9LFxuXG5cdFx0ZW5kOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEVuZHMgdXNlIG9mIHRoZSBjdXJyZW50IGBOb2RlTGlzdGAgYnkgcmV0dXJuaW5nIHRoZSBwcmV2aW91cyBOb2RlTGlzdFxuXHRcdFx0Ly9cdFx0dGhhdCBnZW5lcmF0ZWQgdGhlIGN1cnJlbnQgTm9kZUxpc3QuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIGBOb2RlTGlzdGAgdGhhdCBnZW5lcmF0ZWQgdGhlIGN1cnJlbnQgYE5vZGVMaXN0YC4gSWYgdGhlcmVcblx0XHRcdC8vXHRcdGlzIG5vIHBhcmVudCBOb2RlTGlzdCwgYW4gZW1wdHkgTm9kZUxpc3QgaXMgcmV0dXJuZWQuXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9xdWVyeVwiLCBcImRvam8vTm9kZUxpc3QtZG9tXCJcblx0XHRcdC8vXHR8XHRdLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0XHQvL1x0fFx0XHRxdWVyeShcImFcIilcblx0XHRcdC8vXHR8XHRcdFx0LmZpbHRlcihcIi5kaXNhYmxlZFwiKVxuXHRcdFx0Ly9cdHxcdFx0XHRcdC8vIG9wZXJhdGUgb24gdGhlIGFuY2hvcnMgdGhhdCBvbmx5IGhhdmUgYSBkaXNhYmxlZCBjbGFzc1xuXHRcdFx0Ly9cdHxcdFx0XHRcdC5zdHlsZShcImNvbG9yXCIsIFwiZ3JleVwiKVxuXHRcdFx0Ly9cdHxcdFx0XHQuZW5kKClcblx0XHRcdC8vXHR8XHRcdFx0Ly8ganVtcCBiYWNrIHRvIHRoZSBsaXN0IG9mIGFuY2hvcnNcblx0XHRcdC8vXHR8XHRcdFx0LnN0eWxlKC4uLilcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXG5cdFx0XHRpZih0aGlzLl9wYXJlbnQpe1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGFyZW50O1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vSnVzdCByZXR1cm4gZW1wdHkgbGlzdC5cblx0XHRcdFx0cmV0dXJuIG5ldyB0aGlzLl9Ob2RlTGlzdEN0b3IoMCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIGh0dHA6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZTpHbG9iYWxfT2JqZWN0czpBcnJheSNNZXRob2RzXG5cblx0XHQvLyBGSVhNRTogaGFuZGxlIHJldHVybiB2YWx1ZXMgZm9yICMzMjQ0XG5cdFx0Ly9cdFx0aHR0cDovL3RyYWMuZG9qb3Rvb2xraXQub3JnL3RpY2tldC8zMjQ0XG5cblx0XHQvLyBGSVhNRTpcblx0XHQvL1x0XHRuZWVkIHRvIHdyYXAgb3IgaW1wbGVtZW50OlxuXHRcdC8vXHRcdFx0am9pbiAocGVyaGFwcyB3LyBpbm5lckhUTUwvb3V0ZXJIVE1MIG92ZXJsb2FkIGZvciB0b1N0cmluZygpIG9mIGl0ZW1zPylcblx0XHQvL1x0XHRcdHJlZHVjZVxuXHRcdC8vXHRcdFx0cmVkdWNlUmlnaHRcblxuXHRcdC8qPT09PT1cblx0XHRzbGljZTogZnVuY3Rpb24oYmVnaW4sIGVuZCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIG5ldyBOb2RlTGlzdCwgbWFpbnRhaW5pbmcgdGhpcyBvbmUgaW4gcGxhY2Vcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0VGhpcyBtZXRob2QgYmVoYXZlcyBleGFjdGx5IGxpa2UgdGhlIEFycmF5LnNsaWNlIG1ldGhvZFxuXHRcdFx0Ly9cdFx0d2l0aCB0aGUgY2F2ZWF0IHRoYXQgaXQgcmV0dXJucyBhIGBkb2pvL05vZGVMaXN0YCBhbmQgbm90IGFcblx0XHRcdC8vXHRcdHJhdyBBcnJheS4gRm9yIG1vcmUgZGV0YWlscywgc2VlIE1vemlsbGEncyBbc2xpY2Vcblx0XHRcdC8vXHRcdGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NsaWNlKVxuXHRcdFx0Ly8gYmVnaW46IEludGVnZXJcblx0XHRcdC8vXHRcdENhbiBiZSBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIsIHdpdGggcG9zaXRpdmVcblx0XHRcdC8vXHRcdGludGVnZXJzIG5vdGluZyB0aGUgb2Zmc2V0IHRvIGJlZ2luIGF0LCBhbmQgbmVnYXRpdmVcblx0XHRcdC8vXHRcdGludGVnZXJzIGRlbm90aW5nIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgKGkuZS4sIHRvIHRoZSBsZWZ0XG5cdFx0XHQvL1x0XHRvZiB0aGUgZW5kKVxuXHRcdFx0Ly8gZW5kOiBJbnRlZ2VyP1xuXHRcdFx0Ly9cdFx0T3B0aW9uYWwgcGFyYW1ldGVyIHRvIGRlc2NyaWJlIHdoYXQgcG9zaXRpb24gcmVsYXRpdmUgdG9cblx0XHRcdC8vXHRcdHRoZSBOb2RlTGlzdCdzIHplcm8gaW5kZXggdG8gZW5kIHRoZSBzbGljZSBhdC4gTGlrZSBiZWdpbixcblx0XHRcdC8vXHRcdGNhbiBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZS5cblx0XHRcdHJldHVybiB0aGlzLl93cmFwKGEuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdFx0fSxcblxuXHRcdHNwbGljZTogZnVuY3Rpb24oaW5kZXgsIGhvd21hbnksIGl0ZW0pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgYSBuZXcgTm9kZUxpc3QsIG1hbmlwdWxhdGluZyB0aGlzIE5vZGVMaXN0IGJhc2VkIG9uXG5cdFx0XHQvL1x0XHR0aGUgYXJndW1lbnRzIHBhc3NlZCwgcG90ZW50aWFsbHkgc3BsaWNpbmcgaW4gbmV3IGVsZW1lbnRzXG5cdFx0XHQvL1x0XHRhdCBhbiBvZmZzZXQsIG9wdGlvbmFsbHkgZGVsZXRpbmcgZWxlbWVudHNcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0VGhpcyBtZXRob2QgYmVoYXZlcyBleGFjdGx5IGxpa2UgdGhlIEFycmF5LnNwbGljZSBtZXRob2Rcblx0XHRcdC8vXHRcdHdpdGggdGhlIGNhdmVhdCB0aGF0IGl0IHJldHVybnMgYSBgZG9qby9Ob2RlTGlzdGAgYW5kIG5vdCBhXG5cdFx0XHQvL1x0XHRyYXcgQXJyYXkuIEZvciBtb3JlIGRldGFpbHMsIHNlZSBNb3ppbGxhJ3MgW3NwbGljZVxuXHRcdFx0Ly9cdFx0ZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc3BsaWNlKVxuXHRcdFx0Ly9cdFx0Rm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBjYWxsaW5nIC5lbmQoKSBvbiB0aGUgc3BsaWNlZCBOb2RlTGlzdFxuXHRcdFx0Ly9cdFx0ZG9lcyBub3QgcmV0dXJuIHRoZSBvcmlnaW5hbCBOb2RlTGlzdCAtLSBzcGxpY2UgYWx0ZXJzIHRoZSBOb2RlTGlzdCBpbiBwbGFjZS5cblx0XHRcdC8vIGluZGV4OiBJbnRlZ2VyXG5cdFx0XHQvL1x0XHRiZWdpbiBjYW4gYmUgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyLCB3aXRoIHBvc2l0aXZlXG5cdFx0XHQvL1x0XHRpbnRlZ2VycyBub3RpbmcgdGhlIG9mZnNldCB0byBiZWdpbiBhdCwgYW5kIG5lZ2F0aXZlXG5cdFx0XHQvL1x0XHRpbnRlZ2VycyBkZW5vdGluZyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIChpLmUuLCB0byB0aGUgbGVmdFxuXHRcdFx0Ly9cdFx0b2YgdGhlIGVuZClcblx0XHRcdC8vIGhvd21hbnk6IEludGVnZXI/XG5cdFx0XHQvL1x0XHRPcHRpb25hbCBwYXJhbWV0ZXIgdG8gZGVzY3JpYmUgd2hhdCBwb3NpdGlvbiByZWxhdGl2ZSB0b1xuXHRcdFx0Ly9cdFx0dGhlIE5vZGVMaXN0J3MgemVybyBpbmRleCB0byBlbmQgdGhlIHNsaWNlIGF0LiBMaWtlIGJlZ2luLFxuXHRcdFx0Ly9cdFx0Y2FuIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLlxuXHRcdFx0Ly8gaXRlbTogT2JqZWN0Li4uP1xuXHRcdFx0Ly9cdFx0QW55IG51bWJlciBvZiBvcHRpb25hbCBwYXJhbWV0ZXJzIG1heSBiZSBwYXNzZWQgaW4gdG8gYmVcblx0XHRcdC8vXHRcdHNwbGljZWQgaW50byB0aGUgTm9kZUxpc3Rcblx0XHRcdHJldHVybiB0aGlzLl93cmFwKGEuc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1x0Ly8gZG9qby9Ob2RlTGlzdFxuXHRcdH0sXG5cblx0XHRpbmRleE9mOiBmdW5jdGlvbih2YWx1ZSwgZnJvbUluZGV4KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRzZWUgYGRvam8vX2Jhc2UvYXJyYXkuaW5kZXhPZigpYC4gVGhlIHByaW1hcnkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoZSBhY3RlZC1vblxuXHRcdFx0Ly9cdFx0YXJyYXkgaXMgaW1wbGljaXRseSB0aGlzIE5vZGVMaXN0XG5cdFx0XHQvLyB2YWx1ZTogT2JqZWN0XG5cdFx0XHQvL1x0XHRUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cblx0XHRcdC8vIGZyb21JbmRleDogSW50ZWdlcj9cblx0XHRcdC8vXHRcdFRoZSBsb2NhdGlvbiB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS4gT3B0aW9uYWwuIERlZmF1bHRzIHRvIDAuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEZvciBtb3JlIGRldGFpbHMgb24gdGhlIGJlaGF2aW9yIG9mIGluZGV4T2YsIHNlZSBNb3ppbGxhJ3Ncblx0XHRcdC8vXHRcdFtpbmRleE9mXG5cdFx0XHQvL1x0XHRkb2NzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mKVxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdFBvc2l0aXZlIEludGVnZXIgb3IgMCBmb3IgYSBtYXRjaCwgLTEgb2Ygbm90IGZvdW5kLlxuXHRcdFx0cmV0dXJuIGQuaW5kZXhPZih0aGlzLCB2YWx1ZSwgZnJvbUluZGV4KTsgLy8gSW50ZWdlclxuXHRcdH0sXG5cblx0XHRsYXN0SW5kZXhPZjogZnVuY3Rpb24odmFsdWUsIGZyb21JbmRleCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0c2VlIGBkb2pvL19iYXNlL2FycmF5Lmxhc3RJbmRleE9mKClgLiBUaGUgcHJpbWFyeSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhlXG5cdFx0XHQvL1x0XHRhY3RlZC1vbiBhcnJheSBpcyBpbXBsaWNpdGx5IHRoaXMgTm9kZUxpc3Rcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0Rm9yIG1vcmUgZGV0YWlscyBvbiB0aGUgYmVoYXZpb3Igb2YgbGFzdEluZGV4T2YsIHNlZVxuXHRcdFx0Ly9cdFx0TW96aWxsYSdzIFtsYXN0SW5kZXhPZlxuXHRcdFx0Ly9cdFx0ZG9jc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGFzdEluZGV4T2YpXG5cdFx0XHQvLyB2YWx1ZTogT2JqZWN0XG5cdFx0XHQvL1x0XHRUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cblx0XHRcdC8vIGZyb21JbmRleDogSW50ZWdlcj9cblx0XHRcdC8vXHRcdFRoZSBsb2NhdGlvbiB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS4gT3B0aW9uYWwuIERlZmF1bHRzIHRvIDAuXG5cdFx0XHQvLyByZXR1cm5zOlxuXHRcdFx0Ly9cdFx0UG9zaXRpdmUgSW50ZWdlciBvciAwIGZvciBhIG1hdGNoLCAtMSBvZiBub3QgZm91bmQuXG5cdFx0XHRyZXR1cm4gZC5sYXN0SW5kZXhPZih0aGlzLCB2YWx1ZSwgZnJvbUluZGV4KTsgLy8gSW50ZWdlclxuXHRcdH0sXG5cblx0XHRldmVyeTogZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNPYmplY3Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdHNlZSBgZG9qby9fYmFzZS9hcnJheS5ldmVyeSgpYCBhbmQgdGhlIFtBcnJheS5ldmVyeVxuXHRcdFx0Ly9cdFx0ZG9jc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZXZlcnkpLlxuXHRcdFx0Ly9cdFx0VGFrZXMgdGhlIHNhbWUgc3RydWN0dXJlIG9mIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhc1xuXHRcdFx0Ly9cdFx0ZG9qby9fYmFzZS9hcnJheS5ldmVyeSgpIHdpdGggdGhlIGNhdmVhdCB0aGF0IHRoZSBwYXNzZWQgYXJyYXkgaXNcblx0XHRcdC8vXHRcdGltcGxpY2l0bHkgdGhpcyBOb2RlTGlzdFxuXHRcdFx0Ly8gY2FsbGJhY2s6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHR0aGUgY2FsbGJhY2tcblx0XHRcdC8vIHRoaXNPYmplY3Q6IE9iamVjdD9cblx0XHRcdC8vXHRcdHRoZSBjb250ZXh0XG5cdFx0XHRyZXR1cm4gZC5ldmVyeSh0aGlzLCBjYWxsYmFjaywgdGhpc09iamVjdCk7IC8vIEJvb2xlYW5cblx0XHR9LFxuXG5cdFx0c29tZTogZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNPYmplY3Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRha2VzIHRoZSBzYW1lIHN0cnVjdHVyZSBvZiBhcmd1bWVudHMgYW5kIHJldHVybnMgYXNcblx0XHRcdC8vXHRcdGBkb2pvL19iYXNlL2FycmF5LnNvbWUoKWAgd2l0aCB0aGUgY2F2ZWF0IHRoYXQgdGhlIHBhc3NlZCBhcnJheSBpc1xuXHRcdFx0Ly9cdFx0aW1wbGljaXRseSB0aGlzIE5vZGVMaXN0LiAgU2VlIGBkb2pvL19iYXNlL2FycmF5LnNvbWUoKWAgYW5kIE1vemlsbGEnc1xuXHRcdFx0Ly9cdFx0W0FycmF5LnNvbWVcblx0XHRcdC8vXHRcdGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWUpLlxuXHRcdFx0Ly8gY2FsbGJhY2s6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHR0aGUgY2FsbGJhY2tcblx0XHRcdC8vIHRoaXNPYmplY3Q6IE9iamVjdD9cblx0XHRcdC8vXHRcdHRoZSBjb250ZXh0XG5cdFx0XHRyZXR1cm4gZC5zb21lKHRoaXMsIGNhbGxiYWNrLCB0aGlzT2JqZWN0KTsgLy8gQm9vbGVhblxuXHRcdH0sXG5cdFx0PT09PT0qL1xuXG5cdFx0Y29uY2F0OiBmdW5jdGlvbihpdGVtKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgbmV3IE5vZGVMaXN0IGNvbXByaXNlZCBvZiBpdGVtcyBpbiB0aGlzIE5vZGVMaXN0XG5cdFx0XHQvL1x0XHRhcyB3ZWxsIGFzIGl0ZW1zIHBhc3NlZCBpbiBhcyBwYXJhbWV0ZXJzXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoaXMgbWV0aG9kIGJlaGF2ZXMgZXhhY3RseSBsaWtlIHRoZSBBcnJheS5jb25jYXQgbWV0aG9kXG5cdFx0XHQvL1x0XHR3aXRoIHRoZSBjYXZlYXQgdGhhdCBpdCByZXR1cm5zIGEgYE5vZGVMaXN0YCBhbmQgbm90IGFcblx0XHRcdC8vXHRcdHJhdyBBcnJheS4gRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBbQXJyYXkuY29uY2F0XG5cdFx0XHQvL1x0XHRkb2NzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9jb25jYXQpXG5cdFx0XHQvLyBpdGVtOiBPYmplY3Q/XG5cdFx0XHQvL1x0XHRBbnkgbnVtYmVyIG9mIG9wdGlvbmFsIHBhcmFtZXRlcnMgbWF5IGJlIHBhc3NlZCBpbiB0byBiZVxuXHRcdFx0Ly9cdFx0c3BsaWNlZCBpbnRvIHRoZSBOb2RlTGlzdFxuXG5cdFx0XHQvL3JldHVybiB0aGlzLl93cmFwKGFwYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0XHRcdC8vIHRoZSBsaW5lIGFib3ZlIHdvbid0IHdvcmsgZm9yIHRoZSBuYXRpdmUgTm9kZUxpc3QsIG9yIGZvciBEb2pvIE5vZGVMaXN0cyBlaXRoZXIgOi0oXG5cblx0XHRcdC8vIGltcGxlbWVudGF0aW9uIG5vdGVzOlxuXHRcdFx0Ly8gQXJyYXkuY29uY2F0KCkgZG9lc24ndCByZWNvZ25pemUgbmF0aXZlIE5vZGVMaXN0cyBvciBEb2pvIE5vZGVMaXN0c1xuXHRcdFx0Ly8gYXMgYXJyYXlzLCBhbmQgc28gZG9lcyBub3QgaW5saW5lIHRoZW0gaW50byBhIHVuaW9uZWQgYXJyYXksIGJ1dFxuXHRcdFx0Ly8gYXBwZW5kcyB0aGVtIGFzIHNpbmdsZSBlbnRpdGllcy4gQm90aCB0aGUgb3JpZ2luYWwgTm9kZUxpc3QgYW5kIHRoZVxuXHRcdFx0Ly8gaXRlbXMgcGFzc2VkIGluIGFzIHBhcmFtZXRlcnMgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gcmF3IEFycmF5c1xuXHRcdFx0Ly8gYW5kIHRoZW4gdGhlIGNvbmNhdGVuYXRpb24gcmVzdWx0IG1heSBiZSByZS1fd3JhcCgpZWQgYXMgYSBEb2pvIE5vZGVMaXN0LlxuXG5cdFx0XHR2YXIgdCA9IGFwcy5jYWxsKHRoaXMsIDApLFxuXHRcdFx0XHRtID0gYXJyYXkubWFwKGFyZ3VtZW50cywgZnVuY3Rpb24oYSl7XG5cdFx0XHRcdFx0cmV0dXJuIGFwcy5jYWxsKGEsIDApO1xuXHRcdFx0XHR9KTtcblx0XHRcdHJldHVybiB0aGlzLl93cmFwKGFwYy5hcHBseSh0LCBtKSwgdGhpcyk7XHQvLyBkb2pvL05vZGVMaXN0XG5cdFx0fSxcblxuXHRcdG1hcDogZnVuY3Rpb24oLypGdW5jdGlvbiovIGZ1bmMsIC8qRnVuY3Rpb24/Ki8gb2JqKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRzZWUgYGRvam8vX2Jhc2UvYXJyYXkubWFwKClgLiBUaGUgcHJpbWFyeSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhlIGFjdGVkLW9uXG5cdFx0XHQvL1x0XHRhcnJheSBpcyBpbXBsaWNpdGx5IHRoaXMgTm9kZUxpc3QgYW5kIHRoZSByZXR1cm4gaXMgYVxuXHRcdFx0Ly9cdFx0Tm9kZUxpc3QgKGEgc3ViY2xhc3Mgb2YgQXJyYXkpXG5cdFx0XHRyZXR1cm4gdGhpcy5fd3JhcChhcnJheS5tYXAodGhpcywgZnVuYywgb2JqKSwgdGhpcyk7IC8vIGRvam8vTm9kZUxpc3Rcblx0XHR9LFxuXG5cdFx0Zm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNPYmope1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdHNlZSBgZG9qby9fYmFzZS9hcnJheS5mb3JFYWNoKClgLiBUaGUgcHJpbWFyeSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhlIGFjdGVkLW9uXG5cdFx0XHQvL1x0XHRhcnJheSBpcyBpbXBsaWNpdGx5IHRoaXMgTm9kZUxpc3QuIElmIHlvdSB3YW50IHRoZSBvcHRpb24gdG8gYnJlYWsgb3V0XG5cdFx0XHQvL1x0XHRvZiB0aGUgZm9yRWFjaCBsb29wLCB1c2UgZXZlcnkoKSBvciBzb21lKCkgaW5zdGVhZC5cblx0XHRcdGZvckVhY2godGhpcywgY2FsbGJhY2ssIHRoaXNPYmopO1xuXHRcdFx0Ly8gbm9uLXN0YW5kYXJkIHJldHVybiB0byBhbGxvdyBlYXNpZXIgY2hhaW5pbmdcblx0XHRcdHJldHVybiB0aGlzOyAvLyBkb2pvL05vZGVMaXN0XG5cdFx0fSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKC8qU3RyaW5nfEZ1bmN0aW9uKi8gZmlsdGVyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRcIm1hc2tzXCIgdGhlIGJ1aWx0LWluIGphdmFzY3JpcHQgZmlsdGVyKCkgbWV0aG9kIChzdXBwb3J0ZWRcblx0XHRcdC8vXHRcdGluIERvam8gdmlhIGBkb2pvL19iYXNlL2FycmF5LmZpbHRlcmApIHRvIHN1cHBvcnQgcGFzc2luZyBhIHNpbXBsZVxuXHRcdFx0Ly9cdFx0c3RyaW5nIGZpbHRlciBpbiBhZGRpdGlvbiB0byBzdXBwb3J0aW5nIGZpbHRlcmluZyBmdW5jdGlvblxuXHRcdFx0Ly9cdFx0b2JqZWN0cy5cblx0XHRcdC8vIGZpbHRlcjpcblx0XHRcdC8vXHRcdElmIGEgc3RyaW5nLCBhIENTUyBydWxlIGxpa2UgXCIudGhpbmdlclwiIG9yIFwiZGl2ID4gc3BhblwiLlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdFwicmVndWxhclwiIEpTIGZpbHRlciBzeW50YXggYXMgZXhwb3NlZCBpbiBgZG9qby9fYmFzZS9hcnJheS5maWx0ZXJgOlxuXHRcdFx0Ly9cdFx0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5XCIsIFwiZG9qby9Ob2RlTGlzdC1kb21cIlxuXHRcdFx0Ly9cdFx0fFx0XSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdFx0Ly9cdFx0fFx0XHRxdWVyeShcIipcIikuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0Ly9cdFx0fFx0XHRcdC8vIGhpZ2hsaWdodCBldmVyeSBwYXJhZ3JhcGhcblx0XHRcdC8vXHRcdHxcdFx0XHRyZXR1cm4gKGl0ZW0ubm9kZU5hbWUgPT0gXCJwXCIpO1xuXHRcdFx0Ly9cdFx0fFx0XHR9KS5zdHlsZShcImJhY2tncm91bmRDb2xvclwiLCBcInllbGxvd1wiKTtcblx0XHRcdC8vXHRcdHxcdH0pO1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdHRoZSBzYW1lIGZpbHRlcmluZyB1c2luZyBhIENTUyBzZWxlY3RvclxuXHRcdFx0Ly9cdFx0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5XCIsIFwiZG9qby9Ob2RlTGlzdC1kb21cIlxuXHRcdFx0Ly9cdFx0fFx0XSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdFx0Ly9cdFx0fFx0XHRxdWVyeShcIipcIikuZmlsdGVyKFwicFwiKS5zdHlsZXMoXCJiYWNrZ3JvdW5kQ29sb3JcIiwgXCJ5ZWxsb3dcIik7XG5cdFx0XHQvL1x0XHR8XHR9KTtcblxuXHRcdFx0dmFyIGEgPSBhcmd1bWVudHMsIGl0ZW1zID0gdGhpcywgc3RhcnQgPSAwO1xuXHRcdFx0aWYodHlwZW9mIGZpbHRlciA9PSBcInN0cmluZ1wiKXsgLy8gaW5saW5lJ2QgdHlwZSBjaGVja1xuXHRcdFx0XHRpdGVtcyA9IHF1ZXJ5Ll9maWx0ZXJSZXN1bHQodGhpcywgYVswXSk7XG5cdFx0XHRcdGlmKGEubGVuZ3RoID09IDEpe1xuXHRcdFx0XHRcdC8vIGlmIHdlIG9ubHkgZ290IGEgc3RyaW5nIHF1ZXJ5LCBwYXNzIGJhY2sgdGhlIGZpbHRlcmVkIHJlc3VsdHNcblx0XHRcdFx0XHRyZXR1cm4gaXRlbXMuX3N0YXNoKHRoaXMpOyAvLyBkb2pvL05vZGVMaXN0XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgd2UgZ290IGEgY2FsbGJhY2ssIHJ1biBpdCBvdmVyIHRoZSBmaWx0ZXJlZCBpdGVtc1xuXHRcdFx0XHRzdGFydCA9IDE7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fd3JhcChhcnJheS5maWx0ZXIoaXRlbXMsIGFbc3RhcnRdLCBhW3N0YXJ0ICsgMV0pLCB0aGlzKTtcdC8vIGRvam8vTm9kZUxpc3Rcblx0XHR9LFxuXHRcdGluc3RhbnRpYXRlOiBmdW5jdGlvbigvKlN0cmluZ3xPYmplY3QqLyBkZWNsYXJlZENsYXNzLCAvKk9iamVjdD8qLyBwcm9wZXJ0aWVzKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBzcGVjaWZpZWQgY2xhc3MsIHVzaW5nIHRoZVxuXHRcdFx0Ly9cdFx0c3BlY2lmaWVkIHByb3BlcnRpZXMgYW5kIGVhY2ggbm9kZSBpbiB0aGUgTm9kZUxpc3QgYXMgYVxuXHRcdFx0Ly9cdFx0c3JjTm9kZVJlZi5cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRHcmFicyBhbGwgYnV0dG9ucyBpbiB0aGUgcGFnZSBhbmQgY29udmVydHMgdGhlbSB0byBkaWppdC9mb3JtL0J1dHRvbidzLlxuXHRcdFx0Ly9cdHxcdHZhciBidXR0b25zID0gcXVlcnkoXCJidXR0b25cIikuaW5zdGFudGlhdGUoQnV0dG9uLCB7c2hvd0xhYmVsOiB0cnVlfSk7XG5cdFx0XHR2YXIgYyA9IGxhbmcuaXNGdW5jdGlvbihkZWNsYXJlZENsYXNzKSA/IGRlY2xhcmVkQ2xhc3MgOiBsYW5nLmdldE9iamVjdChkZWNsYXJlZENsYXNzKTtcblx0XHRcdHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuXHRcdFx0cmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcblx0XHRcdFx0bmV3IGMocHJvcGVydGllcywgbm9kZSk7XG5cdFx0XHR9KTtcdC8vIGRvam8vTm9kZUxpc3Rcblx0XHR9LFxuXHRcdGF0OiBmdW5jdGlvbigvKj09PT09IGluZGV4ID09PT09Ki8pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgYSBuZXcgTm9kZUxpc3QgY29tcHJpc2VkIG9mIGl0ZW1zIGluIHRoaXMgTm9kZUxpc3Rcblx0XHRcdC8vXHRcdGF0IHRoZSBnaXZlbiBpbmRleCBvciBpbmRpY2VzLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGluZGV4OiBJbnRlZ2VyLi4uXG5cdFx0XHQvL1x0XHRPbmUgb3IgbW9yZSAwLWJhc2VkIGluZGljZXMgb2YgaXRlbXMgaW4gdGhlIGN1cnJlbnRcblx0XHRcdC8vXHRcdE5vZGVMaXN0LiBBIG5lZ2F0aXZlIGluZGV4IHdpbGwgc3RhcnQgYXQgdGhlIGVuZCBvZiB0aGVcblx0XHRcdC8vXHRcdGxpc3QgYW5kIGdvIGJhY2t3YXJkcy5cblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFNob3J0ZW4gdGhlIGxpc3QgdG8gdGhlIGZpcnN0LCBzZWNvbmQsIGFuZCB0aGlyZCBlbGVtZW50c1xuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9xdWVyeVwiXG5cdFx0XHQvL1x0fFx0XSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdFx0Ly9cdHxcdFx0cXVlcnkoXCJhXCIpLmF0KDAsIDEsIDIpLmZvckVhY2goZm4pO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0UmV0cmlldmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnRzIG9mIGEgdW5vcmRlcmVkIGxpc3Q6XG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5XCJcblx0XHRcdC8vXHR8XHRdLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0XHQvL1x0fFx0XHRxdWVyeShcInVsID4gbGlcIikuYXQoMCwgLTEpLmZvckVhY2goY2IpO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0RG8gc29tZXRoaW5nIGZvciB0aGUgZmlyc3QgZWxlbWVudCBvbmx5LCBidXQgZW5kKCkgb3V0IGJhY2sgdG9cblx0XHRcdC8vXHR0aGUgb3JpZ2luYWwgbGlzdCBhbmQgY29udGludWUgY2hhaW5pbmc6XG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5XCJcblx0XHRcdC8vXHR8XHRdLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0XHQvL1x0fFx0XHRxdWVyeShcImFcIikuYXQoMCkub25jbGljayhmbikuZW5kKCkuZm9yRWFjaChmdW5jdGlvbihuKXtcblx0XHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2cobik7IC8vIGFsbCBhbmNob3JzIG9uIHRoZSBwYWdlLlxuXHRcdFx0Ly9cdHxcdH0pXG5cdFx0XHQvL1x0fFx0fSk7XG5cblx0XHRcdHZhciB0ID0gbmV3IHRoaXMuX05vZGVMaXN0Q3RvcigwKTtcblx0XHRcdGZvckVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihpKXtcblx0XHRcdFx0aWYoaSA8IDApeyBpID0gdGhpcy5sZW5ndGggKyBpOyB9XG5cdFx0XHRcdGlmKHRoaXNbaV0peyB0LnB1c2godGhpc1tpXSk7IH1cblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0cmV0dXJuIHQuX3N0YXNoKHRoaXMpOyAvLyBkb2pvL05vZGVMaXN0XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBxdWVyeUZvckVuZ2luZShlbmdpbmUsIE5vZGVMaXN0KXtcblx0XHR2YXIgcXVlcnkgPSBmdW5jdGlvbigvKlN0cmluZyovIHF1ZXJ5LCAvKlN0cmluZ3xET01Ob2RlPyovIHJvb3Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgbm9kZXMgd2hpY2ggbWF0Y2ggdGhlIGdpdmVuIENTUyBzZWxlY3Rvciwgc2VhcmNoaW5nIHRoZVxuXHRcdFx0Ly9cdFx0ZW50aXJlIGRvY3VtZW50IGJ5IGRlZmF1bHQgYnV0IG9wdGlvbmFsbHkgdGFraW5nIGEgbm9kZSB0byBzY29wZVxuXHRcdFx0Ly9cdFx0dGhlIHNlYXJjaCBieS4gUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBOb2RlTGlzdC5cblx0XHRcdGlmKHR5cGVvZiByb290ID09IFwic3RyaW5nXCIpe1xuXHRcdFx0XHRyb290ID0gZG9tLmJ5SWQocm9vdCk7XG5cdFx0XHRcdGlmKCFyb290KXtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IE5vZGVMaXN0KFtdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIHJlc3VsdHMgPSB0eXBlb2YgcXVlcnkgPT0gXCJzdHJpbmdcIiA/IGVuZ2luZShxdWVyeSwgcm9vdCkgOiBxdWVyeSA/IChxdWVyeS5lbmQgJiYgcXVlcnkub24pID8gcXVlcnkgOiBbcXVlcnldIDogW107XG5cdFx0XHRpZihyZXN1bHRzLmVuZCAmJiByZXN1bHRzLm9uKXtcblx0XHRcdFx0Ly8gYWxyZWFkeSB3cmFwcGVkXG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBOb2RlTGlzdChyZXN1bHRzKTtcblx0XHR9O1xuXHRcdHF1ZXJ5Lm1hdGNoZXMgPSBlbmdpbmUubWF0Y2ggfHwgZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IsIHJvb3Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRlc3QgdG8gc2VlIGlmIGEgbm9kZSBtYXRjaGVzIGEgc2VsZWN0b3Jcblx0XHRcdHJldHVybiBxdWVyeS5maWx0ZXIoW25vZGVdLCBzZWxlY3Rvciwgcm9vdCkubGVuZ3RoID4gMDtcblx0XHR9O1xuXHRcdC8vIHRoZSBlbmdpbmUgcHJvdmlkZXMgYSBmaWx0ZXJpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBmb3IgbWF0Y2hpbmdcblx0XHRxdWVyeS5maWx0ZXIgPSBlbmdpbmUuZmlsdGVyIHx8IGZ1bmN0aW9uKG5vZGVzLCBzZWxlY3Rvciwgcm9vdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RmlsdGVycyBhbiBhcnJheSBvZiBub2Rlcy4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgZ3VhcmFudGVlIHRvIHJldHVybiBhIE5vZGVMaXN0LCBqdXN0IGFuIGFycmF5LlxuXHRcdFx0cmV0dXJuIHF1ZXJ5KHNlbGVjdG9yLCByb290KS5maWx0ZXIoZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdHJldHVybiBhcnJheS5pbmRleE9mKG5vZGVzLCBub2RlKSA+IC0xO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHRpZih0eXBlb2YgZW5naW5lICE9IFwiZnVuY3Rpb25cIil7XG5cdFx0XHR2YXIgc2VhcmNoID0gZW5naW5lLnNlYXJjaDtcblx0XHRcdGVuZ2luZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCByb290KXtcblx0XHRcdFx0Ly8gU2xpY2sgZG9lcyBpdCBiYWNrd2FyZHMgKG9yIGV2ZXJ5b25lIGVsc2UgZG9lcyBpdCBiYWNrd2FyZHMsIHByb2JhYmx5IHRoZSBsYXR0ZXIpXG5cdFx0XHRcdHJldHVybiBzZWFyY2gocm9vdCB8fCBkb2N1bWVudCwgc2VsZWN0b3IpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9XG5cdHZhciBxdWVyeSA9IHF1ZXJ5Rm9yRW5naW5lKGRlZmF1bHRFbmdpbmUsIE5vZGVMaXN0KTtcblx0Lyo9PT09PVxuXHRxdWVyeSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoaXMgbW9kdWxlcyBwcm92aWRlcyBET00gcXVlcnlpbmcgZnVuY3Rpb25hbGl0eS4gVGhlIG1vZHVsZSBleHBvcnQgaXMgYSBmdW5jdGlvblxuXHRcdC8vXHRcdHRoYXQgY2FuIGJlIHVzZWQgdG8gcXVlcnkgZm9yIERPTSBub2RlcyBieSBDU1Mgc2VsZWN0b3IgYW5kIHJldHVybnMgYSBOb2RlTGlzdFxuXHRcdC8vXHRcdHJlcHJlc2VudGluZyB0aGUgbWF0Y2hpbmcgbm9kZXMuXG5cdFx0Ly8gc2VsZWN0b3I6IFN0cmluZ1xuXHRcdC8vXHRcdEEgQ1NTIHNlbGVjdG9yIHRvIHNlYXJjaCBmb3IuXG5cdFx0Ly8gY29udGV4dDogU3RyaW5nfERvbU5vZGU/XG5cdFx0Ly9cdFx0QW4gb3B0aW9uYWwgY29udGV4dCB0byBsaW1pdCB0aGUgc2VhcmNoaW5nIHNjb3BlLiBPbmx5IG5vZGVzIHVuZGVyIGBjb250ZXh0YCB3aWxsIGJlXG5cdFx0Ly9cdFx0c2Nhbm5lZC5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdGFkZCBhbiBvbmNsaWNrIGhhbmRsZXIgdG8gZXZlcnkgc3VibWl0IGJ1dHRvbiBpbiB0aGUgZG9jdW1lbnRcblx0XHQvL1x0XHR3aGljaCBjYXVzZXMgdGhlIGZvcm0gdG8gYmUgc2VudCB2aWEgQWpheCBpbnN0ZWFkOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnlcIiwgXCJkb2pvL3JlcXVlc3RcIiwgXCJkb2pvL2RvbS1mb3JtXCIsIFwiZG9qby9kb20tY29uc3RydWN0XCIsIFwiZG9qby9kb20tc3R5bGVcIlxuXHRcdC8vXHR8XHRdLCBmdW5jdGlvbihxdWVyeSwgcmVxdWVzdCwgZG9tRm9ybSwgZG9tQ29uc3RydWN0LCBkb21TdHlsZSl7XG5cdFx0Ly9cdHxcdFx0cXVlcnkoXCJpbnB1dFt0eXBlPSdzdWJtaXQnXVwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpe1xuXHRcdC8vXHR8XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50IHNlbmRpbmcgdGhlIGZvcm1cblx0XHQvL1x0fFx0XHRcdHZhciBidG4gPSBlLnRhcmdldDtcblx0XHQvL1x0fFx0XHRcdHJlcXVlc3QucG9zdChcImh0dHA6Ly9leGFtcGxlLmNvbS9cIiwge1xuXHRcdC8vXHR8XHRcdFx0XHRkYXRhOiBkb21Gb3JtLnRvT2JqZWN0KGJ0bi5mb3JtKVxuXHRcdC8vXHR8XHRcdFx0fSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG5cdFx0Ly9cdHxcdFx0XHRcdC8vIHJlcGxhY2UgdGhlIGZvcm0gd2l0aCB0aGUgcmVzcG9uc2Vcblx0XHQvL1x0fFx0XHRcdFx0ZG9tQ29uc3RydWN0LmNyZWF0ZShkaXYsIHtpbm5lckhUTUw6IHJlc3BvbnNlfSwgYnRuLmZvcm0sIFwiYWZ0ZXJcIik7XG5cdFx0Ly9cdHxcdFx0XHRcdGRvbVN0eWxlLnNldChidG4uZm9ybSwgXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcblx0XHQvL1x0fFx0XHRcdH0pO1xuXHRcdC8vXHR8XHRcdH0pO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1xuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdGRvam8vcXVlcnkgaXMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcgdGhlIGFwcHJvcHJpYXRlIHF1ZXJ5IGVuZ2luZSBhbmQgd3JhcHBpbmdcblx0XHQvL1x0XHRpdHMgcmVzdWx0cyB3aXRoIGEgYE5vZGVMaXN0YC4gWW91IGNhbiB1c2UgZG9qby9xdWVyeSB3aXRoIGEgc3BlY2lmaWMgc2VsZWN0b3IgZW5naW5lXG5cdFx0Ly9cdFx0YnkgdXNpbmcgaXQgYXMgYSBwbHVnaW4uIEZvciBleGFtcGxlLCBpZiB5b3UgaW5zdGFsbGVkIHRoZSBzaXp6bGUgcGFja2FnZSwgeW91IGNvdWxkXG5cdFx0Ly9cdFx0dXNlIGl0IGFzIHRoZSBzZWxlY3RvciBlbmdpbmUgd2l0aDpcblx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnkhc2l6emxlXCJdLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0Ly9cdFx0fFx0XHRxdWVyeShcImRpdlwiKS4uLlxuXHRcdC8vXG5cdFx0Ly9cdFx0VGhlIGlkIGFmdGVyIHRoZSAhIGNhbiBiZSBhIG1vZHVsZSBpZCBvZiB0aGUgc2VsZWN0b3IgZW5naW5lIG9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcblx0XHQvL1xuXHRcdC8vXHRcdC0gYWNtZTogVGhpcyBpcyB0aGUgZGVmYXVsdCBlbmdpbmUgdXNlZCBieSBEb2pvIGJhc2UsIGFuZCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBmdWxsXG5cdFx0Ly9cdFx0QWNtZSBlbmdpbmUgaXMgYWx3YXlzIGxvYWRlZC5cblx0XHQvL1xuXHRcdC8vXHRcdC0gY3NzMjogSWYgdGhlIGJyb3dzZXIgaGFzIGEgbmF0aXZlIHNlbGVjdG9yIGVuZ2luZSwgdGhpcyB3aWxsIGJlIHVzZWQsIG90aGVyd2lzZSBhXG5cdFx0Ly9cdFx0dmVyeSBtaW5pbWFsIGxpZ2h0d2VpZ2h0IHNlbGVjdG9yIGVuZ2luZSB3aWxsIGJlIGxvYWRlZCB0aGF0IGNhbiBkbyBzaW1wbGUgQ1NTMiBzZWxlY3RvcnNcblx0XHQvL1x0XHQoYnkgI2lkLCAuY2xhc3MsIHRhZywgYW5kIFtuYW1lPXZhbHVlXSBhdHRyaWJ1dGVzLCB3aXRoIHN0YW5kYXJkIGNoaWxkIG9yIGRlc2NlbmRhbnQgKD4pXG5cdFx0Ly9cdFx0b3BlcmF0b3JzKSBhbmQgbm90aGluZyBtb3JlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0LSBjc3MyLjE6IElmIHRoZSBicm93c2VyIGhhcyBhIG5hdGl2ZSBzZWxlY3RvciBlbmdpbmUsIHRoaXMgd2lsbCBiZSB1c2VkLCBvdGhlcndpc2UgdGhlXG5cdFx0Ly9cdFx0ZnVsbCBBY21lIGVuZ2luZSB3aWxsIGJlIGxvYWRlZC5cblx0XHQvL1xuXHRcdC8vXHRcdC0gY3NzMzogSWYgdGhlIGJyb3dzZXIgaGFzIGEgbmF0aXZlIHNlbGVjdG9yIGVuZ2luZSB3aXRoIHN1cHBvcnQgZm9yIENTUzMgcHNldWRvXG5cdFx0Ly9cdFx0c2VsZWN0b3JzIChtb3N0IG1vZGVybiBicm93c2VycyBleGNlcHQgSUU4KSwgdGhpcyB3aWxsIGJlIHVzZWQsIG90aGVyd2lzZSB0aGVcblx0XHQvL1x0XHRmdWxsIEFjbWUgZW5naW5lIHdpbGwgYmUgbG9hZGVkLlxuXHRcdC8vXG5cdFx0Ly9cdFx0LSBPciB0aGUgbW9kdWxlIGlkIG9mIGEgc2VsZWN0b3IgZW5naW5lIGNhbiBiZSB1c2VkIHRvIGV4cGxpY2l0bHkgY2hvb3NlIHRoZSBzZWxlY3RvciBlbmdpbmVcblx0XHQvL1xuXHRcdC8vXHRcdEZvciBleGFtcGxlLCBpZiB5b3UgYXJlIHVzaW5nIENTUzMgcHNldWRvIHNlbGVjdG9ycyBpbiBtb2R1bGUsIHlvdSBjYW4gc3BlY2lmeSB0aGF0XG5cdFx0Ly9cdFx0eW91IHdpbGwgbmVlZCBzdXBwb3J0IHRoZW0gd2l0aDpcblx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnkhY3NzM1wiXSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdC8vXHRcdHxcdFx0cXVlcnkoJyN0ID4gaDM6bnRoLWNoaWxkKG9kZCknKS4uLlxuXHRcdC8vXG5cdFx0Ly9cdFx0WW91IGNhbiBhbHNvIGNob29zZSB0aGUgc2VsZWN0b3IgZW5naW5lL2xvYWQgY29uZmlndXJhdGlvbiBieSBzZXR0aW5nIHRoZSBxdWVyeS1zZWxlY3Rvcjpcblx0XHQvL1x0XHRGb3IgZXhhbXBsZTpcblx0XHQvL1x0XHR8XHQ8c2NyaXB0IGRhdGEtZG9qby1jb25maWc9XCJxdWVyeS1zZWxlY3RvcjonY3NzMydcIiBzcmM9XCJkb2pvLmpzXCI+PC9zY3JpcHQ+XG5cdFx0Ly9cblx0XHRyZXR1cm4gbmV3IE5vZGVMaXN0KCk7IC8vIGRvam8vTm9kZUxpc3Rcblx0IH07XG5cdCA9PT09PSovXG5cblx0Ly8gdGhlIHF1ZXJ5IHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB0aGlzIG1vZHVsZSBpcyBzbGlnaHRseSBkaWZmZXJlbnQgdGhhbiBkb2pvLnF1ZXJ5LFxuXHQvLyBiZWNhdXNlIGRvam8ucXVlcnkgaGFzIHRvIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggcmV0dXJuaW5nIGFcblx0Ly8gdHJ1ZSBhcnJheSB3aGljaCBoYXMgcGVyZm9ybWFuY2UgcHJvYmxlbXMuIFRoZSBxdWVyeSByZXR1cm5lZCBmcm9tIHRoZSBtb2R1bGVcblx0Ly8gZG9lcyBub3QgdXNlIHRydWUgYXJyYXlzLCBidXQgcmF0aGVyIGluaGVyaXRzIGZyb20gQXJyYXksIG1ha2luZyBpdCBtdWNoIGZhc3RlciB0b1xuXHQvLyBpbnN0YW50aWF0ZS5cblx0ZG9qby5xdWVyeSA9IHF1ZXJ5Rm9yRW5naW5lKGRlZmF1bHRFbmdpbmUsIGZ1bmN0aW9uKGFycmF5KXtcblx0XHQvLyBjYWxsIGl0IHdpdGhvdXQgdGhlIG5ldyBvcGVyYXRvciB0byBpbnZva2UgdGhlIGJhY2stY29tcGF0IGJlaGF2aW9yIHRoYXQgcmV0dXJucyBhIHRydWUgYXJyYXlcblx0XHRyZXR1cm4gTm9kZUxpc3QoYXJyYXkpO1x0Ly8gZG9qby9Ob2RlTGlzdFxuXHR9KTtcblxuXHRxdWVyeS5sb2FkID0gZnVuY3Rpb24oaWQsIHBhcmVudFJlcXVpcmUsIGxvYWRlZCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRjYW4gYmUgdXNlZCBhcyBBTUQgcGx1Z2luIHRvIGNvbmRpdGlvbmFsbHkgbG9hZCBuZXcgcXVlcnkgZW5naW5lXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5IWN1c3RvbVwiXSwgZnVuY3Rpb24ocXNhKXtcblx0XHQvL1x0fFx0XHQvLyBsb2FkZWQgc2VsZWN0b3IvY3VzdG9tLmpzIGFzIGVuZ2luZVxuXHRcdC8vXHR8XHRcdHFzYShcIiNmb29iYXJcIikuZm9yRWFjaCguLi4pO1xuXHRcdC8vXHR8XHR9KTtcblx0XHRsb2FkZXIubG9hZChpZCwgcGFyZW50UmVxdWlyZSwgZnVuY3Rpb24oZW5naW5lKXtcblx0XHRcdGxvYWRlZChxdWVyeUZvckVuZ2luZShlbmdpbmUsIE5vZGVMaXN0KSk7XG5cdFx0fSk7XG5cdH07XG5cblx0ZG9qby5fZmlsdGVyUXVlcnlSZXN1bHQgPSBxdWVyeS5fZmlsdGVyUmVzdWx0ID0gZnVuY3Rpb24obm9kZXMsIHNlbGVjdG9yLCByb290KXtcblx0XHRyZXR1cm4gbmV3IE5vZGVMaXN0KHF1ZXJ5LmZpbHRlcihub2Rlcywgc2VsZWN0b3IsIHJvb3QpKTtcblx0fTtcblx0ZG9qby5Ob2RlTGlzdCA9IHF1ZXJ5Lk5vZGVMaXN0ID0gTm9kZUxpc3Q7XG5cdHJldHVybiBxdWVyeTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vX2Jhc2Uva2VybmVsXCIsIFwiLi9oYXNcIiwgXCJyZXF1aXJlXCIsIFwiLi9oYXMhaG9zdC1icm93c2VyPy4vZG9tUmVhZHlcIiwgXCIuL19iYXNlL2xhbmdcIl0sIGZ1bmN0aW9uKGRvam8sIGhhcywgcmVxdWlyZSwgZG9tUmVhZHksIGxhbmcpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vcmVhZHlcblx0Ly8gbm90ZTpcblx0Ly9cdFx0VGhpcyBtb2R1bGUgc2hvdWxkIGJlIHVubmVjZXNzYXJ5IGluIGRvam8gMi4wXG5cblx0dmFyXG5cdFx0Ly8gdHJ1dGh5IGlmIERPTUNvbnRlbnRMb2FkZWQgb3IgYmV0dGVyIChlLmcuLCB3aW5kb3cub25sb2FkIGZpcmVkKSBoYXMgYmVlbiBhY2hpZXZlZFxuXHRcdGlzRG9tUmVhZHkgPSAwLFxuXG5cdFx0Ly8gVGhlIHF1ZXVlIG9mIGZ1bmN0aW9ucyB3YWl0aW5nIHRvIGV4ZWN1dGUgYXMgc29vbiBhcyBkb2pvLnJlYWR5IGNvbmRpdGlvbnMgc2F0aXNmaWVkXG5cdFx0bG9hZFEgPSBbXSxcblxuXHRcdC8vIHByZXZlbnQgcmVjdXJzaW9uIGluIG9uTG9hZFxuXHRcdG9uTG9hZFJlY3Vyc2l2ZUd1YXJkID0gMCxcblxuXHRcdGhhbmRsZURvbVJlYWR5ID0gZnVuY3Rpb24oKXtcblx0XHRcdGlzRG9tUmVhZHkgPSAxO1xuXHRcdFx0ZG9qby5fcG9zdExvYWQgPSBkb2pvLmNvbmZpZy5hZnRlck9uTG9hZCA9IHRydWU7XG5cdFx0XHRvbkV2ZW50KCk7XG5cdFx0fSxcblxuXHRcdG9uRXZlbnQgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQ2FsbGVkIHdoZW4gc29tZSBzdGF0ZSBjaGFuZ2VzOlxuXHRcdFx0Ly9cdFx0LSBkb20gcmVhZHlcblx0XHRcdC8vXHRcdC0gZG9qby9kb21SZWFkeSBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZyBldmVyeXRoaW5nIGluIGl0cyBxdWV1ZVxuXHRcdFx0Ly9cdFx0LSB0YXNrIGFkZGVkIHRvIGxvYWRRXG5cdFx0XHQvL1x0XHQtIHJlcXVpcmUoKSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbGwgY3VycmVudGx5IHJlcXVlc3RlZCBtb2R1bGVzXG5cdFx0XHQvL1xuXHRcdFx0Ly8gUnVuIHRoZSBmdW5jdGlvbnMgcXVldWVkIHdpdGggZG9qby5yZWFkeSBpZiBhcHByb3ByaWF0ZS5cblxuXG5cdFx0XHQvL2d1YXJkIGFnYWluc3QgcmVjdXJzaW9ucyBpbnRvIHRoaXMgZnVuY3Rpb25cblx0XHRcdGlmKG9uTG9hZFJlY3Vyc2l2ZUd1YXJkKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b25Mb2FkUmVjdXJzaXZlR3VhcmQgPSAxO1xuXG5cdFx0XHQvLyBSdW4gdGFza3MgaW4gcXVldWUgaWYgcmVxdWlyZSgpIGlzIGZpbmlzaGVkIGxvYWRpbmcgbW9kdWxlcywgdGhlIGRvbSBpcyByZWFkeSwgYW5kIHRoZXJlIGFyZSBub1xuXHRcdFx0Ly8gcGVuZGluZyB0YXNrcyByZWdpc3RlcmVkIHZpYSBkb21SZWFkeSgpLlxuXHRcdFx0Ly8gVGhlIGxhc3Qgc3RlcCBpcyBuZWNlc3Nhcnkgc28gdGhhdCBhIHVzZXIgZGVmaW5lZCBkb2pvLnJlYWR5KCkgY2FsbGJhY2sgaXMgZGVsYXllZCB1bnRpbCBhZnRlciB0aGVcblx0XHRcdC8vIGRvbVJlYWR5KCkgY2FsbHMgaW5zaWRlIG9mIGRvam8uXHQgIEZhaWx1cmUgY2FuIGJlIHNlZW4gb24gZGlqaXQvdGVzdHMvcm9ib3QvRGlhbG9nX2FsbHkuaHRtbCBvbiBJRThcblx0XHRcdC8vIGJlY2F1c2UgdGhlIGRpaml0L2ZvY3VzLmpzIGRvbVJlYWR5KCkgY2FsbGJhY2sgZG9lc24ndCBleGVjdXRlIHVudGlsIGFmdGVyIHRoZSB0ZXN0IHN0YXJ0cyBydW5uaW5nLlxuXHRcdFx0d2hpbGUoaXNEb21SZWFkeSAmJiAoIWRvbVJlYWR5IHx8IGRvbVJlYWR5Ll9RLmxlbmd0aCA9PSAwKSAmJiAocmVxdWlyZS5pZGxlID8gcmVxdWlyZS5pZGxlKCkgOiB0cnVlKSAmJiBsb2FkUS5sZW5ndGgpe1xuXHRcdFx0XHR2YXIgZiA9IGxvYWRRLnNoaWZ0KCk7XG5cdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRmKCk7XG5cdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0XHQvLyBmb3JjZSB0aGUgZG9qby5qcyBvbihcImVycm9yXCIpIGhhbmRsZXIgZG8gZGlzcGxheSB0aGUgbWVzc2FnZVxuXHRcdFx0XHRcdGUuaW5mbyA9IGUubWVzc2FnZTtcblx0XHRcdFx0XHRpZihyZXF1aXJlLnNpZ25hbCl7XG5cdFx0XHRcdFx0XHRyZXF1aXJlLnNpZ25hbChcImVycm9yXCIsIGUpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0b25Mb2FkUmVjdXJzaXZlR3VhcmQgPSAwO1xuXHRcdH07XG5cblx0Ly8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHJ1biB0aGUgbmV4dCBxdWV1ZSBvcGVyYXRpb24gd2hlbmV2ZXIgcmVxdWlyZSgpIGZpbmlzaGVzIGxvYWRpbmcgbW9kdWxlcyBvciBkb21SZWFkeVxuXHQvLyBmaW5pc2hlcyBwcm9jZXNzaW5nIGl0J3MgcXVldWUuXG5cdHJlcXVpcmUub24gJiYgcmVxdWlyZS5vbihcImlkbGVcIiwgb25FdmVudCk7XG5cdGlmKGRvbVJlYWR5KXtcblx0XHRkb21SZWFkeS5fb25RRW1wdHkgPSBvbkV2ZW50O1xuXHR9XG5cblx0dmFyIHJlYWR5ID0gZG9qby5yZWFkeSA9IGRvam8uYWRkT25Mb2FkID0gZnVuY3Rpb24ocHJpb3JpdHksIGNvbnRleHQsIGNhbGxiYWNrKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEFkZCBhIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gRE9NIGNvbnRlbnQgbG9hZGVkIGFuZCBhbGwgcmVxdWVzdGVkIG1vZHVsZXMgaGF2ZSBhcnJpdmVkIGFuZCBiZWVuIGV2YWx1YXRlZC5cblx0XHQvL1x0XHRJbiBtb3N0IGNhc2VzLCB0aGUgYGRvbVJlYWR5YCBwbHVnLWluIHNob3VsZCBzdWZmaWNlIGFuZCB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIG5lZWRlZC5cblx0XHQvL1xuXHRcdC8vXHRcdFdoZW4gY2FsbGVkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQsIGp1c3QgY2hlY2tzIHRoYXQgYWxsIHJlcXVlc3RlZCBtb2R1bGVzIGhhdmUgYXJyaXZlZCBhbmQgYmVlblxuXHRcdC8vXHRcdGV2YWx1YXRlZC5cblx0XHQvLyBwcmlvcml0eTogSW50ZWdlcj9cblx0XHQvL1x0XHRUaGUgb3JkZXIgaW4gd2hpY2ggdG8gZXhlYyB0aGlzIGNhbGxiYWNrIHJlbGF0aXZlIHRvIG90aGVyIGNhbGxiYWNrcywgZGVmYXVsdHMgdG8gMTAwMFxuXHRcdC8vIGNvbnRleHQ6IE9iamVjdD98RnVuY3Rpb25cblx0XHQvL1x0XHRUaGUgY29udGV4dCBpbiB3aGljaCB0byBydW4gZXhlY3V0ZSBjYWxsYmFjaywgb3IgYSBjYWxsYmFjayBpZiBub3QgdXNpbmcgY29udGV4dFxuXHRcdC8vIGNhbGxiYWNrOiBGdW5jdGlvbj9cblx0XHQvL1x0XHRUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFNpbXBsZSBET00gYW5kIE1vZHVsZXMgcmVhZHkgc3ludGF4XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9yZWFkeVwiXSwgZnVuY3Rpb24ocmVhZHkpe1xuXHRcdC8vXHR8XHRcdHJlYWR5KGZ1bmN0aW9uKCl7IGFsZXJ0KFwiRG9tIHJlYWR5IVwiKTsgfSk7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0VXNpbmcgYSBwcmlvcml0eVxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vcmVhZHlcIl0sIGZ1bmN0aW9uKHJlYWR5KXtcblx0XHQvL1x0fFx0XHRyZWFkeSgyLCBmdW5jdGlvbigpeyBhbGVydChcImxvdyBwcmlvcml0eSByZWFkeSFcIik7IH0pXG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0VXNpbmcgY29udGV4dFxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vcmVhZHlcIl0sIGZ1bmN0aW9uKHJlYWR5KXtcblx0XHQvL1x0fFx0XHRyZWFkeShmb28sIGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHQvLyBpbiBoZXJlLCB0aGlzID09IGZvb1xuXHRcdC8vXHR8XHRcdH0pO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFVzaW5nIGRvam8vaGl0Y2ggc3R5bGUgYXJnczpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL3JlYWR5XCJdLCBmdW5jdGlvbihyZWFkeSl7XG5cdFx0Ly9cdHxcdFx0dmFyIGZvbyA9IHsgZG9qb1JlYWR5OiBmdW5jdGlvbigpeyBjb25zb2xlLndhcm4odGhpcywgXCJkb2pvIGRvbSBhbmQgbW9kdWxlcyByZWFkeS5cIik7IH0gfTtcblx0XHQvL1x0fFx0XHRyZWFkeShmb28sIFwiZG9qb1JlYWR5XCIpO1xuXHRcdC8vXHR8XHR9KTtcblxuXHRcdHZhciBoaXRjaEFyZ3MgPSBsYW5nLl90b0FycmF5KGFyZ3VtZW50cyk7XG5cdFx0aWYodHlwZW9mIHByaW9yaXR5ICE9IFwibnVtYmVyXCIpe1xuXHRcdFx0Y2FsbGJhY2sgPSBjb250ZXh0O1xuXHRcdFx0Y29udGV4dCA9IHByaW9yaXR5O1xuXHRcdFx0cHJpb3JpdHkgPSAxMDAwO1xuXHRcdH1lbHNle1xuXHRcdFx0aGl0Y2hBcmdzLnNoaWZ0KCk7XG5cdFx0fVxuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2sgP1xuXHRcdFx0bGFuZy5oaXRjaC5hcHBseShkb2pvLCBoaXRjaEFyZ3MpIDpcblx0XHRcdGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGNvbnRleHQoKTtcblx0XHRcdH07XG5cdFx0Y2FsbGJhY2sucHJpb3JpdHkgPSBwcmlvcml0eTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbG9hZFEubGVuZ3RoICYmIHByaW9yaXR5ID49IGxvYWRRW2ldLnByaW9yaXR5OyBpKyspe31cblx0XHRsb2FkUS5zcGxpY2UoaSwgMCwgY2FsbGJhY2spO1xuXHRcdG9uRXZlbnQoKTtcblx0fTtcblxuXHRoYXMuYWRkKFwiZG9qby1jb25maWctYWRkT25Mb2FkXCIsIDEpO1xuXHRpZihoYXMoXCJkb2pvLWNvbmZpZy1hZGRPbkxvYWRcIikpe1xuXHRcdHZhciBkY2EgPSBkb2pvLmNvbmZpZy5hZGRPbkxvYWQ7XG5cdFx0aWYoZGNhKXtcblx0XHRcdHJlYWR5WyhsYW5nLmlzQXJyYXkoZGNhKSA/IFwiYXBwbHlcIiA6IFwiY2FsbFwiKV0oZG9qbywgZGNhKTtcblx0XHR9XG5cdH1cblxuXHRpZihoYXMoXCJkb2pvLXN5bmMtbG9hZGVyXCIpICYmIGRvam8uY29uZmlnLnBhcnNlT25Mb2FkICYmICFkb2pvLmlzQXN5bmMpe1xuXHRcdHJlYWR5KDk5LCBmdW5jdGlvbigpe1xuXHRcdFx0aWYoIWRvam8ucGFyc2VyKXtcblx0XHRcdFx0ZG9qby5kZXByZWNhdGVkKFwiQWRkIGV4cGxpY2l0IHJlcXVpcmUoWydkb2pvL3BhcnNlciddKTtcIiwgXCJcIiwgXCIyLjBcIik7XG5cdFx0XHRcdHJlcXVpcmUoW1wiZG9qby9wYXJzZXJcIl0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0aWYoZG9tUmVhZHkpe1xuXHRcdGRvbVJlYWR5KGhhbmRsZURvbVJlYWR5KTtcblx0fWVsc2V7XG5cdFx0aGFuZGxlRG9tUmVhZHkoKTtcblx0fVxuXG5cdHJldHVybiByZWFkeTtcbn0pO1xuIiwiZGVmaW5lKFtcblx0Jy4vcmVxdWVzdC9kZWZhdWx0IScvKj09PT09LFxuXHQnLi9fYmFzZS9kZWNsYXJlJyxcblx0Jy4vcHJvbWlzZS9Qcm9taXNlJyA9PT09PSovXG5dLCBmdW5jdGlvbihyZXF1ZXN0Lyo9PT09PSwgZGVjbGFyZSwgUHJvbWlzZSA9PT09PSovKXtcblx0Lyo9PT09PVxuXHRyZXF1ZXN0ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNlbmQgYSByZXF1ZXN0IHVzaW5nIHRoZSBkZWZhdWx0IHRyYW5zcG9ydCBmb3IgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG5cdFx0Ly8gdXJsOiBTdHJpbmdcblx0XHQvL1x0XHRUaGUgVVJMIHRvIHJlcXVlc3QuXG5cdFx0Ly8gb3B0aW9uczogZG9qby9yZXF1ZXN0Ll9fT3B0aW9ucz9cblx0XHQvL1x0XHRPcHRpb25zIGZvciB0aGUgcmVxdWVzdC5cblx0XHQvLyByZXR1cm5zOiBkb2pvL3JlcXVlc3QuX19Qcm9taXNlXG5cdH07XG5cdHJlcXVlc3QuX19Qcm9taXNlID0gZGVjbGFyZShQcm9taXNlLCB7XG5cdFx0Ly8gcmVzcG9uc2U6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdFx0Ly9cdFx0QSBwcm9taXNlIHJlc29sdmluZyB0byBhbiBvYmplY3QgcmVwcmVzZW50aW5nXG5cdFx0Ly9cdFx0dGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci5cblx0fSk7XG5cdHJlcXVlc3QuX19CYXNlT3B0aW9ucyA9IGRlY2xhcmUobnVsbCwge1xuXHRcdC8vIHF1ZXJ5OiBTdHJpbmd8T2JqZWN0P1xuXHRcdC8vXHRcdFF1ZXJ5IHBhcmFtZXRlcnMgdG8gYXBwZW5kIHRvIHRoZSBVUkwuXG5cdFx0Ly8gZGF0YTogU3RyaW5nfE9iamVjdD9cblx0XHQvL1x0XHREYXRhIHRvIHRyYW5zZmVyLiAgVGhpcyBpcyBpZ25vcmVkIGZvciBHRVQgYW5kIERFTEVURVxuXHRcdC8vXHRcdHJlcXVlc3RzLlxuXHRcdC8vIHByZXZlbnRDYWNoZTogQm9vbGVhbj9cblx0XHQvL1x0XHRXaGV0aGVyIHRvIGFwcGVuZCBhIGNhY2hlLWJ1c3RpbmcgcGFyYW1ldGVyIHRvIHRoZSBVUkwuXG5cdFx0Ly8gdGltZW91dDogSW50ZWdlcj9cblx0XHQvL1x0XHRNaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIHJlc3BvbnNlLiAgSWYgdGhpcyB0aW1lXG5cdFx0Ly9cdFx0cGFzc2VzLCB0aGUgdGhlbiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cblx0XHQvLyBoYW5kbGVBczogU3RyaW5nP1xuXHRcdC8vXHRcdEhvdyB0byBoYW5kbGUgdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci4gIERlZmF1bHQgaXNcblx0XHQvL1x0XHQndGV4dCcuICBPdGhlciB2YWx1ZXMgYXJlICdqc29uJywgJ2phdmFzY3JpcHQnLCBhbmQgJ3htbCcuXG5cdH0pO1xuXHRyZXF1ZXN0Ll9fTWV0aG9kT3B0aW9ucyA9IGRlY2xhcmUobnVsbCwge1xuXHRcdC8vIG1ldGhvZDogU3RyaW5nP1xuXHRcdC8vXHRcdFRoZSBIVFRQIG1ldGhvZCB0byB1c2UgdG8gbWFrZSB0aGUgcmVxdWVzdC4gIE11c3QgYmVcblx0XHQvL1x0XHR1cHBlcmNhc2UuXG5cdH0pO1xuXHRyZXF1ZXN0Ll9fT3B0aW9ucyA9IGRlY2xhcmUoW3JlcXVlc3QuX19CYXNlT3B0aW9ucywgcmVxdWVzdC5fX01ldGhvZE9wdGlvbnNdKTtcblxuXHRyZXF1ZXN0LmdldCA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZW5kIGFuIEhUVFAgR0VUIHJlcXVlc3QgdXNpbmcgdGhlIGRlZmF1bHQgdHJhbnNwb3J0IGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybS5cblx0XHQvLyB1cmw6IFN0cmluZ1xuXHRcdC8vXHRcdFVSTCB0byByZXF1ZXN0XG5cdFx0Ly8gb3B0aW9uczogZG9qby9yZXF1ZXN0Ll9fQmFzZU9wdGlvbnM/XG5cdFx0Ly9cdFx0T3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuXG5cdFx0Ly8gcmV0dXJuczogZG9qby9yZXF1ZXN0Ll9fUHJvbWlzZVxuXHR9O1xuXHRyZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0U2VuZCBhbiBIVFRQIFBPU1QgcmVxdWVzdCB1c2luZyB0aGUgZGVmYXVsdCB0cmFuc3BvcnQgZm9yIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuXHRcdC8vIHVybDogU3RyaW5nXG5cdFx0Ly9cdFx0VVJMIHRvIHJlcXVlc3Rcblx0XHQvLyBvcHRpb25zOiBkb2pvL3JlcXVlc3QuX19CYXNlT3B0aW9ucz9cblx0XHQvL1x0XHRPcHRpb25zIGZvciB0aGUgcmVxdWVzdC5cblx0XHQvLyByZXR1cm5zOiBkb2pvL3JlcXVlc3QuX19Qcm9taXNlXG5cdH07XG5cdHJlcXVlc3QucHV0ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNlbmQgYW4gSFRUUCBQT1NUIHJlcXVlc3QgdXNpbmcgdGhlIGRlZmF1bHQgdHJhbnNwb3J0IGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybS5cblx0XHQvLyB1cmw6IFN0cmluZ1xuXHRcdC8vXHRcdFVSTCB0byByZXF1ZXN0XG5cdFx0Ly8gb3B0aW9uczogZG9qby9yZXF1ZXN0Ll9fQmFzZU9wdGlvbnM/XG5cdFx0Ly9cdFx0T3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuXG5cdFx0Ly8gcmV0dXJuczogZG9qby9yZXF1ZXN0Ll9fUHJvbWlzZVxuXHR9O1xuXHRyZXF1ZXN0LmRlbCA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZW5kIGFuIEhUVFAgREVMRVRFIHJlcXVlc3QgdXNpbmcgdGhlIGRlZmF1bHQgdHJhbnNwb3J0IGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybS5cblx0XHQvLyB1cmw6IFN0cmluZ1xuXHRcdC8vXHRcdFVSTCB0byByZXF1ZXN0XG5cdFx0Ly8gb3B0aW9uczogZG9qby9yZXF1ZXN0Ll9fQmFzZU9wdGlvbnM/XG5cdFx0Ly9cdFx0T3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuXG5cdFx0Ly8gcmV0dXJuczogZG9qby9yZXF1ZXN0Ll9fUHJvbWlzZVxuXHR9O1xuXHQ9PT09PSovXG5cdHJldHVybiByZXF1ZXN0O1xufSk7XG4iLCJkZWZpbmUoW1xuXHQnLi4vanNvbicsXG5cdCcuLi9fYmFzZS9rZXJuZWwnLFxuXHQnLi4vX2Jhc2UvYXJyYXknLFxuXHQnLi4vaGFzJyxcblx0Jy4uL2hhcyFkb20/Li4vc2VsZWN0b3IvX2xvYWRlcicgLy8gb25seSBpbmNsdWRlZCBmb3IgaGFzKCkgcXNhIHRlc3RzXG5dLCBmdW5jdGlvbihKU09OLCBrZXJuZWwsIGFycmF5LCBoYXMpe1xuXHRoYXMuYWRkKCdhY3RpdmV4JywgdHlwZW9mIEFjdGl2ZVhPYmplY3QgIT09ICd1bmRlZmluZWQnKTtcblx0aGFzLmFkZCgnZG9tLXBhcnNlcicsIGZ1bmN0aW9uKGdsb2JhbCl7XG5cdFx0cmV0dXJuICdET01QYXJzZXInIGluIGdsb2JhbDtcblx0fSk7XG5cblx0dmFyIGhhbmRsZVhNTDtcblx0aWYoaGFzKCdhY3RpdmV4Jykpe1xuXHRcdC8vIEdVSURzIG9idGFpbmVkIGZyb20gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNzU3ODM3KFZTLjg1KS5hc3B4XG5cdFx0dmFyIGRwID0gW1xuXHRcdFx0J01zeG1sMi5ET01Eb2N1bWVudC42LjAnLFxuXHRcdFx0J01zeG1sMi5ET01Eb2N1bWVudC40LjAnLFxuXHRcdFx0J01TWE1MMi5ET01Eb2N1bWVudC4zLjAnLFxuXHRcdFx0J01TWE1MLkRPTURvY3VtZW50JyAvLyAyLjBcblx0XHRdO1xuXHRcdHZhciBsYXN0UGFyc2VyO1xuXG5cdFx0aGFuZGxlWE1MID0gZnVuY3Rpb24ocmVzcG9uc2Upe1xuXHRcdFx0dmFyIHJlc3VsdCA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHR2YXIgdGV4dCA9IHJlc3BvbnNlLnRleHQ7XG5cblx0XHRcdGlmKHJlc3VsdCAmJiBoYXMoJ2RvbS1xc2EyLjEnKSAmJiAhcmVzdWx0LnF1ZXJ5U2VsZWN0b3JBbGwgJiYgaGFzKCdkb20tcGFyc2VyJykpe1xuXHRcdFx0XHQvLyBodHRwOi8vYnVncy5kb2pvdG9vbGtpdC5vcmcvdGlja2V0LzE1NjMxXG5cdFx0XHRcdC8vIElFOSBzdXBwb3J0cyBhIENTUzMgcXVlcnlTZWxlY3RvckFsbCBpbXBsZW1lbnRhdGlvbiwgYnV0IHRoZSBET00gaW1wbGVtZW50YXRpb25cblx0XHRcdFx0Ly8gcmV0dXJuZWQgYnkgSUU5IHhoci5yZXNwb25zZVhNTCBkb2VzIG5vdC4gTWFudWFsbHkgY3JlYXRlIHRoZSBYTUwgRE9NIHRvIGdhaW5cblx0XHRcdFx0Ly8gdGhlIGZ1bGxlci1mZWF0dXJlZCBpbXBsZW1lbnRhdGlvbiBhbmQgYXZvaWQgYnVncyBjYXVzZWQgYnkgdGhlIGluY29uc2lzdGVuY3lcblx0XHRcdFx0cmVzdWx0ID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCAnYXBwbGljYXRpb24veG1sJyk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50KHApIHtcblx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHR2YXIgZG9tID0gbmV3IEFjdGl2ZVhPYmplY3QocCk7XG5cdFx0XHRcdFx0XHRkb20uYXN5bmMgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGRvbS5sb2FkWE1MKHRleHQpO1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gZG9tO1xuXHRcdFx0XHRcdFx0bGFzdFBhcnNlciA9IHA7XG5cdFx0XHRcdFx0fWNhdGNoKGUpeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIXJlc3VsdCB8fCAhcmVzdWx0LmRvY3VtZW50RWxlbWVudCl7XG5cdFx0XHRcdC8vIFRoZSBjcmVhdGlvbiBvZiBhbiBBY3RpdmVYIG9iamVjdCBpcyBleHBlbnNpdmUsIHNvIHdlIGNhY2hlIHRoZVxuXHRcdFx0XHQvLyBwYXJzZXIgdHlwZSB0byBhdm9pZCB0cnlpbmcgYWxsIHBhcnNlciB0eXBlcyBlYWNoIHRpbWUgd2UgaGFuZGxlIGFcblx0XHRcdFx0Ly8gZG9jdW1lbnQuIFRoZXJlIGlzIHNvbWUgY29uY2VybiB0aGF0IHNvbWUgcGFyc2VyIHR5cGVzIG1pZ2h0IGZhaWxcblx0XHRcdFx0Ly8gZGVwZW5kaW5nIG9uIHRoZSBkb2N1bWVudCBiZWluZyBwYXJzZWQuIElmIHBhcnNpbmcgdXNpbmcgdGhlIGNhY2hlZFxuXHRcdFx0XHQvLyBwYXJzZXIgdHlwZSBmYWlscywgd2UgZG8gdGhlIG1vcmUgZXhwZW5zaXZlIG9wZXJhdGlvbiBvZiBmaW5kaW5nIG9uZVxuXHRcdFx0XHQvLyB0aGF0IHdvcmtzIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG5cdFx0XHRcdC8vIGh0dHBzOi8vYnVncy5kb2pvdG9vbGtpdC5vcmcvdGlja2V0LzE1MjQ2XG5cdFx0XHRcdGlmKCFsYXN0UGFyc2VyIHx8ICFjcmVhdGVEb2N1bWVudChsYXN0UGFyc2VyKSkge1xuXHRcdFx0XHRcdGFycmF5LnNvbWUoZHAsIGNyZWF0ZURvY3VtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH1cblxuXHR2YXIgaGFuZGxlTmF0aXZlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuXHRcdGlmKCFoYXMoJ25hdGl2ZS14aHIyLWJsb2InKSAmJiByZXNwb25zZS5vcHRpb25zLmhhbmRsZUFzID09PSAnYmxvYicgJiYgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnKXtcblx0XHRcdHJldHVybiBuZXcgQmxvYihbIHJlc3BvbnNlLnhoci5yZXNwb25zZSBdLCB7IHR5cGU6IHJlc3BvbnNlLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykgfSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3BvbnNlLnhoci5yZXNwb25zZTtcblx0fVxuXG5cdHZhciBoYW5kbGVycyA9IHtcblx0XHQnamF2YXNjcmlwdCc6IGZ1bmN0aW9uKHJlc3BvbnNlKXtcblx0XHRcdHJldHVybiBrZXJuZWwuZXZhbChyZXNwb25zZS50ZXh0IHx8ICcnKTtcblx0XHR9LFxuXHRcdCdqc29uJzogZnVuY3Rpb24ocmVzcG9uc2Upe1xuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UudGV4dCB8fCBudWxsKTtcblx0XHR9LFxuXHRcdCd4bWwnOiBoYW5kbGVYTUwsXG5cdFx0J2Jsb2InOiBoYW5kbGVOYXRpdmVSZXNwb25zZSxcblx0XHQnYXJyYXlidWZmZXInOiBoYW5kbGVOYXRpdmVSZXNwb25zZSxcblx0XHQnZG9jdW1lbnQnOiBoYW5kbGVOYXRpdmVSZXNwb25zZVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGhhbmRsZShyZXNwb25zZSl7XG5cdFx0dmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tyZXNwb25zZS5vcHRpb25zLmhhbmRsZUFzXTtcblxuXHRcdHJlc3BvbnNlLmRhdGEgPSBoYW5kbGVyID8gaGFuZGxlcihyZXNwb25zZSkgOiAocmVzcG9uc2UuZGF0YSB8fCByZXNwb25zZS50ZXh0KTtcblxuXHRcdHJldHVybiByZXNwb25zZTtcblx0fVxuXG5cdGhhbmRsZS5yZWdpc3RlciA9IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIpe1xuXHRcdGhhbmRsZXJzW25hbWVdID0gaGFuZGxlcjtcblx0fTtcblxuXHRyZXR1cm4gaGFuZGxlO1xufSk7XG4iLCJkZWZpbmUoW1xuXHQnZXhwb3J0cycsXG5cdCcuLi9lcnJvcnMvUmVxdWVzdEVycm9yJyxcblx0Jy4uL2Vycm9ycy9DYW5jZWxFcnJvcicsXG5cdCcuLi9EZWZlcnJlZCcsXG5cdCcuLi9pby1xdWVyeScsXG5cdCcuLi9fYmFzZS9hcnJheScsXG5cdCcuLi9fYmFzZS9sYW5nJyxcblx0Jy4uL3Byb21pc2UvUHJvbWlzZScsXG5cdCcuLi9oYXMnXG5dLCBmdW5jdGlvbihleHBvcnRzLCBSZXF1ZXN0RXJyb3IsIENhbmNlbEVycm9yLCBEZWZlcnJlZCwgaW9RdWVyeSwgYXJyYXksIGxhbmcsIFByb21pc2UsIGhhcyl7XG5cblx0ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuXHRcdHJldHVybiBoYXMoJ25hdGl2ZS1hcnJheWJ1ZmZlcicpICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcblx0fVxuXG5cdGZ1bmN0aW9uIGlzQmxvYih2YWx1ZSkge1xuXHRcdHJldHVybiBoYXMoJ25hdGl2ZS1ibG9iJykgJiYgdmFsdWUgaW5zdGFuY2VvZiBCbG9iXG5cdH1cblx0XG5cdGZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQodmFsdWUpIHtcblx0XHRpZih0eXBlb2YgSFRNTEZvcm1FbGVtZW50ICE9PSAndW5kZWZpbmVkJykgeyAvL2FsbCBvdGhlclxuXHRcdFx0cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50O1xuXHRcdH0gZWxzZSB7IC8vSUU8PTdcblx0XHRcdHZhbHVlLnRhZ05hbWUgPT09IFwiRk9STVwiXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWx1ZSkge1xuXHRcdHJldHVybiBoYXMoJ25hdGl2ZS1mb3JtZGF0YScpICYmIHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGE7XG5cdH1cblxuXHRmdW5jdGlvbiBzaG91bGREZWVwQ29weSh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0IWlzRm9ybURhdGEodmFsdWUpICYmXG5cdFx0XHQhaXNGb3JtRWxlbWVudCh2YWx1ZSkgJiZcblx0XHRcdCFpc0Jsb2IodmFsdWUpICYmXG5cdFx0XHQhaXNBcnJheUJ1ZmZlcih2YWx1ZSlcblx0fVxuXG5cdGV4cG9ydHMuZGVlcENvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuXHRcdGZvciAodmFyIG5hbWUgaW4gc291cmNlKSB7XG5cdFx0XHR2YXIgdHZhbCA9IHRhcmdldFtuYW1lXSxcbiAgXHRcdFx0ICAgIHN2YWwgPSBzb3VyY2VbbmFtZV07XG5cdFx0XHRpZiAodHZhbCAhPT0gc3ZhbCkge1xuXHRcdFx0XHRpZiAoc2hvdWxkRGVlcENvcHkoc3ZhbCkpIHtcblx0XHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN2YWwpID09PSAnW29iamVjdCBEYXRlXScpIHsgLy8gdXNlIHRoaXMgZGF0ZSB0ZXN0IHRvIGhhbmRsZSBjcm9zc2luZyBmcmFtZSBib3VuZGFyaWVzXG5cdFx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBuZXcgRGF0ZShzdmFsKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGxhbmcuaXNBcnJheShzdmFsKSkge1xuIFx0XHRcdFx0XHRcdCAgdGFyZ2V0W25hbWVdID0gZXhwb3J0cy5kZWVwQ29weUFycmF5KHN2YWwpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAodHZhbCAmJiB0eXBlb2YgdHZhbCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0ZXhwb3J0cy5kZWVwQ29weSh0dmFsLCBzdmFsKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IGV4cG9ydHMuZGVlcENvcHkoe30sIHN2YWwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBzdmFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0ZXhwb3J0cy5kZWVwQ29weUFycmF5ID0gZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0dmFyIGNsb25lZEFycmF5ID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc3ZhbEl0ZW0gPSBzb3VyY2VbaV07XG5cdFx0XHRpZiAodHlwZW9mIHN2YWxJdGVtID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRjbG9uZWRBcnJheS5wdXNoKGV4cG9ydHMuZGVlcENvcHkoe30sIHN2YWxJdGVtKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZWRBcnJheS5wdXNoKHN2YWxJdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvbmVkQXJyYXk7XG5cdH07XG5cblx0ZXhwb3J0cy5kZWVwQ3JlYXRlID0gZnVuY3Rpb24gZGVlcENyZWF0ZShzb3VyY2UsIHByb3BlcnRpZXMpe1xuXHRcdHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuXHRcdHZhciB0YXJnZXQgPSBsYW5nLmRlbGVnYXRlKHNvdXJjZSksXG5cdFx0XHRuYW1lLCB2YWx1ZTtcblxuXHRcdGZvcihuYW1lIGluIHNvdXJjZSl7XG5cdFx0XHR2YWx1ZSA9IHNvdXJjZVtuYW1lXTtcblxuXHRcdFx0aWYodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jyl7XG5cdFx0XHRcdHRhcmdldFtuYW1lXSA9IGV4cG9ydHMuZGVlcENyZWF0ZSh2YWx1ZSwgcHJvcGVydGllc1tuYW1lXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBleHBvcnRzLmRlZXBDb3B5KHRhcmdldCwgcHJvcGVydGllcyk7XG5cdH07XG5cblx0dmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemUgfHwgZnVuY3Rpb24ob2JqKXsgcmV0dXJuIG9iajsgfTtcblx0ZnVuY3Rpb24gb2tIYW5kbGVyKHJlc3BvbnNlKXtcblx0XHRyZXR1cm4gZnJlZXplKHJlc3BvbnNlKTtcblx0fVxuXHRmdW5jdGlvbiBkYXRhSGFuZGxlciAocmVzcG9uc2UpIHtcblx0XHRyZXR1cm4gcmVzcG9uc2UuZGF0YSAhPT0gdW5kZWZpbmVkID8gcmVzcG9uc2UuZGF0YSA6IHJlc3BvbnNlLnRleHQ7XG5cdH1cblxuXHRleHBvcnRzLmRlZmVycmVkID0gZnVuY3Rpb24gZGVmZXJyZWQocmVzcG9uc2UsIGNhbmNlbCwgaXNWYWxpZCwgaXNSZWFkeSwgaGFuZGxlUmVzcG9uc2UsIGxhc3Qpe1xuXHRcdHZhciBkZWYgPSBuZXcgRGVmZXJyZWQoZnVuY3Rpb24ocmVhc29uKXtcblx0XHRcdGNhbmNlbCAmJiBjYW5jZWwoZGVmLCByZXNwb25zZSk7XG5cblx0XHRcdGlmKCFyZWFzb24gfHwgIShyZWFzb24gaW5zdGFuY2VvZiBSZXF1ZXN0RXJyb3IpICYmICEocmVhc29uIGluc3RhbmNlb2YgQ2FuY2VsRXJyb3IpKXtcblx0XHRcdFx0cmV0dXJuIG5ldyBDYW5jZWxFcnJvcignUmVxdWVzdCBjYW5jZWxlZCcsIHJlc3BvbnNlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWFzb247XG5cdFx0fSk7XG5cblx0XHRkZWYucmVzcG9uc2UgPSByZXNwb25zZTtcblx0XHRkZWYuaXNWYWxpZCA9IGlzVmFsaWQ7XG5cdFx0ZGVmLmlzUmVhZHkgPSBpc1JlYWR5O1xuXHRcdGRlZi5oYW5kbGVSZXNwb25zZSA9IGhhbmRsZVJlc3BvbnNlO1xuXG5cdFx0ZnVuY3Rpb24gZXJySGFuZGxlcihlcnJvcil7XG5cdFx0XHRlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHRcdHZhciByZXNwb25zZVByb21pc2UgPSBkZWYudGhlbihva0hhbmRsZXIpLm90aGVyd2lzZShlcnJIYW5kbGVyKTtcblxuXHRcdGlmKGV4cG9ydHMubm90aWZ5KXtcblx0XHRcdHJlc3BvbnNlUHJvbWlzZS50aGVuKFxuXHRcdFx0XHRsYW5nLmhpdGNoKGV4cG9ydHMubm90aWZ5LCAnZW1pdCcsICdsb2FkJyksXG5cdFx0XHRcdGxhbmcuaGl0Y2goZXhwb3J0cy5ub3RpZnksICdlbWl0JywgJ2Vycm9yJylcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFQcm9taXNlID0gcmVzcG9uc2VQcm9taXNlLnRoZW4oZGF0YUhhbmRsZXIpO1xuXG5cdFx0Ly8gaHR0cDovL2J1Z3MuZG9qb3Rvb2xraXQub3JnL3RpY2tldC8xNjc5NFxuXHRcdC8vIFRoZSBmb2xsb3dpbmcgd29ya3MgYXJvdW5kIGEgbGVhayBpbiBJRTkgdGhyb3VnaCB0aGVcblx0XHQvLyBwcm90b3R5cGUgdXNpbmcgbGFuZy5kZWxlZ2F0ZSBvbiBkYXRhUHJvbWlzZSBhbmRcblx0XHQvLyBhc3NpZ25pbmcgdGhlIHJlc3VsdCBhIHByb3BlcnR5IHdpdGggYSByZWZlcmVuY2UgdG9cblx0XHQvLyByZXNwb25zZVByb21pc2UuXG5cdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgpO1xuXHRcdGZvciAodmFyIHByb3AgaW4gZGF0YVByb21pc2UpIHtcblx0XHRcdGlmIChkYXRhUHJvbWlzZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRwcm9taXNlW3Byb3BdID0gZGF0YVByb21pc2VbcHJvcF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHByb21pc2UucmVzcG9uc2UgPSByZXNwb25zZVByb21pc2U7XG5cdFx0ZnJlZXplKHByb21pc2UpO1xuXHRcdC8vIEVuZCBsZWFrIGZpeFxuXG5cblx0XHRpZihsYXN0KXtcblx0XHRcdGRlZi50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcblx0XHRcdFx0bGFzdC5jYWxsKGRlZiwgcmVzcG9uc2UpO1xuXHRcdFx0fSwgZnVuY3Rpb24oZXJyb3Ipe1xuXHRcdFx0XHRsYXN0LmNhbGwoZGVmLCByZXNwb25zZSwgZXJyb3IpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0ZGVmLnByb21pc2UgPSBwcm9taXNlO1xuXHRcdGRlZi50aGVuID0gcHJvbWlzZS50aGVuO1xuXG5cdFx0cmV0dXJuIGRlZjtcblx0fTtcblxuXHRleHBvcnRzLmFkZENvbW1vbk1ldGhvZHMgPSBmdW5jdGlvbiBhZGRDb21tb25NZXRob2RzKHByb3ZpZGVyLCBtZXRob2RzKXtcblx0XHRhcnJheS5mb3JFYWNoKG1ldGhvZHN8fFsnR0VUJywgJ1BPU1QnLCAnUFVUJywgJ0RFTEVURSddLCBmdW5jdGlvbihtZXRob2Qpe1xuXHRcdFx0cHJvdmlkZXJbKG1ldGhvZCA9PT0gJ0RFTEVURScgPyAnREVMJyA6IG1ldGhvZCkudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMpe1xuXHRcdFx0XHRvcHRpb25zID0gbGFuZy5kZWxlZ2F0ZShvcHRpb25zfHx7fSk7XG5cdFx0XHRcdG9wdGlvbnMubWV0aG9kID0gbWV0aG9kO1xuXHRcdFx0XHRyZXR1cm4gcHJvdmlkZXIodXJsLCBvcHRpb25zKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdH07XG5cblx0ZXhwb3J0cy5wYXJzZUFyZ3MgPSBmdW5jdGlvbiBwYXJzZUFyZ3ModXJsLCBvcHRpb25zLCBza2lwRGF0YSl7XG5cdFx0dmFyIGRhdGEgPSBvcHRpb25zLmRhdGEsXG5cdFx0XHRxdWVyeSA9IG9wdGlvbnMucXVlcnk7XG5cblx0XHRpZihkYXRhICYmICFza2lwRGF0YSl7XG5cdFx0XHRpZih0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgKCEoaGFzKCduYXRpdmUteGhyMicpKSB8fCAhKGlzQXJyYXlCdWZmZXIoZGF0YSkgfHwgaXNCbG9iKGRhdGEpICkpKXtcblx0XHRcdFx0b3B0aW9ucy5kYXRhID0gaW9RdWVyeS5vYmplY3RUb1F1ZXJ5KGRhdGEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKHF1ZXJ5KXtcblx0XHRcdGlmKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcpe1xuXHRcdFx0XHRxdWVyeSA9IGlvUXVlcnkub2JqZWN0VG9RdWVyeShxdWVyeSk7XG5cdFx0XHR9XG5cdFx0XHRpZihvcHRpb25zLnByZXZlbnRDYWNoZSl7XG5cdFx0XHRcdHF1ZXJ5ICs9IChxdWVyeSA/ICcmJyA6ICcnKSArICdyZXF1ZXN0LnByZXZlbnRDYWNoZT0nICsgKCsobmV3IERhdGUpKTtcblx0XHRcdH1cblx0XHR9ZWxzZSBpZihvcHRpb25zLnByZXZlbnRDYWNoZSl7XG5cdFx0XHRxdWVyeSA9ICdyZXF1ZXN0LnByZXZlbnRDYWNoZT0nICsgKCsobmV3IERhdGUpKTtcblx0XHR9XG5cblx0XHRpZih1cmwgJiYgcXVlcnkpe1xuXHRcdFx0dXJsICs9ICh+dXJsLmluZGV4T2YoJz8nKSA/ICcmJyA6ICc/JykgKyBxdWVyeTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHRvcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0Z2V0SGVhZGVyOiBmdW5jdGlvbihoZWFkZXJOYW1lKXsgcmV0dXJuIG51bGw7IH1cblx0XHR9O1xuXHR9O1xuXG5cdGV4cG9ydHMuY2hlY2tTdGF0dXMgPSBmdW5jdGlvbihzdGF0KXtcblx0XHRzdGF0ID0gc3RhdCB8fCAwO1xuXHRcdHJldHVybiAoc3RhdCA+PSAyMDAgJiYgc3RhdCA8IDMwMCkgfHwgLy8gYWxsb3cgYW55IDJYWCByZXNwb25zZSBjb2RlXG5cdFx0XHRzdGF0ID09PSAzMDQgfHwgICAgICAgICAgICAgICAgIC8vIG9yLCBnZXQgaXQgb3V0IG9mIHRoZSBjYWNoZVxuXHRcdFx0c3RhdCA9PT0gMTIyMyB8fCAgICAgICAgICAgICAgICAvLyBvciwgSW50ZXJuZXQgRXhwbG9yZXIgbWFuZ2xlZCB0aGUgc3RhdHVzIGNvZGVcblx0XHRcdCFzdGF0OyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciwgd2UncmUgVGl0YW5pdW0vYnJvd3NlciBjaHJvbWUvY2hyb21lIGV4dGVuc2lvbiByZXF1ZXN0aW5nIGEgbG9jYWwgZmlsZVxuXHR9O1xufSk7XG4iLCJkZWZpbmUoW1xuXHQnLi91dGlsJyxcblx0Jy4uL2Vycm9ycy9SZXF1ZXN0VGltZW91dEVycm9yJyxcblx0Jy4uL2Vycm9ycy9DYW5jZWxFcnJvcicsXG5cdCcuLi9fYmFzZS9hcnJheScsXG5cdCcuLi9oYXMhaG9zdC1icm93c2VyPy4uL19iYXNlL3dpbmRvdzonLFxuXHQnLi4vaGFzIWhvc3QtYnJvd3Nlcj9kb20tYWRkZXZlbnRsaXN0ZW5lcj86Li4vb246J1xuXSwgZnVuY3Rpb24odXRpbCwgUmVxdWVzdFRpbWVvdXRFcnJvciwgQ2FuY2VsRXJyb3IsIGFycmF5LCB3aW4sIG9uKXtcblx0Ly8gYXZvaWQgc2V0dGluZyBhIHRpbWVyIHBlciByZXF1ZXN0LiBJdCBkZWdyYWRlcyBwZXJmb3JtYW5jZSBvbiBJRVxuXHQvLyBzb21ldGhpbmcgZmllcmVjZSBpZiB3ZSBkb24ndCB1c2UgdW5pZmllZCBsb29wcy5cblx0dmFyIF9pbkZsaWdodEludHZsID0gbnVsbCxcblx0XHRfaW5GbGlnaHQgPSBbXTtcblxuXHRmdW5jdGlvbiB3YXRjaEluRmxpZ2h0KCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRpbnRlcm5hbCBtZXRob2QgdGhhdCBjaGVja3MgZWFjaCBpbmZsaWdodCBYTUxIdHRwUmVxdWVzdCB0byBzZWVcblx0XHQvL1x0XHRpZiBpdCBoYXMgY29tcGxldGVkIG9yIGlmIHRoZSB0aW1lb3V0IHNpdHVhdGlvbiBhcHBsaWVzLlxuXG5cdFx0dmFyIG5vdyA9ICsobmV3IERhdGUpO1xuXG5cdFx0Ly8gd2UgbmVlZCBtYW51YWwgbG9vcCBiZWNhdXNlIHdlIG9mdGVuIG1vZGlmeSBfaW5GbGlnaHQgKGFuZCB0aGVyZWZvcmUgJ2knKSB3aGlsZSBpdGVyYXRpbmdcblx0XHRmb3IodmFyIGkgPSAwLCBkZmQ7IGkgPCBfaW5GbGlnaHQubGVuZ3RoICYmIChkZmQgPSBfaW5GbGlnaHRbaV0pOyBpKyspe1xuXHRcdFx0dmFyIHJlc3BvbnNlID0gZGZkLnJlc3BvbnNlLFxuXHRcdFx0XHRvcHRpb25zID0gcmVzcG9uc2Uub3B0aW9ucztcblx0XHRcdGlmKChkZmQuaXNDYW5jZWxlZCAmJiBkZmQuaXNDYW5jZWxlZCgpKSB8fCAoZGZkLmlzVmFsaWQgJiYgIWRmZC5pc1ZhbGlkKHJlc3BvbnNlKSkpe1xuXHRcdFx0XHRfaW5GbGlnaHQuc3BsaWNlKGktLSwgMSk7XG5cdFx0XHRcdHdhdGNoLl9vbkFjdGlvbiAmJiB3YXRjaC5fb25BY3Rpb24oKTtcblx0XHRcdH1lbHNlIGlmKGRmZC5pc1JlYWR5ICYmIGRmZC5pc1JlYWR5KHJlc3BvbnNlKSl7XG5cdFx0XHRcdF9pbkZsaWdodC5zcGxpY2UoaS0tLCAxKTtcblx0XHRcdFx0ZGZkLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcblx0XHRcdFx0d2F0Y2guX29uQWN0aW9uICYmIHdhdGNoLl9vbkFjdGlvbigpO1xuXHRcdFx0fWVsc2UgaWYoZGZkLnN0YXJ0VGltZSl7XG5cdFx0XHRcdC8vIGRpZCB3ZSB0aW1lb3V0P1xuXHRcdFx0XHRpZihkZmQuc3RhcnRUaW1lICsgKG9wdGlvbnMudGltZW91dCB8fCAwKSA8IG5vdyl7XG5cdFx0XHRcdFx0X2luRmxpZ2h0LnNwbGljZShpLS0sIDEpO1xuXHRcdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdCBzbyB0aGUgaW8gbW9kdWxlIGNhbiBkbyBhcHByb3ByaWF0ZSBjbGVhbnVwLlxuXHRcdFx0XHRcdGRmZC5jYW5jZWwobmV3IFJlcXVlc3RUaW1lb3V0RXJyb3IoJ1RpbWVvdXQgZXhjZWVkZWQnLCByZXNwb25zZSkpO1xuXHRcdFx0XHRcdHdhdGNoLl9vbkFjdGlvbiAmJiB3YXRjaC5fb25BY3Rpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHdhdGNoLl9vbkluRmxpZ2h0ICYmIHdhdGNoLl9vbkluRmxpZ2h0KGRmZCk7XG5cblx0XHRpZighX2luRmxpZ2h0Lmxlbmd0aCl7XG5cdFx0XHRjbGVhckludGVydmFsKF9pbkZsaWdodEludHZsKTtcblx0XHRcdF9pbkZsaWdodEludHZsID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiB3YXRjaChkZmQpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0V2F0Y2hlcyB0aGUgaW8gcmVxdWVzdCByZXByZXNlbnRlZCBieSBkZmQgdG8gc2VlIGlmIGl0IGNvbXBsZXRlcy5cblx0XHQvLyBkZmQ6IERlZmVycmVkXG5cdFx0Ly9cdFx0VGhlIERlZmVycmVkIG9iamVjdCB0byB3YXRjaC5cblx0XHQvLyByZXNwb25zZTogT2JqZWN0XG5cdFx0Ly9cdFx0VGhlIG9iamVjdCB1c2VkIGFzIHRoZSB2YWx1ZSBvZiB0aGUgcmVxdWVzdCBwcm9taXNlLlxuXHRcdC8vIHZhbGlkQ2hlY2s6IEZ1bmN0aW9uXG5cdFx0Ly9cdFx0RnVuY3Rpb24gdXNlZCB0byBjaGVjayBpZiB0aGUgSU8gcmVxdWVzdCBpcyBzdGlsbCB2YWxpZC4gR2V0cyB0aGUgZGZkXG5cdFx0Ly9cdFx0b2JqZWN0IGFzIGl0cyBvbmx5IGFyZ3VtZW50LlxuXHRcdC8vIGlvQ2hlY2s6IEZ1bmN0aW9uXG5cdFx0Ly9cdFx0RnVuY3Rpb24gdXNlZCB0byBjaGVjayBpZiBiYXNpYyBJTyBjYWxsIHdvcmtlZC4gR2V0cyB0aGUgZGZkXG5cdFx0Ly9cdFx0b2JqZWN0IGFzIGl0cyBvbmx5IGFyZ3VtZW50LlxuXHRcdC8vIHJlc0hhbmRsZTogRnVuY3Rpb25cblx0XHQvL1x0XHRGdW5jdGlvbiB1c2VkIHRvIHByb2Nlc3MgcmVzcG9uc2UuIEdldHMgdGhlIGRmZFxuXHRcdC8vXHRcdG9iamVjdCBhcyBpdHMgb25seSBhcmd1bWVudC5cblx0XHRpZihkZmQucmVzcG9uc2Uub3B0aW9ucy50aW1lb3V0KXtcblx0XHRcdGRmZC5zdGFydFRpbWUgPSArKG5ldyBEYXRlKTtcblx0XHR9XG5cblx0XHRpZihkZmQuaXNGdWxmaWxsZWQoKSl7XG5cdFx0XHQvLyBiYWlsIG91dCBpZiB0aGUgZGVmZXJyZWQgaXMgYWxyZWFkeSBmdWxmaWxsZWRcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRfaW5GbGlnaHQucHVzaChkZmQpO1xuXHRcdGlmKCFfaW5GbGlnaHRJbnR2bCl7XG5cdFx0XHRfaW5GbGlnaHRJbnR2bCA9IHNldEludGVydmFsKHdhdGNoSW5GbGlnaHQsIDUwKTtcblx0XHR9XG5cblx0XHQvLyBoYW5kbGUgc3luYyByZXF1ZXN0cyBzZXBhcmF0ZWx5IGZyb20gYXN5bmM6XG5cdFx0Ly8gaHR0cDovL2J1Z3MuZG9qb3Rvb2xraXQub3JnL3RpY2tldC84NDY3XG5cdFx0aWYoZGZkLnJlc3BvbnNlLm9wdGlvbnMuc3luYyl7XG5cdFx0XHR3YXRjaEluRmxpZ2h0KCk7XG5cdFx0fVxuXHR9XG5cblx0d2F0Y2guY2FuY2VsQWxsID0gZnVuY3Rpb24gY2FuY2VsQWxsKCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRDYW5jZWxzIGFsbCBwZW5kaW5nIElPIHJlcXVlc3RzLCByZWdhcmRsZXNzIG9mIElPIHR5cGVcblx0XHR0cnl7XG5cdFx0XHRhcnJheS5mb3JFYWNoKF9pbkZsaWdodCwgZnVuY3Rpb24oZGZkKXtcblx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdGRmZC5jYW5jZWwobmV3IENhbmNlbEVycm9yKCdBbGwgcmVxdWVzdHMgY2FuY2VsZWQuJykpO1xuXHRcdFx0XHR9Y2F0Y2goZSl7fVxuXHRcdFx0fSk7XG5cdFx0fWNhdGNoKGUpe31cblx0fTtcblxuXHRpZih3aW4gJiYgb24gJiYgd2luLmRvYy5hdHRhY2hFdmVudCl7XG5cdFx0Ly8gQXV0b21hdGljYWxseSBjYWxsIGNhbmNlbCBhbGwgaW8gY2FsbHMgb24gdW5sb2FkIGluIElFXG5cdFx0Ly8gaHR0cDovL2J1Z3MuZG9qb3Rvb2xraXQub3JnL3RpY2tldC8yMzU3XG5cdFx0b24od2luLmdsb2JhbCwgJ3VubG9hZCcsIGZ1bmN0aW9uKCl7XG5cdFx0XHR3YXRjaC5jYW5jZWxBbGwoKTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB3YXRjaDtcbn0pO1xuIiwiZGVmaW5lKFtcblx0Jy4uL2Vycm9ycy9SZXF1ZXN0RXJyb3InLFxuXHQnLi93YXRjaCcsXG5cdCcuL2hhbmRsZXJzJyxcblx0Jy4vdXRpbCcsXG5cdCcuLi9oYXMnLyo9PT09PSxcblx0Jy4uL3JlcXVlc3QnLFxuXHQnLi4vX2Jhc2UvZGVjbGFyZScgPT09PT0qL1xuXSwgZnVuY3Rpb24oUmVxdWVzdEVycm9yLCB3YXRjaCwgaGFuZGxlcnMsIHV0aWwsIGhhcy8qPT09PT0sIHJlcXVlc3QsIGRlY2xhcmUgPT09PT0qLyl7XG5cdGhhcy5hZGQoJ25hdGl2ZS14aHInLCBmdW5jdGlvbigpe1xuXHRcdC8vIGlmIHRydWUsIHRoZSBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgWEhSIGltcGxlbWVudGF0aW9uXG5cdFx0cmV0dXJuIHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCc7XG5cdH0pO1xuXHRoYXMuYWRkKCdkb2pvLWZvcmNlLWFjdGl2ZXgteGhyJywgZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gaGFzKCdhY3RpdmV4JykgJiYgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnZmlsZTonO1xuXHR9KTtcblxuXHRoYXMuYWRkKCduYXRpdmUteGhyMicsIGZ1bmN0aW9uKCl7XG5cdFx0aWYoIWhhcygnbmF0aXZlLXhocicpIHx8IGhhcygnZG9qby1mb3JjZS1hY3RpdmV4LXhocicpKXsgcmV0dXJuOyB9XG5cdFx0dmFyIHggPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRyZXR1cm4gdHlwZW9mIHhbJ2FkZEV2ZW50TGlzdGVuZXInXSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdCh0eXBlb2Ygb3BlcmEgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB4Wyd1cGxvYWQnXSAhPT0gJ3VuZGVmaW5lZCcpO1xuXHR9KTtcblxuXHRoYXMuYWRkKCduYXRpdmUtZm9ybWRhdGEnLCBmdW5jdGlvbigpe1xuXHRcdC8vIGlmIHRydWUsIHRoZSBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgRm9ybURhdGEgaW1wbGVtZW50YXRpb25cblx0XHRyZXR1cm4gdHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJztcblx0fSk7XG5cblx0aGFzLmFkZCgnbmF0aXZlLWJsb2InLCBmdW5jdGlvbigpe1xuXHRcdC8vIGlmIHRydWUsIHRoZSBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgQmxvYiBpbXBsZW1lbnRhdGlvblxuXHRcdHJldHVybiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCc7XG5cdH0pO1xuXG5cdGhhcy5hZGQoJ25hdGl2ZS1hcnJheWJ1ZmZlcicsIGZ1bmN0aW9uKCl7XG5cdFx0Ly8gaWYgdHJ1ZSwgdGhlIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSBBcnJheUJ1ZmZlciBpbXBsZW1lbnRhdGlvblxuXHRcdHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnO1xuXHR9KTtcblxuXHRoYXMuYWRkKCduYXRpdmUtcmVzcG9uc2UtdHlwZScsIGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIGhhcygnbmF0aXZlLXhocicpICYmIHR5cGVvZiBuZXcgWE1MSHR0cFJlcXVlc3QoKS5yZXNwb25zZVR5cGUgIT09ICd1bmRlZmluZWQnO1xuXHR9KTtcblxuXHRoYXMuYWRkKCduYXRpdmUteGhyMi1ibG9iJywgZnVuY3Rpb24oKXtcblx0XHRpZighaGFzKCduYXRpdmUtcmVzcG9uc2UtdHlwZScpKXsgcmV0dXJuOyB9XG5cdFx0dmFyIHggPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHQvLyBUaGUgVVJMIHVzZWQgaGVyZSBkb2VzIG5vdCBoYXZlIHRvIGJlIHJlYWNoYWJsZSBhcyB0aGUgWEhSJ3MgYHNlbmRgIG1ldGhvZCBpcyBuZXZlciBjYWxsZWQuXG5cdFx0Ly8gSXQgZG9lcyBuZWVkIHRvIGJlIHBhcnNhYmxlL3Jlc29sdmFibGUgaW4gYWxsIGNhc2VzLCBzbyBpdCBzaG91bGQgYmUgYW4gYWJzb2x1dGUgVVJMLlxuXHRcdC8vIFhNTEh0dHBSZXF1ZXN0IHdpdGhpbiBhIFdvcmtlciBjcmVhdGVkIGZyb20gYSBCbG9iIGRvZXMgbm90IHN1cHBvcnQgcmVsYXRpdmUgVVJMIHBhdGhzLlxuXHRcdHgub3BlbignR0VUJywgJ2h0dHBzOi8vZG9qb3Rvb2xraXQub3JnLycsIHRydWUpO1xuXHRcdHgucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuXHRcdC8vIHdpbGwgbm90IGJlIHNldCBpZiB1bnN1cHBvcnRlZFxuXHRcdHZhciByZXNwb25zZVR5cGUgPSB4LnJlc3BvbnNlVHlwZTtcblx0XHR4LmFib3J0KCk7XG5cdFx0cmV0dXJuIHJlc3BvbnNlVHlwZSA9PT0gJ2Jsb2InO1xuXHR9KTtcblxuXHQvLyBHb29nbGUgQ2hyb21lIGRvZXNuJ3Qgc3VwcG9ydCBcImpzb25cIiByZXNwb25zZSB0eXBlXG5cdC8vIHVwIHRvIHZlcnNpb24gMzAsIHNvIGl0J3MgaW50ZW50aW9uYWxseSBub3QgaW5jbHVkZWQgaGVyZVxuXHR2YXIgbmF0aXZlUmVzcG9uc2VUeXBlcyA9IHtcblx0XHQnYmxvYic6IGhhcygnbmF0aXZlLXhocjItYmxvYicpID8gJ2Jsb2InIDogJ2FycmF5YnVmZmVyJyxcblx0XHQnZG9jdW1lbnQnOiAnZG9jdW1lbnQnLFxuXHRcdCdhcnJheWJ1ZmZlcic6ICdhcnJheWJ1ZmZlcidcblx0fTtcblxuXHRmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShyZXNwb25zZSwgZXJyb3Ipe1xuXHRcdHZhciBfeGhyID0gcmVzcG9uc2UueGhyO1xuXHRcdHJlc3BvbnNlLnN0YXR1cyA9IHJlc3BvbnNlLnhoci5zdGF0dXM7XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gRmlyZWZveCB0aHJvd3MgYW4gZXJyb3Igd2hlbiB0cnlpbmcgdG8gYWNjZXNzXG5cdFx0XHQvLyB4aHIucmVzcG9uc2VUZXh0IGlmIHJlc3BvbnNlIGlzbid0IHRleHRcblx0XHRcdHJlc3BvbnNlLnRleHQgPSBfeGhyLnJlc3BvbnNlVGV4dDtcblx0XHR9IGNhdGNoIChlKSB7fVxuXG5cdFx0aWYocmVzcG9uc2Uub3B0aW9ucy5oYW5kbGVBcyA9PT0gJ3htbCcpe1xuXHRcdFx0cmVzcG9uc2UuZGF0YSA9IF94aHIucmVzcG9uc2VYTUw7XG5cdFx0fVxuXG5cdFx0dmFyIGhhbmRsZUVycm9yO1xuXHRcdGlmKGVycm9yKXtcblx0XHRcdHRoaXMucmVqZWN0KGVycm9yKTtcblx0XHR9ZWxzZXtcblx0XHRcdHRyeXtcblx0XHRcdFx0aGFuZGxlcnMocmVzcG9uc2UpO1xuXHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHRoYW5kbGVFcnJvciA9IGU7XG5cdFx0XHR9XG5cdFx0XHRpZih1dGlsLmNoZWNrU3RhdHVzKF94aHIuc3RhdHVzKSl7XG5cdFx0XHRcdGlmKCFoYW5kbGVFcnJvcil7XG5cdFx0XHRcdFx0dGhpcy5yZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0dGhpcy5yZWplY3QoaGFuZGxlRXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0aWYoIWhhbmRsZUVycm9yKXtcblx0XHRcdFx0XHRlcnJvciA9IG5ldyBSZXF1ZXN0RXJyb3IoJ1VuYWJsZSB0byBsb2FkICcgKyByZXNwb25zZS51cmwgKyAnIHN0YXR1czogJyArIF94aHIuc3RhdHVzLCByZXNwb25zZSk7XG5cdFx0XHRcdFx0dGhpcy5yZWplY3QoZXJyb3IpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRlcnJvciA9IG5ldyBSZXF1ZXN0RXJyb3IoJ1VuYWJsZSB0byBsb2FkICcgKyByZXNwb25zZS51cmwgKyAnIHN0YXR1czogJyArIF94aHIuc3RhdHVzICtcblx0XHRcdFx0XHRcdCcgYW5kIGFuIGVycm9yIGluIGhhbmRsZUFzOiB0cmFuc2Zvcm1hdGlvbiBvZiByZXNwb25zZScsIHJlc3BvbnNlKTtcblx0XHRcdFx0XHR0aGlzLnJlamVjdChlcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgaXNWYWxpZCwgaXNSZWFkeSwgYWRkTGlzdGVuZXJzLCBjYW5jZWw7XG5cdGlmKGhhcygnbmF0aXZlLXhocjInKSl7XG5cdFx0Ly8gQW55IHBsYXRmb3JtIHdpdGggWEhSMiB3aWxsIG9ubHkgdXNlIHRoZSB3YXRjaCBtZWNoYW5pc20gZm9yIHRpbWVvdXQuXG5cblx0XHRpc1ZhbGlkID0gZnVuY3Rpb24ocmVzcG9uc2Upe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENoZWNrIHRvIHNlZSBpZiB0aGUgcmVxdWVzdCBzaG91bGQgYmUgdGFrZW4gb3V0IG9mIHRoZSB3YXRjaCBxdWV1ZVxuXHRcdFx0cmV0dXJuICF0aGlzLmlzRnVsZmlsbGVkKCk7XG5cdFx0fTtcblx0XHRjYW5jZWwgPSBmdW5jdGlvbihkZmQsIHJlc3BvbnNlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYW5jZWxlciBmb3IgZGVmZXJyZWRcblx0XHRcdHJlc3BvbnNlLnhoci5hYm9ydCgpO1xuXHRcdH07XG5cdFx0YWRkTGlzdGVuZXJzID0gZnVuY3Rpb24oX3hociwgZGZkLCByZXNwb25zZSwgdXBsb2FkUHJvZ3Jlc3Mpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBYTUxIdHRwUmVxdWVzdCBvYmplY3Rcblx0XHRcdGZ1bmN0aW9uIG9uTG9hZChldnQpe1xuXHRcdFx0XHRkZmQuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gb25FcnJvcihldnQpe1xuXHRcdFx0XHR2YXIgX3hociA9IGV2dC50YXJnZXQ7XG5cdFx0XHRcdHZhciBlcnJvciA9IG5ldyBSZXF1ZXN0RXJyb3IoJ1VuYWJsZSB0byBsb2FkICcgKyByZXNwb25zZS51cmwgKyAnIHN0YXR1czogJyArIF94aHIuc3RhdHVzLCByZXNwb25zZSk7XG5cdFx0XHRcdGRmZC5oYW5kbGVSZXNwb25zZShyZXNwb25zZSwgZXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBvblByb2dyZXNzKHRyYW5zZmVyVHlwZSwgZXZ0KXtcblx0XHRcdFx0cmVzcG9uc2UudHJhbnNmZXJUeXBlID0gdHJhbnNmZXJUeXBlO1xuXHRcdFx0XHRpZihldnQubGVuZ3RoQ29tcHV0YWJsZSl7XG5cdFx0XHRcdFx0cmVzcG9uc2UubG9hZGVkID0gZXZ0LmxvYWRlZDtcblx0XHRcdFx0XHRyZXNwb25zZS50b3RhbCA9IGV2dC50b3RhbDtcblx0XHRcdFx0XHRkZmQucHJvZ3Jlc3MocmVzcG9uc2UpO1xuXHRcdFx0XHR9IGVsc2UgaWYocmVzcG9uc2UueGhyLnJlYWR5U3RhdGUgPT09IDMpe1xuXHRcdFx0XHRcdHJlc3BvbnNlLmxvYWRlZCA9ICgnbG9hZGVkJyBpbiBldnQpID8gZXZ0LmxvYWRlZCA6IGV2dC5wb3NpdGlvbjtcblx0XHRcdFx0XHRkZmQucHJvZ3Jlc3MocmVzcG9uc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uRG93bmxvYWRQcm9ncmVzcyhldnQpIHtcblx0XHRcdFx0cmV0dXJuIG9uUHJvZ3Jlc3MoJ2Rvd25sb2FkJywgZXZ0KTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gb25VcGxvYWRQcm9ncmVzcyhldnQpIHtcblx0XHRcdFx0cmV0dXJuIG9uUHJvZ3Jlc3MoJ3VwbG9hZCcsIGV2dCk7XG5cdFx0XHR9XG5cblx0XHRcdF94aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCwgZmFsc2UpO1xuXHRcdFx0X3hoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IsIGZhbHNlKTtcblx0XHRcdF94aHIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBvbkRvd25sb2FkUHJvZ3Jlc3MsIGZhbHNlKTtcblxuXHRcdFx0aWYgKHVwbG9hZFByb2dyZXNzICYmIF94aHIudXBsb2FkKSB7XG5cdFx0XHRcdF94aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgb25VcGxvYWRQcm9ncmVzcywgZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdFx0X3hoci5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkLCBmYWxzZSk7XG5cdFx0XHRcdF94aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yLCBmYWxzZSk7XG5cdFx0XHRcdF94aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBvbkRvd25sb2FkUHJvZ3Jlc3MsIGZhbHNlKTtcblx0XHRcdFx0X3hoci51cGxvYWQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBvblVwbG9hZFByb2dyZXNzLCBmYWxzZSk7XG5cdFx0XHRcdF94aHIgPSBudWxsO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9ZWxzZXtcblx0XHRpc1ZhbGlkID0gZnVuY3Rpb24ocmVzcG9uc2Upe1xuXHRcdFx0cmV0dXJuIHJlc3BvbnNlLnhoci5yZWFkeVN0YXRlOyAvL2Jvb2xlYW5cblx0XHR9O1xuXHRcdGlzUmVhZHkgPSBmdW5jdGlvbihyZXNwb25zZSl7XG5cdFx0XHRyZXR1cm4gNCA9PT0gcmVzcG9uc2UueGhyLnJlYWR5U3RhdGU7IC8vYm9vbGVhblxuXHRcdH07XG5cdFx0Y2FuY2VsID0gZnVuY3Rpb24oZGZkLCByZXNwb25zZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Y2FuY2VsbGVyIGZ1bmN0aW9uIGZvciB1dGlsLmRlZmVycmVkIGNhbGwuXG5cdFx0XHR2YXIgeGhyID0gcmVzcG9uc2UueGhyO1xuXHRcdFx0dmFyIF9hdCA9IHR5cGVvZiB4aHIuYWJvcnQ7XG5cdFx0XHRpZihfYXQgPT09ICdmdW5jdGlvbicgfHwgX2F0ID09PSAnb2JqZWN0JyB8fCBfYXQgPT09ICd1bmtub3duJyl7XG5cdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRIZWFkZXIoaGVhZGVyTmFtZSl7XG5cdFx0cmV0dXJuIHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlck5hbWUpO1xuXHR9XG5cblx0dmFyIHVuZGVmaW5lZCxcblx0XHRkZWZhdWx0T3B0aW9ucyA9IHtcblx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRxdWVyeTogbnVsbCxcblx0XHRcdHN5bmM6IGZhbHNlLFxuXHRcdFx0bWV0aG9kOiAnR0VUJ1xuXHRcdH07XG5cdGZ1bmN0aW9uIHhocih1cmwsIG9wdGlvbnMsIHJldHVybkRlZmVycmVkKXtcblx0XHR2YXIgaXNGb3JtRGF0YSA9IGhhcygnbmF0aXZlLWZvcm1kYXRhJykgJiYgb3B0aW9ucyAmJiBvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5kYXRhIGluc3RhbmNlb2YgRm9ybURhdGE7XG5cdFx0dmFyIHJlc3BvbnNlID0gdXRpbC5wYXJzZUFyZ3MoXG5cdFx0XHR1cmwsXG5cdFx0XHR1dGlsLmRlZXBDcmVhdGUoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpLFxuXHRcdFx0aXNGb3JtRGF0YVxuXHRcdCk7XG5cdFx0dXJsID0gcmVzcG9uc2UudXJsO1xuXHRcdG9wdGlvbnMgPSByZXNwb25zZS5vcHRpb25zO1xuXHRcdHZhciBoYXNOb0RhdGEgPSAhb3B0aW9ucy5kYXRhICYmIG9wdGlvbnMubWV0aG9kICE9PSAnUE9TVCcgJiYgb3B0aW9ucy5tZXRob2QgIT09ICdQVVQnO1xuXG5cdFx0aWYoaGFzKCdpZScpIDw9IDEwKXtcblx0XHRcdC8vIG9sZGVyIElFIGJyZWFrcyBwb2ludCA5IGluIGh0dHA6Ly93d3cudzMub3JnL1RSL1hNTEh0dHBSZXF1ZXN0LyN0aGUtb3BlbigpLW1ldGhvZCBhbmQgc2VuZHMgZnJhZ21lbnQsIHNvIHN0cmlwIGl0XG5cdFx0XHR1cmwgPSB1cmwuc3BsaXQoJyMnKVswXTtcblx0XHR9XG5cblx0XHR2YXIgcmVtb3Zlcixcblx0XHRcdGxhc3QgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRyZW1vdmVyICYmIHJlbW92ZXIoKTtcblx0XHRcdH07XG5cblx0XHQvL01ha2UgdGhlIERlZmVycmVkIG9iamVjdCBmb3IgdGhpcyB4aHIgcmVxdWVzdC5cblx0XHR2YXIgZGZkID0gdXRpbC5kZWZlcnJlZChcblx0XHRcdHJlc3BvbnNlLFxuXHRcdFx0Y2FuY2VsLFxuXHRcdFx0aXNWYWxpZCxcblx0XHRcdGlzUmVhZHksXG5cdFx0XHRoYW5kbGVSZXNwb25zZSxcblx0XHRcdGxhc3Rcblx0XHQpO1xuXHRcdHZhciBfeGhyID0gcmVzcG9uc2UueGhyID0geGhyLl9jcmVhdGUoKTtcblxuXHRcdGlmKCFfeGhyKXtcblx0XHRcdC8vIElmIFhIUiBmYWN0b3J5IHNvbWVob3cgcmV0dXJucyBub3RoaW5ncyxcblx0XHRcdC8vIGNhbmNlbCB0aGUgZGVmZXJyZWQuXG5cdFx0XHRkZmQuY2FuY2VsKG5ldyBSZXF1ZXN0RXJyb3IoJ1hIUiB3YXMgbm90IGNyZWF0ZWQnKSk7XG5cdFx0XHRyZXR1cm4gcmV0dXJuRGVmZXJyZWQgPyBkZmQgOiBkZmQucHJvbWlzZTtcblx0XHR9XG5cblx0XHRyZXNwb25zZS5nZXRIZWFkZXIgPSBnZXRIZWFkZXI7XG5cblx0XHRpZihhZGRMaXN0ZW5lcnMpe1xuXHRcdFx0cmVtb3ZlciA9IGFkZExpc3RlbmVycyhfeGhyLCBkZmQsIHJlc3BvbnNlLCBvcHRpb25zLnVwbG9hZFByb2dyZXNzKTtcblx0XHR9XG5cblx0XHQvLyBJRTExIHRyZWF0cyBkYXRhOiB1bmRlZmluZWQgZGlmZmVyZW50IHRoYW4gb3RoZXIgYnJvd3NlcnNcblx0XHR2YXIgZGF0YSA9IHR5cGVvZihvcHRpb25zLmRhdGEpID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBvcHRpb25zLmRhdGEsXG5cdFx0XHRhc3luYyA9ICFvcHRpb25zLnN5bmMsXG5cdFx0XHRtZXRob2QgPSBvcHRpb25zLm1ldGhvZDtcblxuXHRcdHRyeXtcblx0XHRcdC8vIElFNiB3b24ndCBsZXQgeW91IGNhbGwgYXBwbHkoKSBvbiB0aGUgbmF0aXZlIGZ1bmN0aW9uLlxuXHRcdFx0X3hoci5vcGVuKG1ldGhvZCwgdXJsLCBhc3luYywgb3B0aW9ucy51c2VyIHx8IHVuZGVmaW5lZCwgb3B0aW9ucy5wYXNzd29yZCB8fCB1bmRlZmluZWQpO1xuXG5cdFx0XHRpZihvcHRpb25zLndpdGhDcmVkZW50aWFscyl7XG5cdFx0XHRcdF94aHIud2l0aENyZWRlbnRpYWxzID0gb3B0aW9ucy53aXRoQ3JlZGVudGlhbHM7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGhhcygnbmF0aXZlLXJlc3BvbnNlLXR5cGUnKSAmJiBvcHRpb25zLmhhbmRsZUFzIGluIG5hdGl2ZVJlc3BvbnNlVHlwZXMpIHtcblx0XHRcdFx0X3hoci5yZXNwb25zZVR5cGUgPSBuYXRpdmVSZXNwb25zZVR5cGVzW29wdGlvbnMuaGFuZGxlQXNdO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyxcblx0XHRcdFx0Y29udGVudFR5cGUgPSAoaXNGb3JtRGF0YSB8fCBoYXNOb0RhdGEpID8gZmFsc2UgOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcblx0XHRcdGlmKGhlYWRlcnMpe1xuXHRcdFx0XHRmb3IodmFyIGhkciBpbiBoZWFkZXJzKXtcblx0XHRcdFx0XHRpZihoZHIudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpe1xuXHRcdFx0XHRcdFx0Y29udGVudFR5cGUgPSBoZWFkZXJzW2hkcl07XG5cdFx0XHRcdFx0fWVsc2UgaWYoaGVhZGVyc1toZHJdKXtcblx0XHRcdFx0XHRcdC8vT25seSBhZGQgaGVhZGVyIGlmIGl0IGhhcyBhIHZhbHVlLiBUaGlzIGFsbG93cyBmb3IgaW5zdGFuY2UsIHNraXBwaW5nXG5cdFx0XHRcdFx0XHQvL2luc2VydGlvbiBvZiBYLVJlcXVlc3RlZC1XaXRoIGJ5IHNwZWNpZnlpbmcgZW1wdHkgdmFsdWUuXG5cdFx0XHRcdFx0XHRfeGhyLnNldFJlcXVlc3RIZWFkZXIoaGRyLCBoZWFkZXJzW2hkcl0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZSAhPT0gZmFsc2Upe1xuXHRcdFx0XHRfeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKTtcblx0XHRcdH1cblx0XHRcdGlmKCFoZWFkZXJzIHx8ICEoJ1gtUmVxdWVzdGVkLVdpdGgnIGluIGhlYWRlcnMpKXtcblx0XHRcdFx0X3hoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHV0aWwubm90aWZ5KXtcblx0XHRcdFx0dXRpbC5ub3RpZnkuZW1pdCgnc2VuZCcsIHJlc3BvbnNlLCBkZmQucHJvbWlzZS5jYW5jZWwpO1xuXHRcdFx0fVxuXHRcdFx0X3hoci5zZW5kKGRhdGEpO1xuXHRcdH1jYXRjaChlKXtcblx0XHRcdGRmZC5yZWplY3QoZSk7XG5cdFx0fVxuXG5cdFx0d2F0Y2goZGZkKTtcblx0XHRfeGhyID0gbnVsbDtcblxuXHRcdHJldHVybiByZXR1cm5EZWZlcnJlZCA/IGRmZCA6IGRmZC5wcm9taXNlO1xuXHR9XG5cblx0Lyo9PT09PVxuXHR4aHIgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0U2VuZHMgYSByZXF1ZXN0IHVzaW5nIFhNTEh0dHBSZXF1ZXN0IHdpdGggdGhlIGdpdmVuIFVSTCBhbmQgb3B0aW9ucy5cblx0XHQvLyB1cmw6IFN0cmluZ1xuXHRcdC8vXHRcdFVSTCB0byByZXF1ZXN0XG5cdFx0Ly8gb3B0aW9uczogZG9qby9yZXF1ZXN0L3hoci5fX09wdGlvbnM/XG5cdFx0Ly9cdFx0T3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuXG5cdFx0Ly8gcmV0dXJuczogZG9qby9yZXF1ZXN0Ll9fUHJvbWlzZVxuXHR9O1xuXHR4aHIuX19CYXNlT3B0aW9ucyA9IGRlY2xhcmUocmVxdWVzdC5fX0Jhc2VPcHRpb25zLCB7XG5cdFx0Ly8gc3luYzogQm9vbGVhbj9cblx0XHQvL1x0XHRXaGV0aGVyIHRvIG1ha2UgYSBzeW5jaHJvbm91cyByZXF1ZXN0IG9yIG5vdC4gRGVmYXVsdFxuXHRcdC8vXHRcdGlzIGBmYWxzZWAgKGFzeW5jaHJvbm91cykuXG5cdFx0Ly8gZGF0YTogU3RyaW5nfE9iamVjdHxGb3JtRGF0YT9cblx0XHQvL1x0XHREYXRhIHRvIHRyYW5zZmVyLiBUaGlzIGlzIGlnbm9yZWQgZm9yIEdFVCBhbmQgREVMRVRFXG5cdFx0Ly9cdFx0cmVxdWVzdHMuXG5cdFx0Ly8gaGVhZGVyczogT2JqZWN0P1xuXHRcdC8vXHRcdEhlYWRlcnMgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cblx0XHQvLyB1c2VyOiBTdHJpbmc/XG5cdFx0Ly9cdFx0VXNlcm5hbWUgdG8gdXNlIGR1cmluZyB0aGUgcmVxdWVzdC5cblx0XHQvLyBwYXNzd29yZDogU3RyaW5nP1xuXHRcdC8vXHRcdFBhc3N3b3JkIHRvIHVzZSBkdXJpbmcgdGhlIHJlcXVlc3QuXG5cdFx0Ly8gd2l0aENyZWRlbnRpYWxzOiBCb29sZWFuP1xuXHRcdC8vXHRcdEZvciBjcm9zcy1zaXRlIHJlcXVlc3RzLCB3aGV0aGVyIHRvIHNlbmQgY3JlZGVudGlhbHNcblx0XHQvL1x0XHRvciBub3QuXG5cdFx0Ly8gdXBsb2FkUHJvZ3Jlc3M6IEJvb2xlYW4/XG5cdFx0Ly9cdFx0VXBsb2FkIHByb2dyZXNzIGV2ZW50cyBjYXVzZSBwcmVmbGlnaHRlZCByZXF1ZXN0cy4gVGhpc1xuXHRcdC8vXHRcdG9wdGlvbiBlbmFibGVzIHVwbG9hZCBwcm9ncmVzcyBldmVudCBzdXBwb3J0IGJ1dCBhbHNvXG5cdFx0Ly9cdFx0Y2F1c2VzIGFsbCByZXF1ZXN0cyB0byBiZSBwcmVmbGlnaHRlZC5cblx0fSk7XG5cdHhoci5fX01ldGhvZE9wdGlvbnMgPSBkZWNsYXJlKG51bGwsIHtcblx0XHQvLyBtZXRob2Q6IFN0cmluZz9cblx0XHQvL1x0XHRUaGUgSFRUUCBtZXRob2QgdG8gdXNlIHRvIG1ha2UgdGhlIHJlcXVlc3QuIE11c3QgYmVcblx0XHQvL1x0XHR1cHBlcmNhc2UuIERlZmF1bHQgaXMgYFwiR0VUXCJgLlxuXHR9KTtcblx0eGhyLl9fT3B0aW9ucyA9IGRlY2xhcmUoW3hoci5fX0Jhc2VPcHRpb25zLCB4aHIuX19NZXRob2RPcHRpb25zXSk7XG5cblx0eGhyLmdldCA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZW5kIGFuIEhUVFAgR0VUIHJlcXVlc3QgdXNpbmcgWE1MSHR0cFJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gVVJMIGFuZCBvcHRpb25zLlxuXHRcdC8vIHVybDogU3RyaW5nXG5cdFx0Ly9cdFx0VVJMIHRvIHJlcXVlc3Rcblx0XHQvLyBvcHRpb25zOiBkb2pvL3JlcXVlc3QveGhyLl9fQmFzZU9wdGlvbnM/XG5cdFx0Ly9cdFx0T3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuXG5cdFx0Ly8gcmV0dXJuczogZG9qby9yZXF1ZXN0Ll9fUHJvbWlzZVxuXHR9O1xuXHR4aHIucG9zdCA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZW5kIGFuIEhUVFAgUE9TVCByZXF1ZXN0IHVzaW5nIFhNTEh0dHBSZXF1ZXN0IHdpdGggdGhlIGdpdmVuIFVSTCBhbmQgb3B0aW9ucy5cblx0XHQvLyB1cmw6IFN0cmluZ1xuXHRcdC8vXHRcdFVSTCB0byByZXF1ZXN0XG5cdFx0Ly8gb3B0aW9uczogZG9qby9yZXF1ZXN0L3hoci5fX0Jhc2VPcHRpb25zP1xuXHRcdC8vXHRcdE9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LlxuXHRcdC8vIHJldHVybnM6IGRvam8vcmVxdWVzdC5fX1Byb21pc2Vcblx0fTtcblx0eGhyLnB1dCA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZW5kIGFuIEhUVFAgUFVUIHJlcXVlc3QgdXNpbmcgWE1MSHR0cFJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gVVJMIGFuZCBvcHRpb25zLlxuXHRcdC8vIHVybDogU3RyaW5nXG5cdFx0Ly9cdFx0VVJMIHRvIHJlcXVlc3Rcblx0XHQvLyBvcHRpb25zOiBkb2pvL3JlcXVlc3QveGhyLl9fQmFzZU9wdGlvbnM/XG5cdFx0Ly9cdFx0T3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuXG5cdFx0Ly8gcmV0dXJuczogZG9qby9yZXF1ZXN0Ll9fUHJvbWlzZVxuXHR9O1xuXHR4aHIuZGVsID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNlbmQgYW4gSFRUUCBERUxFVEUgcmVxdWVzdCB1c2luZyBYTUxIdHRwUmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBVUkwgYW5kIG9wdGlvbnMuXG5cdFx0Ly8gdXJsOiBTdHJpbmdcblx0XHQvL1x0XHRVUkwgdG8gcmVxdWVzdFxuXHRcdC8vIG9wdGlvbnM6IGRvam8vcmVxdWVzdC94aHIuX19CYXNlT3B0aW9ucz9cblx0XHQvL1x0XHRPcHRpb25zIGZvciB0aGUgcmVxdWVzdC5cblx0XHQvLyByZXR1cm5zOiBkb2pvL3JlcXVlc3QuX19Qcm9taXNlXG5cdH07XG5cdD09PT09Ki9cblx0eGhyLl9jcmVhdGUgPSBmdW5jdGlvbigpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0ZG9lcyB0aGUgd29yayBvZiBwb3J0YWJseSBnZW5lcmF0aW5nIGEgbmV3IFhNTEhUVFBSZXF1ZXN0IG9iamVjdC5cblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1hNTEhUVFAgbm90IGF2YWlsYWJsZScpO1xuXHR9O1xuXHRpZihoYXMoJ25hdGl2ZS14aHInKSAmJiAhaGFzKCdkb2pvLWZvcmNlLWFjdGl2ZXgteGhyJykpe1xuXHRcdHhoci5fY3JlYXRlID0gZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR9O1xuXHR9ZWxzZSBpZihoYXMoJ2FjdGl2ZXgnKSl7XG5cdFx0dHJ5e1xuXHRcdFx0bmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7XG5cdFx0XHR4aHIuX2NyZWF0ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTtcblx0XHRcdH07XG5cdFx0fWNhdGNoKGUpe1xuXHRcdFx0dHJ5e1xuXHRcdFx0XHRuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcblx0XHRcdFx0eGhyLl9jcmVhdGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcblx0XHRcdFx0fTtcblx0XHRcdH1jYXRjaChlKXt9XG5cdFx0fVxuXHR9XG5cblx0dXRpbC5hZGRDb21tb25NZXRob2RzKHhocik7XG5cblx0cmV0dXJuIHhocjtcbn0pO1xuIiwiZGVmaW5lKFtcIi4uL2hhc1wiLCBcInJlcXVpcmVcIl0sXG5cdFx0ZnVuY3Rpb24oaGFzLCByZXF1aXJlKXtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdHZhciB0ZXN0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0aGFzLmFkZChcImRvbS1xc2EyLjFcIiwgISF0ZXN0RGl2LnF1ZXJ5U2VsZWN0b3JBbGwpO1xuXHRoYXMuYWRkKFwiZG9tLXFzYTNcIiwgZnVuY3Rpb24oKXtcblx0XHQvLyB0ZXN0IHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVhc29uYWJsZSBuYXRpdmUgc2VsZWN0b3IgZW5naW5lIGF2YWlsYWJsZVxuXHRcdHRyeXtcblx0XHRcdHRlc3REaXYuaW5uZXJIVE1MID0gXCI8cCBjbGFzcz0nVEVTVCc+PC9wPlwiOyAvLyB0ZXN0IGtpbmQgb2YgZnJvbSBzaXp6bGVcblx0XHRcdC8vIFNhZmFyaSBjYW4ndCBoYW5kbGUgdXBwZXJjYXNlIG9yIHVuaWNvZGUgY2hhcmFjdGVycyB3aGVuXG5cdFx0XHQvLyBpbiBxdWlya3MgbW9kZSwgSUU4IGNhbid0IGhhbmRsZSBwc2V1ZG9zIGxpa2UgOmVtcHR5XG5cdFx0XHRyZXR1cm4gdGVzdERpdi5xdWVyeVNlbGVjdG9yQWxsKFwiLlRFU1Q6ZW1wdHlcIikubGVuZ3RoID09IDE7XG5cdFx0fWNhdGNoKGUpe31cblx0fSk7XG59XG5cbnZhciBmdWxsRW5naW5lO1xudmFyIGFjbWUgPSBcIi4vYWNtZVwiLCBsaXRlID0gXCIuL2xpdGVcIjtcbnJldHVybiB7XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdFRoaXMgbW9kdWxlIGhhbmRsZXMgbG9hZGluZyB0aGUgYXBwcm9wcmlhdGUgc2VsZWN0b3IgZW5naW5lIGZvciB0aGUgZ2l2ZW4gYnJvd3NlclxuXG5cdGxvYWQ6IGZ1bmN0aW9uKGlkLCBwYXJlbnRSZXF1aXJlLCBsb2FkZWQsIGNvbmZpZyl7XG5cdFx0aWYgKGNvbmZpZyAmJiBjb25maWcuaXNCdWlsZCkge1xuXHRcdFx0Ly9JbmRpY2F0ZSB0aGF0IHRoZSBvcHRpbWl6ZXIgc2hvdWxkIG5vdCB3YWl0XG5cdFx0XHQvL2ZvciB0aGlzIHJlc291cmNlIGFueSBtb3JlIGFuZCBjb21wbGV0ZSBvcHRpbWl6YXRpb24uXG5cdFx0XHQvL1RoaXMgcmVzb3VyY2Ugd2lsbCBiZSByZXNvbHZlZCBkeW5hbWljYWxseSBkdXJpbmdcblx0XHRcdC8vcnVuIHRpbWUgaW4gdGhlIHdlYiBicm93c2VyLlxuXHRcdFx0bG9hZGVkKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHJlcSA9IHJlcXVpcmU7XG5cdFx0Ly8gaGVyZSB3ZSBpbXBsZW1lbnQgdGhlIGRlZmF1bHQgbG9naWMgZm9yIGNob29zaW5nIGEgc2VsZWN0b3IgZW5naW5lXG5cdFx0aWQgPSBpZCA9PSBcImRlZmF1bHRcIiA/IGhhcyhcImNvbmZpZy1zZWxlY3RvckVuZ2luZVwiKSB8fCBcImNzczNcIiA6IGlkO1xuXHRcdGlkID0gaWQgPT0gXCJjc3MyXCIgfHwgaWQgPT0gXCJsaXRlXCIgPyBsaXRlIDpcblx0XHRcdFx0aWQgPT0gXCJjc3MyLjFcIiA/IGhhcyhcImRvbS1xc2EyLjFcIikgPyBsaXRlIDogYWNtZSA6XG5cdFx0XHRcdGlkID09IFwiY3NzM1wiID8gaGFzKFwiZG9tLXFzYTNcIikgPyBsaXRlIDogYWNtZSA6XG5cdFx0XHRcdGlkID09IFwiYWNtZVwiID8gYWNtZSA6IChyZXEgPSBwYXJlbnRSZXF1aXJlKSAmJiBpZDtcblx0XHRpZihpZC5jaGFyQXQoaWQubGVuZ3RoLTEpID09ICc/Jyl7XG5cdFx0XHRpZCA9IGlkLnN1YnN0cmluZygwLGlkLmxlbmd0aCAtIDEpO1xuXHRcdFx0dmFyIG9wdGlvbmFsTG9hZCA9IHRydWU7XG5cdFx0fVxuXHRcdC8vIHRoZSBxdWVyeSBlbmdpbmUgaXMgb3B0aW9uYWwsIG9ubHkgbG9hZCBpdCBpZiBhIG5hdGl2ZSBvbmUgaXMgbm90IGF2YWlsYWJsZSBvciBleGlzdGluZyBvbmUgaGFzIG5vdCBiZWVuIGxvYWRlZFxuXHRcdGlmKG9wdGlvbmFsTG9hZCAmJiAoaGFzKFwiZG9tLWNvbXBsaWFudC1xc2FcIikgfHwgZnVsbEVuZ2luZSkpe1xuXHRcdFx0cmV0dXJuIGxvYWRlZChmdWxsRW5naW5lKTtcblx0XHR9XG5cdFx0Ly8gbG9hZCB0aGUgcmVmZXJlbmNlZCBzZWxlY3RvciBlbmdpbmVcblx0XHRyZXEoW2lkXSwgZnVuY3Rpb24oZW5naW5lKXtcblx0XHRcdGlmKGlkICE9IFwiLi9saXRlXCIpe1xuXHRcdFx0XHRmdWxsRW5naW5lID0gZW5naW5lO1xuXHRcdFx0fVxuXHRcdFx0bG9hZGVkKGVuZ2luZSk7XG5cdFx0fSk7XG5cdH1cbn07XG59KTtcbiIsImRlZmluZShbXCIuLi9oYXNcIiwgXCIuLi9fYmFzZS9rZXJuZWxcIl0sIGZ1bmN0aW9uKGhhcywgZG9qbyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHRlc3REaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xudmFyIG1hdGNoZXNTZWxlY3RvciA9IHRlc3REaXYubWF0Y2hlcyB8fCB0ZXN0RGl2LndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCB0ZXN0RGl2Lm1vek1hdGNoZXNTZWxlY3RvciB8fCB0ZXN0RGl2Lm1zTWF0Y2hlc1NlbGVjdG9yIHx8IHRlc3REaXYub01hdGNoZXNTZWxlY3RvcjtcbnZhciBxdWVyeVNlbGVjdG9yQWxsID0gdGVzdERpdi5xdWVyeVNlbGVjdG9yQWxsO1xudmFyIHVuaW9uU3BsaXQgPSAvKFteXFxzLF0oPzpcIig/OlxcXFwufFteXCJdKStcInwnKD86XFxcXC58W14nXSkrJ3xbXixdKSopL2c7XG5oYXMuYWRkKFwiZG9tLW1hdGNoZXMtc2VsZWN0b3JcIiwgISFtYXRjaGVzU2VsZWN0b3IpO1xuaGFzLmFkZChcImRvbS1xc2FcIiwgISFxdWVyeVNlbGVjdG9yQWxsKTsgXG5cbi8vIHRoaXMgaXMgYSBzaW1wbGUgcXVlcnkgZW5naW5lLiBJdCBoYXMgaGFuZGxlcyBiYXNpYyBzZWxlY3RvcnMsIGFuZCBmb3Igc2ltcGxlXG4vLyBjb21tb24gc2VsZWN0b3JzIGlzIGV4dHJlbWVseSBmYXN0XG52YXIgbGl0ZUVuZ2luZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCByb290KXtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0QSBzbWFsbCBsaWdodHdlaWdodCBxdWVyeSBzZWxlY3RvciBlbmdpbmUgdGhhdCBpbXBsZW1lbnRzIENTUzIuMSBzZWxlY3RvcnNcblx0Ly9cdFx0bWludXMgcHNldWRvLWNsYXNzZXMgYW5kIHRoZSBzaWJsaW5nIGNvbWJpbmF0b3IsIHBsdXMgQ1NTMyBhdHRyaWJ1dGUgc2VsZWN0b3JzXG5cblx0aWYoY29tYmluZSAmJiBzZWxlY3Rvci5pbmRleE9mKCcsJykgPiAtMSl7XG5cdFx0cmV0dXJuIGNvbWJpbmUoc2VsZWN0b3IsIHJvb3QpO1xuXHR9XG5cdC8vIHVzZSB0aGUgcm9vdCdzIG93bmVyRG9jdW1lbnQgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB0cnkgdG8gdXNlIGRvam8uZG9jLiBOb3RlIFxuXHQvLyB0aGF0IHdlIGRvbid0IHVzZSBkb2pvL19iYXNlL3dpbmRvdydzIGRvYyB0byByZWR1Y2UgZGVwZW5kZW5jaWVzLCBhbmQgXG5cdC8vIGZhbGxiYWNrIHRvIHBsYWluIGRvY3VtZW50IGlmIGRvam8uZG9jIGhhc24ndCBiZWVuIGRlZmluZWQgKGJ5IGRvam8vX2Jhc2Uvd2luZG93KS5cblx0Ly8gcHJlc3VtYWJseSB3ZSB3aWxsIGhhdmUgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXMgaW4gMi4wIFxuXHR2YXIgZG9jID0gcm9vdCA/IHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290IDogZG9qby5kb2MgfHwgZG9jdW1lbnQsIFxuXHRcdG1hdGNoID0gKHF1ZXJ5U2VsZWN0b3JBbGwgPyBcblx0XHRcdC9eKFtcXHddKikjKFtcXHdcXC1dKyQpfF4oXFwuKShbXFx3XFwtXFwqXSskKXxeKFxcdyskKS8gOiAvLyB0aGlzIG9uZSBvbmx5IG1hdGNoZXMgb24gc2ltcGxlIHF1ZXJpZXMgd2hlcmUgd2UgY2FuIGJlYXQgcVNBIHdpdGggc3BlY2lmaWMgbWV0aG9kc1xuXHRcdFx0L14oW1xcd10qKSMoW1xcd1xcLV0rKSg/OlxccysoLiopKT8kfCg/Ol58KD58LitcXHMrKSkoW1xcd1xcLVxcKl0rKShcXFMqJCkvKSAvLyB0aGlzIG9uZSBtYXRjaGVzIHBhcnRzIG9mIHRoZSBxdWVyeSB0aGF0IHdlIGNhbiB1c2UgdG8gc3BlZWQgdXAgbWFudWFsIGZpbHRlcmluZ1xuXHRcdFx0LmV4ZWMoc2VsZWN0b3IpO1xuXHRyb290ID0gcm9vdCB8fCBkb2M7XG5cdGlmKG1hdGNoKXtcblx0XHR2YXIgaXNJbnNpZGVEb21UcmVlID0gaGFzKCdpZScpID09PSA4ICYmIGhhcygncXVpcmtzJyk/XG5cdFx0XHRyb290Lm5vZGVUeXBlID09PSBkb2Mubm9kZVR5cGU6XG5cdFx0XHRyb290LnBhcmVudE5vZGUgIT09IG51bGwgJiYgcm9vdC5ub2RlVHlwZSAhPT0gOSAmJiByb290LnBhcmVudE5vZGUgPT09IGRvYztcblxuXHRcdC8vIGZhc3QgcGF0aCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgb3Igbm90IHF1ZXJ5U2VsZWN0b3JBbGwgZXhpc3RzXG5cdFx0aWYobWF0Y2hbMl0gJiYgaXNJbnNpZGVEb21UcmVlKXtcblx0XHRcdC8vIGFuICNpZFxuXHRcdFx0Ly8gdXNlIGRvam8uYnlJZCBpZiBhdmFpbGFibGUgYXMgaXQgZml4ZXMgdGhlIGlkIHJldHJpZXZhbCBpbiBJRSwgbm90ZSB0aGF0IHdlIGNhbid0IHVzZSB0aGUgZG9qbyBuYW1lc3BhY2UgaW4gMi4wLCBidXQgaWYgdGhlcmUgaXMgYSBjb25kaXRpb25hbCBtb2R1bGUgdXNlLCB3ZSB3aWxsIHVzZSB0aGF0XG5cdFx0XHR2YXIgZm91bmQgPSBkb2pvLmJ5SWQgPyBkb2pvLmJ5SWQobWF0Y2hbMl0sIGRvYykgOiBkb2MuZ2V0RWxlbWVudEJ5SWQobWF0Y2hbMl0pO1xuXHRcdFx0aWYoIWZvdW5kIHx8IChtYXRjaFsxXSAmJiBtYXRjaFsxXSAhPSBmb3VuZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKXtcblx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSB0YWcgcXVhbGlmZXIgYW5kIGl0IGRvZXNuJ3QgbWF0Y2gsIG5vIG1hdGNoZXNcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdFx0aWYocm9vdCAhPSBkb2Mpe1xuXHRcdFx0XHQvLyB0aGVyZSBpcyBhIHJvb3QgZWxlbWVudCwgbWFrZSBzdXJlIHdlIGFyZSBhIGNoaWxkIG9mIGl0XG5cdFx0XHRcdHZhciBwYXJlbnQgPSBmb3VuZDtcblx0XHRcdFx0d2hpbGUocGFyZW50ICE9IHJvb3Qpe1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdGlmKCFwYXJlbnQpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoWzNdID9cblx0XHRcdFx0XHRsaXRlRW5naW5lKG1hdGNoWzNdLCBmb3VuZCkgXG5cdFx0XHRcdFx0OiBbZm91bmRdO1xuXHRcdH1cblx0XHRpZihtYXRjaFszXSAmJiByb290LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpe1xuXHRcdFx0Ly8gYSAuY2xhc3Ncblx0XHRcdHJldHVybiByb290LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobWF0Y2hbNF0pO1xuXHRcdH1cblx0XHR2YXIgZm91bmQ7XG5cdFx0aWYobWF0Y2hbNV0pe1xuXHRcdFx0Ly8gYSB0YWdcblx0XHRcdGZvdW5kID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZShtYXRjaFs1XSk7XG5cdFx0XHRpZihtYXRjaFs0XSB8fCBtYXRjaFs2XSl7XG5cdFx0XHRcdHNlbGVjdG9yID0gKG1hdGNoWzRdIHx8IFwiXCIpICsgbWF0Y2hbNl07XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Ly8gdGhhdCB3YXMgdGhlIGVudGlyZXR5IG9mIHRoZSBxdWVyeSwgcmV0dXJuIHJlc3VsdHNcblx0XHRcdFx0cmV0dXJuIGZvdW5kO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZihxdWVyeVNlbGVjdG9yQWxsKXtcblx0XHQvLyBxU0Egd29ya3Mgc3RyYW5nZWx5IG9uIEVsZW1lbnQtcm9vdGVkIHF1ZXJpZXNcblx0XHQvLyBXZSBjYW4gd29yayBhcm91bmQgdGhpcyBieSBzcGVjaWZ5aW5nIGFuIGV4dHJhIElEIG9uIHRoZSByb290XG5cdFx0Ly8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXG5cdFx0Ly8gSUUgOCBkb2Vzbid0IHdvcmsgb24gb2JqZWN0IGVsZW1lbnRzXG5cdFx0aWYgKHJvb3Qubm9kZVR5cGUgPT09IDEgJiYgcm9vdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKXtcdFx0XHRcdFxuXHRcdFx0cmV0dXJuIHVzZVJvb3Qocm9vdCwgc2VsZWN0b3IsIHJvb3QucXVlcnlTZWxlY3RvckFsbCk7XG5cdFx0fWVsc2V7XG5cdFx0XHQvLyB3ZSBjYW4gdXNlIHRoZSBuYXRpdmUgcVNBXG5cdFx0XHRyZXR1cm4gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblx0XHR9XG5cdH1lbHNlIGlmKCFmb3VuZCl7XG5cdFx0Ly8gc2VhcmNoIGFsbCBjaGlsZHJlbiBhbmQgdGhlbiBmaWx0ZXJcblx0XHRmb3VuZCA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpO1xuXHR9XG5cdC8vIG5vdyB3ZSBmaWx0ZXIgdGhlIG5vZGVzIHRoYXQgd2VyZSBmb3VuZCB1c2luZyB0aGUgbWF0Y2hlc1NlbGVjdG9yXG5cdHZhciByZXN1bHRzID0gW107XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBmb3VuZC5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdHZhciBub2RlID0gZm91bmRbaV07XG5cdFx0aWYobm9kZS5ub2RlVHlwZSA9PSAxICYmIGpzTWF0Y2hlc1NlbGVjdG9yKG5vZGUsIHNlbGVjdG9yLCByb290KSl7XG5cdFx0XHQvLyBrZWVwIHRoZSBub2RlcyB0aGF0IG1hdGNoIHRoZSBzZWxlY3RvclxuXHRcdFx0cmVzdWx0cy5wdXNoKG5vZGUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG52YXIgdXNlUm9vdCA9IGZ1bmN0aW9uKGNvbnRleHQsIHF1ZXJ5LCBtZXRob2Qpe1xuXHQvLyB0aGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSB0ZW1wb3JhcnkgaWQgc28gd2UgY2FuIGRvIHJvb3RlZCBxU0EgcXVlcmllcywgdGhpcyBpcyB0YWtlbiBmcm9tIHNpenpsZVxuXHR2YXIgb2xkQ29udGV4dCA9IGNvbnRleHQsXG5cdFx0b2xkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSxcblx0XHRuaWQgPSBvbGQgfHwgXCJfX2Rvam9fX1wiLFxuXHRcdGhhc1BhcmVudCA9IGNvbnRleHQucGFyZW50Tm9kZSxcblx0XHRyZWxhdGl2ZUhpZXJhcmNoeVNlbGVjdG9yID0gL15cXHMqWyt+XS8udGVzdChxdWVyeSk7XG5cblx0aWYocmVsYXRpdmVIaWVyYXJjaHlTZWxlY3RvciAmJiAhaGFzUGFyZW50KXtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYoIW9sZCl7XG5cdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBuaWQpO1xuXHR9ZWxzZXtcblx0XHRuaWQgPSBuaWQucmVwbGFjZSgvJy9nLCBcIlxcXFwkJlwiKTtcblx0fVxuXHRpZihyZWxhdGl2ZUhpZXJhcmNoeVNlbGVjdG9yICYmIGhhc1BhcmVudCl7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0fVxuXHR2YXIgc2VsZWN0b3JzID0gcXVlcnkubWF0Y2godW5pb25TcGxpdCk7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspe1xuXHRcdHNlbGVjdG9yc1tpXSA9IFwiW2lkPSdcIiArIG5pZCArIFwiJ10gXCIgKyBzZWxlY3RvcnNbaV07XG5cdH1cblx0cXVlcnkgPSBzZWxlY3RvcnMuam9pbihcIixcIik7XG5cblx0dHJ5e1xuXHRcdHJldHVybiBtZXRob2QuY2FsbChjb250ZXh0LCBxdWVyeSk7XG5cdH1maW5hbGx5e1xuXHRcdGlmKCFvbGQpe1xuXHRcdFx0b2xkQ29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHR9XG5cdH1cbn07XG5cbmlmKCFoYXMoXCJkb20tbWF0Y2hlcy1zZWxlY3RvclwiKSl7XG5cdHZhciBqc01hdGNoZXNTZWxlY3RvciA9IChmdW5jdGlvbigpe1xuXHRcdC8vIGEgSlMgaW1wbGVtZW50YXRpb24gb2YgQ1NTIHNlbGVjdG9yIG1hdGNoaW5nLCBmaXJzdCB3ZSBzdGFydCB3aXRoIHRoZSB2YXJpb3VzIGhhbmRsZXJzXG5cdFx0dmFyIGNhc2VGaXggPSB0ZXN0RGl2LnRhZ05hbWUgPT0gXCJkaXZcIiA/IFwidG9Mb3dlckNhc2VcIiA6IFwidG9VcHBlckNhc2VcIjtcblx0XHR2YXIgc2VsZWN0b3JUeXBlcyA9IHtcblx0XHRcdFwiXCI6IGZ1bmN0aW9uKHRhZ05hbWUpe1xuXHRcdFx0XHR0YWdOYW1lID0gdGFnTmFtZVtjYXNlRml4XSgpO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUudGFnTmFtZSA9PSB0YWdOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdFwiLlwiOiBmdW5jdGlvbihjbGFzc05hbWUpe1xuXHRcdFx0XHR2YXIgY2xhc3NOYW1lU3BhY2VkID0gJyAnICsgY2xhc3NOYW1lICsgJyAnO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUuY2xhc3NOYW1lLmluZGV4T2YoY2xhc3NOYW1lKSA+IC0xICYmICgnICcgKyBub2RlLmNsYXNzTmFtZSArICcgJykuaW5kZXhPZihjbGFzc05hbWVTcGFjZWQpID4gLTE7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0XCIjXCI6IGZ1bmN0aW9uKGlkKXtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0XHRcdHJldHVybiBub2RlLmlkID09IGlkO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0dmFyIGF0dHJDb21wYXJhdG9ycyA9IHtcblx0XHRcdFwiXj1cIjogZnVuY3Rpb24oYXR0clZhbHVlLCB2YWx1ZSl7XG5cdFx0XHRcdHJldHVybiBhdHRyVmFsdWUuaW5kZXhPZih2YWx1ZSkgPT0gMDtcblx0XHRcdH0sXG5cdFx0XHRcIio9XCI6IGZ1bmN0aW9uKGF0dHJWYWx1ZSwgdmFsdWUpe1xuXHRcdFx0XHRyZXR1cm4gYXR0clZhbHVlLmluZGV4T2YodmFsdWUpID4gLTE7XG5cdFx0XHR9LFxuXHRcdFx0XCIkPVwiOiBmdW5jdGlvbihhdHRyVmFsdWUsIHZhbHVlKXtcblx0XHRcdFx0cmV0dXJuIGF0dHJWYWx1ZS5zdWJzdHJpbmcoYXR0clZhbHVlLmxlbmd0aCAtIHZhbHVlLmxlbmd0aCwgYXR0clZhbHVlLmxlbmd0aCkgPT0gdmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0XCJ+PVwiOiBmdW5jdGlvbihhdHRyVmFsdWUsIHZhbHVlKXtcblx0XHRcdFx0cmV0dXJuICgnICcgKyBhdHRyVmFsdWUgKyAnICcpLmluZGV4T2YoJyAnICsgdmFsdWUgKyAnICcpID4gLTE7XG5cdFx0XHR9LFxuXHRcdFx0XCJ8PVwiOiBmdW5jdGlvbihhdHRyVmFsdWUsIHZhbHVlKXtcblx0XHRcdFx0cmV0dXJuIChhdHRyVmFsdWUgKyAnLScpLmluZGV4T2YodmFsdWUgKyAnLScpID09IDA7XG5cdFx0XHR9LFxuXHRcdFx0XCI9XCI6IGZ1bmN0aW9uKGF0dHJWYWx1ZSwgdmFsdWUpe1xuXHRcdFx0XHRyZXR1cm4gYXR0clZhbHVlID09IHZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdFwiXCI6IGZ1bmN0aW9uKGF0dHJWYWx1ZSwgdmFsdWUpe1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGZ1bmN0aW9uIGF0dHIobmFtZSwgdmFsdWUsIHR5cGUpe1xuXHRcdFx0dmFyIGZpcnN0Q2hhciA9IHZhbHVlLmNoYXJBdCgwKTtcblx0XHRcdGlmKGZpcnN0Q2hhciA9PSAnXCInIHx8IGZpcnN0Q2hhciA9PSBcIidcIil7XG5cdFx0XHRcdC8vIGl0IGlzIHF1b3RlZCwgcmVtb3ZlIHRoZSBxdW90ZXNcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5zbGljZSgxLCAtMSk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywnJyk7XG5cdFx0XHR2YXIgY29tcGFyYXRvciA9IGF0dHJDb21wYXJhdG9yc1t0eXBlIHx8IFwiXCJdO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0XHR2YXIgYXR0clZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdFx0XHRcdHJldHVybiBhdHRyVmFsdWUgJiYgY29tcGFyYXRvcihhdHRyVmFsdWUsIHZhbHVlKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGFuY2VzdG9yKG1hdGNoZXIpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG5vZGUsIHJvb3Qpe1xuXHRcdFx0XHR3aGlsZSgobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkgIT0gcm9vdCl7XG5cdFx0XHRcdFx0aWYobWF0Y2hlcihub2RlLCByb290KSl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHBhcmVudChtYXRjaGVyKXtcblx0XHRcdHJldHVybiBmdW5jdGlvbihub2RlLCByb290KXtcblx0XHRcdFx0bm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdFx0cmV0dXJuIG1hdGNoZXIgPyBcblx0XHRcdFx0XHRub2RlICE9IHJvb3QgJiYgbWF0Y2hlcihub2RlLCByb290KVxuXHRcdFx0XHRcdDogbm9kZSA9PSByb290O1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0dmFyIGNhY2hlID0ge307XG5cdFx0ZnVuY3Rpb24gYW5kKG1hdGNoZXIsIG5leHQpe1xuXHRcdFx0cmV0dXJuIG1hdGNoZXIgP1xuXHRcdFx0XHRmdW5jdGlvbihub2RlLCByb290KXtcblx0XHRcdFx0XHRyZXR1cm4gbmV4dChub2RlKSAmJiBtYXRjaGVyKG5vZGUsIHJvb3QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdDogbmV4dDtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yLCByb290KXtcblx0XHRcdC8vIHRoaXMgcmV0dXJucyB0cnVlIG9yIGZhbHNlIGJhc2VkIG9uIGlmIHRoZSBub2RlIG1hdGNoZXMgdGhlIHNlbGVjdG9yIChvcHRpb25hbGx5IHdpdGhpbiB0aGUgZ2l2ZW4gcm9vdClcblx0XHRcdHZhciBtYXRjaGVyID0gY2FjaGVbc2VsZWN0b3JdOyAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBjcmVhdGVkIGEgbWF0Y2hlciBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIHNlbGVjdG9yXG5cdFx0XHRpZighbWF0Y2hlcil7XG5cdFx0XHRcdC8vIGNyZWF0ZSBhIG1hdGNoZXIgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBzZWxlY3RvclxuXHRcdFx0XHQvLyBwYXJzZSB0aGUgc2VsZWN0b3JzXG5cdFx0XHRcdGlmKHNlbGVjdG9yLnJlcGxhY2UoLyg/OlxccyooWz4gXSlcXHMqKXwoI3xcXC4pPygoPzpcXFxcLnxbXFx3LV0pKyl8XFxbXFxzKihbXFx3LV0rKVxccyooLj89KT9cXHMqKFwiKD86XFxcXC58W15cIl0pK1wifCcoPzpcXFxcLnxbXiddKSsnfCg/OlxcXFwufFteXFxdXSkqKVxccypcXF0vZywgZnVuY3Rpb24odCwgY29tYmluYXRvciwgdHlwZSwgdmFsdWUsIGF0dHJOYW1lLCBhdHRyVHlwZSwgYXR0clZhbHVlKXtcblx0XHRcdFx0XHRpZih2YWx1ZSl7XG5cdFx0XHRcdFx0XHRtYXRjaGVyID0gYW5kKG1hdGNoZXIsIHNlbGVjdG9yVHlwZXNbdHlwZSB8fCBcIlwiXSh2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmKGNvbWJpbmF0b3Ipe1xuXHRcdFx0XHRcdFx0bWF0Y2hlciA9IChjb21iaW5hdG9yID09IFwiIFwiID8gYW5jZXN0b3IgOiBwYXJlbnQpKG1hdGNoZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmKGF0dHJOYW1lKXtcblx0XHRcdFx0XHRcdG1hdGNoZXIgPSBhbmQobWF0Y2hlciwgYXR0cihhdHRyTmFtZSwgYXR0clZhbHVlLCBhdHRyVHlwZSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdFx0fSkpe1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciBpbiBxdWVyeVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighbWF0Y2hlcil7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FjaGVbc2VsZWN0b3JdID0gbWF0Y2hlcjtcblx0XHRcdH1cblx0XHRcdC8vIG5vdyBydW4gdGhlIG1hdGNoZXIgZnVuY3Rpb24gb24gdGhlIG5vZGVcblx0XHRcdHJldHVybiBtYXRjaGVyKG5vZGUsIHJvb3QpO1xuXHRcdH07XG5cdH0pKCk7XG59XG5pZighaGFzKFwiZG9tLXFzYVwiKSl7XG5cdHZhciBjb21iaW5lID0gZnVuY3Rpb24oc2VsZWN0b3IsIHJvb3Qpe1xuXHRcdC8vIGNvbWJpbmVkIHF1ZXJpZXNcblx0XHR2YXIgc2VsZWN0b3JzID0gc2VsZWN0b3IubWF0Y2godW5pb25TcGxpdCk7XG5cdFx0dmFyIGluZGV4ZWQgPSBbXTtcblx0XHQvLyBhZGQgYWxsIHJlc3VsdHMgYW5kIGtlZXAgdW5pcXVlIG9uZXMsIHRoaXMgb25seSBydW5zIGluIElFLCBzbyB3ZSB0YWtlIGFkdmFudGFnZSBcblx0XHQvLyBvZiBrbm93biBJRSBmZWF0dXJlcywgcGFydGljdWxhcmx5IHNvdXJjZUluZGV4IHdoaWNoIGlzIHVuaXF1ZSBhbmQgYWxsb3dzIHVzIHRvIFxuXHRcdC8vIG9yZGVyIHRoZSByZXN1bHRzIFxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspe1xuXHRcdFx0c2VsZWN0b3IgPSBuZXcgU3RyaW5nKHNlbGVjdG9yc1tpXS5yZXBsYWNlKC9cXHMqJC8sJycpKTtcblx0XHRcdHNlbGVjdG9yLmluZGV4T2YgPSBlc2NhcGU7IC8vIGtlZXAgaXQgZnJvbSByZWN1cnNpdmVseSBlbnRlcmluZyBjb21iaW5lXG5cdFx0XHR2YXIgcmVzdWx0cyA9IGxpdGVFbmdpbmUoc2VsZWN0b3IsIHJvb3QpO1xuXHRcdFx0Zm9yKHZhciBqID0gMCwgbCA9IHJlc3VsdHMubGVuZ3RoOyBqIDwgbDsgaisrKXtcblx0XHRcdFx0dmFyIG5vZGUgPSByZXN1bHRzW2pdO1xuXHRcdFx0XHRpbmRleGVkW25vZGUuc291cmNlSW5kZXhdID0gbm9kZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gbm93IGNvbnZlcnQgZnJvbSBhIHNwYXJzZSBhcnJheSB0byBhIGRlbnNlIGFycmF5XG5cdFx0dmFyIHRvdGFsUmVzdWx0cyA9IFtdO1xuXHRcdGZvcihpIGluIGluZGV4ZWQpe1xuXHRcdFx0dG90YWxSZXN1bHRzLnB1c2goaW5kZXhlZFtpXSk7XG5cdFx0fVxuXHRcdHJldHVybiB0b3RhbFJlc3VsdHM7XG5cdH07XG59XG5cbmxpdGVFbmdpbmUubWF0Y2ggPSBtYXRjaGVzU2VsZWN0b3IgPyBmdW5jdGlvbihub2RlLCBzZWxlY3Rvciwgcm9vdCl7XG5cdGlmKHJvb3QgJiYgcm9vdC5ub2RlVHlwZSAhPSA5KXtcblx0XHQvLyBkb2Vzbid0IHN1cHBvcnQgdGhyZWUgYXJncywgdXNlIHJvb3RlZCBpZCB0cmlja1xuXHRcdHJldHVybiB1c2VSb290KHJvb3QsIHNlbGVjdG9yLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0XHRyZXR1cm4gbWF0Y2hlc1NlbGVjdG9yLmNhbGwobm9kZSwgcXVlcnkpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIHdlIGhhdmUgYSBuYXRpdmUgbWF0Y2hlc1NlbGVjdG9yLCB1c2UgdGhhdFxuXHRyZXR1cm4gbWF0Y2hlc1NlbGVjdG9yLmNhbGwobm9kZSwgc2VsZWN0b3IpO1xufSA6IGpzTWF0Y2hlc1NlbGVjdG9yOyAvLyBvdGhlcndpc2UgdXNlIHRoZSBKUyBtYXRjaGVzIGltcGxcblxucmV0dXJuIGxpdGVFbmdpbmU7XG59KTtcbiIsImRlZmluZShbXCIuL2hhc1wiXSwgZnVuY3Rpb24oaGFzKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL3NuaWZmXG5cblx0Lyo9PT09PVxuXHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoaXMgbW9kdWxlIHNldHMgaGFzKCkgZmxhZ3MgYmFzZWQgb24gdGhlIGN1cnJlbnQgYnJvd3Nlci5cblx0XHQvL1x0XHRJdCByZXR1cm5zIHRoZSBoYXMoKSBmdW5jdGlvbi5cblx0fTtcblx0PT09PT0qL1xuXG5cdGlmKGhhcyhcImhvc3QtYnJvd3NlclwiKSl7XG5cdFx0dmFyIG4gPSBuYXZpZ2F0b3IsXG5cdFx0XHRkdWEgPSBuLnVzZXJBZ2VudCxcblx0XHRcdGRhdiA9IG4uYXBwVmVyc2lvbixcblx0XHRcdHR2ID0gcGFyc2VGbG9hdChkYXYpO1xuXHRcdGhhcy5hZGQoXCJhaXJcIiwgZHVhLmluZGV4T2YoXCJBZG9iZUFJUlwiKSA+PSAwKTtcblx0XHRoYXMuYWRkKFwid3BcIiwgcGFyc2VGbG9hdChkdWEuc3BsaXQoXCJXaW5kb3dzIFBob25lXCIpWzFdKSB8fCB1bmRlZmluZWQpO1xuXHRcdGhhcy5hZGQoXCJtc2FwcFwiLCBwYXJzZUZsb2F0KGR1YS5zcGxpdChcIk1TQXBwSG9zdC9cIilbMV0pIHx8IHVuZGVmaW5lZCk7XG5cdFx0aGFzLmFkZChcImtodG1sXCIsIGRhdi5pbmRleE9mKFwiS29ucXVlcm9yXCIpID49IDAgPyB0diA6IHVuZGVmaW5lZCk7XG5cdFx0aGFzLmFkZChcImVkZ2VcIiwgcGFyc2VGbG9hdChkdWEuc3BsaXQoXCJFZGdlL1wiKVsxXSkgfHwgdW5kZWZpbmVkKTtcblx0XHRoYXMuYWRkKFwib3ByXCIsIHBhcnNlRmxvYXQoZHVhLnNwbGl0KFwiT1BSL1wiKVsxXSkgfHwgdW5kZWZpbmVkKTtcblx0XHQvLyBOT1RFOiBodHRwczovL2Rldi5vcGVyYS5jb20vYmxvZy9vcGVyYS11c2VyLWFnZW50LXN0cmluZ3Mtb3BlcmEtMTUtYW5kLWJleW9uZC9cblx0XHRoYXMuYWRkKFwid2Via2l0XCIsICFoYXMoXCJ3cFwiKSAvLyBOT1RFOiBuZWNlc3Nhcnkgc2luY2UgV2luZG93cyBQaG9uZSA4LjEgVXBkYXRlIDEsIHNlZSAjMTg1NDBcblx0XHRcdCYmICFoYXMoXCJlZGdlXCIpICYmIHBhcnNlRmxvYXQoZHVhLnNwbGl0KFwiV2ViS2l0L1wiKVsxXSkgfHwgdW5kZWZpbmVkKTtcblx0XHRoYXMuYWRkKFwiY2hyb21lXCIsICFoYXMoXCJlZGdlXCIpICYmICFoYXMoXCJvcHJcIilcblx0XHRcdFx0JiYgcGFyc2VGbG9hdChkdWEuc3BsaXQoXCJDaHJvbWUvXCIpWzFdKSB8fCB1bmRlZmluZWQpO1xuXHRcdGhhcy5hZGQoXCJhbmRyb2lkXCIsICFoYXMoXCJ3cFwiKSAvLyBOT1RFOiBuZWNlc3Nhcnkgc2luY2UgV2luZG93cyBQaG9uZSA4LjEgVXBkYXRlIDEsIHNlZSAjMTg1Mjhcblx0XHRcdFx0JiYgcGFyc2VGbG9hdChkdWEuc3BsaXQoXCJBbmRyb2lkIFwiKVsxXSkgfHwgdW5kZWZpbmVkKTtcblx0XHRoYXMuYWRkKFwic2FmYXJpXCIsIGRhdi5pbmRleE9mKFwiU2FmYXJpXCIpID49IDBcblx0XHRcdFx0JiYgIWhhcyhcIndwXCIpIC8vIE5PVEU6IG5lY2Vzc2FyeSBzaW5jZSBXaW5kb3dzIFBob25lIDguMSBVcGRhdGUgMSwgc2VlICMxODU0MFxuXHRcdFx0XHQmJiAhaGFzKFwiY2hyb21lXCIpICYmICFoYXMoXCJhbmRyb2lkXCIpICYmICFoYXMoXCJlZGdlXCIpICYmICFoYXMoXCJvcHJcIikgP1xuXHRcdFx0cGFyc2VGbG9hdChkYXYuc3BsaXQoXCJWZXJzaW9uL1wiKVsxXSkgOiB1bmRlZmluZWQpO1xuXHRcdGhhcy5hZGQoXCJtYWNcIiwgZGF2LmluZGV4T2YoXCJNYWNpbnRvc2hcIikgPj0gMCk7XG5cdFx0aGFzLmFkZChcInF1aXJrc1wiLCBkb2N1bWVudC5jb21wYXRNb2RlID09IFwiQmFja0NvbXBhdFwiKTtcblx0XHRpZighaGFzKFwid3BcIikgLy8gTk9URTogbmVjZXNzYXJ5IHNpbmNlIFdpbmRvd3MgUGhvbmUgOC4xIFVwZGF0ZSAxLCBzZWUgIzE4NTI4XG5cdFx0XHRcdCYmIGR1YS5tYXRjaCgvKGlQaG9uZXxpUG9kfGlQYWQpLykpe1xuXHRcdFx0dmFyIHAgPSBSZWdFeHAuJDEucmVwbGFjZSgvUC8sIFwicFwiKTtcblx0XHRcdHZhciB2ID0gZHVhLm1hdGNoKC9PUyAoW1xcZF9dKykvKSA/IFJlZ0V4cC4kMSA6IFwiMVwiO1xuXHRcdFx0dmFyIG9zID0gcGFyc2VGbG9hdCh2LnJlcGxhY2UoL18vLCBcIi5cIikucmVwbGFjZSgvXy9nLCBcIlwiKSk7XG5cdFx0XHRoYXMuYWRkKHAsIG9zKTtcdFx0Ly8gXCJpcGhvbmVcIiwgXCJpcGFkXCIgb3IgXCJpcG9kXCJcblx0XHRcdGhhcy5hZGQoXCJpb3NcIiwgb3MpO1xuXHRcdH1cblx0XHRoYXMuYWRkKFwiYmJcIiwgKGR1YS5pbmRleE9mKFwiQmxhY2tCZXJyeVwiKSA+PSAwIHx8IGR1YS5pbmRleE9mKFwiQkIxMFwiKSA+PSAwKSAmJiBwYXJzZUZsb2F0KGR1YS5zcGxpdChcIlZlcnNpb24vXCIpWzFdKSB8fCB1bmRlZmluZWQpO1xuXHRcdGhhcy5hZGQoXCJ0cmlkZW50XCIsIHBhcnNlRmxvYXQoZGF2LnNwbGl0KFwiVHJpZGVudC9cIilbMV0pIHx8IHVuZGVmaW5lZCk7XG5cblx0XHRoYXMuYWRkKFwic3ZnXCIsIHR5cGVvZiBTVkdBbmdsZSAhPT0gXCJ1bmRlZmluZWRcIik7XG5cblx0XHRpZighaGFzKFwid2Via2l0XCIpKXtcblx0XHRcdC8vIE9wZXJhXG5cdFx0XHRpZihkdWEuaW5kZXhPZihcIk9wZXJhXCIpID49IDApe1xuXHRcdFx0XHQvLyBzZWUgaHR0cDovL2Rldi5vcGVyYS5jb20vYXJ0aWNsZXMvdmlldy9vcGVyYS11YS1zdHJpbmctY2hhbmdlcyBhbmQgaHR0cDovL3d3dy51c2VyYWdlbnRzdHJpbmcuY29tL3BhZ2VzL09wZXJhL1xuXHRcdFx0XHQvLyA5LjggaGFzIGJvdGggc3R5bGVzOyA8OS44LCA5Ljkgb25seSBvbGQgc3R5bGVcblx0XHRcdFx0aGFzLmFkZChcIm9wZXJhXCIsIHR2ID49IDkuOCA/IHBhcnNlRmxvYXQoZHVhLnNwbGl0KFwiVmVyc2lvbi9cIilbMV0pIHx8IHR2IDogdHYpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNb3ppbGxhIGFuZCBmaXJlZm94XG5cdFx0XHRpZihkdWEuaW5kZXhPZihcIkdlY2tvXCIpID49IDAgJiYgIWhhcyhcIndwXCIpIC8vIE5PVEU6IG5lY2Vzc2FyeSBzaW5jZSBXaW5kb3dzIFBob25lIDguMSBVcGRhdGUgMVxuXHRcdFx0XHRcdCYmICFoYXMoXCJraHRtbFwiKSAmJiAhaGFzKFwidHJpZGVudFwiKSAmJiAhaGFzKFwiZWRnZVwiKSl7XG5cdFx0XHRcdGhhcy5hZGQoXCJtb3ppbGxhXCIsIHR2KTtcblx0XHRcdH1cblx0XHRcdGlmKGhhcyhcIm1vemlsbGFcIikpe1xuXHRcdFx0XHQvL1dlIHJlYWxseSBuZWVkIHRvIGdldCBhd2F5IGZyb20gdGhpcy4gQ29uc2lkZXIgYSBzYW5lIGlzR2Vja28gYXBwcm9hY2ggZm9yIHRoZSBmdXR1cmUuXG5cdFx0XHRcdGhhcy5hZGQoXCJmZlwiLCBwYXJzZUZsb2F0KGR1YS5zcGxpdChcIkZpcmVmb3gvXCIpWzFdIHx8IGR1YS5zcGxpdChcIk1pbmVmaWVsZC9cIilbMV0pIHx8IHVuZGVmaW5lZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElFXG5cdFx0XHRpZihkb2N1bWVudC5hbGwgJiYgIWhhcyhcIm9wZXJhXCIpKXtcblx0XHRcdFx0dmFyIGlzSUUgPSBwYXJzZUZsb2F0KGRhdi5zcGxpdChcIk1TSUUgXCIpWzFdKSB8fCB1bmRlZmluZWQ7XG5cblx0XHRcdFx0Ly9JbiBjYXNlcyB3aGVyZSB0aGUgcGFnZSBoYXMgYW4gSFRUUCBoZWFkZXIgb3IgTUVUQSB0YWcgd2l0aFxuXHRcdFx0XHQvL1gtVUEtQ29tcGF0aWJsZSwgdGhlbiBpdCBpcyBpbiBlbXVsYXRpb24gbW9kZS5cblx0XHRcdFx0Ly9NYWtlIHN1cmUgaXNJRSByZWZsZWN0cyB0aGUgZGVzaXJlZCB2ZXJzaW9uLlxuXHRcdFx0XHQvL2RvY3VtZW50LmRvY3VtZW50TW9kZSBvZiA1IG1lYW5zIHF1aXJrcyBtb2RlLlxuXHRcdFx0XHQvL09ubHkgc3dpdGNoIHRoZSB2YWx1ZSBpZiBkb2N1bWVudE1vZGUncyBtYWpvciB2ZXJzaW9uXG5cdFx0XHRcdC8vaXMgZGlmZmVyZW50IGZyb20gaXNJRSdzIG1ham9yIHZlcnNpb24uXG5cdFx0XHRcdHZhciBtb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuXHRcdFx0XHRpZihtb2RlICYmIG1vZGUgIT0gNSAmJiBNYXRoLmZsb29yKGlzSUUpICE9IG1vZGUpe1xuXHRcdFx0XHRcdGlzSUUgPSBtb2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aGFzLmFkZChcImllXCIsIGlzSUUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXaWlcblx0XHRcdGhhcy5hZGQoXCJ3aWlcIiwgdHlwZW9mIG9wZXJhICE9IFwidW5kZWZpbmVkXCIgJiYgb3BlcmEud2lpcmVtb3RlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gaGFzO1xufSk7XG4iLCJkZWZpbmUoW1xuXHRcIi4vX2Jhc2Uva2VybmVsXCIsXHQvLyBrZXJuZWwuZ2xvYmFsXG5cdFwiLi9fYmFzZS9sYW5nXCJcbl0sIGZ1bmN0aW9uKGtlcm5lbCwgbGFuZyl7XG5cbi8vIG1vZHVsZTpcbi8vXHRcdGRvam8vc3RyaW5nXG52YXIgRVNDQVBFX1JFR0VYUCA9IC9bJjw+J1wiXFwvXS9nO1xudmFyIEVTQ0FQRV9NQVAgPSB7XG5cdCcmJzogJyZhbXA7Jyxcblx0JzwnOiAnJmx0OycsXG5cdCc+JzogJyZndDsnLFxuXHQnXCInOiAnJnF1b3Q7Jyxcblx0XCInXCI6ICcmI3gyNzsnLFxuXHQnLyc6ICcmI3gyRjsnXG59O1xudmFyIHN0cmluZyA9IHtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0U3RyaW5nIHV0aWxpdGllcyBmb3IgRG9qb1xufTtcbmxhbmcuc2V0T2JqZWN0KFwiZG9qby5zdHJpbmdcIiwgc3RyaW5nKTtcblxuc3RyaW5nLmVzY2FwZSA9IGZ1bmN0aW9uKC8qU3RyaW5nKi9zdHIpe1xuXHQvLyBzdW1tYXJ5OlxuXHQvL1x0XHRFZmZpY2llbnRseSBlc2NhcGUgYSBzdHJpbmcgZm9yIGluc2VydGlvbiBpbnRvIEhUTUwgKGlubmVySFRNTCBvciBhdHRyaWJ1dGVzKSwgcmVwbGFjaW5nICYsIDwsID4sIFwiLCAnLCBhbmQgLyBjaGFyYWN0ZXJzLlxuXHQvLyBzdHI6XG5cdC8vXHRcdHRoZSBzdHJpbmcgdG8gZXNjYXBlXG5cdGlmKCFzdHIpeyByZXR1cm4gXCJcIjsgfVxuXHRyZXR1cm4gc3RyLnJlcGxhY2UoRVNDQVBFX1JFR0VYUCwgZnVuY3Rpb24oYykge1xuXHRcdHJldHVybiBFU0NBUEVfTUFQW2NdO1xuXHR9KTtcbn07XG5cbnN0cmluZy5yZXAgPSBmdW5jdGlvbigvKlN0cmluZyovc3RyLCAvKkludGVnZXIqL251bSl7XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdEVmZmljaWVudGx5IHJlcGxpY2F0ZSBhIHN0cmluZyBgbmAgdGltZXMuXG5cdC8vIHN0cjpcblx0Ly9cdFx0dGhlIHN0cmluZyB0byByZXBsaWNhdGVcblx0Ly8gbnVtOlxuXHQvL1x0XHRudW1iZXIgb2YgdGltZXMgdG8gcmVwbGljYXRlIHRoZSBzdHJpbmdcblxuXHRpZihudW0gPD0gMCB8fCAhc3RyKXsgcmV0dXJuIFwiXCI7IH1cblxuXHR2YXIgYnVmID0gW107XG5cdGZvcig7Oyl7XG5cdFx0aWYobnVtICYgMSl7XG5cdFx0XHRidWYucHVzaChzdHIpO1xuXHRcdH1cblx0XHRpZighKG51bSA+Pj0gMSkpeyBicmVhazsgfVxuXHRcdHN0ciArPSBzdHI7XG5cdH1cblx0cmV0dXJuIGJ1Zi5qb2luKFwiXCIpO1x0Ly8gU3RyaW5nXG59O1xuXG5zdHJpbmcucGFkID0gZnVuY3Rpb24oLypTdHJpbmcqL3RleHQsIC8qSW50ZWdlciovc2l6ZSwgLypTdHJpbmc/Ki9jaCwgLypCb29sZWFuPyovZW5kKXtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0UGFkIGEgc3RyaW5nIHRvIGd1YXJhbnRlZSB0aGF0IGl0IGlzIGF0IGxlYXN0IGBzaXplYCBsZW5ndGggYnlcblx0Ly9cdFx0ZmlsbGluZyB3aXRoIHRoZSBjaGFyYWN0ZXIgYGNoYCBhdCBlaXRoZXIgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGVcblx0Ly9cdFx0c3RyaW5nLiBQYWRzIGF0IHRoZSBzdGFydCwgYnkgZGVmYXVsdC5cblx0Ly8gdGV4dDpcblx0Ly9cdFx0dGhlIHN0cmluZyB0byBwYWRcblx0Ly8gc2l6ZTpcblx0Ly9cdFx0bGVuZ3RoIHRvIHByb3ZpZGUgcGFkZGluZ1xuXHQvLyBjaDpcblx0Ly9cdFx0Y2hhcmFjdGVyIHRvIHBhZCwgZGVmYXVsdHMgdG8gJzAnXG5cdC8vIGVuZDpcblx0Ly9cdFx0YWRkcyBwYWRkaW5nIGF0IHRoZSBlbmQgaWYgdHJ1ZSwgb3RoZXJ3aXNlIHBhZHMgYXQgc3RhcnRcblx0Ly8gZXhhbXBsZTpcblx0Ly9cdHxcdC8vIEZpbGwgdGhlIHN0cmluZyB0byBsZW5ndGggMTAgd2l0aCBcIitcIiBjaGFyYWN0ZXJzIG9uIHRoZSByaWdodC4gIFlpZWxkcyBcIkRvam8rKysrKytcIi5cblx0Ly9cdHxcdHN0cmluZy5wYWQoXCJEb2pvXCIsIDEwLCBcIitcIiwgdHJ1ZSk7XG5cblx0aWYoIWNoKXtcblx0XHRjaCA9ICcwJztcblx0fVxuXHR2YXIgb3V0ID0gU3RyaW5nKHRleHQpLFxuXHRcdHBhZCA9IHN0cmluZy5yZXAoY2gsIE1hdGguY2VpbCgoc2l6ZSAtIG91dC5sZW5ndGgpIC8gY2gubGVuZ3RoKSk7XG5cdHJldHVybiBlbmQgPyBvdXQgKyBwYWQgOiBwYWQgKyBvdXQ7XHQvLyBTdHJpbmdcbn07XG5cbnN0cmluZy5zdWJzdGl0dXRlID0gZnVuY3Rpb24oXHQvKlN0cmluZyovXHRcdHRlbXBsYXRlLFxuXHRcdFx0XHRcdFx0XHRcdFx0LypPYmplY3R8QXJyYXkqL21hcCxcblx0XHRcdFx0XHRcdFx0XHRcdC8qRnVuY3Rpb24/Ki9cdHRyYW5zZm9ybSxcblx0XHRcdFx0XHRcdFx0XHRcdC8qT2JqZWN0PyovXHRcdHRoaXNPYmplY3Qpe1xuXHQvLyBzdW1tYXJ5OlxuXHQvL1x0XHRQZXJmb3JtcyBwYXJhbWV0ZXJpemVkIHN1YnN0aXR1dGlvbnMgb24gYSBzdHJpbmcuIFRocm93cyBhblxuXHQvL1x0XHRleGNlcHRpb24gaWYgYW55IHBhcmFtZXRlciBpcyB1bm1hdGNoZWQuXG5cdC8vIHRlbXBsYXRlOlxuXHQvL1x0XHRhIHN0cmluZyB3aXRoIGV4cHJlc3Npb25zIGluIHRoZSBmb3JtIGAke2tleX1gIHRvIGJlIHJlcGxhY2VkIG9yXG5cdC8vXHRcdGAke2tleTpmb3JtYXR9YCB3aGljaCBzcGVjaWZpZXMgYSBmb3JtYXQgZnVuY3Rpb24uIGtleXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuXHQvL1x0XHRUaGUgc3BlY2lhbCBzZXF1ZW5jZSBgJHt9YCBjYW4gYmUgdXNlZCBlc2NhcGUgYCRgLlxuXHQvLyBtYXA6XG5cdC8vXHRcdGhhc2ggdG8gc2VhcmNoIGZvciBzdWJzdGl0dXRpb25zXG5cdC8vIHRyYW5zZm9ybTpcblx0Ly9cdFx0YSBmdW5jdGlvbiB0byBwcm9jZXNzIGFsbCBwYXJhbWV0ZXJzIGJlZm9yZSBzdWJzdGl0dXRpb24gdGFrZXNcblx0Ly9cdFx0cGxhY2UsIGUuZy4gbXlsaWIuZW5jb2RlWE1MXG5cdC8vIHRoaXNPYmplY3Q6XG5cdC8vXHRcdHdoZXJlIHRvIGxvb2sgZm9yIG9wdGlvbmFsIGZvcm1hdCBmdW5jdGlvbjsgZGVmYXVsdCB0byB0aGUgZ2xvYmFsXG5cdC8vXHRcdG5hbWVzcGFjZVxuXHQvLyBleGFtcGxlOlxuXHQvL1x0XHRTdWJzdGl0dXRlcyB0d28gZXhwcmVzc2lvbnMgaW4gYSBzdHJpbmcgZnJvbSBhbiBBcnJheSBvciBPYmplY3Rcblx0Ly9cdHxcdC8vIHJldHVybnMgXCJGaWxlICdmb28uaHRtbCcgaXMgbm90IGZvdW5kIGluIGRpcmVjdG9yeSAnL3RlbXAnLlwiXG5cdC8vXHR8XHQvLyBieSBwcm92aWRpbmcgc3Vic3RpdHV0aW9uIGRhdGEgaW4gYW4gQXJyYXlcblx0Ly9cdHxcdHN0cmluZy5zdWJzdGl0dXRlKFxuXHQvL1x0fFx0XHRcIkZpbGUgJyR7MH0nIGlzIG5vdCBmb3VuZCBpbiBkaXJlY3RvcnkgJyR7MX0nLlwiLFxuXHQvL1x0fFx0XHRbXCJmb28uaHRtbFwiLFwiL3RlbXBcIl1cblx0Ly9cdHxcdCk7XG5cdC8vXHR8XG5cdC8vXHR8XHQvLyBhbHNvIHJldHVybnMgXCJGaWxlICdmb28uaHRtbCcgaXMgbm90IGZvdW5kIGluIGRpcmVjdG9yeSAnL3RlbXAnLlwiXG5cdC8vXHR8XHQvLyBidXQgcHJvdmlkZXMgc3Vic3RpdHV0aW9uIGRhdGEgaW4gYW4gT2JqZWN0IHN0cnVjdHVyZS4gIERvdHRlZFxuXHQvL1x0fFx0Ly8gbm90YXRpb24gbWF5IGJlIHVzZWQgdG8gdHJhdmVyc2UgdGhlIHN0cnVjdHVyZS5cblx0Ly9cdHxcdHN0cmluZy5zdWJzdGl0dXRlKFxuXHQvL1x0fFx0XHRcIkZpbGUgJyR7bmFtZX0nIGlzIG5vdCBmb3VuZCBpbiBkaXJlY3RvcnkgJyR7aW5mby5kaXJ9Jy5cIixcblx0Ly9cdHxcdFx0eyBuYW1lOiBcImZvby5odG1sXCIsIGluZm86IHsgZGlyOiBcIi90ZW1wXCIgfSB9XG5cdC8vXHR8XHQpO1xuXHQvLyBleGFtcGxlOlxuXHQvL1x0XHRVc2UgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gbW9kaWZ5IHRoZSB2YWx1ZXM6XG5cdC8vXHR8XHQvLyByZXR1cm5zIFwiZmlsZSAnZm9vLmh0bWwnIGlzIG5vdCBmb3VuZCBpbiBkaXJlY3RvcnkgJy90ZW1wJy5cIlxuXHQvL1x0fFx0c3RyaW5nLnN1YnN0aXR1dGUoXG5cdC8vXHR8XHRcdFwiJHswfSBpcyBub3QgZm91bmQgaW4gJHsxfS5cIixcblx0Ly9cdHxcdFx0W1wiZm9vLmh0bWxcIixcIi90ZW1wXCJdLFxuXHQvL1x0fFx0XHRmdW5jdGlvbihzdHIpe1xuXHQvL1x0fFx0XHRcdC8vIHRyeSB0byBmaWd1cmUgb3V0IHRoZSB0eXBlXG5cdC8vXHR8XHRcdFx0dmFyIHByZWZpeCA9IChzdHIuY2hhckF0KDApID09IFwiL1wiKSA/IFwiZGlyZWN0b3J5XCI6IFwiZmlsZVwiO1xuXHQvL1x0fFx0XHRcdHJldHVybiBwcmVmaXggKyBcIiAnXCIgKyBzdHIgKyBcIidcIjtcblx0Ly9cdHxcdFx0fVxuXHQvL1x0fFx0KTtcblx0Ly8gZXhhbXBsZTpcblx0Ly9cdFx0VXNlIGEgZm9ybWF0dGVyXG5cdC8vXHR8XHQvLyByZXR1cm5zIFwidGhpbmdlciAtLSBob3dkeVwiXG5cdC8vXHR8XHRzdHJpbmcuc3Vic3RpdHV0ZShcblx0Ly9cdHxcdFx0XCIkezA6cG9zdGZpeH1cIiwgW1widGhpbmdlclwiXSwgbnVsbCwge1xuXHQvL1x0fFx0XHRcdHBvc3RmaXg6IGZ1bmN0aW9uKHZhbHVlLCBrZXkpe1xuXHQvL1x0fFx0XHRcdFx0cmV0dXJuIHZhbHVlICsgXCIgLS0gaG93ZHlcIjtcblx0Ly9cdHxcdFx0XHR9XG5cdC8vXHR8XHRcdH1cblx0Ly9cdHxcdCk7XG5cblx0dGhpc09iamVjdCA9IHRoaXNPYmplY3QgfHwga2VybmVsLmdsb2JhbDtcblx0dHJhbnNmb3JtID0gdHJhbnNmb3JtID9cblx0XHRsYW5nLmhpdGNoKHRoaXNPYmplY3QsIHRyYW5zZm9ybSkgOiBmdW5jdGlvbih2KXsgcmV0dXJuIHY7IH07XG5cblx0cmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xcJFxceyhbXlxcc1xcOlxcfV0qKSg/OlxcOihbXlxcc1xcOlxcfV0rKSk/XFx9L2csXG5cdFx0ZnVuY3Rpb24obWF0Y2gsIGtleSwgZm9ybWF0KXtcblx0XHRcdGlmIChrZXkgPT0gJycpe1xuXHRcdFx0XHRyZXR1cm4gJyQnO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHZhbHVlID0gbGFuZy5nZXRPYmplY3Qoa2V5LCBmYWxzZSwgbWFwKTtcblx0XHRcdGlmKGZvcm1hdCl7XG5cdFx0XHRcdHZhbHVlID0gbGFuZy5nZXRPYmplY3QoZm9ybWF0LCBmYWxzZSwgdGhpc09iamVjdCkuY2FsbCh0aGlzT2JqZWN0LCB2YWx1ZSwga2V5KTtcblx0XHRcdH1cblx0XHRcdHZhciByZXN1bHQgPSB0cmFuc2Zvcm0odmFsdWUsIGtleSk7XG5cblx0XHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZy5zdWJzdGl0dXRlIGNvdWxkIG5vdCBmaW5kIGtleSBcIicgKyBrZXkgKyAnXCIgaW4gdGVtcGxhdGUnKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuXHRcdH0pOyAvLyBTdHJpbmdcbn07XG5cbnN0cmluZy50cmltID0gU3RyaW5nLnByb3RvdHlwZS50cmltID9cblx0bGFuZy50cmltIDogLy8gYWxpYXNpbmcgdG8gdGhlIG5hdGl2ZSBmdW5jdGlvblxuXHRmdW5jdGlvbihzdHIpe1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9eXFxzKy8sICcnKTtcblx0XHRmb3IodmFyIGkgPSBzdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0aWYoL1xcUy8udGVzdChzdHIuY2hhckF0KGkpKSl7XG5cdFx0XHRcdHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSArIDEpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblxuLyo9PT09PVxuIHN0cmluZy50cmltID0gZnVuY3Rpb24oc3RyKXtcblx0IC8vIHN1bW1hcnk6XG5cdCAvL1x0XHRUcmltcyB3aGl0ZXNwYWNlIGZyb20gYm90aCBzaWRlcyBvZiB0aGUgc3RyaW5nXG5cdCAvLyBzdHI6IFN0cmluZ1xuXHQgLy9cdFx0U3RyaW5nIHRvIGJlIHRyaW1tZWRcblx0IC8vIHJldHVybnM6IFN0cmluZ1xuXHQgLy9cdFx0UmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmdcblx0IC8vIGRlc2NyaXB0aW9uOlxuXHQgLy9cdFx0VGhpcyB2ZXJzaW9uIG9mIHRyaW0oKSB3YXMgdGFrZW4gZnJvbSBbU3RldmVuIExldml0aGFuJ3MgYmxvZ10oaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Zhc3Rlci10cmltLWphdmFzY3JpcHQpLlxuXHQgLy9cdFx0VGhlIHNob3J0IHlldCBwZXJmb3JtYW50IHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvbiBpcyBkb2pvL19iYXNlL2xhbmcudHJpbSgpLFxuXHQgLy9cdFx0d2hpY2ggaXMgcGFydCBvZiBEb2pvIGJhc2UuICBVc2VzIFN0cmluZy5wcm90b3R5cGUudHJpbSBpbnN0ZWFkLCBpZiBhdmFpbGFibGUuXG5cdCByZXR1cm4gXCJcIjtcdC8vIFN0cmluZ1xuIH07XG4gPT09PT0qL1xuXG5cdHJldHVybiBzdHJpbmc7XG59KTtcbiIsImRlZmluZShbXCIuL19iYXNlL2tlcm5lbFwiLCBcInJlcXVpcmVcIiwgXCIuL2hhc1wiLCBcIi4vaGFzIWhvc3QtYnJvd3Nlcj8uL3JlcXVlc3RcIl0sIGZ1bmN0aW9uKGRvam8sIHJlcXVpcmUsIGhhcywgcmVxdWVzdCl7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby90ZXh0XG5cblx0dmFyIGdldFRleHQ7XG5cdGlmKGhhcyhcImhvc3QtYnJvd3NlclwiKSl7XG5cdFx0Z2V0VGV4dD0gZnVuY3Rpb24odXJsLCBzeW5jLCBsb2FkKXtcblx0XHRcdHJlcXVlc3QodXJsLCB7c3luYzohIXN5bmMsIGhlYWRlcnM6IHsgJ1gtUmVxdWVzdGVkLVdpdGgnOiBudWxsIH0gfSkudGhlbihsb2FkKTtcblx0XHR9O1xuXHR9ZWxzZXtcblx0XHQvLyBQYXRoIGZvciBub2RlLmpzIGFuZCByaGlubywgdG8gbG9hZCBmcm9tIGxvY2FsIGZpbGUgc3lzdGVtLlxuXHRcdC8vIFRPRE86IHVzZSBub2RlLmpzIG5hdGl2ZSBtZXRob2RzIHJhdGhlciB0aGFuIGRlcGVuZGluZyBvbiBhIHJlcXVpcmUuZ2V0VGV4dCgpIG1ldGhvZCB0byBleGlzdC5cblx0XHRpZihyZXF1aXJlLmdldFRleHQpe1xuXHRcdFx0Z2V0VGV4dD0gcmVxdWlyZS5nZXRUZXh0O1xuXHRcdH1lbHNle1xuXHRcdFx0Y29uc29sZS5lcnJvcihcImRvam8vdGV4dCBwbHVnaW4gZmFpbGVkIHRvIGxvYWQgYmVjYXVzZSBsb2FkZXIgZG9lcyBub3Qgc3VwcG9ydCBnZXRUZXh0XCIpO1xuXHRcdH1cblx0fVxuXG5cdHZhclxuXHRcdHRoZUNhY2hlID0ge30sXG5cblx0XHRzdHJpcD0gZnVuY3Rpb24odGV4dCl7XG5cdFx0XHQvL1N0cmlwcyA8P3htbCAuLi4/PiBkZWNsYXJhdGlvbnMgc28gdGhhdCBleHRlcm5hbCBTVkcgYW5kIFhNTFxuXHRcdFx0Ly9kb2N1bWVudHMgY2FuIGJlIGFkZGVkIHRvIGEgZG9jdW1lbnQgd2l0aG91dCB3b3JyeS4gQWxzbywgaWYgdGhlIHN0cmluZ1xuXHRcdFx0Ly9pcyBhbiBIVE1MIGRvY3VtZW50LCBvbmx5IHRoZSBwYXJ0IGluc2lkZSB0aGUgYm9keSB0YWcgaXMgcmV0dXJuZWQuXG5cdFx0XHRpZih0ZXh0KXtcblx0XHRcdFx0dGV4dD0gdGV4dC5yZXBsYWNlKC9eXFxzKjxcXD94bWwoXFxzKSt2ZXJzaW9uPVtcXCdcXFwiXShcXGQpKi4oXFxkKSpbXFwnXFxcIl0oXFxzKSpcXD8+L2ltLCBcIlwiKTtcblx0XHRcdFx0dmFyIG1hdGNoZXM9IHRleHQubWF0Y2goLzxib2R5W14+XSo+XFxzKihbXFxzXFxTXSspXFxzKjxcXC9ib2R5Pi9pbSk7XG5cdFx0XHRcdGlmKG1hdGNoZXMpe1xuXHRcdFx0XHRcdHRleHQ9IG1hdGNoZXNbMV07XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNle1xuXHRcdFx0XHR0ZXh0ID0gXCJcIjtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH0sXG5cblx0XHRub3RGb3VuZCA9IHt9LFxuXG5cdFx0cGVuZGluZyA9IHt9O1xuXG5cdGRvam8uY2FjaGUgPSBmdW5jdGlvbigvKlN0cmluZ3x8T2JqZWN0Ki9tb2R1bGUsIC8qU3RyaW5nKi91cmwsIC8qU3RyaW5nfHxPYmplY3Q/Ki92YWx1ZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRBIGdldHRlciBhbmQgc2V0dGVyIGZvciBzdG9yaW5nIHRoZSBzdHJpbmcgY29udGVudCBhc3NvY2lhdGVkIHdpdGggdGhlXG5cdFx0Ly9cdFx0bW9kdWxlIGFuZCB1cmwgYXJndW1lbnRzLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdElmIG1vZHVsZSBpcyBhIHN0cmluZyB0aGF0IGNvbnRhaW5zIHNsYXNoZXMsIHRoZW4gaXQgaXMgaW50ZXJwcmV0dGVkIGFzIGEgZnVsbHlcblx0XHQvL1x0XHRyZXNvbHZlZCBwYXRoICh0eXBpY2FsbHkgYSByZXN1bHQgcmV0dXJuZWQgYnkgcmVxdWlyZS50b1VybCksIGFuZCB1cmwgc2hvdWxkIG5vdCBiZVxuXHRcdC8vXHRcdHByb3ZpZGVkLiBUaGlzIGlzIHRoZSBwcmVmZXJyZWQgc2lnbmF0dXJlLiBJZiBtb2R1bGUgaXMgYSBzdHJpbmcgdGhhdCBkb2VzIG5vdFxuXHRcdC8vXHRcdGNvbnRhaW4gc2xhc2hlcywgdGhlbiB1cmwgbXVzdCBhbHNvIGJlIHByb3ZpZGVkIGFuZCBtb2R1bGUgYW5kIHVybCBhcmUgdXNlZCB0b1xuXHRcdC8vXHRcdGNhbGwgYGRvam8ubW9kdWxlVXJsKClgIHRvIGdlbmVyYXRlIGEgbW9kdWxlIFVSTC4gVGhpcyBzaWduYXR1cmUgaXMgZGVwcmVjYXRlZC5cblx0XHQvL1x0XHRJZiB2YWx1ZSBpcyBzcGVjaWZpZWQsIHRoZSBjYWNoZSB2YWx1ZSBmb3IgdGhlIG1vZHVsZVVybCB3aWxsIGJlIHNldCB0b1xuXHRcdC8vXHRcdHRoYXQgdmFsdWUuIE90aGVyd2lzZSwgZG9qby5jYWNoZSB3aWxsIGZldGNoIHRoZSBtb2R1bGVVcmwgYW5kIHN0b3JlIGl0XG5cdFx0Ly9cdFx0aW4gaXRzIGludGVybmFsIGNhY2hlIGFuZCByZXR1cm4gdGhhdCBjYWNoZWQgdmFsdWUgZm9yIHRoZSBVUkwuIFRvIGNsZWFyXG5cdFx0Ly9cdFx0YSBjYWNoZSB2YWx1ZSBwYXNzIG51bGwgZm9yIHZhbHVlLiBTaW5jZSBYTUxIdHRwUmVxdWVzdCAoWEhSKSBpcyB1c2VkIHRvIGZldGNoIHRoZVxuXHRcdC8vXHRcdHRoZSBVUkwgY29udGVudHMsIG9ubHkgbW9kdWxlcyBvbiB0aGUgc2FtZSBkb21haW4gb2YgdGhlIHBhZ2UgY2FuIHVzZSB0aGlzIGNhcGFiaWxpdHkuXG5cdFx0Ly9cdFx0VGhlIGJ1aWxkIHN5c3RlbSBjYW4gaW5saW5lIHRoZSBjYWNoZSB2YWx1ZXMgdGhvdWdoLCB0byBhbGxvdyBmb3IgeGRvbWFpbiBob3N0aW5nLlxuXHRcdC8vIG1vZHVsZTogU3RyaW5nfHxPYmplY3Rcblx0XHQvL1x0XHRJZiBhIFN0cmluZyB3aXRoIHNsYXNoZXMsIGEgZnVsbHkgcmVzb2x2ZWQgcGF0aDsgaWYgYSBTdHJpbmcgd2l0aG91dCBzbGFzaGVzLCB0aGVcblx0XHQvL1x0XHRtb2R1bGUgbmFtZSB0byB1c2UgZm9yIHRoZSBiYXNlIHBhcnQgb2YgdGhlIFVSTCwgc2ltaWxhciB0byBtb2R1bGUgYXJndW1lbnRcblx0XHQvL1x0XHR0byBgZG9qby5tb2R1bGVVcmxgLiBJZiBhbiBPYmplY3QsIHNvbWV0aGluZyB0aGF0IGhhcyBhIC50b1N0cmluZygpIG1ldGhvZCB0aGF0XG5cdFx0Ly9cdFx0Z2VuZXJhdGVzIGEgdmFsaWQgcGF0aCBmb3IgdGhlIGNhY2hlIGl0ZW0uIEZvciBleGFtcGxlLCBhIGRvam8uX1VybCBvYmplY3QuXG5cdFx0Ly8gdXJsOiBTdHJpbmdcblx0XHQvL1x0XHRUaGUgcmVzdCBvZiB0aGUgcGF0aCB0byBhcHBlbmQgdG8gdGhlIHBhdGggZGVyaXZlZCBmcm9tIHRoZSBtb2R1bGUgYXJndW1lbnQuIElmXG5cdFx0Ly9cdFx0bW9kdWxlIGlzIGFuIG9iamVjdCwgdGhlbiB0aGlzIHNlY29uZCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIFwidmFsdWVcIiBhcmd1bWVudCBpbnN0ZWFkLlxuXHRcdC8vIHZhbHVlOiBTdHJpbmd8fE9iamVjdD9cblx0XHQvL1x0XHRJZiBhIFN0cmluZywgdGhlIHZhbHVlIHRvIHVzZSBpbiB0aGUgY2FjaGUgZm9yIHRoZSBtb2R1bGUvdXJsIGNvbWJpbmF0aW9uLlxuXHRcdC8vXHRcdElmIGFuIE9iamVjdCwgaXQgY2FuIGhhdmUgdHdvIHByb3BlcnRpZXM6IHZhbHVlIGFuZCBzYW5pdGl6ZS4gVGhlIHZhbHVlIHByb3BlcnR5XG5cdFx0Ly9cdFx0c2hvdWxkIGJlIHRoZSB2YWx1ZSB0byB1c2UgaW4gdGhlIGNhY2hlLCBhbmQgc2FuaXRpemUgY2FuIGJlIHNldCB0byB0cnVlIG9yIGZhbHNlLFxuXHRcdC8vXHRcdHRvIGluZGljYXRlIGlmIFhNTCBkZWNsYXJhdGlvbnMgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgdmFsdWUgYW5kIGlmIHRoZSBIVE1MXG5cdFx0Ly9cdFx0aW5zaWRlIGEgYm9keSB0YWcgaW4gdGhlIHZhbHVlIHNob3VsZCBiZSBleHRyYWN0ZWQgYXMgdGhlIHJlYWwgdmFsdWUuIFRoZSB2YWx1ZSBhcmd1bWVudFxuXHRcdC8vXHRcdG9yIHRoZSB2YWx1ZSBwcm9wZXJ0eSBvbiB0aGUgdmFsdWUgYXJndW1lbnQgYXJlIHVzdWFsbHkgb25seSB1c2VkIGJ5IHRoZSBidWlsZCBzeXN0ZW1cblx0XHQvL1x0XHRhcyBpdCBpbmxpbmVzIGNhY2hlIGNvbnRlbnQuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRUbyBhc2sgZG9qby5jYWNoZSB0byBmZXRjaCBjb250ZW50IGFuZCBzdG9yZSBpdCBpbiB0aGUgY2FjaGUgKHRoZSBkb2pvW1wiY2FjaGVcIl0gc3R5bGVcblx0XHQvL1x0XHRvZiBjYWxsIGlzIHVzZWQgdG8gYXZvaWQgYW4gaXNzdWUgd2l0aCB0aGUgYnVpbGQgc3lzdGVtIGVycm9uZW91c2x5IHRyeWluZyB0byBpbnRlcm5cblx0XHQvL1x0XHR0aGlzIGV4YW1wbGUuIFRvIGdldCB0aGUgYnVpbGQgc3lzdGVtIHRvIGludGVybiB5b3VyIGRvam8uY2FjaGUgY2FsbHMsIHVzZSB0aGVcblx0XHQvL1x0XHRcImRvam8uY2FjaGVcIiBzdHlsZSBvZiBjYWxsKTpcblx0XHQvL1x0XHR8IC8vSWYgdGVtcGxhdGUuaHRtbCBjb250YWlucyBcIjxoMT5IZWxsbzwvaDE+XCIgdGhhdCB3aWxsIGJlXG5cdFx0Ly9cdFx0fCAvL3RoZSB2YWx1ZSBmb3IgdGhlIHRleHQgdmFyaWFibGUuXG5cdFx0Ly9cdFx0fCAvL05vdGU6IFRoaXMgaXMgcHJlLUFNRCwgZGVwcmVjYXRlZCBzeW50YXhcblx0XHQvL1x0XHR8IHZhciB0ZXh0ID0gZG9qb1tcImNhY2hlXCJdKFwibXkubW9kdWxlXCIsIFwidGVtcGxhdGUuaHRtbFwiKTtcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFRvIGFzayBkb2pvLmNhY2hlIHRvIGZldGNoIGNvbnRlbnQgYW5kIHN0b3JlIGl0IGluIHRoZSBjYWNoZSwgYW5kIHNhbml0aXplIHRoZSBpbnB1dFxuXHRcdC8vXHRcdCAodGhlIGRvam9bXCJjYWNoZVwiXSBzdHlsZSBvZiBjYWxsIGlzIHVzZWQgdG8gYXZvaWQgYW4gaXNzdWUgd2l0aCB0aGUgYnVpbGQgc3lzdGVtXG5cdFx0Ly9cdFx0ZXJyb25lb3VzbHkgdHJ5aW5nIHRvIGludGVybiB0aGlzIGV4YW1wbGUuIFRvIGdldCB0aGUgYnVpbGQgc3lzdGVtIHRvIGludGVybiB5b3VyXG5cdFx0Ly9cdFx0ZG9qby5jYWNoZSBjYWxscywgdXNlIHRoZSBcImRvam8uY2FjaGVcIiBzdHlsZSBvZiBjYWxsKTpcblx0XHQvL1x0XHR8IC8vSWYgdGVtcGxhdGUuaHRtbCBjb250YWlucyBcIjxodG1sPjxib2R5PjxoMT5IZWxsbzwvaDE+PC9ib2R5PjwvaHRtbD5cIiwgdGhlXG5cdFx0Ly9cdFx0fCAvL3RleHQgdmFyaWFibGUgd2lsbCBjb250YWluIGp1c3QgXCI8aDE+SGVsbG88L2gxPlwiLlxuXHRcdC8vXHRcdHwgLy9Ob3RlOiBUaGlzIGlzIHByZS1BTUQsIGRlcHJlY2F0ZWQgc3ludGF4XG5cdFx0Ly9cdFx0fCB2YXIgdGV4dCA9IGRvam9bXCJjYWNoZVwiXShcIm15Lm1vZHVsZVwiLCBcInRlbXBsYXRlLmh0bWxcIiwge3Nhbml0aXplOiB0cnVlfSk7XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRTYW1lIGV4YW1wbGUgYXMgcHJldmlvdXMsIGJ1dCBkZW1vbnN0cmF0ZXMgaG93IGFuIG9iamVjdCBjYW4gYmUgcGFzc2VkIGluIGFzXG5cdFx0Ly9cdFx0dGhlIGZpcnN0IGFyZ3VtZW50LCB0aGVuIHRoZSB2YWx1ZSBhcmd1bWVudCBjYW4gdGhlbiBiZSB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuXHRcdC8vXHRcdHwgLy9JZiB0ZW1wbGF0ZS5odG1sIGNvbnRhaW5zIFwiPGh0bWw+PGJvZHk+PGgxPkhlbGxvPC9oMT48L2JvZHk+PC9odG1sPlwiLCB0aGVcblx0XHQvL1x0XHR8IC8vdGV4dCB2YXJpYWJsZSB3aWxsIGNvbnRhaW4ganVzdCBcIjxoMT5IZWxsbzwvaDE+XCIuXG5cdFx0Ly9cdFx0fCAvL05vdGU6IFRoaXMgaXMgcHJlLUFNRCwgZGVwcmVjYXRlZCBzeW50YXhcblx0XHQvL1x0XHR8IHZhciB0ZXh0ID0gZG9qb1tcImNhY2hlXCJdKG5ldyBkb2pvLl9VcmwoXCJteS9tb2R1bGUvdGVtcGxhdGUuaHRtbFwiKSwge3Nhbml0aXplOiB0cnVlfSk7XG5cblx0XHQvL1x0ICogKHN0cmluZyBzdHJpbmcgW3ZhbHVlXSkgPT4gKG1vZHVsZSwgdXJsLCB2YWx1ZSlcblx0XHQvL1x0ICogKG9iamVjdCBbdmFsdWVdKSAgICAgICAgPT4gKG1vZHVsZSwgdmFsdWUpLCB1cmwgZGVmYXVsdHMgdG8gXCJcIlxuXHRcdC8vXG5cdFx0Ly9cdCAqIGlmIG1vZHVsZSBpcyBhbiBvYmplY3QsIHRoZW4gaXQgbXVzdCBiZSBjb252ZXJ0YWJsZSB0byBhIHN0cmluZ1xuXHRcdC8vXHQgKiAobW9kdWxlLCB1cmwpIG1vZHVsZSArICh1cmwgPyAoXCIvXCIgKyB1cmwpIDogXCJcIikgbXVzdCBiZSBhIGxlZ2FsIGFyZ3VtZW50IHRvIHJlcXVpcmUudG9Vcmxcblx0XHQvL1x0ICogdmFsdWUgbWF5IGJlIGEgc3RyaW5nIG9yIGFuIG9iamVjdDsgaWYgYW4gb2JqZWN0IHRoZW4gbWF5IGhhdmUgdGhlIHByb3BlcnRpZXMgXCJ2YWx1ZVwiIGFuZC9vciBcInNhbml0aXplXCJcblx0XHR2YXIga2V5O1xuXHRcdGlmKHR5cGVvZiBtb2R1bGU9PVwic3RyaW5nXCIpe1xuXHRcdFx0aWYoL1xcLy8udGVzdChtb2R1bGUpKXtcblx0XHRcdFx0Ly8gbW9kdWxlIGlzIGEgdmVyc2lvbiAxLjcrIHJlc29sdmVkIHBhdGhcblx0XHRcdFx0a2V5ID0gbW9kdWxlO1xuXHRcdFx0XHR2YWx1ZSA9IHVybDtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHQvLyBtb2R1bGUgaXMgYSB2ZXJzaW9uIDEuNi0gYXJndW1lbnQgdG8gZG9qby5tb2R1bGVVcmxcblx0XHRcdFx0a2V5ID0gcmVxdWlyZS50b1VybChtb2R1bGUucmVwbGFjZSgvXFwuL2csIFwiL1wiKSArICh1cmwgPyAoXCIvXCIgKyB1cmwpIDogXCJcIikpO1xuXHRcdFx0fVxuXHRcdH1lbHNle1xuXHRcdFx0a2V5ID0gbW9kdWxlICsgXCJcIjtcblx0XHRcdHZhbHVlID0gdXJsO1xuXHRcdH1cblx0XHR2YXJcblx0XHRcdHZhbCA9ICh2YWx1ZSAhPSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpID8gdmFsdWUudmFsdWUgOiB2YWx1ZSxcblx0XHRcdHNhbml0aXplID0gdmFsdWUgJiYgdmFsdWUuc2FuaXRpemU7XG5cblx0XHRpZih0eXBlb2YgdmFsID09IFwic3RyaW5nXCIpe1xuXHRcdFx0Ly9XZSBoYXZlIGEgc3RyaW5nLCBzZXQgY2FjaGUgdmFsdWVcblx0XHRcdHRoZUNhY2hlW2tleV0gPSB2YWw7XG5cdFx0XHRyZXR1cm4gc2FuaXRpemUgPyBzdHJpcCh2YWwpIDogdmFsO1xuXHRcdH1lbHNlIGlmKHZhbCA9PT0gbnVsbCl7XG5cdFx0XHQvL1JlbW92ZSBjYWNoZWQgdmFsdWVcblx0XHRcdGRlbGV0ZSB0aGVDYWNoZVtrZXldO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fWVsc2V7XG5cdFx0XHQvL0FsbG93IGNhY2hlIHZhbHVlcyB0byBiZSBlbXB0eSBzdHJpbmdzLiBJZiBrZXkgcHJvcGVydHkgZG9lc1xuXHRcdFx0Ly9ub3QgZXhpc3QsIGZldGNoIGl0LlxuXHRcdFx0aWYoIShrZXkgaW4gdGhlQ2FjaGUpKXtcblx0XHRcdFx0Z2V0VGV4dChrZXksIHRydWUsIGZ1bmN0aW9uKHRleHQpe1xuXHRcdFx0XHRcdHRoZUNhY2hlW2tleV09IHRleHQ7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNhbml0aXplID8gc3RyaXAodGhlQ2FjaGVba2V5XSkgOiB0aGVDYWNoZVtrZXldO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhpcyBtb2R1bGUgaW1wbGVtZW50cyB0aGUgZG9qby90ZXh0ISBwbHVnaW4gYW5kIHRoZSBkb2pvLmNhY2hlIEFQSS5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRXZSBjaG9vc2UgdG8gaW5jbHVkZSBvdXIgb3duIHBsdWdpbiB0byBsZXZlcmFnZSBmdW5jdGlvbmFsaXR5IGFscmVhZHkgY29udGFpbmVkIGluIGRvam9cblx0XHQvL1x0XHRhbmQgdGhlcmVieSByZWR1Y2UgdGhlIHNpemUgb2YgdGhlIHBsdWdpbiBjb21wYXJlZCB0byB2YXJpb3VzIGZvcmVpZ24gbG9hZGVyIGltcGxlbWVudGF0aW9ucy5cblx0XHQvL1x0XHRBbHNvLCB0aGlzIGFsbG93cyBmb3JlaWduIEFNRCBsb2FkZXJzIHRvIGJlIHVzZWQgd2l0aG91dCB0aGVpciBwbHVnaW5zLlxuXHRcdC8vXG5cdFx0Ly9cdFx0Q0FVVElPTjogdGhpcyBtb2R1bGUgaXMgZGVzaWduZWQgdG8gb3B0aW9uYWxseSBmdW5jdGlvbiBzeW5jaHJvbm91c2x5IHRvIHN1cHBvcnQgdGhlIGRvam8gdjEueCBzeW5jaHJvbm91c1xuXHRcdC8vXHRcdGxvYWRlci4gVGhpcyBmZWF0dXJlIGlzIG91dHNpZGUgdGhlIHNjb3BlIG9mIHRoZSBDb21tb25KUyBwbHVnaW5zIHNwZWNpZmljYXRpb24uXG5cblx0XHQvLyB0aGUgZG9qby90ZXh0IGNhY2hlcyBpdCdzIG93biByZXNvdXJjZXMgYmVjYXVzZSBvZiBkb2pvLmNhY2hlXG5cdFx0ZHluYW1pYzogdHJ1ZSxcblxuXHRcdG5vcm1hbGl6ZTogZnVuY3Rpb24oaWQsIHRvQWJzTWlkKXtcblx0XHRcdC8vIGlkIGlzIHNvbWV0aGluZyBsaWtlIChwYXRoIG1heSBiZSByZWxhdGl2ZSk6XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdCBcInBhdGgvdG8vdGV4dC5odG1sXCJcblx0XHRcdC8vXHQgXCJwYXRoL3RvL3RleHQuaHRtbCFzdHJpcFwiXG5cdFx0XHR2YXIgcGFydHM9IGlkLnNwbGl0KFwiIVwiKSxcblx0XHRcdFx0dXJsPSBwYXJ0c1swXTtcblx0XHRcdHJldHVybiAoL15cXC4vLnRlc3QodXJsKSA/IHRvQWJzTWlkKHVybCkgOiB1cmwpICsgKHBhcnRzWzFdID8gXCIhXCIgKyBwYXJ0c1sxXSA6IFwiXCIpO1xuXHRcdH0sXG5cblx0XHRsb2FkOiBmdW5jdGlvbihpZCwgcmVxdWlyZSwgbG9hZCl7XG5cdFx0XHQvLyBpZDogU3RyaW5nXG5cdFx0XHQvL1x0XHRQYXRoIHRvIHRoZSByZXNvdXJjZS5cblx0XHRcdC8vIHJlcXVpcmU6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRPYmplY3QgdGhhdCBpbmNsdWRlIHRoZSBmdW5jdGlvbiB0b1VybCB3aXRoIGdpdmVuIGlkIHJldHVybnMgYSB2YWxpZCBVUkwgZnJvbSB3aGljaCB0byBsb2FkIHRoZSB0ZXh0LlxuXHRcdFx0Ly8gbG9hZDogRnVuY3Rpb25cblx0XHRcdC8vXHRcdENhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkLCB3aGVuIHRoZSBsb2FkaW5nIGZpbmlzaGVkLlxuXG5cdFx0XHQvLyBpZCBpcyBzb21ldGhpbmcgbGlrZSAocGF0aCBpcyBhbHdheXMgYWJzb2x1dGUpOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHQgXCJwYXRoL3RvL3RleHQuaHRtbFwiXG5cdFx0XHQvL1x0IFwicGF0aC90by90ZXh0Lmh0bWwhc3RyaXBcIlxuXHRcdFx0dmFyXG5cdFx0XHRcdHBhcnRzPSBpZC5zcGxpdChcIiFcIiksXG5cdFx0XHRcdHN0cmlwRmxhZz0gcGFydHMubGVuZ3RoPjEsXG5cdFx0XHRcdGFic01pZD0gcGFydHNbMF0sXG5cdFx0XHRcdHVybCA9IHJlcXVpcmUudG9VcmwocGFydHNbMF0pLFxuXHRcdFx0XHRyZXF1aXJlQ2FjaGVVcmwgPSBcInVybDpcIiArIHVybCxcblx0XHRcdFx0dGV4dCA9IG5vdEZvdW5kLFxuXHRcdFx0XHRmaW5pc2ggPSBmdW5jdGlvbih0ZXh0KXtcblx0XHRcdFx0XHRsb2FkKHN0cmlwRmxhZyA/IHN0cmlwKHRleHQpIDogdGV4dCk7XG5cdFx0XHRcdH07XG5cdFx0XHRpZihhYnNNaWQgaW4gdGhlQ2FjaGUpe1xuXHRcdFx0XHR0ZXh0ID0gdGhlQ2FjaGVbYWJzTWlkXTtcblx0XHRcdH1lbHNlIGlmKHJlcXVpcmUuY2FjaGUgJiYgcmVxdWlyZUNhY2hlVXJsIGluIHJlcXVpcmUuY2FjaGUpe1xuXHRcdFx0XHR0ZXh0ID0gcmVxdWlyZS5jYWNoZVtyZXF1aXJlQ2FjaGVVcmxdO1xuXHRcdFx0fWVsc2UgaWYodXJsIGluIHRoZUNhY2hlKXtcblx0XHRcdFx0dGV4dCA9IHRoZUNhY2hlW3VybF07XG5cdFx0XHR9XG5cdFx0XHRpZih0ZXh0PT09bm90Rm91bmQpe1xuXHRcdFx0XHRpZihwZW5kaW5nW3VybF0pe1xuXHRcdFx0XHRcdHBlbmRpbmdbdXJsXS5wdXNoKGZpbmlzaCk7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHZhciBwZW5kaW5nTGlzdCA9IHBlbmRpbmdbdXJsXSA9IFtmaW5pc2hdO1xuXHRcdFx0XHRcdGdldFRleHQodXJsLCAhcmVxdWlyZS5hc3luYywgZnVuY3Rpb24odGV4dCl7XG5cdFx0XHRcdFx0XHR0aGVDYWNoZVthYnNNaWRdPSB0aGVDYWNoZVt1cmxdPSB0ZXh0O1xuXHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaTxwZW5kaW5nTGlzdC5sZW5ndGg7KXtcblx0XHRcdFx0XHRcdFx0cGVuZGluZ0xpc3RbaSsrXSh0ZXh0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRlbGV0ZSBwZW5kaW5nW3VybF07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNle1xuXHRcdFx0XHRmaW5pc2godGV4dCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG59KTtcblxuIiwiZGVmaW5lKFtcIi4vRXZlbnRlZFwiXSwgZnVuY3Rpb24oRXZlbnRlZCl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL3RvcGljXG5cblx0dmFyIGh1YiA9IG5ldyBFdmVudGVkO1xuXHRyZXR1cm4ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UHVic3ViIGh1Yi5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdHwgXHR0b3BpYy5zdWJzY3JpYmUoXCJzb21lL3RvcGljXCIsIGZ1bmN0aW9uKGV2ZW50KXtcblx0XHQvL1x0XHR8XHQuLi4gZG8gc29tZXRoaW5nIHdpdGggZXZlbnRcblx0XHQvL1x0XHR8XHR9KTtcblx0XHQvL1x0XHR8XHR0b3BpYy5wdWJsaXNoKFwic29tZS90b3BpY1wiLCB7bmFtZTpcInNvbWUgZXZlbnRcIiwgLi4ufSk7XG5cblx0XHRwdWJsaXNoOiBmdW5jdGlvbih0b3BpYywgZXZlbnQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFB1Ymxpc2hlcyBhIG1lc3NhZ2UgdG8gYSB0b3BpYyBvbiB0aGUgcHViL3N1YiBodWIuIEFsbCBhcmd1bWVudHMgYWZ0ZXJcblx0XHRcdC8vXHRcdHRoZSBmaXJzdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgc3Vic2NyaWJlcnMsIHNvIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXG5cdFx0XHQvL1x0XHRjYW4gYmUgcHJvdmlkZWQgKG5vdCBqdXN0IGV2ZW50KS5cblx0XHRcdC8vIHRvcGljOiBTdHJpbmdcblx0XHRcdC8vXHRcdFRoZSBuYW1lIG9mIHRoZSB0b3BpYyB0byBwdWJsaXNoIHRvXG5cdFx0XHQvLyBldmVudDogT2JqZWN0XG5cdFx0XHQvL1x0XHRBbiBldmVudCB0byBkaXN0cmlidXRlIHRvIHRoZSB0b3BpYyBsaXN0ZW5lcnNcblx0XHRcdHJldHVybiBodWIuZW1pdC5hcHBseShodWIsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdHN1YnNjcmliZTogZnVuY3Rpb24odG9waWMsIGxpc3RlbmVyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRTdWJzY3JpYmVzIHRvIGEgdG9waWMgb24gdGhlIHB1Yi9zdWIgaHViXG5cdFx0XHQvLyB0b3BpYzogU3RyaW5nXG5cdFx0XHQvL1x0XHRUaGUgdG9waWMgdG8gc3Vic2NyaWJlIHRvXG5cdFx0XHQvLyBsaXN0ZW5lcjogRnVuY3Rpb25cblx0XHRcdC8vXHRcdEEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgbWVzc2FnZSBpcyBwdWJsaXNoZWQgdG8gdGhlIGdpdmVuIHRvcGljXG5cdFx0XHRyZXR1cm4gaHViLm9uLmFwcGx5KGh1YiwgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG59KTtcbiIsImRlZmluZShbXCIuL19iYXNlL2tlcm5lbFwiLCBcIi4vYXNwZWN0XCIsIFwiLi9kb21cIiwgXCIuL2RvbS1jbGFzc1wiLCBcIi4vX2Jhc2UvbGFuZ1wiLCBcIi4vb25cIiwgXCIuL2hhc1wiLCBcIi4vbW91c2VcIiwgXCIuL2RvbVJlYWR5XCIsIFwiLi9fYmFzZS93aW5kb3dcIl0sXG5mdW5jdGlvbihkb2pvLCBhc3BlY3QsIGRvbSwgZG9tQ2xhc3MsIGxhbmcsIG9uLCBoYXMsIG1vdXNlLCBkb21SZWFkeSwgd2luKXtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vdG91Y2hcblxuXHR2YXIgaW9zNCA9IGhhcyhcImlvc1wiKSA8IDU7XG5cblx0Ly8gRGV0ZWN0IGlmIHBsYXRmb3JtIHN1cHBvcnRzIFBvaW50ZXIgRXZlbnRzLCBhbmQgaWYgc28sIHRoZSBuYW1lcyBvZiB0aGUgZXZlbnRzIChwb2ludGVyZG93biB2cy4gTVNQb2ludGVyRG93bikuXG5cdHZhciBoYXNQb2ludGVyID0gaGFzKFwicG9pbnRlci1ldmVudHNcIikgfHwgaGFzKFwiTVNQb2ludGVyXCIpLFxuXHRcdHBvaW50ZXIgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHBvaW50ZXIgPSB7fTtcblx0XHRcdGZvciAodmFyIHR5cGUgaW4geyBkb3duOiAxLCBtb3ZlOiAxLCB1cDogMSwgY2FuY2VsOiAxLCBvdmVyOiAxLCBvdXQ6IDEgfSkge1xuXHRcdFx0XHRwb2ludGVyW3R5cGVdID0gaGFzKFwiTVNQb2ludGVyXCIpID9cblx0XHRcdFx0XHRcIk1TUG9pbnRlclwiICsgdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc2xpY2UoMSkgOlxuXHRcdFx0XHRcdFwicG9pbnRlclwiICsgdHlwZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwb2ludGVyO1xuXHRcdH0pKCk7XG5cblx0Ly8gRGV0ZWN0IGlmIHBsYXRmb3JtIHN1cHBvcnRzIHRoZSB3ZWJraXQgdG91Y2hzdGFydC90b3VjaGVuZC8uLi4gZXZlbnRzXG5cdHZhciBoYXNUb3VjaCA9IGhhcyhcInRvdWNoLWV2ZW50c1wiKTtcblxuXHQvLyBDbGljayBnZW5lcmF0aW9uIHZhcmlhYmxlc1xuXHR2YXIgY2xpY2tzSW5pdGVkLCBjbGlja1RyYWNrZXIsIHVzZVRhcmdldCA9IGZhbHNlLCBjbGlja1RhcmdldCwgY2xpY2tYLCBjbGlja1ksIGNsaWNrRHgsIGNsaWNrRHksIGNsaWNrVGltZTtcblxuXHQvLyBUaW1lIG9mIG1vc3QgcmVjZW50IHRvdWNoc3RhcnQsIHRvdWNobW92ZSwgb3IgdG91Y2hlbmQgZXZlbnRcblx0dmFyIGxhc3RUb3VjaDtcblxuXHRmdW5jdGlvbiBkdWFsRXZlbnQobW91c2VUeXBlLCB0b3VjaFR5cGUsIHBvaW50ZXJUeXBlKXtcblx0XHQvLyBSZXR1cm5zIHN5bnRoZXRpYyBldmVudCB0aGF0IGxpc3RlbnMgZm9yIGJvdGggdGhlIHNwZWNpZmllZCBtb3VzZSBldmVudCBhbmQgc3BlY2lmaWVkIHRvdWNoIGV2ZW50LlxuXHRcdC8vIEJ1dCBpZ25vcmUgZmFrZSBtb3VzZSBldmVudHMgdGhhdCB3ZXJlIGdlbmVyYXRlZCBkdWUgdG8gdGhlIHVzZXIgdG91Y2hpbmcgdGhlIHNjcmVlbi5cblx0XHRpZihoYXNQb2ludGVyICYmIHBvaW50ZXJUeXBlKXtcblx0XHRcdC8vIElFMTArOiBNU1BvaW50ZXIqIGV2ZW50cyBhcmUgZGVzaWduZWQgdG8gaGFuZGxlIGJvdGggbW91c2UgYW5kIHRvdWNoIGluIGEgdW5pZm9ybSB3YXksXG5cdFx0XHQvLyBzbyBqdXN0IHVzZSB0aGF0IHJlZ2FyZGxlc3Mgb2YgaGFzVG91Y2guXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24obm9kZSwgbGlzdGVuZXIpe1xuXHRcdFx0XHRyZXR1cm4gb24obm9kZSwgcG9pbnRlclR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdH07XG5cdFx0fWVsc2UgaWYoaGFzVG91Y2gpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG5vZGUsIGxpc3RlbmVyKXtcblx0XHRcdFx0dmFyIGhhbmRsZTEgPSBvbihub2RlLCB0b3VjaFR5cGUsIGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHRcdFx0XHRsaXN0ZW5lci5jYWxsKHRoaXMsIGV2dCk7XG5cblx0XHRcdFx0XHRcdC8vIE9uIHNsb3cgbW9iaWxlIGJyb3dzZXJzIChzZWUgaHR0cHM6Ly9idWdzLmRvam90b29sa2l0Lm9yZy90aWNrZXQvMTc2MzQpLFxuXHRcdFx0XHRcdFx0Ly8gYSBoYW5kbGVyIGZvciBhIHRvdWNoIGV2ZW50IG1heSB0YWtlID4xcyB0byBydW4uICBUaGF0IHRpbWUgc2hvdWxkbid0XG5cdFx0XHRcdFx0XHQvLyBiZSBpbmNsdWRlZCBpbiB0aGUgY2FsY3VsYXRpb24gZm9yIGxhc3RUb3VjaC5cblx0XHRcdFx0XHRcdGxhc3RUb3VjaCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0aGFuZGxlMiA9IG9uKG5vZGUsIG1vdXNlVHlwZSwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0XHRcdGlmKCFsYXN0VG91Y2ggfHwgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSA+IGxhc3RUb3VjaCArIDEwMDApe1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lci5jYWxsKHRoaXMsIGV2dCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0aGFuZGxlMS5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGhhbmRsZTIucmVtb3ZlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9ZWxzZXtcblx0XHRcdC8vIEF2b2lkIGNyZWF0aW5nIGxpc3RlbmVycyBmb3IgdG91Y2ggZXZlbnRzIG9uIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZSBvbGRlciBicm93c2VycyBsaWtlIElFNlxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG5vZGUsIGxpc3RlbmVyKXtcblx0XHRcdFx0cmV0dXJuIG9uKG5vZGUsIG1vdXNlVHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBtYXJrZWQoLypET01Ob2RlKi8gbm9kZSl7XG5cdFx0Ly8gU2VhcmNoIGZvciBub2RlIGFuY2VzdG9yIGhhcyBiZWVuIG1hcmtlZCB3aXRoIHRoZSBkb2pvQ2xpY2sgcHJvcGVydHkgdG8gaW5kaWNhdGUgc3BlY2lhbCBwcm9jZXNzaW5nLlxuXHRcdC8vIFJldHVybnMgbWFya2VkIGFuY2VzdG9yLlxuXHRcdGRve1xuXHRcdFx0aWYobm9kZS5kb2pvQ2xpY2sgIT09IHVuZGVmaW5lZCl7IHJldHVybiBub2RlOyB9XG5cdFx0fXdoaWxlKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZG9DbGlja3MoZSwgbW92ZVR5cGUsIGVuZFR5cGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0U2V0dXAgdG91Y2ggbGlzdGVuZXJzIHRvIGdlbmVyYXRlIHN5bnRoZXRpYyBjbGlja3MgaW1tZWRpYXRlbHkgKHJhdGhlciB0aGFuIHdhaXRpbmcgZm9yIHRoZSBicm93c2VyXG5cdFx0Ly9cdFx0dG8gZ2VuZXJhdGUgY2xpY2tzIGFmdGVyIHRoZSBkb3VibGUtdGFwIGRlbGF5KSBhbmQgY29uc2lzdGVudGx5IChyZWdhcmRsZXNzIG9mIHdoZXRoZXIgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdC8vXHRcdHdhcyBjYWxsZWQgaW4gYW4gZXZlbnQgbGlzdGVuZXIuIFN5bnRoZXRpYyBjbGlja3MgYXJlIGdlbmVyYXRlZCBvbmx5IGlmIGEgbm9kZSBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXNcblx0XHQvL1x0XHRpdHMgZG9qb0NsaWNrIHByb3BlcnR5IHNldCB0byB0cnV0aHkuIElmIGEgbm9kZSByZWNlaXZlcyBzeW50aGV0aWMgY2xpY2tzIGJlY2F1c2Ugb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIGl0c1xuXHRcdC8vICAgICAgZG9qb0NsaWNrIHByb3BlcnR5IHNldCB0byB0cnV0aHksIHlvdSBjYW4gZGlzYWJsZSBzeW50aGV0aWMgY2xpY2tzIG9uIHRoaXMgbm9kZSBieSBzZXR0aW5nIGl0cyBvd24gZG9qb0NsaWNrIHByb3BlcnR5XG5cdFx0Ly8gICAgICB0byBmYWxzeS5cblxuXHRcdGlmKG1vdXNlLmlzUmlnaHQoZSkpe1xuXHRcdFx0cmV0dXJuO1x0XHQvLyBhdm9pZCBzcHVyaW91cyBkb2pvY2xpY2sgZXZlbnQgb24gSUUxMCs7IHJpZ2h0IGNsaWNrIGlzIGp1c3QgZm9yIGNvbnRleHQgbWVudVxuXHRcdH1cblxuXHRcdHZhciBtYXJrZWROb2RlID0gbWFya2VkKGUudGFyZ2V0KTtcblx0XHRjbGlja1RyYWNrZXIgID0gIWUudGFyZ2V0LmRpc2FibGVkICYmIG1hcmtlZE5vZGUgJiYgbWFya2VkTm9kZS5kb2pvQ2xpY2s7IC8vIGNsaWNrIHRocmVzaG9sZCA9IHRydWUsIG51bWJlciwgeC95IG9iamVjdCwgb3IgXCJ1c2VUYXJnZXRcIlxuXHRcdGlmKGNsaWNrVHJhY2tlcil7XG5cdFx0XHR1c2VUYXJnZXQgPSAoY2xpY2tUcmFja2VyID09IFwidXNlVGFyZ2V0XCIpO1xuXHRcdFx0Y2xpY2tUYXJnZXQgPSAodXNlVGFyZ2V0P21hcmtlZE5vZGU6ZS50YXJnZXQpO1xuXHRcdFx0aWYodXNlVGFyZ2V0KXtcblx0XHRcdFx0Ly8gV2UgZXhwZWN0IGEgY2xpY2ssIHNvIHByZXZlbnQgYW55IG90aGVyXG5cdFx0XHRcdC8vIGRlZmF1bHQgYWN0aW9uIG9uIFwidG91Y2hwcmVzc1wiXG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHRcdGNsaWNrWCA9IGUuY2hhbmdlZFRvdWNoZXMgPyBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gd2luLmdsb2JhbC5wYWdlWE9mZnNldCA6IGUuY2xpZW50WDtcblx0XHRcdGNsaWNrWSA9IGUuY2hhbmdlZFRvdWNoZXMgPyBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luLmdsb2JhbC5wYWdlWU9mZnNldCA6IGUuY2xpZW50WTtcblx0XHRcdGNsaWNrRHggPSAodHlwZW9mIGNsaWNrVHJhY2tlciA9PSBcIm9iamVjdFwiID8gY2xpY2tUcmFja2VyLnggOiAodHlwZW9mIGNsaWNrVHJhY2tlciA9PSBcIm51bWJlclwiID8gY2xpY2tUcmFja2VyIDogMCkpIHx8IDQ7XG5cdFx0XHRjbGlja0R5ID0gKHR5cGVvZiBjbGlja1RyYWNrZXIgPT0gXCJvYmplY3RcIiA/IGNsaWNrVHJhY2tlci55IDogKHR5cGVvZiBjbGlja1RyYWNrZXIgPT0gXCJudW1iZXJcIiA/IGNsaWNrVHJhY2tlciA6IDApKSB8fCA0O1xuXG5cdFx0XHQvLyBhZGQgbW92ZS9lbmQgaGFuZGxlcnMgb25seSB0aGUgZmlyc3QgdGltZSBhIG5vZGUgd2l0aCBkb2pvQ2xpY2sgaXMgc2Vlbixcblx0XHRcdC8vIHNvIHdlIGRvbid0IGFkZCB0b28gbXVjaCBvdmVyaGVhZCB3aGVuIGRvam9DbGljayBpcyBuZXZlciBzZXQuXG5cdFx0XHRpZighY2xpY2tzSW5pdGVkKXtcblx0XHRcdFx0Y2xpY2tzSW5pdGVkID0gdHJ1ZTtcblxuXHRcdFx0XHRmdW5jdGlvbiB1cGRhdGVDbGlja1RyYWNrZXIoZSl7XG5cdFx0XHRcdFx0aWYodXNlVGFyZ2V0KXtcblx0XHRcdFx0XHRcdGNsaWNrVHJhY2tlciA9IGRvbS5pc0Rlc2NlbmRhbnQoXG5cdFx0XHRcdFx0XHRcdHdpbi5kb2MuZWxlbWVudEZyb21Qb2ludChcblx0XHRcdFx0XHRcdFx0XHQoZS5jaGFuZ2VkVG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW4uZ2xvYmFsLnBhZ2VYT2Zmc2V0IDogZS5jbGllbnRYKSxcblx0XHRcdFx0XHRcdFx0XHQoZS5jaGFuZ2VkVG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSB3aW4uZ2xvYmFsLnBhZ2VZT2Zmc2V0IDogZS5jbGllbnRZKSksXG5cdFx0XHRcdFx0XHRcdGNsaWNrVGFyZ2V0KTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdGNsaWNrVHJhY2tlciA9IGNsaWNrVHJhY2tlciAmJlxuXHRcdFx0XHRcdFx0XHQoZS5jaGFuZ2VkVG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0udGFyZ2V0IDogZS50YXJnZXQpID09IGNsaWNrVGFyZ2V0ICYmXG5cdFx0XHRcdFx0XHRcdE1hdGguYWJzKChlLmNoYW5nZWRUb3VjaGVzID8gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIHdpbi5nbG9iYWwucGFnZVhPZmZzZXQgOiBlLmNsaWVudFgpIC0gY2xpY2tYKSA8PSBjbGlja0R4ICYmXG5cdFx0XHRcdFx0XHRcdE1hdGguYWJzKChlLmNoYW5nZWRUb3VjaGVzID8gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbi5nbG9iYWwucGFnZVlPZmZzZXQgOiBlLmNsaWVudFkpIC0gY2xpY2tZKSA8PSBjbGlja0R5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHdpbi5kb2MuYWRkRXZlbnRMaXN0ZW5lcihtb3ZlVHlwZSwgZnVuY3Rpb24oZSl7XG5cdFx0XHRcdFx0aWYobW91c2UuaXNSaWdodChlKSl7XG5cdFx0XHRcdFx0XHRyZXR1cm47XHRcdC8vIGF2b2lkIHNwdXJpb3VzIGRvam9jbGljayBldmVudCBvbiBJRTEwKzsgcmlnaHQgY2xpY2sgaXMganVzdCBmb3IgY29udGV4dCBtZW51XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHVwZGF0ZUNsaWNrVHJhY2tlcihlKTtcblx0XHRcdFx0XHRpZih1c2VUYXJnZXQpe1xuXHRcdFx0XHRcdFx0Ly8gcHJldmVudCBuYXRpdmUgc2Nyb2xsIGV2ZW50IGFuZCBlbnN1cmUgdG91Y2hlbmQgaXNcblx0XHRcdFx0XHRcdC8vIGZpcmUgYWZ0ZXIgdG91Y2ggbW92ZXMgYmV0d2VlbiBwcmVzcyBhbmQgcmVsZWFzZS5cblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIHRydWUpO1xuXG5cdFx0XHRcdHdpbi5kb2MuYWRkRXZlbnRMaXN0ZW5lcihlbmRUeXBlLCBmdW5jdGlvbihlKXtcblx0XHRcdFx0XHRpZihtb3VzZS5pc1JpZ2h0KGUpKXtcblx0XHRcdFx0XHRcdHJldHVybjtcdFx0Ly8gYXZvaWQgc3B1cmlvdXMgZG9qb2NsaWNrIGV2ZW50IG9uIElFMTArOyByaWdodCBjbGljayBpcyBqdXN0IGZvciBjb250ZXh0IG1lbnVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dXBkYXRlQ2xpY2tUcmFja2VyKGUpO1xuXHRcdFx0XHRcdGlmKGNsaWNrVHJhY2tlcil7XG5cdFx0XHRcdFx0XHRjbGlja1RpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0dmFyIHRhcmdldCA9ICh1c2VUYXJnZXQ/Y2xpY2tUYXJnZXQ6ZS50YXJnZXQpO1xuXHRcdFx0XHRcdFx0aWYodGFyZ2V0LnRhZ05hbWUgPT09IFwiTEFCRUxcIil7XG5cdFx0XHRcdFx0XHRcdC8vIHdoZW4gY2xpY2tpbmcgb24gYSBsYWJlbCwgZm9yd2FyZCBjbGljayB0byBpdHMgYXNzb2NpYXRlZCBpbnB1dCBpZiBhbnlcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gZG9tLmJ5SWQodGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvclwiKSkgfHwgdGFyZ2V0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9zb21lIGF0dHJpYnV0ZXMgY2FuIGJlIG9uIHRoZSBUb3VjaCBvYmplY3QsIG5vdCBvbiB0aGUgRXZlbnQ6XG5cdFx0XHRcdFx0XHQvL2h0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy8jdG91Y2gtaW50ZXJmYWNlXG5cdFx0XHRcdFx0XHR2YXIgc3JjID0gKGUuY2hhbmdlZFRvdWNoZXMpID8gZS5jaGFuZ2VkVG91Y2hlc1swXSA6IGU7XG5cdFx0XHRcdFx0XHRmdW5jdGlvbiBjcmVhdGVNb3VzZUV2ZW50KHR5cGUpe1xuXHRcdFx0XHRcdFx0XHQvL2NyZWF0ZSB0aGUgc3ludGhldGljIGV2ZW50LlxuXHRcdFx0XHRcdFx0XHQvL2h0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jd2lkbC1Nb3VzZUV2ZW50LWluaXRNb3VzZUV2ZW50XG5cdFx0XHRcdFx0XHRcdHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuXHRcdFx0XHRcdFx0XHRldnQuX2Rvam9fY2xpY2sgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRldnQuaW5pdE1vdXNlRXZlbnQodHlwZSxcblx0XHRcdFx0XHRcdFx0XHR0cnVlLCAvL2J1YmJsZXNcblx0XHRcdFx0XHRcdFx0XHR0cnVlLCAvL2NhbmNlbGFibGVcblx0XHRcdFx0XHRcdFx0XHRlLnZpZXcsXG5cdFx0XHRcdFx0XHRcdFx0ZS5kZXRhaWwsXG5cdFx0XHRcdFx0XHRcdFx0c3JjLnNjcmVlblgsXG5cdFx0XHRcdFx0XHRcdFx0c3JjLnNjcmVlblksXG5cdFx0XHRcdFx0XHRcdFx0c3JjLmNsaWVudFgsXG5cdFx0XHRcdFx0XHRcdFx0c3JjLmNsaWVudFksXG5cdFx0XHRcdFx0XHRcdFx0ZS5jdHJsS2V5LFxuXHRcdFx0XHRcdFx0XHRcdGUuYWx0S2V5LFxuXHRcdFx0XHRcdFx0XHRcdGUuc2hpZnRLZXksXG5cdFx0XHRcdFx0XHRcdFx0ZS5tZXRhS2V5LFxuXHRcdFx0XHRcdFx0XHRcdDAsIC8vYnV0dG9uXG5cdFx0XHRcdFx0XHRcdFx0bnVsbCAvL3JlbGF0ZWQgdGFyZ2V0XG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBldnQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgbW91c2VEb3duRXZ0ID0gY3JlYXRlTW91c2VFdmVudChcIm1vdXNlZG93blwiKTtcblx0XHRcdFx0XHRcdHZhciBtb3VzZVVwRXZ0ID0gY3JlYXRlTW91c2VFdmVudChcIm1vdXNldXBcIik7XG5cdFx0XHRcdFx0XHR2YXIgY2xpY2tFdnQgPSBjcmVhdGVNb3VzZUV2ZW50KFwiY2xpY2tcIik7XG5cblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0b24uZW1pdCh0YXJnZXQsIFwibW91c2Vkb3duXCIsIG1vdXNlRG93bkV2dCk7XG5cdFx0XHRcdFx0XHRcdG9uLmVtaXQodGFyZ2V0LCBcIm1vdXNldXBcIiwgbW91c2VVcEV2dCk7XG5cdFx0XHRcdFx0XHRcdG9uLmVtaXQodGFyZ2V0LCBcImNsaWNrXCIsIGNsaWNrRXZ0KTtcblxuXHRcdFx0XHRcdFx0XHQvLyByZWZyZXNoIGNsaWNrVGltZSBpbiBjYXNlIGFwcC1kZWZpbmVkIGNsaWNrIGhhbmRsZXIgdG9vayBhIGxvbmcgdGltZSB0byBydW5cblx0XHRcdFx0XHRcdFx0Y2xpY2tUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XHRcdFx0XHRcdH0sIDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdHJ1ZSk7XG5cblx0XHRcdFx0ZnVuY3Rpb24gc3RvcE5hdGl2ZUV2ZW50cyh0eXBlKXtcblx0XHRcdFx0XHR3aW4uZG9jLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuY3Rpb24oZSl7XG5cdFx0XHRcdFx0XHQvLyBTdG9wIG5hdGl2ZSBldmVudHMgd2hlbiB3ZSBlbWl0dGVkIG91ciBvd24gY2xpY2sgZXZlbnQuICBOb3RlIHRoYXQgdGhlIG5hdGl2ZSBjbGljayBtYXkgb2NjdXJcblx0XHRcdFx0XHRcdC8vIG9uIGEgZGlmZmVyZW50IG5vZGUgdGhhbiB0aGUgc3ludGhldGljIGNsaWNrIGV2ZW50IHdhcyBnZW5lcmF0ZWQgb24uICBGb3IgZXhhbXBsZSxcblx0XHRcdFx0XHRcdC8vIGNsaWNrIG9uIGEgbWVudSBpdGVtLCBjYXVzaW5nIHRoZSBtZW51IHRvIGRpc2FwcGVhciwgYW5kIHRoZW4gKH4zMDBtcyBsYXRlcikgdGhlIGJyb3dzZXJcblx0XHRcdFx0XHRcdC8vIHNlbmRzIGEgY2xpY2sgZXZlbnQgdG8gdGhlIG5vZGUgdGhhdCB3YXMgKnVuZGVybmVhdGgqIHRoZSBtZW51LiAgU28gc3RvcCBhbGwgbmF0aXZlIGV2ZW50c1xuXHRcdFx0XHRcdFx0Ly8gc2VudCBzaG9ydGx5IGFmdGVyIG91cnMsIHNpbWlsYXIgdG8gd2hhdCBpcyBkb25lIGluIGR1YWxFdmVudC5cblx0XHRcdFx0XHRcdC8vIFRoZSBJTlBVVC5kaWppdE9mZlNjcmVlbiB0ZXN0IGlzIGZvciBvZmZzY3JlZW4gaW5wdXRzIHVzZWQgaW4gZGlqaXQvZm9ybS9CdXR0b24sIG9uIHdoaWNoXG5cdFx0XHRcdFx0XHQvLyB3ZSBjYWxsIGNsaWNrKCkgZXhwbGljaXRseSwgd2UgZG9uJ3Qgd2FudCB0byBzdG9wIHRoaXMgZXZlbnQuXG5cdFx0XHRcdFx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG5cdFx0XHRcdFx0XHRpZihjbGlja1RyYWNrZXIgJiYgIWUuX2Rvam9fY2xpY2sgJiZcblx0XHRcdFx0XHRcdFx0XHQobmV3IERhdGUoKSkuZ2V0VGltZSgpIDw9IGNsaWNrVGltZSArIDEwMDAgJiZcblx0XHRcdFx0XHRcdFx0XHQhKHRhcmdldC50YWdOYW1lID09IFwiSU5QVVRcIiAmJiBkb21DbGFzcy5jb250YWlucyh0YXJnZXQsIFwiZGlqaXRPZmZTY3JlZW5cIikpKXtcblx0XHRcdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0aWYodHlwZSA9PSBcImNsaWNrXCIgJiZcblx0XHRcdFx0XHRcdFx0XHQodGFyZ2V0LnRhZ05hbWUgIT0gXCJJTlBVVFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0KHRhcmdldC50eXBlID09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gIzE4MzUyIERvIG5vdCBwcmV2ZW50RGVmYXVsdCBmb3IgcmFkaW9zIHRoYXQgYXJlIG5vdCBkaWppdCBvclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZG9qb3gvbW9iaWxlIHdpZGdldHMuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyAoVGhlIENTUyBjbGFzcyBkaWppdENoZWNrQm94SW5wdXQgaG9sZHMgZm9yIGJvdGggY2hlY2tib3hlcyBhbmQgcmFkaW8gYnV0dG9ucy4pXG5cdFx0XHRcdFx0XHRcdFx0XHQoZG9tQ2xhc3MuY29udGFpbnModGFyZ2V0LCBcImRpaml0Q2hlY2tCb3hJbnB1dFwiKSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkb21DbGFzcy5jb250YWlucyh0YXJnZXQsIFwibWJsUmFkaW9CdXR0b25cIikpKSB8fFxuXHRcdFx0XHRcdFx0XHRcdCh0YXJnZXQudHlwZSA9PSBcImNoZWNrYm94XCIgJiZcblx0XHRcdFx0XHRcdFx0XHRcdC8vICMxODM1MiBEbyBub3QgcHJldmVudERlZmF1bHQgZm9yIGNoZWNrYm94ZXMgdGhhdCBhcmUgbm90IGRpaml0IG9yXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBkb2pveC9tb2JpbGUgd2lkZ2V0cy5cblx0XHRcdFx0XHRcdFx0XHRcdChkb21DbGFzcy5jb250YWlucyh0YXJnZXQsIFwiZGlqaXRDaGVja0JveElucHV0XCIpIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRvbUNsYXNzLmNvbnRhaW5zKHRhcmdldCwgXCJtYmxDaGVja0JveFwiKSkpKSAmJlxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldC50YWdOYW1lICE9IFwiVEVYVEFSRUFcIiAmJiB0YXJnZXQudGFnTmFtZSAhPSBcIkFVRElPXCIgJiYgdGFyZ2V0LnRhZ05hbWUgIT0gXCJWSURFT1wiKXtcblx0XHRcdFx0XHRcdFx0XHQvLyBwcmV2ZW50RGVmYXVsdCgpIGJyZWFrcyB0ZXh0dWFsIDxpbnB1dD5zIG9uIGFuZHJvaWQsIGtleWJvYXJkIGRvZXNuJ3QgcG9wdXAsXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYnV0IGl0IGlzIHN0aWxsIG5lZWRlZCBmb3IgY2hlY2tib3hlcyBhbmQgcmFkaW8gYnV0dG9ucywgb3RoZXJ3aXNlIGluIHNvbWUgY2FzZXNcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGUgY2hlY2tlZCBzdGF0ZSBiZWNvbWVzIGluY29uc2lzdGVudCB3aXRoIHRoZSB3aWRnZXQncyBzdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRydWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RvcE5hdGl2ZUV2ZW50cyhcImNsaWNrXCIpO1xuXG5cdFx0XHRcdC8vIFdlIGFsc28gc3RvcCBtb3VzZWRvd24vdXAgc2luY2UgdGhlc2Ugd291bGQgYmUgc2VudCB3ZWxsIGFmdGVyIHdpdGggb3VyIFwiZmFzdFwiIGNsaWNrICgzMDBtcyksXG5cdFx0XHRcdC8vIHdoaWNoIGNhbiBjb25mdXNlIHNvbWUgZGlqaXQgd2lkZ2V0cy5cblx0XHRcdFx0c3RvcE5hdGl2ZUV2ZW50cyhcIm1vdXNlZG93blwiKTtcblx0XHRcdFx0c3RvcE5hdGl2ZUV2ZW50cyhcIm1vdXNldXBcIik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGhvdmVyZWROb2RlO1xuXG5cdGlmKGhhcyhcInRvdWNoXCIpKXtcblx0XHRpZihoYXNQb2ludGVyKXtcblx0XHRcdC8vIE1TUG9pbnRlciAoSUUxMCspIGFscmVhZHkgaGFzIHN1cHBvcnQgZm9yIG92ZXIgYW5kIG91dCwgc28gd2UganVzdCBuZWVkIHRvIGluaXQgY2xpY2sgc3VwcG9ydFxuXHRcdFx0ZG9tUmVhZHkoZnVuY3Rpb24oKXtcblx0XHRcdFx0d2luLmRvYy5hZGRFdmVudExpc3RlbmVyKHBvaW50ZXIuZG93biwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0XHRkb0NsaWNrcyhldnQsIHBvaW50ZXIubW92ZSwgcG9pbnRlci51cCk7XG5cdFx0XHRcdH0sIHRydWUpO1xuXHRcdFx0fSk7XG5cdFx0fWVsc2V7XG5cdFx0XHRkb21SZWFkeShmdW5jdGlvbigpe1xuXHRcdFx0XHQvLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnRseSBob3ZlcmVkIG5vZGVcblx0XHRcdFx0aG92ZXJlZE5vZGUgPSB3aW4uYm9keSgpO1x0Ly8gY3VycmVudGx5IGhvdmVyZWQgbm9kZVxuXG5cdFx0XHRcdHdpbi5kb2MuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0XHRcdGxhc3RUb3VjaCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cblx0XHRcdFx0XHQvLyBQcmVjZWRlIHRvdWNoc3RhcnQgZXZlbnQgd2l0aCB0b3VjaC5vdmVyIGV2ZW50LiAgRG5EIGRlcGVuZHMgb24gdGhpcy5cblx0XHRcdFx0XHQvLyBVc2UgYWRkRXZlbnRMaXN0ZW5lcihjYiwgdHJ1ZSkgdG8gcnVuIGNiIGJlZm9yZSBhbnkgdG91Y2hzdGFydCBoYW5kbGVycyBvbiBub2RlIHJ1bixcblx0XHRcdFx0XHQvLyBhbmQgdG8gZW5zdXJlIHRoaXMgY29kZSBydW5zIGV2ZW4gaWYgdGhlIGxpc3RlbmVyIG9uIHRoZSBub2RlIGRvZXMgZXZlbnQuc3RvcCgpLlxuXHRcdFx0XHRcdHZhciBvbGROb2RlID0gaG92ZXJlZE5vZGU7XG5cdFx0XHRcdFx0aG92ZXJlZE5vZGUgPSBldnQudGFyZ2V0O1xuXHRcdFx0XHRcdG9uLmVtaXQob2xkTm9kZSwgXCJkb2pvdG91Y2hvdXRcIiwge1xuXHRcdFx0XHRcdFx0cmVsYXRlZFRhcmdldDogaG92ZXJlZE5vZGUsXG5cdFx0XHRcdFx0XHRidWJibGVzOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0b24uZW1pdChob3ZlcmVkTm9kZSwgXCJkb2pvdG91Y2hvdmVyXCIsIHtcblx0XHRcdFx0XHRcdHJlbGF0ZWRUYXJnZXQ6IG9sZE5vZGUsXG5cdFx0XHRcdFx0XHRidWJibGVzOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRkb0NsaWNrcyhldnQsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIik7IC8vIGluaXQgY2xpY2sgZ2VuZXJhdGlvblxuXHRcdFx0XHR9LCB0cnVlKTtcblxuXHRcdFx0XHRmdW5jdGlvbiBjb3B5RXZlbnRQcm9wcyhldnQpe1xuXHRcdFx0XHRcdC8vIE1ha2UgY29weSBvZiBldmVudCBvYmplY3QgYW5kIGFsc28gc2V0IGJ1YmJsZXM6dHJ1ZS4gIFVzZWQgd2hlbiBjYWxsaW5nIG9uLmVtaXQoKS5cblx0XHRcdFx0XHR2YXIgcHJvcHMgPSBsYW5nLmRlbGVnYXRlKGV2dCwge1xuXHRcdFx0XHRcdFx0YnViYmxlczogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0aWYoaGFzKFwiaW9zXCIpID49IDYpe1xuXHRcdFx0XHRcdFx0Ly8gT24gaU9TNiBcInRvdWNoZXNcIiBiZWNhbWUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSwgd2hpY2hcblx0XHRcdFx0XHRcdC8vIGlzIG5vdCBoaXQgYnkgZm9yLi4uaW4uICBEaXR0byBmb3IgdGhlIG90aGVyIHByb3BlcnRpZXMgYmVsb3cuXG5cdFx0XHRcdFx0XHRwcm9wcy50b3VjaGVzID0gZXZ0LnRvdWNoZXM7XG5cdFx0XHRcdFx0XHRwcm9wcy5hbHRLZXkgPSBldnQuYWx0S2V5O1xuXHRcdFx0XHRcdFx0cHJvcHMuY2hhbmdlZFRvdWNoZXMgPSBldnQuY2hhbmdlZFRvdWNoZXM7XG5cdFx0XHRcdFx0XHRwcm9wcy5jdHJsS2V5ID0gZXZ0LmN0cmxLZXk7XG5cdFx0XHRcdFx0XHRwcm9wcy5tZXRhS2V5ID0gZXZ0Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRwcm9wcy5zaGlmdEtleSA9IGV2dC5zaGlmdEtleTtcblx0XHRcdFx0XHRcdHByb3BzLnRhcmdldFRvdWNoZXMgPSBldnQudGFyZ2V0VG91Y2hlcztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gcHJvcHM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvbih3aW4uZG9jLCBcInRvdWNobW92ZVwiLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRcdGxhc3RUb3VjaCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cblx0XHRcdFx0XHR2YXIgbmV3Tm9kZSA9IHdpbi5kb2MuZWxlbWVudEZyb21Qb2ludChcblx0XHRcdFx0XHRcdGV2dC5wYWdlWCAtIChpb3M0ID8gMCA6IHdpbi5nbG9iYWwucGFnZVhPZmZzZXQpLCAvLyBpT1MgNCBleHBlY3RzIHBhZ2UgY29vcmRzXG5cdFx0XHRcdFx0XHRldnQucGFnZVkgLSAoaW9zNCA/IDAgOiB3aW4uZ2xvYmFsLnBhZ2VZT2Zmc2V0KVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZihuZXdOb2RlKXtcblx0XHRcdFx0XHRcdC8vIEZpcmUgc3ludGhldGljIHRvdWNob3ZlciBhbmQgdG91Y2hvdXQgZXZlbnRzIG9uIG5vZGVzIHNpbmNlIHRoZSBicm93c2VyIHdvbid0IGRvIGl0IG5hdGl2ZWx5LlxuXHRcdFx0XHRcdFx0aWYoaG92ZXJlZE5vZGUgIT09IG5ld05vZGUpe1xuXHRcdFx0XHRcdFx0XHQvLyB0b3VjaCBvdXQgb24gdGhlIG9sZCBub2RlXG5cdFx0XHRcdFx0XHRcdG9uLmVtaXQoaG92ZXJlZE5vZGUsIFwiZG9qb3RvdWNob3V0XCIsIHtcblx0XHRcdFx0XHRcdFx0XHRyZWxhdGVkVGFyZ2V0OiBuZXdOb2RlLFxuXHRcdFx0XHRcdFx0XHRcdGJ1YmJsZXM6IHRydWVcblx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gdG91Y2hvdmVyIG9uIHRoZSBuZXcgbm9kZVxuXHRcdFx0XHRcdFx0XHRvbi5lbWl0KG5ld05vZGUsIFwiZG9qb3RvdWNob3ZlclwiLCB7XG5cdFx0XHRcdFx0XHRcdFx0cmVsYXRlZFRhcmdldDogaG92ZXJlZE5vZGUsXG5cdFx0XHRcdFx0XHRcdFx0YnViYmxlczogdHJ1ZVxuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRob3ZlcmVkTm9kZSA9IG5ld05vZGU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFVubGlrZSBhIGxpc3RlbmVyIG9uIFwidG91Y2htb3ZlXCIsIG9uKG5vZGUsIFwiZG9qb3RvdWNobW92ZVwiLCBsaXN0ZW5lcikgZmlyZXMgd2hlbiB0aGUgZmluZ2VyXG5cdFx0XHRcdFx0XHQvLyBkcmFncyBvdmVyIHRoZSBzcGVjaWZpZWQgbm9kZSwgcmVnYXJkbGVzcyBvZiB3aGljaCBub2RlIHRoZSB0b3VjaCBzdGFydGVkIG9uLlxuXHRcdFx0XHRcdFx0aWYoIW9uLmVtaXQobmV3Tm9kZSwgXCJkb2pvdG91Y2htb3ZlXCIsIGNvcHlFdmVudFByb3BzKGV2dCkpKXtcblx0XHRcdFx0XHRcdFx0Ly8gZW1pdCByZXR1cm5zIGZhbHNlIHdoZW4gc3ludGhldGljIGV2ZW50IFwiZG9qb3RvdWNobW92ZVwiIGlzIGNhbmNlbGxlZCwgc28gd2UgcHJldmVudCB0aGVcblx0XHRcdFx0XHRcdFx0Ly8gZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgdW5kZXJseWluZyBuYXRpdmUgZXZlbnQgXCJ0b3VjaG1vdmVcIi5cblx0XHRcdFx0XHRcdFx0ZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBGaXJlIGEgZG9qb3RvdWNoZW5kIGV2ZW50IG9uIHRoZSBub2RlIHdoZXJlIHRoZSBmaW5nZXIgd2FzIGJlZm9yZSBpdCB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBzY3JlZW4uXG5cdFx0XHRcdC8vIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gdGhlIG5hdGl2ZSB0b3VjaGVuZCwgd2hpY2ggZmlyZXMgb24gdGhlIG5vZGUgd2hlcmUgdGhlIGRyYWcgc3RhcnRlZC5cblx0XHRcdFx0b24od2luLmRvYywgXCJ0b3VjaGVuZFwiLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRcdFx0bGFzdFRvdWNoID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XHRcdFx0XHR2YXIgbm9kZSA9IHdpbi5kb2MuZWxlbWVudEZyb21Qb2ludChcblx0XHRcdFx0XHRcdGV2dC5wYWdlWCAtIChpb3M0ID8gMCA6IHdpbi5nbG9iYWwucGFnZVhPZmZzZXQpLCAvLyBpT1MgNCBleHBlY3RzIHBhZ2UgY29vcmRzXG5cdFx0XHRcdFx0XHRldnQucGFnZVkgLSAoaW9zNCA/IDAgOiB3aW4uZ2xvYmFsLnBhZ2VZT2Zmc2V0KVxuXHRcdFx0XHRcdCkgfHwgd2luLmJvZHkoKTsgLy8gaWYgb3V0IG9mIHRoZSBzY3JlZW5cblxuXHRcdFx0XHRcdG9uLmVtaXQobm9kZSwgXCJkb2pvdG91Y2hlbmRcIiwgY29weUV2ZW50UHJvcHMoZXZ0KSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0Ly9kZXZpY2UgbmV1dHJhbCBldmVudHMgLSB0b3VjaC5wcmVzc3xtb3ZlfHJlbGVhc2V8Y2FuY2VsL292ZXIvb3V0XG5cdHZhciB0b3VjaCA9IHtcblx0XHRwcmVzczogZHVhbEV2ZW50KFwibW91c2Vkb3duXCIsIFwidG91Y2hzdGFydFwiLCBwb2ludGVyLmRvd24pLFxuXHRcdG1vdmU6IGR1YWxFdmVudChcIm1vdXNlbW92ZVwiLCBcImRvam90b3VjaG1vdmVcIiwgcG9pbnRlci5tb3ZlKSxcblx0XHRyZWxlYXNlOiBkdWFsRXZlbnQoXCJtb3VzZXVwXCIsIFwiZG9qb3RvdWNoZW5kXCIsIHBvaW50ZXIudXApLFxuXHRcdGNhbmNlbDogZHVhbEV2ZW50KG1vdXNlLmxlYXZlLCBcInRvdWNoY2FuY2VsXCIsIGhhc1BvaW50ZXIgPyBwb2ludGVyLmNhbmNlbCA6IG51bGwpLFxuXHRcdG92ZXI6IGR1YWxFdmVudChcIm1vdXNlb3ZlclwiLCBcImRvam90b3VjaG92ZXJcIiwgcG9pbnRlci5vdmVyKSxcblx0XHRvdXQ6IGR1YWxFdmVudChcIm1vdXNlb3V0XCIsIFwiZG9qb3RvdWNob3V0XCIsIHBvaW50ZXIub3V0KSxcblx0XHRlbnRlcjogbW91c2UuX2V2ZW50SGFuZGxlcihkdWFsRXZlbnQoXCJtb3VzZW92ZXJcIixcImRvam90b3VjaG92ZXJcIiwgcG9pbnRlci5vdmVyKSksXG5cdFx0bGVhdmU6IG1vdXNlLl9ldmVudEhhbmRsZXIoZHVhbEV2ZW50KFwibW91c2VvdXRcIiwgXCJkb2pvdG91Y2hvdXRcIiwgcG9pbnRlci5vdXQpKVxuXHR9O1xuXG5cdC8qPT09PT1cblx0dG91Y2ggPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGlzIG1vZHVsZSBwcm92aWRlcyB1bmlmaWVkIHRvdWNoIGV2ZW50IGhhbmRsZXJzIGJ5IGV4cG9ydGluZ1xuXHRcdC8vXHRcdHByZXNzLCBtb3ZlLCByZWxlYXNlIGFuZCBjYW5jZWwgd2hpY2ggY2FuIGFsc28gcnVuIHdlbGwgb24gZGVza3RvcC5cblx0XHQvL1x0XHRCYXNlZCBvbiBodHRwOi8vZHZjcy53My5vcmcvaGcvd2ViZXZlbnRzL3Jhdy1maWxlL3RpcC90b3VjaGV2ZW50cy5odG1sXG5cdFx0Ly8gICAgICBBbHNvLCBpZiB0aGUgZG9qb0NsaWNrIHByb3BlcnR5IGlzIHNldCB0byB0cnV0aHkgb24gYSBET00gbm9kZSwgZG9qby90b3VjaCBnZW5lcmF0ZXNcblx0XHQvLyAgICAgIGNsaWNrIGV2ZW50cyBpbW1lZGlhdGVseSBmb3IgdGhpcyBub2RlIGFuZCBpdHMgZGVzY2VuZGFudHMgKGV4Y2VwdCBmb3IgZGVzY2VuZGFudHMgdGhhdFxuXHRcdC8vICAgICAgaGF2ZSBhIGRvam9DbGljayBwcm9wZXJ0eSBzZXQgdG8gZmFsc3kpLCB0byBhdm9pZCB0aGUgZGVsYXkgYmVmb3JlIG5hdGl2ZSBicm93c2VyIGNsaWNrIGV2ZW50cyxcblx0XHQvLyAgICAgIGFuZCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgZXZ0LnByZXZlbnREZWZhdWx0KCkgd2FzIGNhbGxlZCBpbiBhIHRvdWNoLnByZXNzIGV2ZW50IGxpc3RlbmVyLlxuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRVc2VkIHdpdGggZG9qby9vblxuXHRcdC8vXHRcdHxcdGRlZmluZShbXCJkb2pvL29uXCIsIFwiZG9qby90b3VjaFwiXSwgZnVuY3Rpb24ob24sIHRvdWNoKXtcblx0XHQvL1x0XHR8XHRcdG9uKG5vZGUsIHRvdWNoLnByZXNzLCBmdW5jdGlvbihlKXt9KTtcblx0XHQvL1x0XHR8XHRcdG9uKG5vZGUsIHRvdWNoLm1vdmUsIGZ1bmN0aW9uKGUpe30pO1xuXHRcdC8vXHRcdHxcdFx0b24obm9kZSwgdG91Y2gucmVsZWFzZSwgZnVuY3Rpb24oZSl7fSk7XG5cdFx0Ly9cdFx0fFx0XHRvbihub2RlLCB0b3VjaC5jYW5jZWwsIGZ1bmN0aW9uKGUpe30pO1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0VXNlZCB3aXRoIHRvdWNoLiogZGlyZWN0bHlcblx0XHQvL1x0XHR8XHR0b3VjaC5wcmVzcyhub2RlLCBmdW5jdGlvbihlKXt9KTtcblx0XHQvL1x0XHR8XHR0b3VjaC5tb3ZlKG5vZGUsIGZ1bmN0aW9uKGUpe30pO1xuXHRcdC8vXHRcdHxcdHRvdWNoLnJlbGVhc2Uobm9kZSwgZnVuY3Rpb24oZSl7fSk7XG5cdFx0Ly9cdFx0fFx0dG91Y2guY2FuY2VsKG5vZGUsIGZ1bmN0aW9uKGUpe30pO1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0SGF2ZSBkb2pvL3RvdWNoIGdlbmVyYXRlIGNsaWNrcyB3aXRob3V0IGRlbGF5LCB3aXRoIGEgZGVmYXVsdCBtb3ZlIHRocmVzaG9sZCBvZiA0IHBpeGVsc1xuXHRcdC8vXHRcdHxcdG5vZGUuZG9qb0NsaWNrID0gdHJ1ZTtcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdEhhdmUgZG9qby90b3VjaCBnZW5lcmF0ZSBjbGlja3Mgd2l0aG91dCBkZWxheSwgd2l0aCBhIG1vdmUgdGhyZXNob2xkIG9mIDEwIHBpeGVscyBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHlcblx0XHQvL1x0XHR8XHRub2RlLmRvam9DbGljayA9IDEwO1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0SGF2ZSBkb2pvL3RvdWNoIGdlbmVyYXRlIGNsaWNrcyB3aXRob3V0IGRlbGF5LCB3aXRoIGEgbW92ZSB0aHJlc2hvbGQgb2YgNTAgcGl4ZWxzIGhvcml6b250YWxseSBhbmQgMTAgcGl4ZWxzIHZlcnRpY2FsbHlcblx0XHQvL1x0XHR8XHRub2RlLmRvam9DbGljayA9IHt4OjUwLCB5OjV9O1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0RGlzYWJsZSBjbGlja3Mgd2l0aG91dCBkZWxheSBnZW5lcmF0ZWQgYnkgZG9qby90b3VjaCBvbiBhIG5vZGUgdGhhdCBoYXMgYW4gYW5jZXN0b3Igd2l0aCBwcm9wZXJ0eSBkb2pvQ2xpY2sgc2V0IHRvIHRydXRoeVxuXHRcdC8vXHRcdHwgIG5vZGUuZG9qb0NsaWNrID0gZmFsc2U7XG5cblx0XHRwcmVzczogZnVuY3Rpb24obm9kZSwgbGlzdGVuZXIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlZ2lzdGVyIGEgbGlzdGVuZXIgdG8gJ3RvdWNoc3RhcnQnfCdtb3VzZWRvd24nIGZvciB0aGUgZ2l2ZW4gbm9kZVxuXHRcdFx0Ly8gbm9kZTogRG9tXG5cdFx0XHQvL1x0XHRUYXJnZXQgbm9kZSB0byBsaXN0ZW4gdG9cblx0XHRcdC8vIGxpc3RlbmVyOiBGdW5jdGlvblxuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgZnVuY3Rpb25cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRBIGhhbmRsZSB3aGljaCB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBieSBoYW5kbGUucmVtb3ZlKClcblx0XHR9LFxuXHRcdG1vdmU6IGZ1bmN0aW9uKG5vZGUsIGxpc3RlbmVyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZWdpc3RlciBhIGxpc3RlbmVyIHRoYXQgZmlyZXMgd2hlbiB0aGUgbW91c2UgY3Vyc29yIG9yIGEgZmluZ2VyIGlzIGRyYWdnZWQgb3ZlciB0aGUgZ2l2ZW4gbm9kZS5cblx0XHRcdC8vIG5vZGU6IERvbVxuXHRcdFx0Ly9cdFx0VGFyZ2V0IG5vZGUgdG8gbGlzdGVuIHRvXG5cdFx0XHQvLyBsaXN0ZW5lcjogRnVuY3Rpb25cblx0XHRcdC8vXHRcdENhbGxiYWNrIGZ1bmN0aW9uXG5cdFx0XHQvLyByZXR1cm5zOlxuXHRcdFx0Ly9cdFx0QSBoYW5kbGUgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgYnkgaGFuZGxlLnJlbW92ZSgpXG5cdFx0fSxcblx0XHRyZWxlYXNlOiBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVnaXN0ZXIgYSBsaXN0ZW5lciB0byByZWxlYXNpbmcgdGhlIG1vdXNlIGJ1dHRvbiB3aGlsZSB0aGUgY3Vyc29yIGlzIG92ZXIgdGhlIGdpdmVuIG5vZGVcblx0XHRcdC8vXHRcdChpLmUuIFwibW91c2V1cFwiKSBvciBmb3IgcmVtb3ZpbmcgdGhlIGZpbmdlciBmcm9tIHRoZSBzY3JlZW4gd2hpbGUgdG91Y2hpbmcgdGhlIGdpdmVuIG5vZGUuXG5cdFx0XHQvLyBub2RlOiBEb21cblx0XHRcdC8vXHRcdFRhcmdldCBub2RlIHRvIGxpc3RlbiB0b1xuXHRcdFx0Ly8gbGlzdGVuZXI6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRDYWxsYmFjayBmdW5jdGlvblxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdEEgaGFuZGxlIHdoaWNoIHdpbGwgYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGJ5IGhhbmRsZS5yZW1vdmUoKVxuXHRcdH0sXG5cdFx0Y2FuY2VsOiBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVnaXN0ZXIgYSBsaXN0ZW5lciB0byAndG91Y2hjYW5jZWwnfCdtb3VzZWxlYXZlJyBmb3IgdGhlIGdpdmVuIG5vZGVcblx0XHRcdC8vIG5vZGU6IERvbVxuXHRcdFx0Ly9cdFx0VGFyZ2V0IG5vZGUgdG8gbGlzdGVuIHRvXG5cdFx0XHQvLyBsaXN0ZW5lcjogRnVuY3Rpb25cblx0XHRcdC8vXHRcdENhbGxiYWNrIGZ1bmN0aW9uXG5cdFx0XHQvLyByZXR1cm5zOlxuXHRcdFx0Ly9cdFx0QSBoYW5kbGUgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgYnkgaGFuZGxlLnJlbW92ZSgpXG5cdFx0fSxcblx0XHRvdmVyOiBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVnaXN0ZXIgYSBsaXN0ZW5lciB0byAnbW91c2VvdmVyJyBvciB0b3VjaCBlcXVpdmFsZW50IGZvciB0aGUgZ2l2ZW4gbm9kZVxuXHRcdFx0Ly8gbm9kZTogRG9tXG5cdFx0XHQvL1x0XHRUYXJnZXQgbm9kZSB0byBsaXN0ZW4gdG9cblx0XHRcdC8vIGxpc3RlbmVyOiBGdW5jdGlvblxuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgZnVuY3Rpb25cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRBIGhhbmRsZSB3aGljaCB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBieSBoYW5kbGUucmVtb3ZlKClcblx0XHR9LFxuXHRcdG91dDogZnVuY3Rpb24obm9kZSwgbGlzdGVuZXIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlZ2lzdGVyIGEgbGlzdGVuZXIgdG8gJ21vdXNlb3V0JyBvciB0b3VjaCBlcXVpdmFsZW50IGZvciB0aGUgZ2l2ZW4gbm9kZVxuXHRcdFx0Ly8gbm9kZTogRG9tXG5cdFx0XHQvL1x0XHRUYXJnZXQgbm9kZSB0byBsaXN0ZW4gdG9cblx0XHRcdC8vIGxpc3RlbmVyOiBGdW5jdGlvblxuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgZnVuY3Rpb25cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRBIGhhbmRsZSB3aGljaCB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBieSBoYW5kbGUucmVtb3ZlKClcblx0XHR9LFxuXHRcdGVudGVyOiBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVnaXN0ZXIgYSBsaXN0ZW5lciB0byBtb3VzZS5lbnRlciBvciB0b3VjaCBlcXVpdmFsZW50IGZvciB0aGUgZ2l2ZW4gbm9kZVxuXHRcdFx0Ly8gbm9kZTogRG9tXG5cdFx0XHQvL1x0XHRUYXJnZXQgbm9kZSB0byBsaXN0ZW4gdG9cblx0XHRcdC8vIGxpc3RlbmVyOiBGdW5jdGlvblxuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgZnVuY3Rpb25cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRBIGhhbmRsZSB3aGljaCB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBieSBoYW5kbGUucmVtb3ZlKClcblx0XHR9LFxuXHRcdGxlYXZlOiBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVnaXN0ZXIgYSBsaXN0ZW5lciB0byBtb3VzZS5sZWF2ZSBvciB0b3VjaCBlcXVpdmFsZW50IGZvciB0aGUgZ2l2ZW4gbm9kZVxuXHRcdFx0Ly8gbm9kZTogRG9tXG5cdFx0XHQvL1x0XHRUYXJnZXQgbm9kZSB0byBsaXN0ZW4gdG9cblx0XHRcdC8vIGxpc3RlbmVyOiBGdW5jdGlvblxuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgZnVuY3Rpb25cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRBIGhhbmRsZSB3aGljaCB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBieSBoYW5kbGUucmVtb3ZlKClcblx0XHR9XG5cdH07XG5cdD09PT09Ki9cblxuXHRoYXMoXCJleHRlbmQtZG9qb1wiKSAmJiAoZG9qby50b3VjaCA9IHRvdWNoKTtcblxuXHRyZXR1cm4gdG91Y2g7XG59KTtcbiIsImRlZmluZShbXCIuL2RvbS1nZW9tZXRyeVwiLCBcIi4vX2Jhc2UvbGFuZ1wiLCBcIi4vZG9tUmVhZHlcIiwgXCIuL3NuaWZmXCIsIFwiLi9fYmFzZS93aW5kb3dcIl0sXG5cdGZ1bmN0aW9uKGdlb21ldHJ5LCBsYW5nLCBkb21SZWFkeSwgaGFzLCBiYXNlV2luZG93KXtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vdWFjc3NcblxuXHQvKj09PT09XG5cdHJldHVybiB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRBcHBsaWVzIHByZS1zZXQgQ1NTIGNsYXNzZXMgdG8gdGhlIHRvcC1sZXZlbCBIVE1MIG5vZGUsIGJhc2VkIG9uOlxuXHRcdC8vXG5cdFx0Ly9cdFx0LSBicm93c2VyIChleDogZGpfaWUpXG5cdFx0Ly9cdFx0LSBicm93c2VyIHZlcnNpb24gKGV4OiBkal9pZTYpXG5cdFx0Ly9cdFx0LSBib3ggbW9kZWwgKGV4OiBkal9jb250ZW50Qm94KVxuXHRcdC8vXHRcdC0gdGV4dCBkaXJlY3Rpb24gKGV4OiBkaWppdFJ0bClcblx0XHQvL1xuXHRcdC8vXHRcdEluIGFkZGl0aW9uLCBicm93c2VyLCBicm93c2VyIHZlcnNpb24sIGFuZCBib3ggbW9kZWwgYXJlXG5cdFx0Ly9cdFx0Y29tYmluZWQgd2l0aCBhbiBSVEwgZmxhZyB3aGVuIGJyb3dzZXIgdGV4dCBpcyBSVEwuIGV4OiBkal9pZS1ydGwuXG5cdFx0Ly9cblx0XHQvL1x0XHRSZXR1cm5zIHRoZSBoYXMoKSBtZXRob2QuXG5cdH07XG5cdD09PT09Ki9cblxuXHR2YXJcblx0XHRodG1sID0gYmFzZVdpbmRvdy5kb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdGllID0gaGFzKFwiaWVcIiksXG5cdFx0dHJpZGVudCA9IGhhcyhcInRyaWRlbnRcIiksXG5cdFx0b3BlcmEgPSBoYXMoXCJvcGVyYVwiKSxcblx0XHRtYWogPSBNYXRoLmZsb29yLFxuXHRcdGZmID0gaGFzKFwiZmZcIiksXG5cdFx0Ym94TW9kZWwgPSBnZW9tZXRyeS5ib3hNb2RlbC5yZXBsYWNlKC8tLywnJyksXG5cblx0XHRjbGFzc2VzID0ge1xuXHRcdFx0XCJkal9xdWlya3NcIjogaGFzKFwicXVpcmtzXCIpLFxuXG5cdFx0XHQvLyBOT1RFOiBPcGVyYSBub3Qgc3VwcG9ydGVkIGJ5IGRpaml0XG5cdFx0XHRcImRqX29wZXJhXCI6IG9wZXJhLFxuXG5cdFx0XHRcImRqX2todG1sXCI6IGhhcyhcImtodG1sXCIpLFxuXG5cdFx0XHRcImRqX3dlYmtpdFwiOiBoYXMoXCJ3ZWJraXRcIiksXG5cdFx0XHRcImRqX3NhZmFyaVwiOiBoYXMoXCJzYWZhcmlcIiksXG5cdFx0XHRcImRqX2Nocm9tZVwiOiBoYXMoXCJjaHJvbWVcIiksXG5cdFx0XHRcImRqX2VkZ2VcIjogaGFzKFwiZWRnZVwiKSxcblxuXHRcdFx0XCJkal9nZWNrb1wiOiBoYXMoXCJtb3ppbGxhXCIpLFxuXG5cdFx0XHRcImRqX2lvc1wiOiBoYXMoXCJpb3NcIiksXG5cdFx0XHRcImRqX2FuZHJvaWRcIjogaGFzKFwiYW5kcm9pZFwiKVxuXHRcdH07IC8vIG5vIGRvam8gdW5zdXBwb3J0ZWQgYnJvd3NlcnNcblxuXHRpZihpZSl7XG5cdFx0Y2xhc3Nlc1tcImRqX2llXCJdID0gdHJ1ZTtcblx0XHRjbGFzc2VzW1wiZGpfaWVcIiArIG1haihpZSldID0gdHJ1ZTtcblx0XHRjbGFzc2VzW1wiZGpfaWVxdWlya3NcIl0gPSBoYXMoXCJxdWlya3NcIik7XG5cdH1cblx0aWYodHJpZGVudCl7XG5cdFx0Y2xhc3Nlc1tcImRqX3RyaWRlbnRcIl0gPSB0cnVlO1xuXHRcdGNsYXNzZXNbXCJkal90cmlkZW50XCIgKyBtYWoodHJpZGVudCldID0gdHJ1ZTtcblx0fVxuXHRpZihmZil7XG5cdFx0Y2xhc3Nlc1tcImRqX2ZmXCIgKyBtYWooZmYpXSA9IHRydWU7XG5cdH1cblxuXHRjbGFzc2VzW1wiZGpfXCIgKyBib3hNb2RlbF0gPSB0cnVlO1xuXG5cdC8vIGFwcGx5IGJyb3dzZXIsIGJyb3dzZXIgdmVyc2lvbiwgYW5kIGJveCBtb2RlbCBjbGFzcyBuYW1lc1xuXHR2YXIgY2xhc3NTdHIgPSBcIlwiO1xuXHRmb3IodmFyIGNseiBpbiBjbGFzc2VzKXtcblx0XHRpZihjbGFzc2VzW2Nsel0pe1xuXHRcdFx0Y2xhc3NTdHIgKz0gY2x6ICsgXCIgXCI7XG5cdFx0fVxuXHR9XG5cdGh0bWwuY2xhc3NOYW1lID0gbGFuZy50cmltKGh0bWwuY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc1N0cik7XG5cblx0Ly8gSWYgUlRMIG1vZGUsIHRoZW4gYWRkIGRqX3J0bCBmbGFnIHBsdXMgcmVwZWF0IGV4aXN0aW5nIGNsYXNzZXMgd2l0aCAtcnRsIGV4dGVuc2lvbi5cblx0Ly8gV2UgY2FuJ3QgcnVuIHRoZSBjb2RlIGJlbG93IHVudGlsIHRoZSA8Ym9keT4gdGFnIGhhcyBsb2FkZWQgKHNvIHdlIGNhbiBjaGVjayBmb3IgZGlyPXJ0bCkuXG5cdGRvbVJlYWR5KGZ1bmN0aW9uKCl7XG5cdFx0aWYoIWdlb21ldHJ5LmlzQm9keUx0cigpKXtcblx0XHRcdHZhciBydGxDbGFzc1N0ciA9IFwiZGpfcnRsIGRpaml0UnRsIFwiICsgY2xhc3NTdHIucmVwbGFjZSgvIC9nLCBcIi1ydGwgXCIpO1xuXHRcdFx0aHRtbC5jbGFzc05hbWUgPSBsYW5nLnRyaW0oaHRtbC5jbGFzc05hbWUgKyBcIiBcIiArIHJ0bENsYXNzU3RyICsgXCJkal9ydGwgZGlqaXRSdGwgXCIgKyBjbGFzc1N0ci5yZXBsYWNlKC8gL2csIFwiLXJ0bCBcIikpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBoYXM7XG59KTtcbiIsImRlZmluZShbXG5cdFwiLi9EZWZlcnJlZFwiLFxuXHRcIi4vcHJvbWlzZS9Qcm9taXNlXCJcbl0sIGZ1bmN0aW9uKERlZmVycmVkLCBQcm9taXNlKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL3doZW5cblxuXHRyZXR1cm4gZnVuY3Rpb24gd2hlbih2YWx1ZU9yUHJvbWlzZSwgY2FsbGJhY2ssIGVycmJhY2ssIHByb2diYWNrKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRyYW5zcGFyZW50bHkgYXBwbGllcyBjYWxsYmFja3MgdG8gdmFsdWVzIGFuZC9vciBwcm9taXNlcy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRBY2NlcHRzIHByb21pc2VzIGJ1dCBhbHNvIHRyYW5zcGFyZW50bHkgaGFuZGxlcyBub24tcHJvbWlzZXMuIElmIG5vXG5cdFx0Ly9cdFx0Y2FsbGJhY2tzIGFyZSBwcm92aWRlZCByZXR1cm5zIGEgcHJvbWlzZSwgcmVnYXJkbGVzcyBvZiB0aGUgaW5pdGlhbFxuXHRcdC8vXHRcdHZhbHVlLiBGb3JlaWduIHByb21pc2VzIGFyZSBjb252ZXJ0ZWQuXG5cdFx0Ly9cblx0XHQvL1x0XHRJZiBjYWxsYmFja3MgYXJlIHByb3ZpZGVkIGFuZCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBub3QgYSBwcm9taXNlLFxuXHRcdC8vXHRcdHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBpbW1lZGlhdGVseSB3aXRoIG5vIGVycm9yIGhhbmRsaW5nLiBSZXR1cm5zXG5cdFx0Ly9cdFx0YSBwcm9taXNlIGlmIHRoZSBpbml0aWFsIHZhbHVlIGlzIGEgcHJvbWlzZSwgb3IgdGhlIHJlc3VsdCBvZiB0aGVcblx0XHQvL1x0XHRjYWxsYmFjayBvdGhlcndpc2UuXG5cdFx0Ly8gdmFsdWVPclByb21pc2U6XG5cdFx0Ly9cdFx0RWl0aGVyIGEgcmVndWxhciB2YWx1ZSBvciBhbiBvYmplY3Qgd2l0aCBhIGB0aGVuKClgIG1ldGhvZCB0aGF0XG5cdFx0Ly9cdFx0Zm9sbG93cyB0aGUgUHJvbWlzZXMvQSBzcGVjaWZpY2F0aW9uLlxuXHRcdC8vIGNhbGxiYWNrOiBGdW5jdGlvbj9cblx0XHQvL1x0XHRDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQsIG9yIGEgbm9uLXByb21pc2Vcblx0XHQvL1x0XHRpcyByZWNlaXZlZC5cblx0XHQvLyBlcnJiYWNrOiBGdW5jdGlvbj9cblx0XHQvL1x0XHRDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG5cdFx0Ly8gcHJvZ2JhY2s6IEZ1bmN0aW9uP1xuXHRcdC8vXHRcdENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgcHJvbWlzZSBlbWl0cyBhIHByb2dyZXNzIHVwZGF0ZS5cblx0XHQvLyByZXR1cm5zOiBkb2pvL3Byb21pc2UvUHJvbWlzZVxuXHRcdC8vXHRcdFByb21pc2UsIG9yIGlmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQsIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrLlxuXG5cdFx0dmFyIHJlY2VpdmVkUHJvbWlzZSA9IHZhbHVlT3JQcm9taXNlICYmIHR5cGVvZiB2YWx1ZU9yUHJvbWlzZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG5cdFx0dmFyIG5hdGl2ZVByb21pc2UgPSByZWNlaXZlZFByb21pc2UgJiYgdmFsdWVPclByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlO1xuXG5cdFx0aWYoIXJlY2VpdmVkUHJvbWlzZSl7XG5cdFx0XHRpZihhcmd1bWVudHMubGVuZ3RoID4gMSl7XG5cdFx0XHRcdHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKHZhbHVlT3JQcm9taXNlKSA6IHZhbHVlT3JQcm9taXNlO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHJldHVybiBuZXcgRGVmZXJyZWQoKS5yZXNvbHZlKHZhbHVlT3JQcm9taXNlKTtcblx0XHRcdH1cblx0XHR9ZWxzZSBpZighbmF0aXZlUHJvbWlzZSl7XG5cdFx0XHR2YXIgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQodmFsdWVPclByb21pc2UuY2FuY2VsKTtcblx0XHRcdHZhbHVlT3JQcm9taXNlLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5wcm9ncmVzcyk7XG5cdFx0XHR2YWx1ZU9yUHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2U7XG5cdFx0fVxuXG5cdFx0aWYoY2FsbGJhY2sgfHwgZXJyYmFjayB8fCBwcm9nYmFjayl7XG5cdFx0XHRyZXR1cm4gdmFsdWVPclByb21pc2UudGhlbihjYWxsYmFjaywgZXJyYmFjaywgcHJvZ2JhY2spO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWVPclByb21pc2U7XG5cdH07XG59KTtcbiIsImRlZmluZShbXCIuL19iYXNlL2xhbmdcIiwgXCIuL3NuaWZmXCIsIFwiLi9fYmFzZS93aW5kb3dcIiwgXCIuL2RvbVwiLCBcIi4vZG9tLWdlb21ldHJ5XCIsIFwiLi9kb20tc3R5bGVcIiwgXCIuL2RvbS1jb25zdHJ1Y3RcIl0sXG5cdGZ1bmN0aW9uKGxhbmcsIGhhcywgYmFzZVdpbmRvdywgZG9tLCBnZW9tLCBzdHlsZSwgZG9tQ29uc3RydWN0KXtcblxuXHQvLyBmZWF0dXJlIGRldGVjdGlvblxuXHQvKiBub3QgbmVlZGVkIGJ1dCBpbmNsdWRlZCBoZXJlIGZvciBmdXR1cmUgcmVmZXJlbmNlXG5cdGhhcy5hZGQoXCJydGwtaW5uZXJWZXJ0aWNhbFNjcm9sbEJhci1vbi1sZWZ0XCIsIGZ1bmN0aW9uKHdpbiwgZG9jKXtcblx0XHR2YXJcdGJvZHkgPSBiYXNlV2luZG93LmJvZHkoZG9jKSxcblx0XHRcdHNjcm9sbGFibGUgPSBkb21Db25zdHJ1Y3QuY3JlYXRlKCdkaXYnLCB7XG5cdFx0XHRcdHN0eWxlOiB7b3ZlcmZsb3c6J3Njcm9sbCcsIG92ZXJmbG93WDonaGlkZGVuJywgZGlyZWN0aW9uOidydGwnLCB2aXNpYmlsaXR5OidoaWRkZW4nLCBwb3NpdGlvbjonYWJzb2x1dGUnLCBsZWZ0OicwJywgd2lkdGg6JzY0cHgnLCBoZWlnaHQ6JzY0cHgnfVxuXHRcdFx0fSwgYm9keSwgXCJsYXN0XCIpLFxuXHRcdFx0Y2VudGVyID0gZG9tQ29uc3RydWN0LmNyZWF0ZSgnY2VudGVyJywge1xuXHRcdFx0XHRzdHlsZToge292ZXJmbG93OidoaWRkZW4nLCBkaXJlY3Rpb246J2x0cid9XG5cdFx0XHR9LCBzY3JvbGxhYmxlLCBcImxhc3RcIiksXG5cdFx0XHRpbm5lciA9IGRvbUNvbnN0cnVjdC5jcmVhdGUoJ2RpdicsIHtcblx0XHRcdFx0c3R5bGU6IHtvdmVyZmxvdzondmlzaWJsZScsIGRpc3BsYXk6J2lubGluZScgfVxuXHRcdFx0fSwgY2VudGVyLCBcImxhc3RcIik7XG5cdFx0aW5uZXIuaW5uZXJIVE1MPVwiJm5ic3A7XCI7XG5cdFx0dmFyIG1pZFBvaW50ID0gTWF0aC5tYXgoaW5uZXIub2Zmc2V0TGVmdCwgZ2VvbS5wb3NpdGlvbihpbm5lcikueCk7XG5cdFx0dmFyIHJldCA9IG1pZFBvaW50ID49IDMyO1xuXHRcdGNlbnRlci5yZW1vdmVDaGlsZChpbm5lcik7XG5cdFx0c2Nyb2xsYWJsZS5yZW1vdmVDaGlsZChjZW50ZXIpO1xuXHRcdGJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsYWJsZSk7XG5cdFx0cmV0dXJuIHJldDtcblx0fSk7XG5cdCovXG5cdGhhcy5hZGQoXCJydGwtYWRqdXN0LXBvc2l0aW9uLWZvci12ZXJ0aWNhbFNjcm9sbEJhclwiLCBmdW5jdGlvbih3aW4sIGRvYyl7XG5cdFx0dmFyXHRib2R5ID0gYmFzZVdpbmRvdy5ib2R5KGRvYyksXG5cdFx0XHRzY3JvbGxhYmxlID0gZG9tQ29uc3RydWN0LmNyZWF0ZSgnZGl2Jywge1xuXHRcdFx0XHRzdHlsZToge292ZXJmbG93OidzY3JvbGwnLCBvdmVyZmxvd1g6J3Zpc2libGUnLCBkaXJlY3Rpb246J3J0bCcsIHZpc2liaWxpdHk6J2hpZGRlbicsIHBvc2l0aW9uOidhYnNvbHV0ZScsIGxlZnQ6JzAnLCB0b3A6JzAnLCB3aWR0aDonNjRweCcsIGhlaWdodDonNjRweCd9XG5cdFx0XHR9LCBib2R5LCBcImxhc3RcIiksXG5cdFx0XHRkaXYgPSBkb21Db25zdHJ1Y3QuY3JlYXRlKCdkaXYnLCB7XG5cdFx0XHRcdHN0eWxlOiB7b3ZlcmZsb3c6J2hpZGRlbicsIGRpcmVjdGlvbjonbHRyJ31cblx0XHRcdH0sIHNjcm9sbGFibGUsIFwibGFzdFwiKSxcblx0XHRcdHJldCA9IGdlb20ucG9zaXRpb24oZGl2KS54ICE9IDA7XG5cdFx0c2Nyb2xsYWJsZS5yZW1vdmVDaGlsZChkaXYpO1xuXHRcdGJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsYWJsZSk7XG5cdFx0cmV0dXJuIHJldDtcblx0fSk7XG5cblx0aGFzLmFkZChcInBvc2l0aW9uLWZpeGVkLXN1cHBvcnRcIiwgZnVuY3Rpb24od2luLCBkb2Mpe1xuXHRcdC8vIElFNiwgSUU3K3F1aXJrcywgYW5kIHNvbWUgb2xkZXIgbW9iaWxlIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgcG9zaXRpb246Zml4ZWRcblx0XHR2YXJcdGJvZHkgPSBiYXNlV2luZG93LmJvZHkoZG9jKSxcblx0XHRcdG91dGVyID0gZG9tQ29uc3RydWN0LmNyZWF0ZSgnc3BhbicsIHtcblx0XHRcdFx0c3R5bGU6IHt2aXNpYmlsaXR5OidoaWRkZW4nLCBwb3NpdGlvbjonZml4ZWQnLCBsZWZ0OicxcHgnLCB0b3A6JzFweCd9XG5cdFx0XHR9LCBib2R5LCBcImxhc3RcIiksXG5cdFx0XHRpbm5lciA9IGRvbUNvbnN0cnVjdC5jcmVhdGUoJ3NwYW4nLCB7XG5cdFx0XHRcdHN0eWxlOiB7cG9zaXRpb246J2ZpeGVkJywgbGVmdDonMCcsIHRvcDonMCd9XG5cdFx0XHR9LCBvdXRlciwgXCJsYXN0XCIpLFxuXHRcdFx0cmV0ID0gZ2VvbS5wb3NpdGlvbihpbm5lcikueCAhPSBnZW9tLnBvc2l0aW9uKG91dGVyKS54O1xuXHRcdG91dGVyLnJlbW92ZUNoaWxkKGlubmVyKTtcblx0XHRib2R5LnJlbW92ZUNoaWxkKG91dGVyKTtcblx0XHRyZXR1cm4gcmV0O1xuXHR9KTtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vd2luZG93XG5cblx0dmFyIHdpbmRvdyA9IHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRPRE9DXG5cblx0XHRnZXRCb3g6IGZ1bmN0aW9uKC8qRG9jdW1lbnQ/Ki8gZG9jKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRoZSBkaW1lbnNpb25zIGFuZCBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHZpZXdhYmxlIGFyZWEgb2YgYSBicm93c2VyIHdpbmRvd1xuXG5cdFx0XHRkb2MgPSBkb2MgfHwgYmFzZVdpbmRvdy5kb2M7XG5cblx0XHRcdHZhclxuXHRcdFx0XHRzY3JvbGxSb290ID0gKGRvYy5jb21wYXRNb2RlID09ICdCYWNrQ29tcGF0JykgPyBiYXNlV2luZG93LmJvZHkoZG9jKSA6IGRvYy5kb2N1bWVudEVsZW1lbnQsXG5cdFx0XHRcdC8vIGdldCBzY3JvbGwgcG9zaXRpb25cblx0XHRcdFx0c2Nyb2xsID0gZ2VvbS5kb2NTY3JvbGwoZG9jKSwgLy8gc2Nyb2xsUm9vdC5zY3JvbGxUb3AvTGVmdCBzaG91bGQgd29ya1xuXHRcdFx0XHR3LCBoO1xuXG5cdFx0XHRpZihoYXMoXCJ0b3VjaFwiKSl7IC8vIGlmKHNjcm9sbGJhcnMgbm90IHN1cHBvcnRlZClcblx0XHRcdFx0dmFyIHVpV2luZG93ID0gd2luZG93LmdldChkb2MpOyAgIC8vIHVzZSBVSSB3aW5kb3csIG5vdCBkb2pvLmdsb2JhbCB3aW5kb3dcblx0XHRcdFx0Ly8gb24gbW9iaWxlLCBzY3JvbGxSb290LmNsaWVudEhlaWdodCA8PSB1aVdpbmRvdy5pbm5lckhlaWdodCA8PSBzY3JvbGxSb290Lm9mZnNldEhlaWdodCwgcmV0dXJuIHVpV2luZG93LmlubmVySGVpZ2h0XG5cdFx0XHRcdHcgPSB1aVdpbmRvdy5pbm5lcldpZHRoIHx8IHNjcm9sbFJvb3QuY2xpZW50V2lkdGg7IC8vIHx8IHNjcm9sbFJvb3QuY2xpZW50WFhYIHByb2JhYmx5IG5ldmVyIGV2YWx1YXRlZFxuXHRcdFx0XHRoID0gdWlXaW5kb3cuaW5uZXJIZWlnaHQgfHwgc2Nyb2xsUm9vdC5jbGllbnRIZWlnaHQ7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Ly8gb24gZGVza3RvcHMsIHNjcm9sbFJvb3QuY2xpZW50SGVpZ2h0IDw9IHNjcm9sbFJvb3Qub2Zmc2V0SGVpZ2h0IDw9IHVpV2luZG93LmlubmVySGVpZ2h0LCByZXR1cm4gc2Nyb2xsUm9vdC5jbGllbnRIZWlnaHRcblx0XHRcdFx0Ly8gdWlXaW5kb3cuaW5uZXJXaWR0aC9IZWlnaHQgaW5jbHVkZXMgdGhlIHNjcm9sbGJhciBhbmQgY2Fubm90IGJlIHVzZWRcblx0XHRcdFx0dyA9IHNjcm9sbFJvb3QuY2xpZW50V2lkdGg7XG5cdFx0XHRcdGggPSBzY3JvbGxSb290LmNsaWVudEhlaWdodDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGw6IHNjcm9sbC54LFxuXHRcdFx0XHR0OiBzY3JvbGwueSxcblx0XHRcdFx0dzogdyxcblx0XHRcdFx0aDogaFxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Z2V0OiBmdW5jdGlvbigvKkRvY3VtZW50Ki8gZG9jKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRHZXQgd2luZG93IG9iamVjdCBhc3NvY2lhdGVkIHdpdGggZG9jdW1lbnQgZG9jLlxuXHRcdFx0Ly8gZG9jOlxuXHRcdFx0Ly9cdFx0VGhlIGRvY3VtZW50IHRvIGdldCB0aGUgYXNzb2NpYXRlZCB3aW5kb3cgZm9yLlxuXG5cdFx0XHQvLyBJbiBzb21lIElFIHZlcnNpb25zIChhdCBsZWFzdCA2LjApLCBkb2N1bWVudC5wYXJlbnRXaW5kb3cgZG9lcyBub3QgcmV0dXJuIGFcblx0XHRcdC8vIHJlZmVyZW5jZSB0byB0aGUgcmVhbCB3aW5kb3cgb2JqZWN0IChtYXliZSBhIGNvcHkpLCBzbyB3ZSBtdXN0IGZpeCBpdCBhcyB3ZWxsXG5cdFx0XHQvLyBXZSB1c2UgSUUgc3BlY2lmaWMgZXhlY1NjcmlwdCB0byBhdHRhY2ggdGhlIHJlYWwgd2luZG93IHJlZmVyZW5jZSB0b1xuXHRcdFx0Ly8gZG9jdW1lbnQuX3BhcmVudFdpbmRvdyBmb3IgbGF0ZXIgdXNlXG5cdFx0XHRpZihoYXMoXCJpZVwiKSAmJiB3aW5kb3cgIT09IGRvY3VtZW50LnBhcmVudFdpbmRvdyl7XG5cdFx0XHRcdC8qXG5cdFx0XHRcdEluIElFIDYsIG9ubHkgdGhlIHZhcmlhYmxlIFwid2luZG93XCIgY2FuIGJlIHVzZWQgdG8gY29ubmVjdCBldmVudHMgKG90aGVyc1xuXHRcdFx0XHRtYXkgYmUgb25seSBjb3BpZXMpLlxuXHRcdFx0XHQqL1xuXHRcdFx0XHRkb2MucGFyZW50V2luZG93LmV4ZWNTY3JpcHQoXCJkb2N1bWVudC5fcGFyZW50V2luZG93ID0gd2luZG93O1wiLCBcIkphdmFzY3JpcHRcIik7XG5cdFx0XHRcdC8vdG8gcHJldmVudCBtZW1vcnkgbGVhaywgdW5zZXQgaXQgYWZ0ZXIgdXNlXG5cdFx0XHRcdC8vYW5vdGhlciBwb3NzaWJpbGl0eSBpcyB0byBhZGQgYW4gb25VbmxvYWQgaGFuZGxlciB3aGljaCBzZWVtcyBvdmVya2lsbCB0byBtZSAobGl1Y291Z2FyKVxuXHRcdFx0XHR2YXIgd2luID0gZG9jLl9wYXJlbnRXaW5kb3c7XG5cdFx0XHRcdGRvYy5fcGFyZW50V2luZG93ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIHdpbjtcdC8vXHRXaW5kb3dcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRvYy5wYXJlbnRXaW5kb3cgfHwgZG9jLmRlZmF1bHRWaWV3O1x0Ly9cdFdpbmRvd1xuXHRcdH0sXG5cblx0XHRzY3JvbGxJbnRvVmlldzogZnVuY3Rpb24oLypEb21Ob2RlKi8gbm9kZSwgLypPYmplY3Q/Ki8gcG9zKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRTY3JvbGwgdGhlIHBhc3NlZCBub2RlIGludG8gdmlldyB1c2luZyBtaW5pbWFsIG1vdmVtZW50LCBpZiBpdCBpcyBub3QgYWxyZWFkeS5cblxuXHRcdFx0Ly8gRG9uJ3QgcmVseSBvbiBub2RlLnNjcm9sbEludG9WaWV3IHdvcmtpbmcganVzdCBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyB0aGVyZSBzaW5jZVxuXHRcdFx0Ly8gaXQgZm9yY2VzIHRoZSBub2RlIHRvIHRoZSBwYWdlJ3MgYm90dG9tIG9yIHRvcCAoYW5kIGxlZnQgb3IgcmlnaHQgaW4gSUUpIHdpdGhvdXQgY29uc2lkZXJhdGlvbiBmb3IgdGhlIG1pbmltYWwgbW92ZW1lbnQuXG5cdFx0XHQvLyBXZWJLaXQncyBub2RlLnNjcm9sbEludG9WaWV3SWZOZWVkZWQgZG9lc24ndCB3b3JrIGVpdGhlciBmb3IgaW5uZXIgc2Nyb2xsYmFycyBpbiByaWdodC10by1sZWZ0IG1vZGVcblx0XHRcdC8vIGFuZCB3aGVuIHRoZXJlJ3MgYSBmaXhlZCBwb3NpdGlvbiBzY3JvbGxhYmxlIGVsZW1lbnRcblxuXHRcdFx0dHJ5eyAvLyBjYXRjaCB1bmV4cGVjdGVkL3VucmVjcmVhdGFibGUgZXJyb3JzICgjNzgwOCkgc2luY2Ugd2UgY2FuIHJlY292ZXIgdXNpbmcgYSBzZW1pLWFjY2VwdGFibGUgbmF0aXZlIG1ldGhvZFxuXHRcdFx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0XHRcdHZhclx0ZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IGJhc2VXaW5kb3cuZG9jLFx0Ly8gVE9ETzogd2h5IGJhc2VXaW5kb3cuZG9jPyAgSXNuJ3Qgbm9kZS5vd25lckRvY3VtZW50IGFsd2F5cyBkZWZpbmVkP1xuXHRcdFx0XHRcdGJvZHkgPSBiYXNlV2luZG93LmJvZHkoZG9jKSxcblx0XHRcdFx0XHRodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudCB8fCBib2R5LnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0aXNJRSA9IGhhcyhcImllXCIpIHx8IGhhcyhcInRyaWRlbnRcIiksXG5cdFx0XHRcdFx0aXNXSyA9IGhhcyhcIndlYmtpdFwiKTtcblx0XHRcdFx0Ly8gaWYgYW4gdW50ZXN0ZWQgYnJvd3NlciwgdGhlbiB1c2UgdGhlIG5hdGl2ZSBtZXRob2Rcblx0XHRcdFx0aWYobm9kZSA9PSBib2R5IHx8IG5vZGUgPT0gaHRtbCl7IHJldHVybjsgfVxuXHRcdFx0XHRpZighKGhhcyhcIm1vemlsbGFcIikgfHwgaXNJRSB8fCBpc1dLIHx8IGhhcyhcIm9wZXJhXCIpIHx8IGhhcyhcInRyaWRlbnRcIikgfHwgaGFzKFwiZWRnZVwiKSlcblx0XHRcdFx0XHRcdCYmIChcInNjcm9sbEludG9WaWV3XCIgaW4gbm9kZSkpe1xuXHRcdFx0XHRcdG5vZGUuc2Nyb2xsSW50b1ZpZXcoZmFsc2UpOyAvLyBzaG9ydC1jaXJjdWl0IHRvIG5hdGl2ZSBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXJcdGJhY2tDb21wYXQgPSBkb2MuY29tcGF0TW9kZSA9PSAnQmFja0NvbXBhdCcsXG5cdFx0XHRcdFx0cm9vdFdpZHRoID0gTWF0aC5taW4oYm9keS5jbGllbnRXaWR0aCB8fCBodG1sLmNsaWVudFdpZHRoLCBodG1sLmNsaWVudFdpZHRoIHx8IGJvZHkuY2xpZW50V2lkdGgpLFxuXHRcdFx0XHRcdHJvb3RIZWlnaHQgPSBNYXRoLm1pbihib2R5LmNsaWVudEhlaWdodCB8fCBodG1sLmNsaWVudEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQgfHwgYm9keS5jbGllbnRIZWlnaHQpLFxuXHRcdFx0XHRcdHNjcm9sbFJvb3QgPSAoaXNXSyB8fCBiYWNrQ29tcGF0KSA/IGJvZHkgOiBodG1sLFxuXHRcdFx0XHRcdG5vZGVQb3MgPSBwb3MgfHwgZ2VvbS5wb3NpdGlvbihub2RlKSxcblx0XHRcdFx0XHRlbCA9IG5vZGUucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRpc0ZpeGVkID0gZnVuY3Rpb24oZWwpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIChpc0lFIDw9IDYgfHwgKGlzSUUgPT0gNyAmJiBiYWNrQ29tcGF0KSlcblx0XHRcdFx0XHRcdFx0PyBmYWxzZVxuXHRcdFx0XHRcdFx0XHQ6IChoYXMoXCJwb3NpdGlvbi1maXhlZC1zdXBwb3J0XCIpICYmIChzdHlsZS5nZXQoZWwsICdwb3NpdGlvbicpLnRvTG93ZXJDYXNlKCkgPT0gXCJmaXhlZFwiKSk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzZWxmID0gdGhpcyxcblx0XHRcdFx0XHRzY3JvbGxFbGVtZW50QnkgPSBmdW5jdGlvbihlbCwgeCwgeSl7XG5cdFx0XHRcdFx0XHRpZihlbC50YWdOYW1lID09IFwiQk9EWVwiIHx8IGVsLnRhZ05hbWUgPT0gXCJIVE1MXCIpe1xuXHRcdFx0XHRcdFx0XHRzZWxmLmdldChlbC5vd25lckRvY3VtZW50KS5zY3JvbGxCeSh4LCB5KTtcblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHR4ICYmIChlbC5zY3JvbGxMZWZ0ICs9IHgpO1xuXHRcdFx0XHRcdFx0XHR5ICYmIChlbC5zY3JvbGxUb3AgKz0geSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0aWYoaXNGaXhlZChub2RlKSl7IHJldHVybjsgfSAvLyBub3RoaW5nIHRvIGRvXG5cdFx0XHRcdHdoaWxlKGVsKXtcblx0XHRcdFx0XHRpZihlbCA9PSBib2R5KXsgZWwgPSBzY3JvbGxSb290OyB9XG5cdFx0XHRcdFx0dmFyXHRlbFBvcyA9IGdlb20ucG9zaXRpb24oZWwpLFxuXHRcdFx0XHRcdFx0Zml4ZWRQb3MgPSBpc0ZpeGVkKGVsKSxcblx0XHRcdFx0XHRcdHJ0bCA9IHN0eWxlLmdldENvbXB1dGVkU3R5bGUoZWwpLmRpcmVjdGlvbi50b0xvd2VyQ2FzZSgpID09IFwicnRsXCI7XG5cblx0XHRcdFx0XHRpZihlbCA9PSBzY3JvbGxSb290KXtcblx0XHRcdFx0XHRcdGVsUG9zLncgPSByb290V2lkdGg7IGVsUG9zLmggPSByb290SGVpZ2h0O1xuXHRcdFx0XHRcdFx0aWYoc2Nyb2xsUm9vdCA9PSBodG1sICYmIChpc0lFIHx8IGhhcyhcInRyaWRlbnRcIikpICYmIHJ0bCl7XG5cdFx0XHRcdFx0XHRcdGVsUG9zLnggKz0gc2Nyb2xsUm9vdC5vZmZzZXRXaWR0aC1lbFBvcy53Oy8vIElFIHdvcmthcm91bmQgd2hlcmUgc2Nyb2xsYmFyIGNhdXNlcyBuZWdhdGl2ZSB4XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbFBvcy54ID0gMDtcblx0XHRcdFx0XHRcdGVsUG9zLnkgPSAwO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0dmFyIHBiID0gZ2VvbS5nZXRQYWRCb3JkZXJFeHRlbnRzKGVsKTtcblx0XHRcdFx0XHRcdGVsUG9zLncgLT0gcGIudzsgZWxQb3MuaCAtPSBwYi5oOyBlbFBvcy54ICs9IHBiLmw7IGVsUG9zLnkgKz0gcGIudDtcblx0XHRcdFx0XHRcdHZhciBjbGllbnRTaXplID0gZWwuY2xpZW50V2lkdGgsXG5cdFx0XHRcdFx0XHRcdHNjcm9sbEJhclNpemUgPSBlbFBvcy53IC0gY2xpZW50U2l6ZTtcblx0XHRcdFx0XHRcdGlmKGNsaWVudFNpemUgPiAwICYmIHNjcm9sbEJhclNpemUgPiAwKXtcblx0XHRcdFx0XHRcdFx0aWYocnRsICYmIGhhcyhcInJ0bC1hZGp1c3QtcG9zaXRpb24tZm9yLXZlcnRpY2FsU2Nyb2xsQmFyXCIpKXtcblx0XHRcdFx0XHRcdFx0XHRlbFBvcy54ICs9IHNjcm9sbEJhclNpemU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxQb3MudyA9IGNsaWVudFNpemU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjbGllbnRTaXplID0gZWwuY2xpZW50SGVpZ2h0O1xuXHRcdFx0XHRcdFx0c2Nyb2xsQmFyU2l6ZSA9IGVsUG9zLmggLSBjbGllbnRTaXplO1xuXHRcdFx0XHRcdFx0aWYoY2xpZW50U2l6ZSA+IDAgJiYgc2Nyb2xsQmFyU2l6ZSA+IDApe1xuXHRcdFx0XHRcdFx0XHRlbFBvcy5oID0gY2xpZW50U2l6ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoZml4ZWRQb3MpeyAvLyBib3VuZGVkIGJ5IHZpZXdwb3J0LCBub3QgcGFyZW50c1xuXHRcdFx0XHRcdFx0aWYoZWxQb3MueSA8IDApe1xuXHRcdFx0XHRcdFx0XHRlbFBvcy5oICs9IGVsUG9zLnk7IGVsUG9zLnkgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoZWxQb3MueCA8IDApe1xuXHRcdFx0XHRcdFx0XHRlbFBvcy53ICs9IGVsUG9zLng7IGVsUG9zLnggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoZWxQb3MueSArIGVsUG9zLmggPiByb290SGVpZ2h0KXtcblx0XHRcdFx0XHRcdFx0ZWxQb3MuaCA9IHJvb3RIZWlnaHQgLSBlbFBvcy55O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoZWxQb3MueCArIGVsUG9zLncgPiByb290V2lkdGgpe1xuXHRcdFx0XHRcdFx0XHRlbFBvcy53ID0gcm9vdFdpZHRoIC0gZWxQb3MueDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gY2FsY3VsYXRlIG92ZXJmbG93IGluIGFsbCA0IGRpcmVjdGlvbnNcblx0XHRcdFx0XHR2YXJcdGwgPSBub2RlUG9zLnggLSBlbFBvcy54LCAvLyBiZXlvbmQgbGVmdDogPCAwXG4vL1x0XHRcdFx0XHRcdHQgPSBub2RlUG9zLnkgLSBNYXRoLm1heChlbFBvcy55LCAwKSwgLy8gYmV5b25kIHRvcDogPCAwXG5cdFx0XHRcdFx0XHR0ID0gbm9kZVBvcy55IC0gZWxQb3MueSwgLy8gYmV5b25kIHRvcDogPCAwXG5cdFx0XHRcdFx0XHRyID0gbCArIG5vZGVQb3MudyAtIGVsUG9zLncsIC8vIGJleW9uZCByaWdodDogPiAwXG5cdFx0XHRcdFx0XHRib3QgPSB0ICsgbm9kZVBvcy5oIC0gZWxQb3MuaDsgLy8gYmV5b25kIGJvdHRvbTogPiAwXG5cdFx0XHRcdFx0dmFyIHMsIG9sZDtcblx0XHRcdFx0XHRpZihyICogbCA+IDAgJiYgKCEhZWwuc2Nyb2xsTGVmdCB8fCBlbCA9PSBzY3JvbGxSb290IHx8IGVsLnNjcm9sbFdpZHRoID4gZWwub2Zmc2V0SGVpZ2h0KSl7XG5cdFx0XHRcdFx0XHRzID0gTWF0aFtsIDwgMD8gXCJtYXhcIiA6IFwibWluXCJdKGwsIHIpO1xuXHRcdFx0XHRcdFx0aWYocnRsICYmICgoaXNJRSA9PSA4ICYmICFiYWNrQ29tcGF0KSB8fCBoYXMoXCJ0cmlkZW50XCIpID49IDUpKXsgcyA9IC1zOyB9XG5cdFx0XHRcdFx0XHRvbGQgPSBlbC5zY3JvbGxMZWZ0O1xuXHRcdFx0XHRcdFx0c2Nyb2xsRWxlbWVudEJ5KGVsLCBzLCAwKTtcblx0XHRcdFx0XHRcdHMgPSBlbC5zY3JvbGxMZWZ0IC0gb2xkO1xuXHRcdFx0XHRcdFx0bm9kZVBvcy54IC09IHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGJvdCAqIHQgPiAwICYmICghIWVsLnNjcm9sbFRvcCB8fCBlbCA9PSBzY3JvbGxSb290IHx8IGVsLnNjcm9sbEhlaWdodCA+IGVsLm9mZnNldEhlaWdodCkpe1xuXHRcdFx0XHRcdFx0cyA9IE1hdGguY2VpbChNYXRoW3QgPCAwPyBcIm1heFwiIDogXCJtaW5cIl0odCwgYm90KSk7XG5cdFx0XHRcdFx0XHRvbGQgPSBlbC5zY3JvbGxUb3A7XG5cdFx0XHRcdFx0XHRzY3JvbGxFbGVtZW50QnkoZWwsIDAsIHMpO1xuXHRcdFx0XHRcdFx0cyA9IGVsLnNjcm9sbFRvcCAtIG9sZDtcblx0XHRcdFx0XHRcdG5vZGVQb3MueSAtPSBzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbCA9IChlbCAhPSBzY3JvbGxSb290KSAmJiAhZml4ZWRQb3MgJiYgZWwucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fWNhdGNoKGVycm9yKXtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignc2Nyb2xsSW50b1ZpZXc6ICcgKyBlcnJvcik7XG5cdFx0XHRcdG5vZGUuc2Nyb2xsSW50b1ZpZXcoZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRoYXMoXCJleHRlbmQtZG9qb1wiKSAmJiBsYW5nLnNldE9iamVjdChcImRvam8ud2luZG93XCIsIHdpbmRvdyk7XG5cblx0cmV0dXJuIHdpbmRvdztcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==